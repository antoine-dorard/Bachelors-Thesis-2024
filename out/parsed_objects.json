"[{\"path\": \"dataset/pivaa/app/src/main/assets/com/htbridge/raw/ExternalCode.java\", \"code\": \"import android.util.Log;\\n\\npublic class ExternalCode {\\n    public ExternalCode() {\\n        Log.d(\\\"htbridge\\\", \\\"I am instancied\\\");\\n    }\\n\\n    public String run() {\\n        return \\\"I am working\\\";\\n    }\\n}\", \"classes\": [{\"parent_file\": null, \"name\": \"ExternalCode\", \"position\": {\"start_line\": 3, \"end_line\": 11, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class ExternalCode {\\n    public ExternalCode() {\\n        Log.d(\\\"htbridge\\\", \\\"I am instancied\\\");\\n    }\\n\\n    public String run() {\\n        return \\\"I am working\\\";\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"run\", \"return_type\": \"String\", \"position\": {\"start_line\": 8, \"end_line\": 10, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String run() {\\n        return \\\"I am working\\\";\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/AboutActivity.java\", \"code\": \"package com.htbridge.pivaa;\\n\\nimport android.os.Bundle;\\nimport android.support.v7.app.AppCompatActivity;\\nimport android.support.v7.widget.Toolbar;\\nimport android.util.Log;\\nimport android.view.Menu;\\nimport android.view.MenuItem;\\nimport android.view.View;\\nimport android.view.ViewGroup;\\nimport android.widget.ListView;\\n\\nimport com.htbridge.pivaa.handlers.about.AboutAdapter;\\nimport com.htbridge.pivaa.handlers.about.AboutJSONParser;\\nimport com.htbridge.pivaa.handlers.about.AboutRecord;\\nimport com.htbridge.pivaa.handlers.MenuHandler;\\n\\nimport java.util.ArrayList;\\n\\npublic class AboutActivity extends AppCompatActivity {\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(AboutActivity.this, item.getItemId());\\n    }\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_about);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        renderListView();\\n    }\\n\\n    /**\\n     * Render custom item\\n     */\\n    public void renderListView() {\\n        // get all records\\n\\n        AboutJSONParser aboutJSONParser = new AboutJSONParser(\\\"vulnerabilities.json\\\", getApplicationContext());\\n        ArrayList<AboutRecord> list = aboutJSONParser.parse();\\n\\n        AboutAdapter adapter = new AboutAdapter(list, getApplicationContext());\\n\\n        ListView listView = (ListView) findViewById(R.id.listview_about);\\n        listView.setFocusable(false);\\n        listView.setAdapter(adapter);\\n\\n        this.setListViewHeightBasedOnChildren(listView, adapter);\\n    }\\n\\n\\n    /**\\n     * Shrink listview height\\n     * @param listView\\n     * @param adapter\\n     */\\n    public void setListViewHeightBasedOnChildren(ListView listView, AboutAdapter adapter) {\\n        int totalHeight = 0;\\n        for (int i = 0; i < adapter.getCount(); i++) {\\n            View listItem = adapter.getView(i, null, listView);\\n            listItem.measure(0, 0);\\n            totalHeight += listItem.getMeasuredHeight() + 180;\\n            Log.i(\\\"htbridge\\\", \\\"listItem.getMeasuredHeight()  = \\\" + listItem.getMeasuredHeight() );\\n        }\\n\\n        Log.i(\\\"htbridge\\\", \\\"totalHeight = \\\" + totalHeight);\\n\\n        ViewGroup.LayoutParams params = listView.getLayoutParams();\\n        params.height = totalHeight + (listView.getDividerHeight() * (adapter.getCount() - 1));\\n        listView.setLayoutParams(params);\\n        listView.requestLayout();\\n\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"AboutActivity\", \"position\": {\"start_line\": 20, \"end_line\": 86, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class AboutActivity extends AppCompatActivity {\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(AboutActivity.this, item.getItemId());\\n    }\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_about);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        renderListView();\\n    }\\n\\n    /**\\n     * Render custom item\\n     */\\n    public void renderListView() {\\n        // get all records\\n\\n        AboutJSONParser aboutJSONParser = new AboutJSONParser(\\\"vulnerabilities.json\\\", getApplicationContext());\\n        ArrayList<AboutRecord> list = aboutJSONParser.parse();\\n\\n        AboutAdapter adapter = new AboutAdapter(list, getApplicationContext());\\n\\n        ListView listView = (ListView) findViewById(R.id.listview_about);\\n        listView.setFocusable(false);\\n        listView.setAdapter(adapter);\\n\\n        this.setListViewHeightBasedOnChildren(listView, adapter);\\n    }\\n\\n\\n    /**\\n     * Shrink listview height\\n     * @param listView\\n     * @param adapter\\n     */\\n    public void setListViewHeightBasedOnChildren(ListView listView, AboutAdapter adapter) {\\n        int totalHeight = 0;\\n        for (int i = 0; i < adapter.getCount(); i++) {\\n            View listItem = adapter.getView(i, null, listView);\\n            listItem.measure(0, 0);\\n            totalHeight += listItem.getMeasuredHeight() + 180;\\n            Log.i(\\\"htbridge\\\", \\\"listItem.getMeasuredHeight()  = \\\" + listItem.getMeasuredHeight() );\\n        }\\n\\n        Log.i(\\\"htbridge\\\", \\\"totalHeight = \\\" + totalHeight);\\n\\n        ViewGroup.LayoutParams params = listView.getLayoutParams();\\n        params.height = totalHeight + (listView.getDividerHeight() * (adapter.getCount() - 1));\\n        listView.setLayoutParams(params);\\n        listView.requestLayout();\\n\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onCreateOptionsMenu\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 23, \"end_line\": 26, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"menu\", \"type\": \"Menu\"}]}, {\"name\": \"onOptionsItemSelected\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 29, \"end_line\": 32, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(AboutActivity.this, item.getItemId());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"item\", \"type\": \"MenuItem\"}]}, {\"name\": \"onCreate\", \"return_type\": \"void\", \"position\": {\"start_line\": 35, \"end_line\": 43, \"start_column\": 15, \"end_column\": 5}, \"code\": \"void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_about);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        renderListView();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"savedInstanceState\", \"type\": \"Bundle\"}]}, {\"name\": \"renderListView\", \"return_type\": \"void\", \"position\": {\"start_line\": 48, \"end_line\": 61, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void renderListView() {\\n        // get all records\\n\\n        AboutJSONParser aboutJSONParser = new AboutJSONParser(\\\"vulnerabilities.json\\\", getApplicationContext());\\n        ArrayList<AboutRecord> list = aboutJSONParser.parse();\\n\\n        AboutAdapter adapter = new AboutAdapter(list, getApplicationContext());\\n\\n        ListView listView = (ListView) findViewById(R.id.listview_about);\\n        listView.setFocusable(false);\\n        listView.setAdapter(adapter);\\n\\n        this.setListViewHeightBasedOnChildren(listView, adapter);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"setListViewHeightBasedOnChildren\", \"return_type\": \"void\", \"position\": {\"start_line\": 69, \"end_line\": 85, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setListViewHeightBasedOnChildren(ListView listView, AboutAdapter adapter) {\\n        int totalHeight = 0;\\n        for (int i = 0; i < adapter.getCount(); i++) {\\n            View listItem = adapter.getView(i, null, listView);\\n            listItem.measure(0, 0);\\n            totalHeight += listItem.getMeasuredHeight() + 180;\\n            Log.i(\\\"htbridge\\\", \\\"listItem.getMeasuredHeight()  = \\\" + listItem.getMeasuredHeight() );\\n        }\\n\\n        Log.i(\\\"htbridge\\\", \\\"totalHeight = \\\" + totalHeight);\\n\\n        ViewGroup.LayoutParams params = listView.getLayoutParams();\\n        params.height = totalHeight + (listView.getDividerHeight() * (adapter.getCount() - 1));\\n        listView.setLayoutParams(params);\\n        listView.requestLayout();\\n\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"listView\", \"type\": \"ListView\"}, {\"name\": \"adapter\", \"type\": \"AboutAdapter\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/BroadcastReceiverActivity.java\", \"code\": \"package com.htbridge.pivaa;\\n\\nimport android.content.Intent;\\nimport android.os.AsyncTask;\\nimport android.os.Bundle;\\nimport android.support.design.widget.FloatingActionButton;\\nimport android.support.design.widget.Snackbar;\\nimport android.support.v7.app.AppCompatActivity;\\nimport android.support.v7.widget.Toolbar;\\nimport android.view.Menu;\\nimport android.view.MenuItem;\\nimport android.view.View;\\nimport android.webkit.WebChromeClient;\\nimport android.webkit.WebSettings;\\nimport android.webkit.WebView;\\nimport android.widget.Button;\\nimport android.widget.EditText;\\nimport android.widget.TextView;\\n\\nimport com.htbridge.pivaa.handlers.Authentication;\\nimport com.htbridge.pivaa.handlers.MenuHandler;\\n\\nimport java.io.FileNotFoundException;\\nimport java.io.FileOutputStream;\\nimport java.io.PrintWriter;\\nimport java.util.Date;\\n\\npublic class BroadcastReceiverActivity extends AppCompatActivity {\\n    private WebView myWebView;\\n    private String location;\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(BroadcastReceiverActivity.this, item.getItemId());\\n    }\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_broadcast_receiver);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        myWebView = (WebView) findViewById(R.id.webview_broadcast_receiver);\\n        WebSettings webSettings = myWebView.getSettings();\\n        myWebView.setWebChromeClient(new WebChromeClient());\\n\\n        // setting up configuration for WebView\\n        webSettings.setJavaScriptEnabled(true);\\n        webSettings.setAllowFileAccess(true);\\n        webSettings.setAllowUniversalAccessFromFileURLs(true);\\n\\n        location = this.getExternalFilesDir(null) + \\\"/broadcast.html\\\";\\n        myWebView.loadUrl(\\\"file://\\\" + location);\\n\\n        FileOutputStream fos = null;\\n        try {\\n            fos = new FileOutputStream(location, false);\\n            PrintWriter pw = new PrintWriter(fos);\\n            pw.println(\\\"Your new file\\\");\\n            pw.flush();\\n            pw.close();\\n            fos.close();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n\\n\\n        // send broadcast\\n        Button mWebviewButtonLink1 = (Button) findViewById(R.id.button_broadcast_receiver);\\n        mWebviewButtonLink1.setOnClickListener(new View.OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                EditText mBroadcastInputView = (EditText) findViewById(R.id.input_broadcast_receiver);\\n                String input_broadcast = mBroadcastInputView.getText().toString();\\n\\n\\n                Intent intent = new Intent();\\n                intent.setAction(\\\"service.vulnerable.vulnerableservice.LOG\\\");\\n                intent.putExtra(\\\"data\\\", input_broadcast);\\n                intent.putExtra(\\\"location\\\", location);\\n\\n                sendBroadcast(intent);\\n\\n                // refresh webview\\n                try {\\n                    Thread.sleep(300);\\n                    myWebView.loadUrl((\\\"file://\\\" + location));\\n                } catch (Exception e) {\\n                    e.printStackTrace();\\n                }\\n            }\\n\\n        });\\n\\n\\n\\n    }\\n\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"BroadcastReceiverActivity\", \"position\": {\"start_line\": 28, \"end_line\": 110, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class BroadcastReceiverActivity extends AppCompatActivity {\\n    private WebView myWebView;\\n    private String location;\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(BroadcastReceiverActivity.this, item.getItemId());\\n    }\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_broadcast_receiver);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        myWebView = (WebView) findViewById(R.id.webview_broadcast_receiver);\\n        WebSettings webSettings = myWebView.getSettings();\\n        myWebView.setWebChromeClient(new WebChromeClient());\\n\\n        // setting up configuration for WebView\\n        webSettings.setJavaScriptEnabled(true);\\n        webSettings.setAllowFileAccess(true);\\n        webSettings.setAllowUniversalAccessFromFileURLs(true);\\n\\n        location = this.getExternalFilesDir(null) + \\\"/broadcast.html\\\";\\n        myWebView.loadUrl(\\\"file://\\\" + location);\\n\\n        FileOutputStream fos = null;\\n        try {\\n            fos = new FileOutputStream(location, false);\\n            PrintWriter pw = new PrintWriter(fos);\\n            pw.println(\\\"Your new file\\\");\\n            pw.flush();\\n            pw.close();\\n            fos.close();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n\\n\\n        // send broadcast\\n        Button mWebviewButtonLink1 = (Button) findViewById(R.id.button_broadcast_receiver);\\n        mWebviewButtonLink1.setOnClickListener(new View.OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                EditText mBroadcastInputView = (EditText) findViewById(R.id.input_broadcast_receiver);\\n                String input_broadcast = mBroadcastInputView.getText().toString();\\n\\n\\n                Intent intent = new Intent();\\n                intent.setAction(\\\"service.vulnerable.vulnerableservice.LOG\\\");\\n                intent.putExtra(\\\"data\\\", input_broadcast);\\n                intent.putExtra(\\\"location\\\", location);\\n\\n                sendBroadcast(intent);\\n\\n                // refresh webview\\n                try {\\n                    Thread.sleep(300);\\n                    myWebView.loadUrl((\\\"file://\\\" + location));\\n                } catch (Exception e) {\\n                    e.printStackTrace();\\n                }\\n            }\\n\\n        });\\n\\n\\n\\n    }\\n\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onCreateOptionsMenu\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 33, \"end_line\": 36, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"menu\", \"type\": \"Menu\"}]}, {\"name\": \"onOptionsItemSelected\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 39, \"end_line\": 42, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(BroadcastReceiverActivity.this, item.getItemId());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"item\", \"type\": \"MenuItem\"}]}, {\"name\": \"onCreate\", \"return_type\": \"void\", \"position\": {\"start_line\": 45, \"end_line\": 107, \"start_column\": 15, \"end_column\": 5}, \"code\": \"void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_broadcast_receiver);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        myWebView = (WebView) findViewById(R.id.webview_broadcast_receiver);\\n        WebSettings webSettings = myWebView.getSettings();\\n        myWebView.setWebChromeClient(new WebChromeClient());\\n\\n        // setting up configuration for WebView\\n        webSettings.setJavaScriptEnabled(true);\\n        webSettings.setAllowFileAccess(true);\\n        webSettings.setAllowUniversalAccessFromFileURLs(true);\\n\\n        location = this.getExternalFilesDir(null) + \\\"/broadcast.html\\\";\\n        myWebView.loadUrl(\\\"file://\\\" + location);\\n\\n        FileOutputStream fos = null;\\n        try {\\n            fos = new FileOutputStream(location, false);\\n            PrintWriter pw = new PrintWriter(fos);\\n            pw.println(\\\"Your new file\\\");\\n            pw.flush();\\n            pw.close();\\n            fos.close();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n\\n\\n        // send broadcast\\n        Button mWebviewButtonLink1 = (Button) findViewById(R.id.button_broadcast_receiver);\\n        mWebviewButtonLink1.setOnClickListener(new View.OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                EditText mBroadcastInputView = (EditText) findViewById(R.id.input_broadcast_receiver);\\n                String input_broadcast = mBroadcastInputView.getText().toString();\\n\\n\\n                Intent intent = new Intent();\\n                intent.setAction(\\\"service.vulnerable.vulnerableservice.LOG\\\");\\n                intent.putExtra(\\\"data\\\", input_broadcast);\\n                intent.putExtra(\\\"location\\\", location);\\n\\n                sendBroadcast(intent);\\n\\n                // refresh webview\\n                try {\\n                    Thread.sleep(300);\\n                    myWebView.loadUrl((\\\"file://\\\" + location));\\n                } catch (Exception e) {\\n                    e.printStackTrace();\\n                }\\n            }\\n\\n        });\\n\\n\\n\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"savedInstanceState\", \"type\": \"Bundle\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 82, \"end_line\": 101, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                EditText mBroadcastInputView = (EditText) findViewById(R.id.input_broadcast_receiver);\\n                String input_broadcast = mBroadcastInputView.getText().toString();\\n\\n\\n                Intent intent = new Intent();\\n                intent.setAction(\\\"service.vulnerable.vulnerableservice.LOG\\\");\\n                intent.putExtra(\\\"data\\\", input_broadcast);\\n                intent.putExtra(\\\"location\\\", location);\\n\\n                sendBroadcast(intent);\\n\\n                // refresh webview\\n                try {\\n                    Thread.sleep(300);\\n                    myWebView.loadUrl((\\\"file://\\\" + location));\\n                } catch (Exception e) {\\n                    e.printStackTrace();\\n                }\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/Configuration.java\", \"code\": \"package com.htbridge.pivaa;\\n\\n/**\\n * Configuration file\\n */\\n\\npublic class Configuration {\\n\\n    public String url_json = \\\"https://www.htbridge.com/ssl/api/v1/load_all/1510314123771.html?_=1510314123152\\\";\\n    public String url_webview = \\\"https://www.htbridge.com/ssl/\\\";\\n    public String url_webview_link_1 = \\\"file:///etc/hosts\\\";\\n    public String url_webview_link_2 = \\\"https://xss.rocks/scriptlet.html\\\";\\n\\n\\n    public String default_title_database_item = \\\"My Vulnerable Android Application\\\";\\n    public String default_author_database_item = \\\"High-Tech Bridge\\\";\\n\\n    public String username = \\\"test\\\";\\n    public String password = \\\"verycomplicatedpassword\\\";\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Configuration\", \"position\": {\"start_line\": 7, \"end_line\": 21, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Configuration {\\n\\n    public String url_json = \\\"https://www.htbridge.com/ssl/api/v1/load_all/1510314123771.html?_=1510314123152\\\";\\n    public String url_webview = \\\"https://www.htbridge.com/ssl/\\\";\\n    public String url_webview_link_1 = \\\"file:///etc/hosts\\\";\\n    public String url_webview_link_2 = \\\"https://xss.rocks/scriptlet.html\\\";\\n\\n\\n    public String default_title_database_item = \\\"My Vulnerable Android Application\\\";\\n    public String default_author_database_item = \\\"High-Tech Bridge\\\";\\n\\n    public String username = \\\"test\\\";\\n    public String password = \\\"verycomplicatedpassword\\\";\\n\\n}\", \"summary\": \"\", \"methods\": []}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/ContentProviderActivity.java\", \"code\": \"package com.htbridge.pivaa;\\n\\nimport android.database.Cursor;\\nimport android.database.DatabaseUtils;\\nimport android.database.sqlite.SQLiteDatabase;\\nimport android.net.Uri;\\nimport android.os.Bundle;\\nimport android.support.design.widget.FloatingActionButton;\\nimport android.support.design.widget.Snackbar;\\nimport android.support.v7.app.AppCompatActivity;\\nimport android.support.v7.widget.Toolbar;\\nimport android.util.Log;\\nimport android.view.Menu;\\nimport android.view.MenuItem;\\nimport android.view.View;\\nimport android.webkit.WebChromeClient;\\nimport android.webkit.WebSettings;\\nimport android.webkit.WebView;\\nimport android.widget.Button;\\nimport android.widget.EditText;\\nimport android.widget.TextView;\\n\\nimport com.htbridge.pivaa.handlers.MenuHandler;\\nimport com.htbridge.pivaa.handlers.VulnerableContentProvider;\\n\\npublic class ContentProviderActivity extends AppCompatActivity {\\n    private WebView myWebView;\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(ContentProviderActivity.this, item.getItemId());\\n    }\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_content_provider);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n\\n        Button mContentProviderButtonView = (Button) findViewById(R.id.button_content_provider);\\n        mContentProviderButtonView.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mQueryContentProviderView = (EditText) findViewById(R.id.url_content_provider);\\n                String query = mQueryContentProviderView.getText().toString();;\\n\\n                String url = \\\"content://com.htbridge.pivaa/\\\" + query;\\n                Uri uri = Uri.parse(url);\\n\\n                try {\\n                    Cursor cursor = getContentResolver().query(uri, null, null, null, null);\\n\\n                    StringBuilder sb = new StringBuilder();\\n                    if (cursor != null) cursor.moveToFirst();\\n\\n                    while (!cursor.isAfterLast()) {\\n                        String e = DatabaseUtils.dumpCurrentRowToString(cursor);\\n\\n                        Log.d(\\\"htbridge\\\", e);\\n                        sb.append(e).append(\\\"\\\\n\\\");\\n\\n                        cursor.moveToNext();\\n                    }\\n\\n                    //Log.i(\\\"htbridge\\\", sb.toString());\\n\\n                    TextView mOutputContentProviderView = (TextView) findViewById(R.id.output_content_provider);\\n                    mOutputContentProviderView.setText(sb.toString(), TextView.BufferType.EDITABLE);\\n                } catch (Exception e) {\\n                    e.printStackTrace();\\n                }\\n\\n            }\\n\\n        });\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"ContentProviderActivity\", \"position\": {\"start_line\": 26, \"end_line\": 89, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class ContentProviderActivity extends AppCompatActivity {\\n    private WebView myWebView;\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(ContentProviderActivity.this, item.getItemId());\\n    }\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_content_provider);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n\\n        Button mContentProviderButtonView = (Button) findViewById(R.id.button_content_provider);\\n        mContentProviderButtonView.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mQueryContentProviderView = (EditText) findViewById(R.id.url_content_provider);\\n                String query = mQueryContentProviderView.getText().toString();;\\n\\n                String url = \\\"content://com.htbridge.pivaa/\\\" + query;\\n                Uri uri = Uri.parse(url);\\n\\n                try {\\n                    Cursor cursor = getContentResolver().query(uri, null, null, null, null);\\n\\n                    StringBuilder sb = new StringBuilder();\\n                    if (cursor != null) cursor.moveToFirst();\\n\\n                    while (!cursor.isAfterLast()) {\\n                        String e = DatabaseUtils.dumpCurrentRowToString(cursor);\\n\\n                        Log.d(\\\"htbridge\\\", e);\\n                        sb.append(e).append(\\\"\\\\n\\\");\\n\\n                        cursor.moveToNext();\\n                    }\\n\\n                    //Log.i(\\\"htbridge\\\", sb.toString());\\n\\n                    TextView mOutputContentProviderView = (TextView) findViewById(R.id.output_content_provider);\\n                    mOutputContentProviderView.setText(sb.toString(), TextView.BufferType.EDITABLE);\\n                } catch (Exception e) {\\n                    e.printStackTrace();\\n                }\\n\\n            }\\n\\n        });\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onCreateOptionsMenu\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 30, \"end_line\": 33, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"menu\", \"type\": \"Menu\"}]}, {\"name\": \"onOptionsItemSelected\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 36, \"end_line\": 39, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(ContentProviderActivity.this, item.getItemId());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"item\", \"type\": \"MenuItem\"}]}, {\"name\": \"onCreate\", \"return_type\": \"void\", \"position\": {\"start_line\": 42, \"end_line\": 87, \"start_column\": 15, \"end_column\": 5}, \"code\": \"void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_content_provider);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n\\n        Button mContentProviderButtonView = (Button) findViewById(R.id.button_content_provider);\\n        mContentProviderButtonView.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mQueryContentProviderView = (EditText) findViewById(R.id.url_content_provider);\\n                String query = mQueryContentProviderView.getText().toString();;\\n\\n                String url = \\\"content://com.htbridge.pivaa/\\\" + query;\\n                Uri uri = Uri.parse(url);\\n\\n                try {\\n                    Cursor cursor = getContentResolver().query(uri, null, null, null, null);\\n\\n                    StringBuilder sb = new StringBuilder();\\n                    if (cursor != null) cursor.moveToFirst();\\n\\n                    while (!cursor.isAfterLast()) {\\n                        String e = DatabaseUtils.dumpCurrentRowToString(cursor);\\n\\n                        Log.d(\\\"htbridge\\\", e);\\n                        sb.append(e).append(\\\"\\\\n\\\");\\n\\n                        cursor.moveToNext();\\n                    }\\n\\n                    //Log.i(\\\"htbridge\\\", sb.toString());\\n\\n                    TextView mOutputContentProviderView = (TextView) findViewById(R.id.output_content_provider);\\n                    mOutputContentProviderView.setText(sb.toString(), TextView.BufferType.EDITABLE);\\n                } catch (Exception e) {\\n                    e.printStackTrace();\\n                }\\n\\n            }\\n\\n        });\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"savedInstanceState\", \"type\": \"Bundle\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 54, \"end_line\": 84, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                EditText mQueryContentProviderView = (EditText) findViewById(R.id.url_content_provider);\\n                String query = mQueryContentProviderView.getText().toString();;\\n\\n                String url = \\\"content://com.htbridge.pivaa/\\\" + query;\\n                Uri uri = Uri.parse(url);\\n\\n                try {\\n                    Cursor cursor = getContentResolver().query(uri, null, null, null, null);\\n\\n                    StringBuilder sb = new StringBuilder();\\n                    if (cursor != null) cursor.moveToFirst();\\n\\n                    while (!cursor.isAfterLast()) {\\n                        String e = DatabaseUtils.dumpCurrentRowToString(cursor);\\n\\n                        Log.d(\\\"htbridge\\\", e);\\n                        sb.append(e).append(\\\"\\\\n\\\");\\n\\n                        cursor.moveToNext();\\n                    }\\n\\n                    //Log.i(\\\"htbridge\\\", sb.toString());\\n\\n                    TextView mOutputContentProviderView = (TextView) findViewById(R.id.output_content_provider);\\n                    mOutputContentProviderView.setText(sb.toString(), TextView.BufferType.EDITABLE);\\n                } catch (Exception e) {\\n                    e.printStackTrace();\\n                }\\n\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/DatabaseActivity.java\", \"code\": \"package com.htbridge.pivaa;\\n\\nimport android.os.Bundle;\\nimport android.support.v7.app.AppCompatActivity;\\nimport android.support.v7.widget.Toolbar;\\nimport android.util.Log;\\nimport android.view.Menu;\\nimport android.view.MenuItem;\\nimport android.view.View;\\nimport android.widget.Button;\\nimport android.widget.EditText;\\nimport android.widget.ListView;\\nimport android.widget.TextView;\\n\\nimport com.htbridge.pivaa.handlers.database.DatabaseAdapter;\\nimport com.htbridge.pivaa.handlers.database.DatabaseHelper;\\nimport com.htbridge.pivaa.handlers.database.DatabaseRecord;\\nimport com.htbridge.pivaa.handlers.MenuHandler;\\n\\nimport java.util.ArrayList;\\n\\npublic class DatabaseActivity extends AppCompatActivity {\\n    DatabaseHelper db;\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(DatabaseActivity.this, item.getItemId());\\n    }\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_database);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n\\n        /**\\n         * CRUD Operations\\n         * */\\n        // add record\\n        Configuration config = new Configuration();\\n        db = new DatabaseHelper(this);\\n        db.initDatabaseOuter();\\n        db.addRecord(new DatabaseRecord(config.default_title_database_item, config.default_author_database_item));\\n\\n        renderListView();\\n\\n\\n        // Hooking DB insert button\\n        Button mDatabaseInsertButton = (Button) findViewById(R.id.button_insert_database);\\n        mDatabaseInsertButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mTitleDatabaseView = (EditText) findViewById(R.id.title_database);\\n                EditText mAuthorDatabaseView = (EditText) findViewById(R.id.author_database);\\n\\n\\n                String title = mTitleDatabaseView.getText().toString();\\n                String author = mAuthorDatabaseView.getText().toString();\\n\\n                db.addRecord(new DatabaseRecord(title, author));\\n\\n                renderListView();\\n            }\\n\\n        });\\n\\n\\n        // Hooking DB insert button\\n        Button mDatabaseRawSQLButton = (Button) findViewById(R.id.button_raw_sql_database);\\n        mDatabaseRawSQLButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mTitleDatabaseView = (EditText) findViewById(R.id.raw_sql_database);\\n                String rawSQLText = mTitleDatabaseView.getText().toString();\\n\\n                String result = db.rawSQLQuery(rawSQLText);\\n                Log.d(\\\"htbridge\\\", result);\\n\\n                TextView mOutputDatabaseView = (TextView) findViewById(R.id.output_database);\\n                mOutputDatabaseView.setText(result, TextView.BufferType.EDITABLE);\\n\\n                renderListView();\\n            }\\n\\n        });\\n\\n\\n        // delete one record\\n        //db.deleteRecord(list.get(0));\\n\\n        // get all record\\n        //db.getAllRecords();\\n\\n    }\\n\\n\\n    /**\\n     * Render custom item\\n     */\\n    public void renderListView() {\\n        // get all records\\n        ArrayList<DatabaseRecord> list = db.getAllRecords();\\n        DatabaseAdapter adapter = new DatabaseAdapter(list, getApplicationContext(), db, this);\\n\\n        ListView listView = (ListView) findViewById(R.id.listview_database);\\n        listView.setAdapter(adapter);\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"DatabaseActivity\", \"position\": {\"start_line\": 22, \"end_line\": 121, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class DatabaseActivity extends AppCompatActivity {\\n    DatabaseHelper db;\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(DatabaseActivity.this, item.getItemId());\\n    }\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_database);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n\\n        /**\\n         * CRUD Operations\\n         * */\\n        // add record\\n        Configuration config = new Configuration();\\n        db = new DatabaseHelper(this);\\n        db.initDatabaseOuter();\\n        db.addRecord(new DatabaseRecord(config.default_title_database_item, config.default_author_database_item));\\n\\n        renderListView();\\n\\n\\n        // Hooking DB insert button\\n        Button mDatabaseInsertButton = (Button) findViewById(R.id.button_insert_database);\\n        mDatabaseInsertButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mTitleDatabaseView = (EditText) findViewById(R.id.title_database);\\n                EditText mAuthorDatabaseView = (EditText) findViewById(R.id.author_database);\\n\\n\\n                String title = mTitleDatabaseView.getText().toString();\\n                String author = mAuthorDatabaseView.getText().toString();\\n\\n                db.addRecord(new DatabaseRecord(title, author));\\n\\n                renderListView();\\n            }\\n\\n        });\\n\\n\\n        // Hooking DB insert button\\n        Button mDatabaseRawSQLButton = (Button) findViewById(R.id.button_raw_sql_database);\\n        mDatabaseRawSQLButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mTitleDatabaseView = (EditText) findViewById(R.id.raw_sql_database);\\n                String rawSQLText = mTitleDatabaseView.getText().toString();\\n\\n                String result = db.rawSQLQuery(rawSQLText);\\n                Log.d(\\\"htbridge\\\", result);\\n\\n                TextView mOutputDatabaseView = (TextView) findViewById(R.id.output_database);\\n                mOutputDatabaseView.setText(result, TextView.BufferType.EDITABLE);\\n\\n                renderListView();\\n            }\\n\\n        });\\n\\n\\n        // delete one record\\n        //db.deleteRecord(list.get(0));\\n\\n        // get all record\\n        //db.getAllRecords();\\n\\n    }\\n\\n\\n    /**\\n     * Render custom item\\n     */\\n    public void renderListView() {\\n        // get all records\\n        ArrayList<DatabaseRecord> list = db.getAllRecords();\\n        DatabaseAdapter adapter = new DatabaseAdapter(list, getApplicationContext(), db, this);\\n\\n        ListView listView = (ListView) findViewById(R.id.listview_database);\\n        listView.setAdapter(adapter);\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onCreateOptionsMenu\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 26, \"end_line\": 29, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"menu\", \"type\": \"Menu\"}]}, {\"name\": \"onOptionsItemSelected\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 32, \"end_line\": 35, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(DatabaseActivity.this, item.getItemId());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"item\", \"type\": \"MenuItem\"}]}, {\"name\": \"onCreate\", \"return_type\": \"void\", \"position\": {\"start_line\": 38, \"end_line\": 106, \"start_column\": 15, \"end_column\": 5}, \"code\": \"void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_database);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n\\n        /**\\n         * CRUD Operations\\n         * */\\n        // add record\\n        Configuration config = new Configuration();\\n        db = new DatabaseHelper(this);\\n        db.initDatabaseOuter();\\n        db.addRecord(new DatabaseRecord(config.default_title_database_item, config.default_author_database_item));\\n\\n        renderListView();\\n\\n\\n        // Hooking DB insert button\\n        Button mDatabaseInsertButton = (Button) findViewById(R.id.button_insert_database);\\n        mDatabaseInsertButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mTitleDatabaseView = (EditText) findViewById(R.id.title_database);\\n                EditText mAuthorDatabaseView = (EditText) findViewById(R.id.author_database);\\n\\n\\n                String title = mTitleDatabaseView.getText().toString();\\n                String author = mAuthorDatabaseView.getText().toString();\\n\\n                db.addRecord(new DatabaseRecord(title, author));\\n\\n                renderListView();\\n            }\\n\\n        });\\n\\n\\n        // Hooking DB insert button\\n        Button mDatabaseRawSQLButton = (Button) findViewById(R.id.button_raw_sql_database);\\n        mDatabaseRawSQLButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mTitleDatabaseView = (EditText) findViewById(R.id.raw_sql_database);\\n                String rawSQLText = mTitleDatabaseView.getText().toString();\\n\\n                String result = db.rawSQLQuery(rawSQLText);\\n                Log.d(\\\"htbridge\\\", result);\\n\\n                TextView mOutputDatabaseView = (TextView) findViewById(R.id.output_database);\\n                mOutputDatabaseView.setText(result, TextView.BufferType.EDITABLE);\\n\\n                renderListView();\\n            }\\n\\n        });\\n\\n\\n        // delete one record\\n        //db.deleteRecord(list.get(0));\\n\\n        // get all record\\n        //db.getAllRecords();\\n\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"savedInstanceState\", \"type\": \"Bundle\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 63, \"end_line\": 74, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                EditText mTitleDatabaseView = (EditText) findViewById(R.id.title_database);\\n                EditText mAuthorDatabaseView = (EditText) findViewById(R.id.author_database);\\n\\n\\n                String title = mTitleDatabaseView.getText().toString();\\n                String author = mAuthorDatabaseView.getText().toString();\\n\\n                db.addRecord(new DatabaseRecord(title, author));\\n\\n                renderListView();\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 84, \"end_line\": 95, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                EditText mTitleDatabaseView = (EditText) findViewById(R.id.raw_sql_database);\\n                String rawSQLText = mTitleDatabaseView.getText().toString();\\n\\n                String result = db.rawSQLQuery(rawSQLText);\\n                Log.d(\\\"htbridge\\\", result);\\n\\n                TextView mOutputDatabaseView = (TextView) findViewById(R.id.output_database);\\n                mOutputDatabaseView.setText(result, TextView.BufferType.EDITABLE);\\n\\n                renderListView();\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}, {\"name\": \"renderListView\", \"return_type\": \"void\", \"position\": {\"start_line\": 112, \"end_line\": 119, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void renderListView() {\\n        // get all records\\n        ArrayList<DatabaseRecord> list = db.getAllRecords();\\n        DatabaseAdapter adapter = new DatabaseAdapter(list, getApplicationContext(), db, this);\\n\\n        ListView listView = (ListView) findViewById(R.id.listview_database);\\n        listView.setAdapter(adapter);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/EncryptionActivity.java\", \"code\": \"package com.htbridge.pivaa;\\n\\nimport android.os.Bundle;\\nimport android.support.v7.app.AppCompatActivity;\\nimport android.support.v7.widget.Toolbar;\\nimport android.util.Log;\\nimport android.view.Menu;\\nimport android.view.MenuItem;\\nimport android.view.View;\\nimport android.widget.Button;\\nimport android.widget.EditText;\\nimport android.widget.TextView;\\n\\nimport com.htbridge.pivaa.handlers.Encryption;\\nimport com.htbridge.pivaa.handlers.MenuHandler;\\n\\npublic class EncryptionActivity extends AppCompatActivity {\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(EncryptionActivity.this, item.getItemId());\\n    }\\n\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_encryption);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n\\n\\n        // Hashing\\n        Button mHashingButton = (Button) findViewById(R.id.button_hashing);\\n        mHashingButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked hashing button\\\");\\n\\n                EditText mValueForHashingView = (EditText) findViewById(R.id.value_hashing);\\n                EditText mValueForHashingResultView = (EditText) findViewById(R.id.hashing_result);\\n\\n                String value = mValueForHashingView.getText().toString();\\n                String hashingResult = Encryption.hash(\\\"MD5\\\", value);\\n\\n                mValueForHashingResultView.setText(hashingResult, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // RNG\\n        Button mRNGButton = (Button) findViewById(R.id.button_rng);\\n        mRNGButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked rng button\\\");\\n\\n                EditText mRNGResultView = (EditText) findViewById(R.id.rng_result);\\n\\n                String rngResult = Encryption.rng();\\n\\n                mRNGResultView.setText(rngResult, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // Encryption AES/ECB/PKCS5Padding\\n        Button mEncryptionButton = (Button) findViewById(R.id.button_encryption);\\n        mEncryptionButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked encrypt button\\\");\\n\\n                EditText mEncryptionPlaintextView = (EditText) findViewById(R.id.plaintext_encryption);\\n                EditText mEncryptionCipherView = (EditText) findViewById(R.id.cipher_encryption);\\n                EditText mDecryptionCipherView = (EditText) findViewById(R.id.cipher_decryption);\\n\\n                String value = mEncryptionPlaintextView.getText().toString();\\n                String encryptionResult = Encryption.encryptAES_ECB_PKCS5Padding(value);\\n\\n                mEncryptionCipherView.setText(encryptionResult, TextView.BufferType.EDITABLE);\\n                mDecryptionCipherView.setText(encryptionResult, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n\\n        // Decryption AES/CBC/PKCS5Padding\\n        Button mWeakIVButton = (Button) findViewById(R.id.button_weak_iv);\\n        mWeakIVButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked weak IV button\\\");\\n\\n                EditText mWeakIVCiphertView = (EditText) findViewById(R.id.cipher_weak_iv);\\n                EditText mWeakIVPlaintextView = (EditText) findViewById(R.id.plaintext_weak_iv);\\n\\n                String value = mWeakIVPlaintextView.getText().toString();\\n                String encryptionResult = Encryption.encryptAES_CBC_PKCS5Padding(value);\\n\\n                mWeakIVCiphertView.setText(encryptionResult, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"EncryptionActivity\", \"position\": {\"start_line\": 17, \"end_line\": 120, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class EncryptionActivity extends AppCompatActivity {\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(EncryptionActivity.this, item.getItemId());\\n    }\\n\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_encryption);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n\\n\\n        // Hashing\\n        Button mHashingButton = (Button) findViewById(R.id.button_hashing);\\n        mHashingButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked hashing button\\\");\\n\\n                EditText mValueForHashingView = (EditText) findViewById(R.id.value_hashing);\\n                EditText mValueForHashingResultView = (EditText) findViewById(R.id.hashing_result);\\n\\n                String value = mValueForHashingView.getText().toString();\\n                String hashingResult = Encryption.hash(\\\"MD5\\\", value);\\n\\n                mValueForHashingResultView.setText(hashingResult, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // RNG\\n        Button mRNGButton = (Button) findViewById(R.id.button_rng);\\n        mRNGButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked rng button\\\");\\n\\n                EditText mRNGResultView = (EditText) findViewById(R.id.rng_result);\\n\\n                String rngResult = Encryption.rng();\\n\\n                mRNGResultView.setText(rngResult, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // Encryption AES/ECB/PKCS5Padding\\n        Button mEncryptionButton = (Button) findViewById(R.id.button_encryption);\\n        mEncryptionButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked encrypt button\\\");\\n\\n                EditText mEncryptionPlaintextView = (EditText) findViewById(R.id.plaintext_encryption);\\n                EditText mEncryptionCipherView = (EditText) findViewById(R.id.cipher_encryption);\\n                EditText mDecryptionCipherView = (EditText) findViewById(R.id.cipher_decryption);\\n\\n                String value = mEncryptionPlaintextView.getText().toString();\\n                String encryptionResult = Encryption.encryptAES_ECB_PKCS5Padding(value);\\n\\n                mEncryptionCipherView.setText(encryptionResult, TextView.BufferType.EDITABLE);\\n                mDecryptionCipherView.setText(encryptionResult, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n\\n        // Decryption AES/CBC/PKCS5Padding\\n        Button mWeakIVButton = (Button) findViewById(R.id.button_weak_iv);\\n        mWeakIVButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked weak IV button\\\");\\n\\n                EditText mWeakIVCiphertView = (EditText) findViewById(R.id.cipher_weak_iv);\\n                EditText mWeakIVPlaintextView = (EditText) findViewById(R.id.plaintext_weak_iv);\\n\\n                String value = mWeakIVPlaintextView.getText().toString();\\n                String encryptionResult = Encryption.encryptAES_CBC_PKCS5Padding(value);\\n\\n                mWeakIVCiphertView.setText(encryptionResult, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onCreateOptionsMenu\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 20, \"end_line\": 23, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"menu\", \"type\": \"Menu\"}]}, {\"name\": \"onOptionsItemSelected\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 26, \"end_line\": 29, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(EncryptionActivity.this, item.getItemId());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"item\", \"type\": \"MenuItem\"}]}, {\"name\": \"onCreate\", \"return_type\": \"void\", \"position\": {\"start_line\": 33, \"end_line\": 118, \"start_column\": 15, \"end_column\": 5}, \"code\": \"void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_encryption);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n\\n\\n        // Hashing\\n        Button mHashingButton = (Button) findViewById(R.id.button_hashing);\\n        mHashingButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked hashing button\\\");\\n\\n                EditText mValueForHashingView = (EditText) findViewById(R.id.value_hashing);\\n                EditText mValueForHashingResultView = (EditText) findViewById(R.id.hashing_result);\\n\\n                String value = mValueForHashingView.getText().toString();\\n                String hashingResult = Encryption.hash(\\\"MD5\\\", value);\\n\\n                mValueForHashingResultView.setText(hashingResult, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // RNG\\n        Button mRNGButton = (Button) findViewById(R.id.button_rng);\\n        mRNGButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked rng button\\\");\\n\\n                EditText mRNGResultView = (EditText) findViewById(R.id.rng_result);\\n\\n                String rngResult = Encryption.rng();\\n\\n                mRNGResultView.setText(rngResult, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // Encryption AES/ECB/PKCS5Padding\\n        Button mEncryptionButton = (Button) findViewById(R.id.button_encryption);\\n        mEncryptionButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked encrypt button\\\");\\n\\n                EditText mEncryptionPlaintextView = (EditText) findViewById(R.id.plaintext_encryption);\\n                EditText mEncryptionCipherView = (EditText) findViewById(R.id.cipher_encryption);\\n                EditText mDecryptionCipherView = (EditText) findViewById(R.id.cipher_decryption);\\n\\n                String value = mEncryptionPlaintextView.getText().toString();\\n                String encryptionResult = Encryption.encryptAES_ECB_PKCS5Padding(value);\\n\\n                mEncryptionCipherView.setText(encryptionResult, TextView.BufferType.EDITABLE);\\n                mDecryptionCipherView.setText(encryptionResult, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n\\n        // Decryption AES/CBC/PKCS5Padding\\n        Button mWeakIVButton = (Button) findViewById(R.id.button_weak_iv);\\n        mWeakIVButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked weak IV button\\\");\\n\\n                EditText mWeakIVCiphertView = (EditText) findViewById(R.id.cipher_weak_iv);\\n                EditText mWeakIVPlaintextView = (EditText) findViewById(R.id.plaintext_weak_iv);\\n\\n                String value = mWeakIVPlaintextView.getText().toString();\\n                String encryptionResult = Encryption.encryptAES_CBC_PKCS5Padding(value);\\n\\n                mWeakIVCiphertView.setText(encryptionResult, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"savedInstanceState\", \"type\": \"Bundle\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 47, \"end_line\": 57, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked hashing button\\\");\\n\\n                EditText mValueForHashingView = (EditText) findViewById(R.id.value_hashing);\\n                EditText mValueForHashingResultView = (EditText) findViewById(R.id.hashing_result);\\n\\n                String value = mValueForHashingView.getText().toString();\\n                String hashingResult = Encryption.hash(\\\"MD5\\\", value);\\n\\n                mValueForHashingResultView.setText(hashingResult, TextView.BufferType.EDITABLE);\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 66, \"end_line\": 74, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked rng button\\\");\\n\\n                EditText mRNGResultView = (EditText) findViewById(R.id.rng_result);\\n\\n                String rngResult = Encryption.rng();\\n\\n                mRNGResultView.setText(rngResult, TextView.BufferType.EDITABLE);\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 83, \"end_line\": 95, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked encrypt button\\\");\\n\\n                EditText mEncryptionPlaintextView = (EditText) findViewById(R.id.plaintext_encryption);\\n                EditText mEncryptionCipherView = (EditText) findViewById(R.id.cipher_encryption);\\n                EditText mDecryptionCipherView = (EditText) findViewById(R.id.cipher_decryption);\\n\\n                String value = mEncryptionPlaintextView.getText().toString();\\n                String encryptionResult = Encryption.encryptAES_ECB_PKCS5Padding(value);\\n\\n                mEncryptionCipherView.setText(encryptionResult, TextView.BufferType.EDITABLE);\\n                mDecryptionCipherView.setText(encryptionResult, TextView.BufferType.EDITABLE);\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 105, \"end_line\": 115, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked weak IV button\\\");\\n\\n                EditText mWeakIVCiphertView = (EditText) findViewById(R.id.cipher_weak_iv);\\n                EditText mWeakIVPlaintextView = (EditText) findViewById(R.id.plaintext_weak_iv);\\n\\n                String value = mWeakIVPlaintextView.getText().toString();\\n                String encryptionResult = Encryption.encryptAES_CBC_PKCS5Padding(value);\\n\\n                mWeakIVCiphertView.setText(encryptionResult, TextView.BufferType.EDITABLE);\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/LoadCodeActivity.java\", \"code\": \"package com.htbridge.pivaa;\\n\\nimport android.content.Context;\\nimport android.os.Bundle;\\nimport android.support.design.widget.FloatingActionButton;\\nimport android.support.design.widget.Snackbar;\\nimport android.support.v7.app.AppCompatActivity;\\nimport android.support.v7.widget.Toolbar;\\nimport android.util.Log;\\nimport android.view.Menu;\\nimport android.view.MenuItem;\\nimport android.view.View;\\nimport android.widget.Button;\\nimport android.widget.EditText;\\nimport android.widget.TextView;\\n\\nimport com.htbridge.pivaa.handlers.LoadCode;\\nimport com.htbridge.pivaa.handlers.MenuHandler;\\n\\nimport java.io.File;\\nimport java.io.FileOutputStream;\\nimport java.io.ObjectOutputStream;\\nimport java.io.OutputStreamWriter;\\n\\npublic class LoadCodeActivity extends AppCompatActivity {\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(LoadCodeActivity.this, item.getItemId());\\n    }\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_load_code);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        // Load code\\n        Button mLoadcodeButton = (Button) findViewById(R.id.button_load_code);\\n        mLoadcodeButton.setOnClickListener(new View.OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Load code button clicked\\\");\\n                LoadCode loadCode = new LoadCode(getApplicationContext());\\n                String result = loadCode.load(\\\"com.htbridge.raw.ExternalCode\\\");\\n\\n                TextView mOutputLoadCodeView = (TextView) findViewById(R.id.output_load_code);\\n                mOutputLoadCodeView.setText(result, TextView.BufferType.EDITABLE);\\n            }\\n        });\\n    }\\n\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"LoadCodeActivity\", \"position\": {\"start_line\": 25, \"end_line\": 63, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class LoadCodeActivity extends AppCompatActivity {\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(LoadCodeActivity.this, item.getItemId());\\n    }\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_load_code);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        // Load code\\n        Button mLoadcodeButton = (Button) findViewById(R.id.button_load_code);\\n        mLoadcodeButton.setOnClickListener(new View.OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Load code button clicked\\\");\\n                LoadCode loadCode = new LoadCode(getApplicationContext());\\n                String result = loadCode.load(\\\"com.htbridge.raw.ExternalCode\\\");\\n\\n                TextView mOutputLoadCodeView = (TextView) findViewById(R.id.output_load_code);\\n                mOutputLoadCodeView.setText(result, TextView.BufferType.EDITABLE);\\n            }\\n        });\\n    }\\n\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onCreateOptionsMenu\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 28, \"end_line\": 31, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"menu\", \"type\": \"Menu\"}]}, {\"name\": \"onOptionsItemSelected\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 34, \"end_line\": 37, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(LoadCodeActivity.this, item.getItemId());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"item\", \"type\": \"MenuItem\"}]}, {\"name\": \"onCreate\", \"return_type\": \"void\", \"position\": {\"start_line\": 40, \"end_line\": 60, \"start_column\": 15, \"end_column\": 5}, \"code\": \"void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_load_code);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        // Load code\\n        Button mLoadcodeButton = (Button) findViewById(R.id.button_load_code);\\n        mLoadcodeButton.setOnClickListener(new View.OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Load code button clicked\\\");\\n                LoadCode loadCode = new LoadCode(getApplicationContext());\\n                String result = loadCode.load(\\\"com.htbridge.raw.ExternalCode\\\");\\n\\n                TextView mOutputLoadCodeView = (TextView) findViewById(R.id.output_load_code);\\n                mOutputLoadCodeView.setText(result, TextView.BufferType.EDITABLE);\\n            }\\n        });\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"savedInstanceState\", \"type\": \"Bundle\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 51, \"end_line\": 58, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Load code button clicked\\\");\\n                LoadCode loadCode = new LoadCode(getApplicationContext());\\n                String result = loadCode.load(\\\"com.htbridge.raw.ExternalCode\\\");\\n\\n                TextView mOutputLoadCodeView = (TextView) findViewById(R.id.output_load_code);\\n                mOutputLoadCodeView.setText(result, TextView.BufferType.EDITABLE);\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/MainActivity.java\", \"code\": \"package com.htbridge.pivaa;\\n\\nimport android.animation.Animator;\\nimport android.animation.AnimatorListenerAdapter;\\nimport android.annotation.TargetApi;\\nimport android.content.Intent;\\nimport android.content.pm.PackageManager;\\nimport android.os.StrictMode;\\nimport android.support.annotation.NonNull;\\nimport android.support.v7.app.AppCompatActivity;\\n\\nimport android.os.AsyncTask;\\n\\nimport android.os.Build;\\nimport android.os.Bundle;\\nimport android.text.TextUtils;\\nimport android.util.Log;\\nimport android.view.KeyEvent;\\nimport android.view.Menu;\\nimport android.view.MenuItem;\\nimport android.view.View;\\nimport android.view.View.OnClickListener;\\nimport android.view.inputmethod.EditorInfo;\\nimport android.widget.Button;\\nimport android.widget.EditText;\\nimport android.widget.TextView;\\n\\nimport com.htbridge.pivaa.handlers.API;\\nimport com.htbridge.pivaa.handlers.Authentication;\\nimport com.htbridge.pivaa.handlers.database.DatabaseHelper;\\nimport com.htbridge.pivaa.handlers.MenuHandler;\\nimport com.htbridge.pivaa.handlers.database.DatabaseRecord;\\n\\n/**\\n * A login screen that offers login via username/password.\\n */\\npublic class MainActivity extends AppCompatActivity {\\n\\n    /**\\n     * Id to identity READ_CONTACTS permission request.\\n     */\\n    private static final int REQUEST_READ_CONTACTS = 0;\\n\\n\\n    /**\\n     * Keep track of the login task to ensure we can cancel it if requested.\\n     */\\n    private UserLoginTask mAuthTask = null;\\n\\n    // UI references.\\n    private EditText mUsernameView;\\n    private EditText mPasswordView;\\n    private View mProgressView;\\n    private View mLoginFormView;\\n\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(MainActivity.this, item.getItemId());\\n    }\\n\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_main);\\n\\n        // Set up the login form.\\n        mUsernameView = (EditText) findViewById(R.id.username);\\n        mPasswordView = (EditText) findViewById(R.id.password);\\n        mPasswordView.setOnEditorActionListener(new TextView.OnEditorActionListener() {\\n            @Override\\n            public boolean onEditorAction(TextView textView, int id, KeyEvent keyEvent) {\\n                if (id == EditorInfo.IME_ACTION_DONE || id == EditorInfo.IME_NULL) {\\n                    attemptLogin();\\n                    return true;\\n                }\\n                return false;\\n            }\\n        });\\n\\n        Button mSignInButton = (Button) findViewById(R.id.sign_in_button);\\n        mSignInButton.setOnClickListener(new OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                attemptLogin();\\n            }\\n        });\\n\\n        mLoginFormView = findViewById(R.id.login_form);\\n        mProgressView = findViewById(R.id.login_progress);\\n\\n\\n        /* Load stored credentials from external file */\\n        Authentication authCreds = new Authentication();\\n        String result = authCreds.loadLoginInfoExternalStorage(getApplicationContext());\\n\\n        /* Load JSON from API server */\\n        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();\\n        StrictMode.setThreadPolicy(policy);\\n\\n        Configuration config = new Configuration();\\n\\n        API apiComm = new API();\\n        String jsonData = apiComm.getURL(config.url_json);\\n        Log.i(\\\"htbridge\\\", jsonData);\\n\\n\\n\\n\\n        /* check if there are stored credentials */\\n        if (result.equals(\\\"\\\")) {\\n            // noop\\n        } else {\\n            /* auto input stored credentials */\\n            String[] parts = result.split(\\\":\\\");\\n            mUsernameView.setText(parts[0], TextView.BufferType.EDITABLE);\\n            mPasswordView.setText(parts[1], TextView.BufferType.EDITABLE);\\n        }\\n\\n        Log.i(\\\"htbridge\\\", \\\"Returned -> \\\" + result);\\n\\n\\n        // create sqlite db\\n        DatabaseHelper db = new DatabaseHelper(this);\\n        db.initDatabaseOuter();\\n        db.addRecord(new DatabaseRecord(config.default_title_database_item, config.default_author_database_item));\\n    }\\n\\n\\n\\n    /**\\n     * Callback received when a permissions request has been completed.\\n     */\\n    @Override\\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\\n                                           @NonNull int[] grantResults) {\\n        if (requestCode == REQUEST_READ_CONTACTS) {\\n            if (grantResults.length == 1 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\\n\\n            }\\n        }\\n    }\\n\\n\\n    /**\\n     * Attempts to sign in or register the account specified by the login form.\\n     * If there are form errors (invalid username, missing fields, etc.), the\\n     * errors are presented and no actual login attempt is made.\\n     */\\n    private void attemptLogin() {\\n        if (mAuthTask != null) {\\n            return;\\n        }\\n\\n        // Reset errors.\\n        mUsernameView.setError(null);\\n        mPasswordView.setError(null);\\n\\n        // Store values at the time of the login attempt.\\n        String username = mUsernameView.getText().toString();\\n        String password = mPasswordView.getText().toString();\\n\\n        boolean cancel = false;\\n        View focusView = null;\\n\\n        // Check for a valid password, if the user entered one.\\n        if (!TextUtils.isEmpty(password) && !isPasswordValid(password)) {\\n            mPasswordView.setError(getString(R.string.error_invalid_password));\\n            focusView = mPasswordView;\\n            cancel = true;\\n        }\\n\\n        // Check for a valid username address.\\n        if (TextUtils.isEmpty(username)) {\\n            mUsernameView.setError(getString(R.string.error_field_required));\\n            focusView = mUsernameView;\\n            cancel = true;\\n        } else if (!isUsernameValid(username)) {\\n            mUsernameView.setError(getString(R.string.error_invalid_username));\\n            focusView = mUsernameView;\\n            cancel = true;\\n        };\\n\\n        if (cancel) {\\n            // There was an error; don't attempt login and focus the first\\n            // form field with an error.\\n            focusView.requestFocus();\\n        } else {\\n            // Show a progress spinner, and kick off a background task to\\n            // perform the user login attempt.\\n            showProgress(true);\\n            mAuthTask = new UserLoginTask(username, password);\\n            mAuthTask.execute((Void) null);\\n        }\\n    }\\n\\n\\n    private boolean isUsernameValid(String username) {\\n        //TODO: Replace this with your own logic\\n        return username.length() > 3;\\n    }\\n\\n    private boolean isPasswordValid(String password) {\\n        //TODO: Replace this with your own logic\\n        return password.length() > 3;\\n    }\\n\\n\\n\\n    /**\\n     * Shows the progress UI and hides the login form.\\n     */\\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)\\n    private void showProgress(final boolean show) {\\n        // On Honeycomb MR2 we have the ViewPropertyAnimator APIs, which allow\\n        // for very easy animations. If available, use these APIs to fade-in\\n        // the progress spinner.\\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {\\n            int shortAnimTime = getResources().getInteger(android.R.integer.config_shortAnimTime);\\n\\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\\n            mLoginFormView.animate().setDuration(shortAnimTime).alpha(\\n                    show ? 0 : 1).setListener(new AnimatorListenerAdapter() {\\n                @Override\\n                public void onAnimationEnd(Animator animation) {\\n                    mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\\n                }\\n            });\\n\\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\\n            mProgressView.animate().setDuration(shortAnimTime).alpha(\\n                    show ? 1 : 0).setListener(new AnimatorListenerAdapter() {\\n                @Override\\n                public void onAnimationEnd(Animator animation) {\\n                    mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\\n                }\\n            });\\n        } else {\\n            // The ViewPropertyAnimator APIs are not available, so simply show\\n            // and hide the relevant UI components.\\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\\n        }\\n    }\\n\\n    /*@Override\\n    public Loader<Cursor> onCreateLoader(int i, Bundle bundle) {\\n\\n    }\\n    @Override\\n    public void onLoadFinished() {\\n    }\\n\\n    @Override\\n    public void onLoaderReset(Loader<Cursor> cursorLoader) {\\n\\n    }*/\\n\\n\\n\\n    /**\\n     * Represents an asynchronous login/registration task used to authenticate\\n     * the user.\\n     */\\n    public class UserLoginTask extends AsyncTask<Void, Void, Boolean> {\\n\\n        private final String mUsername;\\n        private final String mPassword;\\n\\n        UserLoginTask(String username, String password) {\\n            mUsername = username;\\n            mPassword = password;\\n\\n            Authentication authCreds = new Authentication();\\n\\n            String text = username + \\\":\\\" + password;\\n\\n            authCreds.createLockFile(getApplicationContext(), text);\\n            authCreds.saveCache(getApplicationContext(), mUsername, mPassword);\\n            authCreds.saveLoginInfoExternalStorage(getApplicationContext(), mUsername, mPassword);\\n        }\\n\\n        @Override\\n        protected Boolean doInBackground(Void... params) {\\n            // TODO: attempt authentication against a network service.\\n\\n\\n            try {\\n                // Simulate network access.\\n                Thread.sleep(2000);\\n            } catch (InterruptedException e) {\\n                return false;\\n            }\\n\\n\\n            return true;\\n        }\\n\\n        @Override\\n        protected void onPostExecute(final Boolean success) {\\n            mAuthTask = null;\\n            showProgress(false);\\n\\n            if (success) {\\n                //finish();\\n                //startActivity(new Intent(MainActivity.this, EncryptionActivity.class));\\n                startActivity(new Intent(MainActivity.this, WebviewActivity.class));\\n\\n            } else {\\n                mPasswordView.setError(getString(R.string.error_incorrect_password));\\n                mPasswordView.requestFocus();\\n            }\\n        }\\n\\n        @Override\\n        protected void onCancelled() {\\n            mAuthTask = null;\\n            showProgress(false);\\n        }\\n    }\\n}\\n\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"MainActivity\", \"position\": {\"start_line\": 37, \"end_line\": 329, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class MainActivity extends AppCompatActivity {\\n\\n    /**\\n     * Id to identity READ_CONTACTS permission request.\\n     */\\n    private static final int REQUEST_READ_CONTACTS = 0;\\n\\n\\n    /**\\n     * Keep track of the login task to ensure we can cancel it if requested.\\n     */\\n    private UserLoginTask mAuthTask = null;\\n\\n    // UI references.\\n    private EditText mUsernameView;\\n    private EditText mPasswordView;\\n    private View mProgressView;\\n    private View mLoginFormView;\\n\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(MainActivity.this, item.getItemId());\\n    }\\n\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_main);\\n\\n        // Set up the login form.\\n        mUsernameView = (EditText) findViewById(R.id.username);\\n        mPasswordView = (EditText) findViewById(R.id.password);\\n        mPasswordView.setOnEditorActionListener(new TextView.OnEditorActionListener() {\\n            @Override\\n            public boolean onEditorAction(TextView textView, int id, KeyEvent keyEvent) {\\n                if (id == EditorInfo.IME_ACTION_DONE || id == EditorInfo.IME_NULL) {\\n                    attemptLogin();\\n                    return true;\\n                }\\n                return false;\\n            }\\n        });\\n\\n        Button mSignInButton = (Button) findViewById(R.id.sign_in_button);\\n        mSignInButton.setOnClickListener(new OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                attemptLogin();\\n            }\\n        });\\n\\n        mLoginFormView = findViewById(R.id.login_form);\\n        mProgressView = findViewById(R.id.login_progress);\\n\\n\\n        /* Load stored credentials from external file */\\n        Authentication authCreds = new Authentication();\\n        String result = authCreds.loadLoginInfoExternalStorage(getApplicationContext());\\n\\n        /* Load JSON from API server */\\n        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();\\n        StrictMode.setThreadPolicy(policy);\\n\\n        Configuration config = new Configuration();\\n\\n        API apiComm = new API();\\n        String jsonData = apiComm.getURL(config.url_json);\\n        Log.i(\\\"htbridge\\\", jsonData);\\n\\n\\n\\n\\n        /* check if there are stored credentials */\\n        if (result.equals(\\\"\\\")) {\\n            // noop\\n        } else {\\n            /* auto input stored credentials */\\n            String[] parts = result.split(\\\":\\\");\\n            mUsernameView.setText(parts[0], TextView.BufferType.EDITABLE);\\n            mPasswordView.setText(parts[1], TextView.BufferType.EDITABLE);\\n        }\\n\\n        Log.i(\\\"htbridge\\\", \\\"Returned -> \\\" + result);\\n\\n\\n        // create sqlite db\\n        DatabaseHelper db = new DatabaseHelper(this);\\n        db.initDatabaseOuter();\\n        db.addRecord(new DatabaseRecord(config.default_title_database_item, config.default_author_database_item));\\n    }\\n\\n\\n\\n    /**\\n     * Callback received when a permissions request has been completed.\\n     */\\n    @Override\\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\\n                                           @NonNull int[] grantResults) {\\n        if (requestCode == REQUEST_READ_CONTACTS) {\\n            if (grantResults.length == 1 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\\n\\n            }\\n        }\\n    }\\n\\n\\n    /**\\n     * Attempts to sign in or register the account specified by the login form.\\n     * If there are form errors (invalid username, missing fields, etc.), the\\n     * errors are presented and no actual login attempt is made.\\n     */\\n    private void attemptLogin() {\\n        if (mAuthTask != null) {\\n            return;\\n        }\\n\\n        // Reset errors.\\n        mUsernameView.setError(null);\\n        mPasswordView.setError(null);\\n\\n        // Store values at the time of the login attempt.\\n        String username = mUsernameView.getText().toString();\\n        String password = mPasswordView.getText().toString();\\n\\n        boolean cancel = false;\\n        View focusView = null;\\n\\n        // Check for a valid password, if the user entered one.\\n        if (!TextUtils.isEmpty(password) && !isPasswordValid(password)) {\\n            mPasswordView.setError(getString(R.string.error_invalid_password));\\n            focusView = mPasswordView;\\n            cancel = true;\\n        }\\n\\n        // Check for a valid username address.\\n        if (TextUtils.isEmpty(username)) {\\n            mUsernameView.setError(getString(R.string.error_field_required));\\n            focusView = mUsernameView;\\n            cancel = true;\\n        } else if (!isUsernameValid(username)) {\\n            mUsernameView.setError(getString(R.string.error_invalid_username));\\n            focusView = mUsernameView;\\n            cancel = true;\\n        };\\n\\n        if (cancel) {\\n            // There was an error; don't attempt login and focus the first\\n            // form field with an error.\\n            focusView.requestFocus();\\n        } else {\\n            // Show a progress spinner, and kick off a background task to\\n            // perform the user login attempt.\\n            showProgress(true);\\n            mAuthTask = new UserLoginTask(username, password);\\n            mAuthTask.execute((Void) null);\\n        }\\n    }\\n\\n\\n    private boolean isUsernameValid(String username) {\\n        //TODO: Replace this with your own logic\\n        return username.length() > 3;\\n    }\\n\\n    private boolean isPasswordValid(String password) {\\n        //TODO: Replace this with your own logic\\n        return password.length() > 3;\\n    }\\n\\n\\n\\n    /**\\n     * Shows the progress UI and hides the login form.\\n     */\\n    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)\\n    private void showProgress(final boolean show) {\\n        // On Honeycomb MR2 we have the ViewPropertyAnimator APIs, which allow\\n        // for very easy animations. If available, use these APIs to fade-in\\n        // the progress spinner.\\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {\\n            int shortAnimTime = getResources().getInteger(android.R.integer.config_shortAnimTime);\\n\\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\\n            mLoginFormView.animate().setDuration(shortAnimTime).alpha(\\n                    show ? 0 : 1).setListener(new AnimatorListenerAdapter() {\\n                @Override\\n                public void onAnimationEnd(Animator animation) {\\n                    mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\\n                }\\n            });\\n\\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\\n            mProgressView.animate().setDuration(shortAnimTime).alpha(\\n                    show ? 1 : 0).setListener(new AnimatorListenerAdapter() {\\n                @Override\\n                public void onAnimationEnd(Animator animation) {\\n                    mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\\n                }\\n            });\\n        } else {\\n            // The ViewPropertyAnimator APIs are not available, so simply show\\n            // and hide the relevant UI components.\\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\\n        }\\n    }\\n\\n    /*@Override\\n    public Loader<Cursor> onCreateLoader(int i, Bundle bundle) {\\n\\n    }\\n    @Override\\n    public void onLoadFinished() {\\n    }\\n\\n    @Override\\n    public void onLoaderReset(Loader<Cursor> cursorLoader) {\\n\\n    }*/\\n\\n\\n\\n    /**\\n     * Represents an asynchronous login/registration task used to authenticate\\n     * the user.\\n     */\\n    public class UserLoginTask extends AsyncTask<Void, Void, Boolean> {\\n\\n        private final String mUsername;\\n        private final String mPassword;\\n\\n        UserLoginTask(String username, String password) {\\n            mUsername = username;\\n            mPassword = password;\\n\\n            Authentication authCreds = new Authentication();\\n\\n            String text = username + \\\":\\\" + password;\\n\\n            authCreds.createLockFile(getApplicationContext(), text);\\n            authCreds.saveCache(getApplicationContext(), mUsername, mPassword);\\n            authCreds.saveLoginInfoExternalStorage(getApplicationContext(), mUsername, mPassword);\\n        }\\n\\n        @Override\\n        protected Boolean doInBackground(Void... params) {\\n            // TODO: attempt authentication against a network service.\\n\\n\\n            try {\\n                // Simulate network access.\\n                Thread.sleep(2000);\\n            } catch (InterruptedException e) {\\n                return false;\\n            }\\n\\n\\n            return true;\\n        }\\n\\n        @Override\\n        protected void onPostExecute(final Boolean success) {\\n            mAuthTask = null;\\n            showProgress(false);\\n\\n            if (success) {\\n                //finish();\\n                //startActivity(new Intent(MainActivity.this, EncryptionActivity.class));\\n                startActivity(new Intent(MainActivity.this, WebviewActivity.class));\\n\\n            } else {\\n                mPasswordView.setError(getString(R.string.error_incorrect_password));\\n                mPasswordView.requestFocus();\\n            }\\n        }\\n\\n        @Override\\n        protected void onCancelled() {\\n            mAuthTask = null;\\n            showProgress(false);\\n        }\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onCreateOptionsMenu\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 58, \"end_line\": 61, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"menu\", \"type\": \"Menu\"}]}, {\"name\": \"onOptionsItemSelected\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 64, \"end_line\": 67, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(MainActivity.this, item.getItemId());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"item\", \"type\": \"MenuItem\"}]}, {\"name\": \"onCreate\", \"return_type\": \"void\", \"position\": {\"start_line\": 71, \"end_line\": 135, \"start_column\": 15, \"end_column\": 5}, \"code\": \"void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_main);\\n\\n        // Set up the login form.\\n        mUsernameView = (EditText) findViewById(R.id.username);\\n        mPasswordView = (EditText) findViewById(R.id.password);\\n        mPasswordView.setOnEditorActionListener(new TextView.OnEditorActionListener() {\\n            @Override\\n            public boolean onEditorAction(TextView textView, int id, KeyEvent keyEvent) {\\n                if (id == EditorInfo.IME_ACTION_DONE || id == EditorInfo.IME_NULL) {\\n                    attemptLogin();\\n                    return true;\\n                }\\n                return false;\\n            }\\n        });\\n\\n        Button mSignInButton = (Button) findViewById(R.id.sign_in_button);\\n        mSignInButton.setOnClickListener(new OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                attemptLogin();\\n            }\\n        });\\n\\n        mLoginFormView = findViewById(R.id.login_form);\\n        mProgressView = findViewById(R.id.login_progress);\\n\\n\\n        /* Load stored credentials from external file */\\n        Authentication authCreds = new Authentication();\\n        String result = authCreds.loadLoginInfoExternalStorage(getApplicationContext());\\n\\n        /* Load JSON from API server */\\n        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();\\n        StrictMode.setThreadPolicy(policy);\\n\\n        Configuration config = new Configuration();\\n\\n        API apiComm = new API();\\n        String jsonData = apiComm.getURL(config.url_json);\\n        Log.i(\\\"htbridge\\\", jsonData);\\n\\n\\n\\n\\n        /* check if there are stored credentials */\\n        if (result.equals(\\\"\\\")) {\\n            // noop\\n        } else {\\n            /* auto input stored credentials */\\n            String[] parts = result.split(\\\":\\\");\\n            mUsernameView.setText(parts[0], TextView.BufferType.EDITABLE);\\n            mPasswordView.setText(parts[1], TextView.BufferType.EDITABLE);\\n        }\\n\\n        Log.i(\\\"htbridge\\\", \\\"Returned -> \\\" + result);\\n\\n\\n        // create sqlite db\\n        DatabaseHelper db = new DatabaseHelper(this);\\n        db.initDatabaseOuter();\\n        db.addRecord(new DatabaseRecord(config.default_title_database_item, config.default_author_database_item));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"savedInstanceState\", \"type\": \"Bundle\"}]}, {\"name\": \"onEditorAction\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 80, \"end_line\": 86, \"start_column\": 20, \"end_column\": 13}, \"code\": \"boolean onEditorAction(TextView textView, int id, KeyEvent keyEvent) {\\n                if (id == EditorInfo.IME_ACTION_DONE || id == EditorInfo.IME_NULL) {\\n                    attemptLogin();\\n                    return true;\\n                }\\n                return false;\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"textView\", \"type\": \"TextView\"}, {\"name\": \"id\", \"type\": \"int\"}, {\"name\": \"keyEvent\", \"type\": \"KeyEvent\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 92, \"end_line\": 94, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                attemptLogin();\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}, {\"name\": \"onRequestPermissionsResult\", \"return_type\": \"void\", \"position\": {\"start_line\": 143, \"end_line\": 150, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\\n                                           @NonNull int[] grantResults) {\\n        if (requestCode == REQUEST_READ_CONTACTS) {\\n            if (grantResults.length == 1 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\\n\\n            }\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"requestCode\", \"type\": \"int\"}, {\"name\": \"permissions\", \"type\": \"String\"}, {\"name\": \"grantResults\", \"type\": \"int\"}]}, {\"name\": \"attemptLogin\", \"return_type\": \"void\", \"position\": {\"start_line\": 158, \"end_line\": 203, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void attemptLogin() {\\n        if (mAuthTask != null) {\\n            return;\\n        }\\n\\n        // Reset errors.\\n        mUsernameView.setError(null);\\n        mPasswordView.setError(null);\\n\\n        // Store values at the time of the login attempt.\\n        String username = mUsernameView.getText().toString();\\n        String password = mPasswordView.getText().toString();\\n\\n        boolean cancel = false;\\n        View focusView = null;\\n\\n        // Check for a valid password, if the user entered one.\\n        if (!TextUtils.isEmpty(password) && !isPasswordValid(password)) {\\n            mPasswordView.setError(getString(R.string.error_invalid_password));\\n            focusView = mPasswordView;\\n            cancel = true;\\n        }\\n\\n        // Check for a valid username address.\\n        if (TextUtils.isEmpty(username)) {\\n            mUsernameView.setError(getString(R.string.error_field_required));\\n            focusView = mUsernameView;\\n            cancel = true;\\n        } else if (!isUsernameValid(username)) {\\n            mUsernameView.setError(getString(R.string.error_invalid_username));\\n            focusView = mUsernameView;\\n            cancel = true;\\n        };\\n\\n        if (cancel) {\\n            // There was an error; don't attempt login and focus the first\\n            // form field with an error.\\n            focusView.requestFocus();\\n        } else {\\n            // Show a progress spinner, and kick off a background task to\\n            // perform the user login attempt.\\n            showProgress(true);\\n            mAuthTask = new UserLoginTask(username, password);\\n            mAuthTask.execute((Void) null);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isUsernameValid\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 206, \"end_line\": 209, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean isUsernameValid(String username) {\\n        //TODO: Replace this with your own logic\\n        return username.length() > 3;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"username\", \"type\": \"String\"}]}, {\"name\": \"isPasswordValid\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 211, \"end_line\": 214, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean isPasswordValid(String password) {\\n        //TODO: Replace this with your own logic\\n        return password.length() > 3;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"password\", \"type\": \"String\"}]}, {\"name\": \"showProgress\", \"return_type\": \"void\", \"position\": {\"start_line\": 222, \"end_line\": 252, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void showProgress(final boolean show) {\\n        // On Honeycomb MR2 we have the ViewPropertyAnimator APIs, which allow\\n        // for very easy animations. If available, use these APIs to fade-in\\n        // the progress spinner.\\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR2) {\\n            int shortAnimTime = getResources().getInteger(android.R.integer.config_shortAnimTime);\\n\\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\\n            mLoginFormView.animate().setDuration(shortAnimTime).alpha(\\n                    show ? 0 : 1).setListener(new AnimatorListenerAdapter() {\\n                @Override\\n                public void onAnimationEnd(Animator animation) {\\n                    mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\\n                }\\n            });\\n\\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\\n            mProgressView.animate().setDuration(shortAnimTime).alpha(\\n                    show ? 1 : 0).setListener(new AnimatorListenerAdapter() {\\n                @Override\\n                public void onAnimationEnd(Animator animation) {\\n                    mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\\n                }\\n            });\\n        } else {\\n            // The ViewPropertyAnimator APIs are not available, so simply show\\n            // and hide the relevant UI components.\\n            mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\\n            mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"show\", \"type\": \"boolean\"}]}, {\"name\": \"onAnimationEnd\", \"return_type\": \"void\", \"position\": {\"start_line\": 233, \"end_line\": 235, \"start_column\": 24, \"end_column\": 17}, \"code\": \"void onAnimationEnd(Animator animation) {\\n                    mLoginFormView.setVisibility(show ? View.GONE : View.VISIBLE);\\n                }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"animation\", \"type\": \"Animator\"}]}, {\"name\": \"onAnimationEnd\", \"return_type\": \"void\", \"position\": {\"start_line\": 242, \"end_line\": 244, \"start_column\": 24, \"end_column\": 17}, \"code\": \"void onAnimationEnd(Animator animation) {\\n                    mProgressView.setVisibility(show ? View.VISIBLE : View.GONE);\\n                }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"animation\", \"type\": \"Animator\"}]}]}, {\"parent_file\": null, \"name\": \"UserLoginTask\", \"position\": {\"start_line\": 273, \"end_line\": 328, \"start_column\": 12, \"end_column\": 5}, \"code\": \"class UserLoginTask extends AsyncTask<Void, Void, Boolean> {\\n\\n        private final String mUsername;\\n        private final String mPassword;\\n\\n        UserLoginTask(String username, String password) {\\n            mUsername = username;\\n            mPassword = password;\\n\\n            Authentication authCreds = new Authentication();\\n\\n            String text = username + \\\":\\\" + password;\\n\\n            authCreds.createLockFile(getApplicationContext(), text);\\n            authCreds.saveCache(getApplicationContext(), mUsername, mPassword);\\n            authCreds.saveLoginInfoExternalStorage(getApplicationContext(), mUsername, mPassword);\\n        }\\n\\n        @Override\\n        protected Boolean doInBackground(Void... params) {\\n            // TODO: attempt authentication against a network service.\\n\\n\\n            try {\\n                // Simulate network access.\\n                Thread.sleep(2000);\\n            } catch (InterruptedException e) {\\n                return false;\\n            }\\n\\n\\n            return true;\\n        }\\n\\n        @Override\\n        protected void onPostExecute(final Boolean success) {\\n            mAuthTask = null;\\n            showProgress(false);\\n\\n            if (success) {\\n                //finish();\\n                //startActivity(new Intent(MainActivity.this, EncryptionActivity.class));\\n                startActivity(new Intent(MainActivity.this, WebviewActivity.class));\\n\\n            } else {\\n                mPasswordView.setError(getString(R.string.error_incorrect_password));\\n                mPasswordView.requestFocus();\\n            }\\n        }\\n\\n        @Override\\n        protected void onCancelled() {\\n            mAuthTask = null;\\n            showProgress(false);\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"doInBackground\", \"return_type\": \"Boolean\", \"position\": {\"start_line\": 292, \"end_line\": 305, \"start_column\": 19, \"end_column\": 9}, \"code\": \"Boolean doInBackground(Void... params) {\\n            // TODO: attempt authentication against a network service.\\n\\n\\n            try {\\n                // Simulate network access.\\n                Thread.sleep(2000);\\n            } catch (InterruptedException e) {\\n                return false;\\n            }\\n\\n\\n            return true;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"params\", \"type\": \"Void\"}]}, {\"name\": \"onPostExecute\", \"return_type\": \"void\", \"position\": {\"start_line\": 308, \"end_line\": 321, \"start_column\": 19, \"end_column\": 9}, \"code\": \"void onPostExecute(final Boolean success) {\\n            mAuthTask = null;\\n            showProgress(false);\\n\\n            if (success) {\\n                //finish();\\n                //startActivity(new Intent(MainActivity.this, EncryptionActivity.class));\\n                startActivity(new Intent(MainActivity.this, WebviewActivity.class));\\n\\n            } else {\\n                mPasswordView.setError(getString(R.string.error_incorrect_password));\\n                mPasswordView.requestFocus();\\n            }\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"success\", \"type\": \"Boolean\"}]}, {\"name\": \"onCancelled\", \"return_type\": \"void\", \"position\": {\"start_line\": 324, \"end_line\": 327, \"start_column\": 19, \"end_column\": 9}, \"code\": \"void onCancelled() {\\n            mAuthTask = null;\\n            showProgress(false);\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/SerializeActivity.java\", \"code\": \"package com.htbridge.pivaa;\\n\\nimport android.os.Bundle;\\nimport android.support.design.widget.FloatingActionButton;\\nimport android.support.design.widget.Snackbar;\\nimport android.support.v7.app.AppCompatActivity;\\nimport android.support.v7.widget.Toolbar;\\nimport android.view.Menu;\\nimport android.view.MenuItem;\\nimport android.view.View;\\nimport android.widget.Button;\\nimport android.widget.EditText;\\nimport android.widget.TextView;\\nimport android.widget.Toast;\\n\\nimport com.htbridge.pivaa.handlers.MenuHandler;\\nimport com.htbridge.pivaa.handlers.ObjectSerialization;\\nimport com.htbridge.pivaa.handlers.database.DatabaseRecord;\\n\\nimport java.util.ServiceLoader;\\n\\npublic class SerializeActivity extends AppCompatActivity {\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(SerializeActivity.this, item.getItemId());\\n    }\\n\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_serialize);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        final String serializableFileLocation = this.getExternalFilesDir(null) + \\\"/serializable.dat\\\";\\n\\n\\n        // Hooking save\\n        Button mSaveSerializeButton = (Button) findViewById(R.id.button_save_serialize);\\n        mSaveSerializeButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mInputSerializeView = (EditText) findViewById(R.id.input_serialize);\\n                String input = mInputSerializeView.getText().toString();\\n\\n                ObjectSerialization obj = new ObjectSerialization(serializableFileLocation);\\n                obj.setProof(input);\\n                obj.saveObject();\\n            }\\n\\n        });\\n\\n        // Hooking load\\n        Button mLoadSerializeButton = (Button) findViewById(R.id.button_load_serialize);\\n        mLoadSerializeButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                ObjectSerialization obj = new ObjectSerialization(serializableFileLocation);\\n                obj.loadObject();\\n                String proof = obj.getProof();\\n                Toast.makeText(getApplicationContext(), proof, Toast.LENGTH_SHORT).show();\\n\\n                EditText mInputSerializeView = (EditText) findViewById(R.id.input_serialize);\\n                mInputSerializeView.setText(proof, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"SerializeActivity\", \"position\": {\"start_line\": 22, \"end_line\": 82, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class SerializeActivity extends AppCompatActivity {\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(SerializeActivity.this, item.getItemId());\\n    }\\n\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_serialize);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        final String serializableFileLocation = this.getExternalFilesDir(null) + \\\"/serializable.dat\\\";\\n\\n\\n        // Hooking save\\n        Button mSaveSerializeButton = (Button) findViewById(R.id.button_save_serialize);\\n        mSaveSerializeButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mInputSerializeView = (EditText) findViewById(R.id.input_serialize);\\n                String input = mInputSerializeView.getText().toString();\\n\\n                ObjectSerialization obj = new ObjectSerialization(serializableFileLocation);\\n                obj.setProof(input);\\n                obj.saveObject();\\n            }\\n\\n        });\\n\\n        // Hooking load\\n        Button mLoadSerializeButton = (Button) findViewById(R.id.button_load_serialize);\\n        mLoadSerializeButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                ObjectSerialization obj = new ObjectSerialization(serializableFileLocation);\\n                obj.loadObject();\\n                String proof = obj.getProof();\\n                Toast.makeText(getApplicationContext(), proof, Toast.LENGTH_SHORT).show();\\n\\n                EditText mInputSerializeView = (EditText) findViewById(R.id.input_serialize);\\n                mInputSerializeView.setText(proof, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onCreateOptionsMenu\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 25, \"end_line\": 28, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"menu\", \"type\": \"Menu\"}]}, {\"name\": \"onOptionsItemSelected\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 31, \"end_line\": 34, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(SerializeActivity.this, item.getItemId());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"item\", \"type\": \"MenuItem\"}]}, {\"name\": \"onCreate\", \"return_type\": \"void\", \"position\": {\"start_line\": 38, \"end_line\": 80, \"start_column\": 15, \"end_column\": 5}, \"code\": \"void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_serialize);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        final String serializableFileLocation = this.getExternalFilesDir(null) + \\\"/serializable.dat\\\";\\n\\n\\n        // Hooking save\\n        Button mSaveSerializeButton = (Button) findViewById(R.id.button_save_serialize);\\n        mSaveSerializeButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mInputSerializeView = (EditText) findViewById(R.id.input_serialize);\\n                String input = mInputSerializeView.getText().toString();\\n\\n                ObjectSerialization obj = new ObjectSerialization(serializableFileLocation);\\n                obj.setProof(input);\\n                obj.saveObject();\\n            }\\n\\n        });\\n\\n        // Hooking load\\n        Button mLoadSerializeButton = (Button) findViewById(R.id.button_load_serialize);\\n        mLoadSerializeButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                ObjectSerialization obj = new ObjectSerialization(serializableFileLocation);\\n                obj.loadObject();\\n                String proof = obj.getProof();\\n                Toast.makeText(getApplicationContext(), proof, Toast.LENGTH_SHORT).show();\\n\\n                EditText mInputSerializeView = (EditText) findViewById(R.id.input_serialize);\\n                mInputSerializeView.setText(proof, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"savedInstanceState\", \"type\": \"Bundle\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 53, \"end_line\": 60, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                EditText mInputSerializeView = (EditText) findViewById(R.id.input_serialize);\\n                String input = mInputSerializeView.getText().toString();\\n\\n                ObjectSerialization obj = new ObjectSerialization(serializableFileLocation);\\n                obj.setProof(input);\\n                obj.saveObject();\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 69, \"end_line\": 77, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                ObjectSerialization obj = new ObjectSerialization(serializableFileLocation);\\n                obj.loadObject();\\n                String proof = obj.getProof();\\n                Toast.makeText(getApplicationContext(), proof, Toast.LENGTH_SHORT).show();\\n\\n                EditText mInputSerializeView = (EditText) findViewById(R.id.input_serialize);\\n                mInputSerializeView.setText(proof, TextView.BufferType.EDITABLE);\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/ServiceActivity.java\", \"code\": \"package com.htbridge.pivaa;\\n\\nimport android.content.Intent;\\nimport android.os.Bundle;\\nimport android.support.design.widget.FloatingActionButton;\\nimport android.support.design.widget.Snackbar;\\nimport android.support.v7.app.AppCompatActivity;\\nimport android.support.v7.widget.Toolbar;\\nimport android.view.Menu;\\nimport android.view.MenuItem;\\nimport android.view.View;\\nimport android.widget.Button;\\nimport android.widget.EditText;\\n\\nimport com.htbridge.pivaa.handlers.MenuHandler;\\nimport com.htbridge.pivaa.handlers.VulnerableService;\\n\\npublic class ServiceActivity extends AppCompatActivity {\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(ServiceActivity.this, item.getItemId());\\n    }\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_service);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        // URL navigate\\n        Button mServiceButton = (Button) findViewById(R.id.button_service);\\n        mServiceButton.setOnClickListener(new View.OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                Intent serviceIntent = new Intent(ServiceActivity.this, VulnerableService.class);\\n                startService(serviceIntent);\\n            }\\n        });\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"ServiceActivity\", \"position\": {\"start_line\": 18, \"end_line\": 51, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class ServiceActivity extends AppCompatActivity {\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(ServiceActivity.this, item.getItemId());\\n    }\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_service);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        // URL navigate\\n        Button mServiceButton = (Button) findViewById(R.id.button_service);\\n        mServiceButton.setOnClickListener(new View.OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                Intent serviceIntent = new Intent(ServiceActivity.this, VulnerableService.class);\\n                startService(serviceIntent);\\n            }\\n        });\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onCreateOptionsMenu\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 21, \"end_line\": 24, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"menu\", \"type\": \"Menu\"}]}, {\"name\": \"onOptionsItemSelected\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 27, \"end_line\": 30, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(ServiceActivity.this, item.getItemId());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"item\", \"type\": \"MenuItem\"}]}, {\"name\": \"onCreate\", \"return_type\": \"void\", \"position\": {\"start_line\": 33, \"end_line\": 49, \"start_column\": 15, \"end_column\": 5}, \"code\": \"void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_service);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        // URL navigate\\n        Button mServiceButton = (Button) findViewById(R.id.button_service);\\n        mServiceButton.setOnClickListener(new View.OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                Intent serviceIntent = new Intent(ServiceActivity.this, VulnerableService.class);\\n                startService(serviceIntent);\\n            }\\n        });\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"savedInstanceState\", \"type\": \"Bundle\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 44, \"end_line\": 47, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                Intent serviceIntent = new Intent(ServiceActivity.this, VulnerableService.class);\\n                startService(serviceIntent);\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/WebviewActivity.java\", \"code\": \"package com.htbridge.pivaa;\\n\\nimport android.os.Bundle;\\nimport android.support.v7.app.AppCompatActivity;\\nimport android.support.v7.widget.Toolbar;\\nimport android.util.Log;\\nimport android.view.Menu;\\nimport android.view.MenuItem;\\nimport android.view.View;\\nimport android.webkit.WebChromeClient;\\nimport android.webkit.WebSettings;\\nimport android.webkit.WebView;\\nimport android.widget.Button;\\nimport android.widget.EditText;\\nimport android.widget.TextView;\\n\\nimport com.htbridge.pivaa.handlers.MenuHandler;\\n\\npublic class WebviewActivity extends AppCompatActivity {\\n    private WebView myWebView;\\n    private Configuration config;\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(WebviewActivity.this, item.getItemId());\\n    }\\n\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_webview);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        myWebView = (WebView) findViewById(R.id.webview);\\n        WebSettings webSettings = myWebView.getSettings();\\n        myWebView.setWebChromeClient(new WebChromeClient());\\n\\n        // setting up configuration for WebView\\n        webSettings.setJavaScriptEnabled(true);\\n        webSettings.setAllowFileAccess(true);\\n        webSettings.setPluginState(WebSettings.PluginState.ON);\\n        webSettings.setAllowUniversalAccessFromFileURLs(true);\\n\\n\\n        // loading configuration URL and showing on UI\\n        config = new Configuration();\\n\\n\\n        // URL navigate\\n        Button mWebviewButton = (Button) findViewById(R.id.button_webview);\\n        mWebviewButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                String url = mWebviewURLView.getText().toString();\\n                myWebView.loadUrl(url);\\n            }\\n\\n        });\\n\\n        // LINK 1 navigate\\n        Button mWebviewButtonLink1 = (Button) findViewById(R.id.button_webview_link1);\\n        mWebviewButtonLink1.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                myWebView.loadUrl(config.url_webview_link_1);\\n                mWebviewURLView.setText(config.url_webview_link_1, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // LINK 2 navigate\\n        Button mWebviewButtonLink2 = (Button) findViewById(R.id.button_webview_link2);\\n        mWebviewButtonLink2.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                myWebView.loadUrl(config.url_webview_link_2);\\n                mWebviewURLView.setText(config.url_webview_link_2, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // LINK 3 navigate\\n        Button mWebviewButtonLink3 = (Button) findViewById(R.id.button_webview_link3);\\n        mWebviewButtonLink3.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                myWebView.loadUrl(\\\"http://google.com\\\");\\n                mWebviewURLView.setText(\\\"http://google.com\\\", TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // XSS me\\n        Button mXSSButton = (Button) findViewById(R.id.button_xss);\\n        mXSSButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked XSS button\\\");\\n                myWebView.loadUrl(\\\"javascript:alert('Hello World!')\\\");\\n            }\\n\\n        });\\n\\n\\n        EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n        mWebviewURLView.setText(config.url_webview, TextView.BufferType.EDITABLE);\\n\\n        // opening url\\n        myWebView.loadUrl(config.url_webview);\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"WebviewActivity\", \"position\": {\"start_line\": 19, \"end_line\": 131, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class WebviewActivity extends AppCompatActivity {\\n    private WebView myWebView;\\n    private Configuration config;\\n\\n    @Override\\n    public boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(WebviewActivity.this, item.getItemId());\\n    }\\n\\n\\n    @Override\\n    protected void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_webview);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        myWebView = (WebView) findViewById(R.id.webview);\\n        WebSettings webSettings = myWebView.getSettings();\\n        myWebView.setWebChromeClient(new WebChromeClient());\\n\\n        // setting up configuration for WebView\\n        webSettings.setJavaScriptEnabled(true);\\n        webSettings.setAllowFileAccess(true);\\n        webSettings.setPluginState(WebSettings.PluginState.ON);\\n        webSettings.setAllowUniversalAccessFromFileURLs(true);\\n\\n\\n        // loading configuration URL and showing on UI\\n        config = new Configuration();\\n\\n\\n        // URL navigate\\n        Button mWebviewButton = (Button) findViewById(R.id.button_webview);\\n        mWebviewButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                String url = mWebviewURLView.getText().toString();\\n                myWebView.loadUrl(url);\\n            }\\n\\n        });\\n\\n        // LINK 1 navigate\\n        Button mWebviewButtonLink1 = (Button) findViewById(R.id.button_webview_link1);\\n        mWebviewButtonLink1.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                myWebView.loadUrl(config.url_webview_link_1);\\n                mWebviewURLView.setText(config.url_webview_link_1, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // LINK 2 navigate\\n        Button mWebviewButtonLink2 = (Button) findViewById(R.id.button_webview_link2);\\n        mWebviewButtonLink2.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                myWebView.loadUrl(config.url_webview_link_2);\\n                mWebviewURLView.setText(config.url_webview_link_2, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // LINK 3 navigate\\n        Button mWebviewButtonLink3 = (Button) findViewById(R.id.button_webview_link3);\\n        mWebviewButtonLink3.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                myWebView.loadUrl(\\\"http://google.com\\\");\\n                mWebviewURLView.setText(\\\"http://google.com\\\", TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // XSS me\\n        Button mXSSButton = (Button) findViewById(R.id.button_xss);\\n        mXSSButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked XSS button\\\");\\n                myWebView.loadUrl(\\\"javascript:alert('Hello World!')\\\");\\n            }\\n\\n        });\\n\\n\\n        EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n        mWebviewURLView.setText(config.url_webview, TextView.BufferType.EDITABLE);\\n\\n        // opening url\\n        myWebView.loadUrl(config.url_webview);\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onCreateOptionsMenu\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 24, \"end_line\": 27, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onCreateOptionsMenu(Menu menu) {\\n        getMenuInflater().inflate(R.menu.main, menu);\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"menu\", \"type\": \"Menu\"}]}, {\"name\": \"onOptionsItemSelected\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 30, \"end_line\": 33, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onOptionsItemSelected(MenuItem item) {\\n        MenuHandler menuHandler = new MenuHandler();\\n        return menuHandler.route(WebviewActivity.this, item.getItemId());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"item\", \"type\": \"MenuItem\"}]}, {\"name\": \"onCreate\", \"return_type\": \"void\", \"position\": {\"start_line\": 37, \"end_line\": 129, \"start_column\": 15, \"end_column\": 5}, \"code\": \"void onCreate(Bundle savedInstanceState) {\\n        super.onCreate(savedInstanceState);\\n        setContentView(R.layout.activity_webview);\\n\\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\\n        setSupportActionBar(toolbar);\\n\\n        myWebView = (WebView) findViewById(R.id.webview);\\n        WebSettings webSettings = myWebView.getSettings();\\n        myWebView.setWebChromeClient(new WebChromeClient());\\n\\n        // setting up configuration for WebView\\n        webSettings.setJavaScriptEnabled(true);\\n        webSettings.setAllowFileAccess(true);\\n        webSettings.setPluginState(WebSettings.PluginState.ON);\\n        webSettings.setAllowUniversalAccessFromFileURLs(true);\\n\\n\\n        // loading configuration URL and showing on UI\\n        config = new Configuration();\\n\\n\\n        // URL navigate\\n        Button mWebviewButton = (Button) findViewById(R.id.button_webview);\\n        mWebviewButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                String url = mWebviewURLView.getText().toString();\\n                myWebView.loadUrl(url);\\n            }\\n\\n        });\\n\\n        // LINK 1 navigate\\n        Button mWebviewButtonLink1 = (Button) findViewById(R.id.button_webview_link1);\\n        mWebviewButtonLink1.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                myWebView.loadUrl(config.url_webview_link_1);\\n                mWebviewURLView.setText(config.url_webview_link_1, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // LINK 2 navigate\\n        Button mWebviewButtonLink2 = (Button) findViewById(R.id.button_webview_link2);\\n        mWebviewButtonLink2.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                myWebView.loadUrl(config.url_webview_link_2);\\n                mWebviewURLView.setText(config.url_webview_link_2, TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // LINK 3 navigate\\n        Button mWebviewButtonLink3 = (Button) findViewById(R.id.button_webview_link3);\\n        mWebviewButtonLink3.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                myWebView.loadUrl(\\\"http://google.com\\\");\\n                mWebviewURLView.setText(\\\"http://google.com\\\", TextView.BufferType.EDITABLE);\\n            }\\n\\n        });\\n\\n        // XSS me\\n        Button mXSSButton = (Button) findViewById(R.id.button_xss);\\n        mXSSButton.setOnClickListener(new View.OnClickListener() {\\n\\n            @Override\\n            public void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked XSS button\\\");\\n                myWebView.loadUrl(\\\"javascript:alert('Hello World!')\\\");\\n            }\\n\\n        });\\n\\n\\n        EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n        mWebviewURLView.setText(config.url_webview, TextView.BufferType.EDITABLE);\\n\\n        // opening url\\n        myWebView.loadUrl(config.url_webview);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"savedInstanceState\", \"type\": \"Bundle\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 64, \"end_line\": 68, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                String url = mWebviewURLView.getText().toString();\\n                myWebView.loadUrl(url);\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 77, \"end_line\": 81, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                myWebView.loadUrl(config.url_webview_link_1);\\n                mWebviewURLView.setText(config.url_webview_link_1, TextView.BufferType.EDITABLE);\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 90, \"end_line\": 94, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                myWebView.loadUrl(config.url_webview_link_2);\\n                mWebviewURLView.setText(config.url_webview_link_2, TextView.BufferType.EDITABLE);\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 103, \"end_line\": 107, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                EditText mWebviewURLView = (EditText) findViewById(R.id.url_webview);\\n                myWebView.loadUrl(\\\"http://google.com\\\");\\n                mWebviewURLView.setText(\\\"http://google.com\\\", TextView.BufferType.EDITABLE);\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 116, \"end_line\": 119, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                Log.i(\\\"htbridge\\\", \\\"Clicked XSS button\\\");\\n                myWebView.loadUrl(\\\"javascript:alert('Hello World!')\\\");\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/API.java\", \"code\": \"package com.htbridge.pivaa.handlers;\\n\\nimport android.support.v7.app.AppCompatActivity;\\nimport android.util.Log;\\n\\nimport java.io.BufferedInputStream;\\nimport java.io.BufferedReader;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.io.InputStreamReader;\\nimport java.net.HttpURLConnection;\\nimport java.net.MalformedURLException;\\nimport java.net.URL;\\nimport java.security.cert.CertificateException;\\nimport java.security.cert.X509Certificate;\\n\\nimport javax.net.ssl.HostnameVerifier;\\nimport javax.net.ssl.HttpsURLConnection;\\nimport javax.net.ssl.SSLContext;\\nimport javax.net.ssl.SSLSession;\\nimport javax.net.ssl.TrustManager;\\nimport javax.net.ssl.X509TrustManager;\\n\\n\\npublic class API extends AppCompatActivity {\\n    public API() {\\n\\n    }\\n\\n    // always verify the host - dont check for certificate\\n    final static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {\\n        public boolean verify(String hostname, SSLSession session) {\\n            return true;\\n        }\\n    };\\n\\n    /**\\n     * Trust every server - dont check for any certificate\\n     */\\n    private static void trustAllHosts() {\\n        // Create a trust manager that does not validate certificate chains\\n        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\\n                return new java.security.cert.X509Certificate[] {};\\n            }\\n\\n            public void checkClientTrusted(X509Certificate[] chain,\\n                                           String authType) throws CertificateException {\\n            }\\n\\n            public void checkServerTrusted(X509Certificate[] chain,\\n                                           String authType) throws CertificateException {\\n            }\\n        } };\\n\\n        // Install the all-trusting trust manager\\n        try {\\n            SSLContext sc = SSLContext.getInstance(\\\"TLS\\\");\\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n    /**\\n     * Perform login to API by HTTP\\n     * @return\\n     */\\n    public String getURL(String inputedURL) {\\n        HttpURLConnection urlConnection = null;\\n        StringBuilder sb = new StringBuilder();\\n\\n        try {\\n            URL url = new URL(inputedURL);\\n\\n            if (url.getProtocol().toLowerCase().equals(\\\"https\\\")) {\\n                trustAllHosts();\\n                HttpsURLConnection https = (HttpsURLConnection) url.openConnection();\\n                https.setHostnameVerifier(DO_NOT_VERIFY);\\n                urlConnection = https;\\n            } else {\\n                urlConnection = (HttpURLConnection) url.openConnection();\\n            }\\n\\n            InputStreamReader inputStream = new InputStreamReader(urlConnection.getInputStream());\\n            BufferedReader in = new BufferedReader(inputStream);\\n\\n            String inputLine;\\n            while ((inputLine = in.readLine()) != null) {\\n                //System.out.println(inputLine);\\n                sb.append(inputLine).append(\\\"\\\\n\\\");\\n            }\\n            in.close();\\n            return sb.toString();\\n\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        } finally {\\n            urlConnection.disconnect();\\n        }\\n\\n        return \\\"\\\";\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"API\", \"position\": {\"start_line\": 25, \"end_line\": 105, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class API extends AppCompatActivity {\\n    public API() {\\n\\n    }\\n\\n    // always verify the host - dont check for certificate\\n    final static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {\\n        public boolean verify(String hostname, SSLSession session) {\\n            return true;\\n        }\\n    };\\n\\n    /**\\n     * Trust every server - dont check for any certificate\\n     */\\n    private static void trustAllHosts() {\\n        // Create a trust manager that does not validate certificate chains\\n        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\\n                return new java.security.cert.X509Certificate[] {};\\n            }\\n\\n            public void checkClientTrusted(X509Certificate[] chain,\\n                                           String authType) throws CertificateException {\\n            }\\n\\n            public void checkServerTrusted(X509Certificate[] chain,\\n                                           String authType) throws CertificateException {\\n            }\\n        } };\\n\\n        // Install the all-trusting trust manager\\n        try {\\n            SSLContext sc = SSLContext.getInstance(\\\"TLS\\\");\\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n    /**\\n     * Perform login to API by HTTP\\n     * @return\\n     */\\n    public String getURL(String inputedURL) {\\n        HttpURLConnection urlConnection = null;\\n        StringBuilder sb = new StringBuilder();\\n\\n        try {\\n            URL url = new URL(inputedURL);\\n\\n            if (url.getProtocol().toLowerCase().equals(\\\"https\\\")) {\\n                trustAllHosts();\\n                HttpsURLConnection https = (HttpsURLConnection) url.openConnection();\\n                https.setHostnameVerifier(DO_NOT_VERIFY);\\n                urlConnection = https;\\n            } else {\\n                urlConnection = (HttpURLConnection) url.openConnection();\\n            }\\n\\n            InputStreamReader inputStream = new InputStreamReader(urlConnection.getInputStream());\\n            BufferedReader in = new BufferedReader(inputStream);\\n\\n            String inputLine;\\n            while ((inputLine = in.readLine()) != null) {\\n                //System.out.println(inputLine);\\n                sb.append(inputLine).append(\\\"\\\\n\\\");\\n            }\\n            in.close();\\n            return sb.toString();\\n\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        } finally {\\n            urlConnection.disconnect();\\n        }\\n\\n        return \\\"\\\";\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"verify\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 32, \"end_line\": 34, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean verify(String hostname, SSLSession session) {\\n            return true;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"hostname\", \"type\": \"String\"}, {\"name\": \"session\", \"type\": \"SSLSession\"}]}, {\"name\": \"trustAllHosts\", \"return_type\": \"void\", \"position\": {\"start_line\": 40, \"end_line\": 64, \"start_column\": 20, \"end_column\": 5}, \"code\": \"void trustAllHosts() {\\n        // Create a trust manager that does not validate certificate chains\\n        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\\n                return new java.security.cert.X509Certificate[] {};\\n            }\\n\\n            public void checkClientTrusted(X509Certificate[] chain,\\n                                           String authType) throws CertificateException {\\n            }\\n\\n            public void checkServerTrusted(X509Certificate[] chain,\\n                                           String authType) throws CertificateException {\\n            }\\n        } };\\n\\n        // Install the all-trusting trust manager\\n        try {\\n            SSLContext sc = SSLContext.getInstance(\\\"TLS\\\");\\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getAcceptedIssuers\", \"return_type\": \"java\", \"position\": {\"start_line\": 43, \"end_line\": 45, \"start_column\": 20, \"end_column\": 13}, \"code\": \"java.security.cert.X509Certificate[] getAcceptedIssuers() {\\n                return new java.security.cert.X509Certificate[] {};\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"checkClientTrusted\", \"return_type\": \"void\", \"position\": {\"start_line\": 47, \"end_line\": 49, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void checkClientTrusted(X509Certificate[] chain,\\n                                           String authType) throws CertificateException {\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"chain\", \"type\": \"X509Certificate\"}, {\"name\": \"authType\", \"type\": \"String\"}]}, {\"name\": \"checkServerTrusted\", \"return_type\": \"void\", \"position\": {\"start_line\": 51, \"end_line\": 53, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void checkServerTrusted(X509Certificate[] chain,\\n                                           String authType) throws CertificateException {\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"chain\", \"type\": \"X509Certificate\"}, {\"name\": \"authType\", \"type\": \"String\"}]}, {\"name\": \"getURL\", \"return_type\": \"String\", \"position\": {\"start_line\": 70, \"end_line\": 104, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getURL(String inputedURL) {\\n        HttpURLConnection urlConnection = null;\\n        StringBuilder sb = new StringBuilder();\\n\\n        try {\\n            URL url = new URL(inputedURL);\\n\\n            if (url.getProtocol().toLowerCase().equals(\\\"https\\\")) {\\n                trustAllHosts();\\n                HttpsURLConnection https = (HttpsURLConnection) url.openConnection();\\n                https.setHostnameVerifier(DO_NOT_VERIFY);\\n                urlConnection = https;\\n            } else {\\n                urlConnection = (HttpURLConnection) url.openConnection();\\n            }\\n\\n            InputStreamReader inputStream = new InputStreamReader(urlConnection.getInputStream());\\n            BufferedReader in = new BufferedReader(inputStream);\\n\\n            String inputLine;\\n            while ((inputLine = in.readLine()) != null) {\\n                //System.out.println(inputLine);\\n                sb.append(inputLine).append(\\\"\\\\n\\\");\\n            }\\n            in.close();\\n            return sb.toString();\\n\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        } finally {\\n            urlConnection.disconnect();\\n        }\\n\\n        return \\\"\\\";\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"inputedURL\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/Authentication.java\", \"code\": \"package com.htbridge.pivaa.handlers;\\n\\nimport android.content.Context;\\nimport android.os.Environment;\\nimport android.support.v7.app.AppCompatActivity;\\nimport android.util.Log;\\n\\nimport com.htbridge.pivaa.handlers.Encryption;\\n\\nimport java.io.BufferedReader;\\nimport java.io.BufferedWriter;\\nimport java.io.File;\\nimport java.io.FileInputStream;\\nimport java.io.FileOutputStream;\\nimport java.io.FileWriter;\\nimport java.io.IOException;\\nimport java.io.InputStreamReader;\\nimport java.io.OutputStreamWriter;\\n\\n\\npublic class Authentication extends AppCompatActivity {\\n\\n    public Authentication() {\\n    }\\n\\n\\n    /**\\n     * Save loggin info\\n     * @param context\\n     * @param username\\n     * @param password\\n     * @return\\n     */\\n    public boolean saveCache(Context context, String username, String password) {\\n        String content = username + \\\":\\\" + password;\\n\\n        Log.i( \\\"info\\\", \\\"saveLoginInfo: username = \\\" + username + \\\" | password = \\\" + password);\\n\\n        try {\\n            File outputDir = context.getCacheDir(); // context being the Activity pointer\\n            File outputFile = File.createTempFile(\\\"cache\\\", \\\"\\\", outputDir);\\n\\n            content = Encryption.hash(\\\"MD5\\\", content);\\n\\n            Log.i( \\\"saveLoginInfo\\\", \\\"Saving to file \\\" + outputFile.getAbsoluteFile() + \\\" md5 content = \\\" + content);\\n\\n            FileWriter fw = new FileWriter(outputFile.getAbsoluteFile());\\n            BufferedWriter bw = new BufferedWriter(fw);\\n            bw.write(content + \\\"\\\\n\\\");\\n            bw.close();\\n\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n\\n\\n    /* Checks if external storage is available for read and write */\\n    public boolean isExternalStorageWritable() {\\n        String state = Environment.getExternalStorageState();\\n        if (Environment.MEDIA_MOUNTED.equals(state)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /* Checks if external storage is available to at least read */\\n    public boolean isExternalStorageReadable() {\\n        String state = Environment.getExternalStorageState();\\n        if (Environment.MEDIA_MOUNTED.equals(state) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\n    /**\\n     * Creates lockfile\\n     * @return boolean\\n     */\\n    public boolean createLockFile(Context context, String text) {\\n        try {\\n            Log.i( \\\"info\\\", \\\"createLockFile: start\\\");\\n            FileOutputStream fos = context.openFileOutput(\\\"lockfile\\\", context.MODE_WORLD_WRITEABLE);\\n            String string = text + \\\"\\\\n\\\";\\n            fos.write(string.getBytes());\\n            fos.close();\\n            Log.i( \\\"info\\\", \\\"createLockFile: done\\\");\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Save username and password to external file\\n     * @param context\\n     * @param username\\n     * @param password\\n     * @return boolean\\n     */\\n    public boolean saveLoginInfoExternalStorage(Context context, String username, String password) {\\n        if (isExternalStorageWritable()) {\\n            Log.i( \\\"htbridge\\\", \\\"saveLoginInfoExternalStorage: writable, all ok!\\\");\\n            Log.i( \\\"htbridge\\\", \\\"getExternalStorageDirectory = \\\" + Environment.getExternalStorageDirectory());\\n            Log.i( \\\"htbridge\\\", \\\"getExternalStoragePublicDirectory = \\\" + context.getExternalFilesDir(null) );\\n\\n\\n\\n            String filename = context.getExternalFilesDir(null) + \\\"/credentials.dat\\\";\\n\\n            Log.i( \\\"htbridge\\\", \\\"saveLoginInfoExternalStorage: username = \\\" + username + \\\" | password = \\\" + password);\\n            Log.i( \\\"htbridge\\\", \\\"saveLoginInfoExternalStorage: opening for writing \\\" + filename);\\n\\n            File file = new File(context.getExternalFilesDir(null), \\\"/credentials.dat\\\");\\n\\n            Log.i( \\\"htbridge\\\", \\\"saveLoginInfoExternalStorage: opening for reading \\\" + filename);\\n\\n            try {\\n                String content = username + \\\":\\\" + password + \\\"\\\\n\\\";\\n\\n                file.createNewFile();\\n                FileOutputStream fOut = new FileOutputStream(file);\\n                OutputStreamWriter myOutWriter = new OutputStreamWriter(fOut);\\n\\n                myOutWriter.write(content);\\n                myOutWriter.close();\\n                fOut.flush();\\n                fOut.close();\\n\\n            } catch (Exception e) {\\n                e.printStackTrace();\\n                return false;\\n            }\\n\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * Read stored username/password\\n     * @param context\\n     * @return\\n     */\\n    public String loadLoginInfoExternalStorage(Context context) {\\n        if (isExternalStorageReadable()) {\\n            Log.i( \\\"htbridge\\\", \\\"loadLoginInfoExternalStorage: readable, all ok!\\\");\\n            Log.i( \\\"htbridge\\\", \\\"getExternalStorageDirectory = \\\" + Environment.getExternalStorageDirectory());\\n            Log.i( \\\"htbridge\\\", \\\"getExternalStoragePublicDirectory = \\\" + context.getExternalFilesDir(null) );\\n\\n\\n            String filename = context.getExternalFilesDir(null) + \\\"/credentials.dat\\\";\\n            File file = new File(context.getExternalFilesDir(null), \\\"/credentials.dat\\\");\\n\\n            Log.i( \\\"htbridge\\\", \\\"loadLoginInfoExternalStorage: opening for reading \\\" + filename);\\n\\n            try {\\n                FileInputStream inputStream = new FileInputStream(file);\\n\\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\\n                StringBuilder sb = new StringBuilder();\\n                String line = null;\\n\\n                while ((line = reader.readLine()) != null) {\\n                    Log.i(\\\"htbridge\\\", line);\\n                    sb.append(line).append(\\\"\\\\n\\\");\\n                }\\n                reader.close();\\n                return sb.toString();\\n\\n            } catch (Exception e) {\\n                e.printStackTrace();\\n                return \\\"\\\";\\n            }\\n        } else {\\n            return \\\"\\\";\\n        }\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Authentication\", \"position\": {\"start_line\": 21, \"end_line\": 189, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Authentication extends AppCompatActivity {\\n\\n    public Authentication() {\\n    }\\n\\n\\n    /**\\n     * Save loggin info\\n     * @param context\\n     * @param username\\n     * @param password\\n     * @return\\n     */\\n    public boolean saveCache(Context context, String username, String password) {\\n        String content = username + \\\":\\\" + password;\\n\\n        Log.i( \\\"info\\\", \\\"saveLoginInfo: username = \\\" + username + \\\" | password = \\\" + password);\\n\\n        try {\\n            File outputDir = context.getCacheDir(); // context being the Activity pointer\\n            File outputFile = File.createTempFile(\\\"cache\\\", \\\"\\\", outputDir);\\n\\n            content = Encryption.hash(\\\"MD5\\\", content);\\n\\n            Log.i( \\\"saveLoginInfo\\\", \\\"Saving to file \\\" + outputFile.getAbsoluteFile() + \\\" md5 content = \\\" + content);\\n\\n            FileWriter fw = new FileWriter(outputFile.getAbsoluteFile());\\n            BufferedWriter bw = new BufferedWriter(fw);\\n            bw.write(content + \\\"\\\\n\\\");\\n            bw.close();\\n\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n\\n\\n    /* Checks if external storage is available for read and write */\\n    public boolean isExternalStorageWritable() {\\n        String state = Environment.getExternalStorageState();\\n        if (Environment.MEDIA_MOUNTED.equals(state)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /* Checks if external storage is available to at least read */\\n    public boolean isExternalStorageReadable() {\\n        String state = Environment.getExternalStorageState();\\n        if (Environment.MEDIA_MOUNTED.equals(state) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\n    /**\\n     * Creates lockfile\\n     * @return boolean\\n     */\\n    public boolean createLockFile(Context context, String text) {\\n        try {\\n            Log.i( \\\"info\\\", \\\"createLockFile: start\\\");\\n            FileOutputStream fos = context.openFileOutput(\\\"lockfile\\\", context.MODE_WORLD_WRITEABLE);\\n            String string = text + \\\"\\\\n\\\";\\n            fos.write(string.getBytes());\\n            fos.close();\\n            Log.i( \\\"info\\\", \\\"createLockFile: done\\\");\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Save username and password to external file\\n     * @param context\\n     * @param username\\n     * @param password\\n     * @return boolean\\n     */\\n    public boolean saveLoginInfoExternalStorage(Context context, String username, String password) {\\n        if (isExternalStorageWritable()) {\\n            Log.i( \\\"htbridge\\\", \\\"saveLoginInfoExternalStorage: writable, all ok!\\\");\\n            Log.i( \\\"htbridge\\\", \\\"getExternalStorageDirectory = \\\" + Environment.getExternalStorageDirectory());\\n            Log.i( \\\"htbridge\\\", \\\"getExternalStoragePublicDirectory = \\\" + context.getExternalFilesDir(null) );\\n\\n\\n\\n            String filename = context.getExternalFilesDir(null) + \\\"/credentials.dat\\\";\\n\\n            Log.i( \\\"htbridge\\\", \\\"saveLoginInfoExternalStorage: username = \\\" + username + \\\" | password = \\\" + password);\\n            Log.i( \\\"htbridge\\\", \\\"saveLoginInfoExternalStorage: opening for writing \\\" + filename);\\n\\n            File file = new File(context.getExternalFilesDir(null), \\\"/credentials.dat\\\");\\n\\n            Log.i( \\\"htbridge\\\", \\\"saveLoginInfoExternalStorage: opening for reading \\\" + filename);\\n\\n            try {\\n                String content = username + \\\":\\\" + password + \\\"\\\\n\\\";\\n\\n                file.createNewFile();\\n                FileOutputStream fOut = new FileOutputStream(file);\\n                OutputStreamWriter myOutWriter = new OutputStreamWriter(fOut);\\n\\n                myOutWriter.write(content);\\n                myOutWriter.close();\\n                fOut.flush();\\n                fOut.close();\\n\\n            } catch (Exception e) {\\n                e.printStackTrace();\\n                return false;\\n            }\\n\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * Read stored username/password\\n     * @param context\\n     * @return\\n     */\\n    public String loadLoginInfoExternalStorage(Context context) {\\n        if (isExternalStorageReadable()) {\\n            Log.i( \\\"htbridge\\\", \\\"loadLoginInfoExternalStorage: readable, all ok!\\\");\\n            Log.i( \\\"htbridge\\\", \\\"getExternalStorageDirectory = \\\" + Environment.getExternalStorageDirectory());\\n            Log.i( \\\"htbridge\\\", \\\"getExternalStoragePublicDirectory = \\\" + context.getExternalFilesDir(null) );\\n\\n\\n            String filename = context.getExternalFilesDir(null) + \\\"/credentials.dat\\\";\\n            File file = new File(context.getExternalFilesDir(null), \\\"/credentials.dat\\\");\\n\\n            Log.i( \\\"htbridge\\\", \\\"loadLoginInfoExternalStorage: opening for reading \\\" + filename);\\n\\n            try {\\n                FileInputStream inputStream = new FileInputStream(file);\\n\\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\\n                StringBuilder sb = new StringBuilder();\\n                String line = null;\\n\\n                while ((line = reader.readLine()) != null) {\\n                    Log.i(\\\"htbridge\\\", line);\\n                    sb.append(line).append(\\\"\\\\n\\\");\\n                }\\n                reader.close();\\n                return sb.toString();\\n\\n            } catch (Exception e) {\\n                e.printStackTrace();\\n                return \\\"\\\";\\n            }\\n        } else {\\n            return \\\"\\\";\\n        }\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"saveCache\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 34, \"end_line\": 58, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean saveCache(Context context, String username, String password) {\\n        String content = username + \\\":\\\" + password;\\n\\n        Log.i( \\\"info\\\", \\\"saveLoginInfo: username = \\\" + username + \\\" | password = \\\" + password);\\n\\n        try {\\n            File outputDir = context.getCacheDir(); // context being the Activity pointer\\n            File outputFile = File.createTempFile(\\\"cache\\\", \\\"\\\", outputDir);\\n\\n            content = Encryption.hash(\\\"MD5\\\", content);\\n\\n            Log.i( \\\"saveLoginInfo\\\", \\\"Saving to file \\\" + outputFile.getAbsoluteFile() + \\\" md5 content = \\\" + content);\\n\\n            FileWriter fw = new FileWriter(outputFile.getAbsoluteFile());\\n            BufferedWriter bw = new BufferedWriter(fw);\\n            bw.write(content + \\\"\\\\n\\\");\\n            bw.close();\\n\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n            return false;\\n        }\\n\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"context\", \"type\": \"Context\"}, {\"name\": \"username\", \"type\": \"String\"}, {\"name\": \"password\", \"type\": \"String\"}]}, {\"name\": \"isExternalStorageWritable\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 63, \"end_line\": 69, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isExternalStorageWritable() {\\n        String state = Environment.getExternalStorageState();\\n        if (Environment.MEDIA_MOUNTED.equals(state)) {\\n            return true;\\n        }\\n        return false;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isExternalStorageReadable\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 72, \"end_line\": 78, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isExternalStorageReadable() {\\n        String state = Environment.getExternalStorageState();\\n        if (Environment.MEDIA_MOUNTED.equals(state) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {\\n            return true;\\n        }\\n        return false;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"createLockFile\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 85, \"end_line\": 99, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean createLockFile(Context context, String text) {\\n        try {\\n            Log.i( \\\"info\\\", \\\"createLockFile: start\\\");\\n            FileOutputStream fos = context.openFileOutput(\\\"lockfile\\\", context.MODE_WORLD_WRITEABLE);\\n            String string = text + \\\"\\\\n\\\";\\n            fos.write(string.getBytes());\\n            fos.close();\\n            Log.i( \\\"info\\\", \\\"createLockFile: done\\\");\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            return false;\\n        }\\n\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"context\", \"type\": \"Context\"}, {\"name\": \"text\", \"type\": \"String\"}]}, {\"name\": \"saveLoginInfoExternalStorage\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 108, \"end_line\": 147, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean saveLoginInfoExternalStorage(Context context, String username, String password) {\\n        if (isExternalStorageWritable()) {\\n            Log.i( \\\"htbridge\\\", \\\"saveLoginInfoExternalStorage: writable, all ok!\\\");\\n            Log.i( \\\"htbridge\\\", \\\"getExternalStorageDirectory = \\\" + Environment.getExternalStorageDirectory());\\n            Log.i( \\\"htbridge\\\", \\\"getExternalStoragePublicDirectory = \\\" + context.getExternalFilesDir(null) );\\n\\n\\n\\n            String filename = context.getExternalFilesDir(null) + \\\"/credentials.dat\\\";\\n\\n            Log.i( \\\"htbridge\\\", \\\"saveLoginInfoExternalStorage: username = \\\" + username + \\\" | password = \\\" + password);\\n            Log.i( \\\"htbridge\\\", \\\"saveLoginInfoExternalStorage: opening for writing \\\" + filename);\\n\\n            File file = new File(context.getExternalFilesDir(null), \\\"/credentials.dat\\\");\\n\\n            Log.i( \\\"htbridge\\\", \\\"saveLoginInfoExternalStorage: opening for reading \\\" + filename);\\n\\n            try {\\n                String content = username + \\\":\\\" + password + \\\"\\\\n\\\";\\n\\n                file.createNewFile();\\n                FileOutputStream fOut = new FileOutputStream(file);\\n                OutputStreamWriter myOutWriter = new OutputStreamWriter(fOut);\\n\\n                myOutWriter.write(content);\\n                myOutWriter.close();\\n                fOut.flush();\\n                fOut.close();\\n\\n            } catch (Exception e) {\\n                e.printStackTrace();\\n                return false;\\n            }\\n\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"context\", \"type\": \"Context\"}, {\"name\": \"username\", \"type\": \"String\"}, {\"name\": \"password\", \"type\": \"String\"}]}, {\"name\": \"loadLoginInfoExternalStorage\", \"return_type\": \"String\", \"position\": {\"start_line\": 154, \"end_line\": 187, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String loadLoginInfoExternalStorage(Context context) {\\n        if (isExternalStorageReadable()) {\\n            Log.i( \\\"htbridge\\\", \\\"loadLoginInfoExternalStorage: readable, all ok!\\\");\\n            Log.i( \\\"htbridge\\\", \\\"getExternalStorageDirectory = \\\" + Environment.getExternalStorageDirectory());\\n            Log.i( \\\"htbridge\\\", \\\"getExternalStoragePublicDirectory = \\\" + context.getExternalFilesDir(null) );\\n\\n\\n            String filename = context.getExternalFilesDir(null) + \\\"/credentials.dat\\\";\\n            File file = new File(context.getExternalFilesDir(null), \\\"/credentials.dat\\\");\\n\\n            Log.i( \\\"htbridge\\\", \\\"loadLoginInfoExternalStorage: opening for reading \\\" + filename);\\n\\n            try {\\n                FileInputStream inputStream = new FileInputStream(file);\\n\\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\\n                StringBuilder sb = new StringBuilder();\\n                String line = null;\\n\\n                while ((line = reader.readLine()) != null) {\\n                    Log.i(\\\"htbridge\\\", line);\\n                    sb.append(line).append(\\\"\\\\n\\\");\\n                }\\n                reader.close();\\n                return sb.toString();\\n\\n            } catch (Exception e) {\\n                e.printStackTrace();\\n                return \\\"\\\";\\n            }\\n        } else {\\n            return \\\"\\\";\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"context\", \"type\": \"Context\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/Encryption.java\", \"code\": \"package com.htbridge.pivaa.handlers;\\n\\nimport java.math.BigInteger;\\nimport java.security.MessageDigest;\\nimport java.util.Random;\\n\\nimport javax.crypto.Cipher;\\nimport javax.crypto.spec.IvParameterSpec;\\nimport javax.crypto.spec.SecretKeySpec;\\nimport org.apache.commons.codec.binary.Base64;\\n\\npublic final class Encryption {\\n\\n    /**\\n     * Hashing algorithm\\n     * @param text\\n     * @return\\n     */\\n    public static String hash(String algorithm, String text) {\\n        String hashedOutput = \\\"\\\";\\n        MessageDigest digest = null;\\n\\n        try {\\n            digest = MessageDigest.getInstance(algorithm);\\n            digest.update(text.getBytes());\\n            byte[] messageDigest = digest.digest();\\n\\n            hashedOutput = String.format(\\\"%032X\\\", new BigInteger(1, messageDigest));\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        return hashedOutput;\\n    }\\n\\n    /**\\n     * Weak random number generator\\n     * @return\\n     */\\n    public static String rng() {\\n        Random rnd = new Random();\\n        int n = rnd.nextInt(100000) + 1;\\n\\n        return Integer.toString(n);\\n    }\\n\\n    /**\\n     * Encrypt DATA\\n     * @param value\\n     * @return\\n     */\\n    public static String encryptAES_ECB_PKCS5Padding(String value) {\\n        try {\\n            byte[] key = {\\n                    1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1\\n            };\\n            SecretKeySpec skeySpec = new SecretKeySpec(key, \\\"AES\\\");\\n\\n            Cipher cipher = Cipher.getInstance(\\\"AES/ECB/PKCS5Padding\\\");\\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\\n\\n            byte[] encrypted = cipher.doFinal(value.getBytes());\\n\\n            Base64 b64 = new Base64();\\n            System.out.println(\\\"encrypted string: \\\" + new String(b64.encodeBase64(encrypted)));\\n\\n            return new String(b64.encodeBase64(encrypted));\\n        } catch (Exception ex) {\\n            ex.printStackTrace();\\n        }\\n\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * Decrypt DATA\\n     * @param encryptedBase64\\n     * @return\\n     */\\n    public static String decryptAES_ECB_PKCS5Padding(String encryptedBase64) {\\n        try {\\n            byte[] IV = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n            IvParameterSpec iv = new IvParameterSpec(IV);\\n\\n            byte[] key = {\\n                    1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1\\n            };\\n            SecretKeySpec skeySpec = new SecretKeySpec(key, \\\"AES\\\");\\n\\n            Cipher cipher = Cipher.getInstance(\\\"AES/ECB/PKCS5Padding\\\");\\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec);\\n\\n            Base64 b64 = new Base64();\\n            byte[] encryptedBase64Bytes = encryptedBase64.getBytes();\\n            byte[] original = cipher.doFinal(b64.decodeBase64(encryptedBase64Bytes));\\n\\n            return new String(original);\\n        } catch (Exception ex) {\\n            ex.printStackTrace();\\n        }\\n\\n        return null;\\n    }\\n\\n\\n\\n    /**\\n     * Encrypt DATA\\n     * @param value\\n     * @return\\n     */\\n    public static String encryptAES_CBC_PKCS5Padding(String value) {\\n        try {\\n            byte[] IV = {\\n                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\\n            };\\n            IvParameterSpec iv = new IvParameterSpec(IV);\\n\\n            byte[] key = {\\n                    1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1\\n            };\\n            SecretKeySpec skeySpec = new SecretKeySpec(key, \\\"AES\\\");\\n\\n            Cipher cipher = Cipher.getInstance(\\\"AES/CBC/PKCS5Padding\\\");\\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\\n\\n            byte[] encrypted = cipher.doFinal(value.getBytes());\\n\\n            Base64 b64 = new Base64();\\n            System.out.println(\\\"encrypted string: \\\" + new String(b64.encodeBase64(encrypted)));\\n\\n            return new String(b64.encodeBase64(encrypted));\\n        } catch (Exception ex) {\\n            ex.printStackTrace();\\n        }\\n\\n        return \\\"\\\";\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Encryption\", \"position\": {\"start_line\": 12, \"end_line\": 139, \"start_column\": 14, \"end_column\": 1}, \"code\": \"class Encryption {\\n\\n    /**\\n     * Hashing algorithm\\n     * @param text\\n     * @return\\n     */\\n    public static String hash(String algorithm, String text) {\\n        String hashedOutput = \\\"\\\";\\n        MessageDigest digest = null;\\n\\n        try {\\n            digest = MessageDigest.getInstance(algorithm);\\n            digest.update(text.getBytes());\\n            byte[] messageDigest = digest.digest();\\n\\n            hashedOutput = String.format(\\\"%032X\\\", new BigInteger(1, messageDigest));\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        return hashedOutput;\\n    }\\n\\n    /**\\n     * Weak random number generator\\n     * @return\\n     */\\n    public static String rng() {\\n        Random rnd = new Random();\\n        int n = rnd.nextInt(100000) + 1;\\n\\n        return Integer.toString(n);\\n    }\\n\\n    /**\\n     * Encrypt DATA\\n     * @param value\\n     * @return\\n     */\\n    public static String encryptAES_ECB_PKCS5Padding(String value) {\\n        try {\\n            byte[] key = {\\n                    1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1\\n            };\\n            SecretKeySpec skeySpec = new SecretKeySpec(key, \\\"AES\\\");\\n\\n            Cipher cipher = Cipher.getInstance(\\\"AES/ECB/PKCS5Padding\\\");\\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\\n\\n            byte[] encrypted = cipher.doFinal(value.getBytes());\\n\\n            Base64 b64 = new Base64();\\n            System.out.println(\\\"encrypted string: \\\" + new String(b64.encodeBase64(encrypted)));\\n\\n            return new String(b64.encodeBase64(encrypted));\\n        } catch (Exception ex) {\\n            ex.printStackTrace();\\n        }\\n\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * Decrypt DATA\\n     * @param encryptedBase64\\n     * @return\\n     */\\n    public static String decryptAES_ECB_PKCS5Padding(String encryptedBase64) {\\n        try {\\n            byte[] IV = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n            IvParameterSpec iv = new IvParameterSpec(IV);\\n\\n            byte[] key = {\\n                    1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1\\n            };\\n            SecretKeySpec skeySpec = new SecretKeySpec(key, \\\"AES\\\");\\n\\n            Cipher cipher = Cipher.getInstance(\\\"AES/ECB/PKCS5Padding\\\");\\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec);\\n\\n            Base64 b64 = new Base64();\\n            byte[] encryptedBase64Bytes = encryptedBase64.getBytes();\\n            byte[] original = cipher.doFinal(b64.decodeBase64(encryptedBase64Bytes));\\n\\n            return new String(original);\\n        } catch (Exception ex) {\\n            ex.printStackTrace();\\n        }\\n\\n        return null;\\n    }\\n\\n\\n\\n    /**\\n     * Encrypt DATA\\n     * @param value\\n     * @return\\n     */\\n    public static String encryptAES_CBC_PKCS5Padding(String value) {\\n        try {\\n            byte[] IV = {\\n                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\\n            };\\n            IvParameterSpec iv = new IvParameterSpec(IV);\\n\\n            byte[] key = {\\n                    1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1\\n            };\\n            SecretKeySpec skeySpec = new SecretKeySpec(key, \\\"AES\\\");\\n\\n            Cipher cipher = Cipher.getInstance(\\\"AES/CBC/PKCS5Padding\\\");\\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\\n\\n            byte[] encrypted = cipher.doFinal(value.getBytes());\\n\\n            Base64 b64 = new Base64();\\n            System.out.println(\\\"encrypted string: \\\" + new String(b64.encodeBase64(encrypted)));\\n\\n            return new String(b64.encodeBase64(encrypted));\\n        } catch (Exception ex) {\\n            ex.printStackTrace();\\n        }\\n\\n        return \\\"\\\";\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"hash\", \"return_type\": \"String\", \"position\": {\"start_line\": 19, \"end_line\": 34, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hash(String algorithm, String text) {\\n        String hashedOutput = \\\"\\\";\\n        MessageDigest digest = null;\\n\\n        try {\\n            digest = MessageDigest.getInstance(algorithm);\\n            digest.update(text.getBytes());\\n            byte[] messageDigest = digest.digest();\\n\\n            hashedOutput = String.format(\\\"%032X\\\", new BigInteger(1, messageDigest));\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        return hashedOutput;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"algorithm\", \"type\": \"String\"}, {\"name\": \"text\", \"type\": \"String\"}]}, {\"name\": \"rng\", \"return_type\": \"String\", \"position\": {\"start_line\": 40, \"end_line\": 45, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String rng() {\\n        Random rnd = new Random();\\n        int n = rnd.nextInt(100000) + 1;\\n\\n        return Integer.toString(n);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"encryptAES_ECB_PKCS5Padding\", \"return_type\": \"String\", \"position\": {\"start_line\": 52, \"end_line\": 73, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String encryptAES_ECB_PKCS5Padding(String value) {\\n        try {\\n            byte[] key = {\\n                    1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1\\n            };\\n            SecretKeySpec skeySpec = new SecretKeySpec(key, \\\"AES\\\");\\n\\n            Cipher cipher = Cipher.getInstance(\\\"AES/ECB/PKCS5Padding\\\");\\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\\n\\n            byte[] encrypted = cipher.doFinal(value.getBytes());\\n\\n            Base64 b64 = new Base64();\\n            System.out.println(\\\"encrypted string: \\\" + new String(b64.encodeBase64(encrypted)));\\n\\n            return new String(b64.encodeBase64(encrypted));\\n        } catch (Exception ex) {\\n            ex.printStackTrace();\\n        }\\n\\n        return \\\"\\\";\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}]}, {\"name\": \"decryptAES_ECB_PKCS5Padding\", \"return_type\": \"String\", \"position\": {\"start_line\": 80, \"end_line\": 103, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String decryptAES_ECB_PKCS5Padding(String encryptedBase64) {\\n        try {\\n            byte[] IV = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\\n            IvParameterSpec iv = new IvParameterSpec(IV);\\n\\n            byte[] key = {\\n                    1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1\\n            };\\n            SecretKeySpec skeySpec = new SecretKeySpec(key, \\\"AES\\\");\\n\\n            Cipher cipher = Cipher.getInstance(\\\"AES/ECB/PKCS5Padding\\\");\\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec);\\n\\n            Base64 b64 = new Base64();\\n            byte[] encryptedBase64Bytes = encryptedBase64.getBytes();\\n            byte[] original = cipher.doFinal(b64.decodeBase64(encryptedBase64Bytes));\\n\\n            return new String(original);\\n        } catch (Exception ex) {\\n            ex.printStackTrace();\\n        }\\n\\n        return null;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"encryptedBase64\", \"type\": \"String\"}]}, {\"name\": \"encryptAES_CBC_PKCS5Padding\", \"return_type\": \"String\", \"position\": {\"start_line\": 112, \"end_line\": 138, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String encryptAES_CBC_PKCS5Padding(String value) {\\n        try {\\n            byte[] IV = {\\n                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\\n            };\\n            IvParameterSpec iv = new IvParameterSpec(IV);\\n\\n            byte[] key = {\\n                    1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1\\n            };\\n            SecretKeySpec skeySpec = new SecretKeySpec(key, \\\"AES\\\");\\n\\n            Cipher cipher = Cipher.getInstance(\\\"AES/CBC/PKCS5Padding\\\");\\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\\n\\n            byte[] encrypted = cipher.doFinal(value.getBytes());\\n\\n            Base64 b64 = new Base64();\\n            System.out.println(\\\"encrypted string: \\\" + new String(b64.encodeBase64(encrypted)));\\n\\n            return new String(b64.encodeBase64(encrypted));\\n        } catch (Exception ex) {\\n            ex.printStackTrace();\\n        }\\n\\n        return \\\"\\\";\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/LoadCode.java\", \"code\": \"package com.htbridge.pivaa.handlers;\\n\\nimport android.content.Context;\\nimport android.util.Log;\\n\\nimport java.io.File;\\nimport java.io.FileOutputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.lang.reflect.Method;\\n\\nimport dalvik.system.DexClassLoader;\\n\\n\\npublic class LoadCode extends ClassLoader {\\n    Context context;\\n\\n    public LoadCode(Context context) {\\n        this.context = context;\\n    }\\n\\n    /**\\n     * Method for load and execute class\\n     * @param classname\\n     * @return\\n     */\\n    public String load(String classname) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        String path = classname;\\n        path = path.replace('.', '/');\\n        path = \\\"assets/\\\" + path + \\\".jar\\\";\\n\\n\\n        String[] classnameExploded = classname.split(\\\"\\\\\\\\.\\\");\\n        classname = classnameExploded[classnameExploded.length - 1];\\n\\n        String resCopy = copyAssetsToFiles(path);\\n        sb.append(resCopy).append(\\\"\\\\n\\\").append(\\\"\\\\n\\\");\\n\\n        String filePath = context.getFilesDir().getPath() + \\\"/test.jar\\\";\\n\\n        Log.i(\\\"htbridge\\\", \\\"Loading class file \\\" + filePath);\\n        sb.append(\\\"Loading class file \\\" + filePath).append(\\\"\\\\n\\\").append(\\\"\\\\n\\\");\\n\\n\\n        /**\\n         * Print all assets\\n         */\\n        /*try {\\n            String[] res = this.context.getAssets().list(\\\"com/htbridge/raw\\\");\\n            for (String s: res) {\\n                Log.i(\\\"htbridge\\\", s);\\n            }\\n        } catch(Exception e) {\\n            e.printStackTrace();\\n        }*/\\n\\n\\n        try {\\n            String dexDir = this.context.getDir(\\\"dex\\\", 0).getAbsolutePath();\\n            ClassLoader parent = getClass().getClassLoader();\\n            DexClassLoader loader  = new DexClassLoader(filePath, dexDir, null, parent);\\n            Class c = loader.loadClass(classname);\\n            Object o = c.newInstance();\\n            Method m = c.getMethod(\\\"run\\\");\\n\\n            Object res = m.invoke(o);\\n\\n            Log.i(\\\"htbridge\\\", res.toString());\\n            sb.append(\\\"Output from executed code: \\\\\\\"\\\" + res.toString() + \\\"\\\\\\\"\\\").append(\\\"\\\\n\\\").append(\\\"\\\\n\\\");\\n\\n            return sb.toString();\\n\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        sb.append(\\\"Error in running\\\").append(\\\"\\\\n\\\").append(\\\"\\\\n\\\");\\n\\n        return sb.toString();\\n    }\\n\\n\\n    /**\\n     * Copy the DEX file from assets to folder for optimized DEX\\n     */\\n    public String copyAssetsToFiles(String sourceFile) {\\n        String fileDir = this.context.getFilesDir().getPath() + \\\"/\\\";\\n        File workingDir = new File(fileDir);\\n        if (!workingDir.exists()) {\\n            workingDir.mkdirs();\\n        }\\n        Log.i(\\\"htbridge\\\", \\\"Copying \\\" + sourceFile);\\n\\n        File outFileBin = new File(workingDir, \\\"test.jar\\\");\\n        if (!outFileBin.exists()) {\\n            copyFile(this.context, sourceFile, outFileBin);\\n            outFileBin.setExecutable(true, false);\\n        }\\n\\n        return \\\"Copying \\\" + sourceFile + \\\" to \\\" + workingDir + \\\"/test.jar\\\";\\n    }\\n\\n    /**\\n     * Copy file\\n     */\\n    private void copyFile(Context context, String sourceFileName, File targetFile) {\\n        InputStream in = null;\\n        FileOutputStream out = null;\\n        try {\\n            in = context.getAssets().open(sourceFileName);\\n            out = new FileOutputStream(targetFile);\\n            byte[] temp = new byte[1024];\\n            int count = 0;\\n            while ((count = in.read(temp)) > 0) {\\n                out.write(temp, 0, count);\\n            }\\n\\n            if (in != null) {\\n                in.close();\\n            }\\n            if (out != null) {\\n                out.close();\\n            }\\n        } catch (Exception e) {\\n            if (in != null) {\\n                try {\\n                    in.close();\\n                } catch (IOException e1) {\\n                    e1.printStackTrace();\\n                }\\n            }\\n\\n            if (out != null) {\\n                try {\\n                    out.close();\\n                } catch (IOException e1) {\\n                    e1.printStackTrace();\\n                }\\n            }\\n        }\\n    }\\n}\", \"classes\": [{\"parent_file\": null, \"name\": \"LoadCode\", \"position\": {\"start_line\": 15, \"end_line\": 144, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class LoadCode extends ClassLoader {\\n    Context context;\\n\\n    public LoadCode(Context context) {\\n        this.context = context;\\n    }\\n\\n    /**\\n     * Method for load and execute class\\n     * @param classname\\n     * @return\\n     */\\n    public String load(String classname) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        String path = classname;\\n        path = path.replace('.', '/');\\n        path = \\\"assets/\\\" + path + \\\".jar\\\";\\n\\n\\n        String[] classnameExploded = classname.split(\\\"\\\\\\\\.\\\");\\n        classname = classnameExploded[classnameExploded.length - 1];\\n\\n        String resCopy = copyAssetsToFiles(path);\\n        sb.append(resCopy).append(\\\"\\\\n\\\").append(\\\"\\\\n\\\");\\n\\n        String filePath = context.getFilesDir().getPath() + \\\"/test.jar\\\";\\n\\n        Log.i(\\\"htbridge\\\", \\\"Loading class file \\\" + filePath);\\n        sb.append(\\\"Loading class file \\\" + filePath).append(\\\"\\\\n\\\").append(\\\"\\\\n\\\");\\n\\n\\n        /**\\n         * Print all assets\\n         */\\n        /*try {\\n            String[] res = this.context.getAssets().list(\\\"com/htbridge/raw\\\");\\n            for (String s: res) {\\n                Log.i(\\\"htbridge\\\", s);\\n            }\\n        } catch(Exception e) {\\n            e.printStackTrace();\\n        }*/\\n\\n\\n        try {\\n            String dexDir = this.context.getDir(\\\"dex\\\", 0).getAbsolutePath();\\n            ClassLoader parent = getClass().getClassLoader();\\n            DexClassLoader loader  = new DexClassLoader(filePath, dexDir, null, parent);\\n            Class c = loader.loadClass(classname);\\n            Object o = c.newInstance();\\n            Method m = c.getMethod(\\\"run\\\");\\n\\n            Object res = m.invoke(o);\\n\\n            Log.i(\\\"htbridge\\\", res.toString());\\n            sb.append(\\\"Output from executed code: \\\\\\\"\\\" + res.toString() + \\\"\\\\\\\"\\\").append(\\\"\\\\n\\\").append(\\\"\\\\n\\\");\\n\\n            return sb.toString();\\n\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        sb.append(\\\"Error in running\\\").append(\\\"\\\\n\\\").append(\\\"\\\\n\\\");\\n\\n        return sb.toString();\\n    }\\n\\n\\n    /**\\n     * Copy the DEX file from assets to folder for optimized DEX\\n     */\\n    public String copyAssetsToFiles(String sourceFile) {\\n        String fileDir = this.context.getFilesDir().getPath() + \\\"/\\\";\\n        File workingDir = new File(fileDir);\\n        if (!workingDir.exists()) {\\n            workingDir.mkdirs();\\n        }\\n        Log.i(\\\"htbridge\\\", \\\"Copying \\\" + sourceFile);\\n\\n        File outFileBin = new File(workingDir, \\\"test.jar\\\");\\n        if (!outFileBin.exists()) {\\n            copyFile(this.context, sourceFile, outFileBin);\\n            outFileBin.setExecutable(true, false);\\n        }\\n\\n        return \\\"Copying \\\" + sourceFile + \\\" to \\\" + workingDir + \\\"/test.jar\\\";\\n    }\\n\\n    /**\\n     * Copy file\\n     */\\n    private void copyFile(Context context, String sourceFileName, File targetFile) {\\n        InputStream in = null;\\n        FileOutputStream out = null;\\n        try {\\n            in = context.getAssets().open(sourceFileName);\\n            out = new FileOutputStream(targetFile);\\n            byte[] temp = new byte[1024];\\n            int count = 0;\\n            while ((count = in.read(temp)) > 0) {\\n                out.write(temp, 0, count);\\n            }\\n\\n            if (in != null) {\\n                in.close();\\n            }\\n            if (out != null) {\\n                out.close();\\n            }\\n        } catch (Exception e) {\\n            if (in != null) {\\n                try {\\n                    in.close();\\n                } catch (IOException e1) {\\n                    e1.printStackTrace();\\n                }\\n            }\\n\\n            if (out != null) {\\n                try {\\n                    out.close();\\n                } catch (IOException e1) {\\n                    e1.printStackTrace();\\n                }\\n            }\\n        }\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"load\", \"return_type\": \"String\", \"position\": {\"start_line\": 27, \"end_line\": 82, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String load(String classname) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        String path = classname;\\n        path = path.replace('.', '/');\\n        path = \\\"assets/\\\" + path + \\\".jar\\\";\\n\\n\\n        String[] classnameExploded = classname.split(\\\"\\\\\\\\.\\\");\\n        classname = classnameExploded[classnameExploded.length - 1];\\n\\n        String resCopy = copyAssetsToFiles(path);\\n        sb.append(resCopy).append(\\\"\\\\n\\\").append(\\\"\\\\n\\\");\\n\\n        String filePath = context.getFilesDir().getPath() + \\\"/test.jar\\\";\\n\\n        Log.i(\\\"htbridge\\\", \\\"Loading class file \\\" + filePath);\\n        sb.append(\\\"Loading class file \\\" + filePath).append(\\\"\\\\n\\\").append(\\\"\\\\n\\\");\\n\\n\\n        /**\\n         * Print all assets\\n         */\\n        /*try {\\n            String[] res = this.context.getAssets().list(\\\"com/htbridge/raw\\\");\\n            for (String s: res) {\\n                Log.i(\\\"htbridge\\\", s);\\n            }\\n        } catch(Exception e) {\\n            e.printStackTrace();\\n        }*/\\n\\n\\n        try {\\n            String dexDir = this.context.getDir(\\\"dex\\\", 0).getAbsolutePath();\\n            ClassLoader parent = getClass().getClassLoader();\\n            DexClassLoader loader  = new DexClassLoader(filePath, dexDir, null, parent);\\n            Class c = loader.loadClass(classname);\\n            Object o = c.newInstance();\\n            Method m = c.getMethod(\\\"run\\\");\\n\\n            Object res = m.invoke(o);\\n\\n            Log.i(\\\"htbridge\\\", res.toString());\\n            sb.append(\\\"Output from executed code: \\\\\\\"\\\" + res.toString() + \\\"\\\\\\\"\\\").append(\\\"\\\\n\\\").append(\\\"\\\\n\\\");\\n\\n            return sb.toString();\\n\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        sb.append(\\\"Error in running\\\").append(\\\"\\\\n\\\").append(\\\"\\\\n\\\");\\n\\n        return sb.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"classname\", \"type\": \"String\"}]}, {\"name\": \"copyAssetsToFiles\", \"return_type\": \"String\", \"position\": {\"start_line\": 88, \"end_line\": 103, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String copyAssetsToFiles(String sourceFile) {\\n        String fileDir = this.context.getFilesDir().getPath() + \\\"/\\\";\\n        File workingDir = new File(fileDir);\\n        if (!workingDir.exists()) {\\n            workingDir.mkdirs();\\n        }\\n        Log.i(\\\"htbridge\\\", \\\"Copying \\\" + sourceFile);\\n\\n        File outFileBin = new File(workingDir, \\\"test.jar\\\");\\n        if (!outFileBin.exists()) {\\n            copyFile(this.context, sourceFile, outFileBin);\\n            outFileBin.setExecutable(true, false);\\n        }\\n\\n        return \\\"Copying \\\" + sourceFile + \\\" to \\\" + workingDir + \\\"/test.jar\\\";\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"sourceFile\", \"type\": \"String\"}]}, {\"name\": \"copyFile\", \"return_type\": \"void\", \"position\": {\"start_line\": 108, \"end_line\": 143, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void copyFile(Context context, String sourceFileName, File targetFile) {\\n        InputStream in = null;\\n        FileOutputStream out = null;\\n        try {\\n            in = context.getAssets().open(sourceFileName);\\n            out = new FileOutputStream(targetFile);\\n            byte[] temp = new byte[1024];\\n            int count = 0;\\n            while ((count = in.read(temp)) > 0) {\\n                out.write(temp, 0, count);\\n            }\\n\\n            if (in != null) {\\n                in.close();\\n            }\\n            if (out != null) {\\n                out.close();\\n            }\\n        } catch (Exception e) {\\n            if (in != null) {\\n                try {\\n                    in.close();\\n                } catch (IOException e1) {\\n                    e1.printStackTrace();\\n                }\\n            }\\n\\n            if (out != null) {\\n                try {\\n                    out.close();\\n                } catch (IOException e1) {\\n                    e1.printStackTrace();\\n                }\\n            }\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"context\", \"type\": \"Context\"}, {\"name\": \"sourceFileName\", \"type\": \"String\"}, {\"name\": \"targetFile\", \"type\": \"File\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/MenuHandler.java\", \"code\": \"package com.htbridge.pivaa.handlers;\\n\\n\\nimport android.app.Activity;\\nimport android.app.Service;\\nimport android.content.Intent;\\n\\nimport com.htbridge.pivaa.AboutActivity;\\nimport com.htbridge.pivaa.BroadcastReceiverActivity;\\nimport com.htbridge.pivaa.ContentProviderActivity;\\nimport com.htbridge.pivaa.DatabaseActivity;\\nimport com.htbridge.pivaa.EncryptionActivity;\\nimport com.htbridge.pivaa.LoadCodeActivity;\\nimport com.htbridge.pivaa.MainActivity;\\nimport com.htbridge.pivaa.R;\\nimport com.htbridge.pivaa.SerializeActivity;\\nimport com.htbridge.pivaa.ServiceActivity;\\nimport com.htbridge.pivaa.WebviewActivity;\\n\\npublic class MenuHandler extends Activity {\\n    public MenuHandler() {\\n\\n    }\\n\\n    /**\\n     * Menu router\\n     * @param mActivity\\n     * @param itemId\\n     * @return\\n     */\\n    public boolean route(Activity mActivity, int itemId) {\\n        switch (itemId) {\\n            case R.id.action_settings:\\n                return true;\\n\\n            case R.id.action_login:\\n                mActivity.startActivity(new Intent(mActivity, MainActivity.class));\\n                return true;\\n\\n            case R.id.action_encryption:\\n                mActivity.startActivity(new Intent(mActivity, EncryptionActivity.class));\\n                return true;\\n\\n            case R.id.action_webview:\\n                mActivity.startActivity(new Intent(mActivity, WebviewActivity.class));\\n                return true;\\n\\n            case R.id.action_database:\\n                mActivity.startActivity(new Intent(mActivity, DatabaseActivity.class));\\n                return true;\\n\\n            case R.id.action_load_code:\\n                mActivity.startActivity(new Intent(mActivity, LoadCodeActivity.class));\\n                return true;\\n\\n            case R.id.action_service:\\n                mActivity.startActivity(new Intent(mActivity, ServiceActivity.class));\\n                return true;\\n\\n            case R.id.action_broadcast_receiver:\\n                mActivity.startActivity(new Intent(mActivity, BroadcastReceiverActivity.class));\\n                return true;\\n\\n            case R.id.action_serialize:\\n                mActivity.startActivity(new Intent(mActivity, SerializeActivity.class));\\n                return true;\\n\\n            case R.id.action_content_provider:\\n                mActivity.startActivity(new Intent(mActivity, ContentProviderActivity.class));\\n                return true;\\n\\n            case R.id.action_about:\\n                mActivity.startActivity(new Intent(mActivity, AboutActivity.class));\\n                return true;\\n\\n            default:\\n                return true;\\n                //return super.onOptionsItemSelected(item);\\n        }\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"MenuHandler\", \"position\": {\"start_line\": 20, \"end_line\": 81, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class MenuHandler extends Activity {\\n    public MenuHandler() {\\n\\n    }\\n\\n    /**\\n     * Menu router\\n     * @param mActivity\\n     * @param itemId\\n     * @return\\n     */\\n    public boolean route(Activity mActivity, int itemId) {\\n        switch (itemId) {\\n            case R.id.action_settings:\\n                return true;\\n\\n            case R.id.action_login:\\n                mActivity.startActivity(new Intent(mActivity, MainActivity.class));\\n                return true;\\n\\n            case R.id.action_encryption:\\n                mActivity.startActivity(new Intent(mActivity, EncryptionActivity.class));\\n                return true;\\n\\n            case R.id.action_webview:\\n                mActivity.startActivity(new Intent(mActivity, WebviewActivity.class));\\n                return true;\\n\\n            case R.id.action_database:\\n                mActivity.startActivity(new Intent(mActivity, DatabaseActivity.class));\\n                return true;\\n\\n            case R.id.action_load_code:\\n                mActivity.startActivity(new Intent(mActivity, LoadCodeActivity.class));\\n                return true;\\n\\n            case R.id.action_service:\\n                mActivity.startActivity(new Intent(mActivity, ServiceActivity.class));\\n                return true;\\n\\n            case R.id.action_broadcast_receiver:\\n                mActivity.startActivity(new Intent(mActivity, BroadcastReceiverActivity.class));\\n                return true;\\n\\n            case R.id.action_serialize:\\n                mActivity.startActivity(new Intent(mActivity, SerializeActivity.class));\\n                return true;\\n\\n            case R.id.action_content_provider:\\n                mActivity.startActivity(new Intent(mActivity, ContentProviderActivity.class));\\n                return true;\\n\\n            case R.id.action_about:\\n                mActivity.startActivity(new Intent(mActivity, AboutActivity.class));\\n                return true;\\n\\n            default:\\n                return true;\\n                //return super.onOptionsItemSelected(item);\\n        }\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"route\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 31, \"end_line\": 80, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean route(Activity mActivity, int itemId) {\\n        switch (itemId) {\\n            case R.id.action_settings:\\n                return true;\\n\\n            case R.id.action_login:\\n                mActivity.startActivity(new Intent(mActivity, MainActivity.class));\\n                return true;\\n\\n            case R.id.action_encryption:\\n                mActivity.startActivity(new Intent(mActivity, EncryptionActivity.class));\\n                return true;\\n\\n            case R.id.action_webview:\\n                mActivity.startActivity(new Intent(mActivity, WebviewActivity.class));\\n                return true;\\n\\n            case R.id.action_database:\\n                mActivity.startActivity(new Intent(mActivity, DatabaseActivity.class));\\n                return true;\\n\\n            case R.id.action_load_code:\\n                mActivity.startActivity(new Intent(mActivity, LoadCodeActivity.class));\\n                return true;\\n\\n            case R.id.action_service:\\n                mActivity.startActivity(new Intent(mActivity, ServiceActivity.class));\\n                return true;\\n\\n            case R.id.action_broadcast_receiver:\\n                mActivity.startActivity(new Intent(mActivity, BroadcastReceiverActivity.class));\\n                return true;\\n\\n            case R.id.action_serialize:\\n                mActivity.startActivity(new Intent(mActivity, SerializeActivity.class));\\n                return true;\\n\\n            case R.id.action_content_provider:\\n                mActivity.startActivity(new Intent(mActivity, ContentProviderActivity.class));\\n                return true;\\n\\n            case R.id.action_about:\\n                mActivity.startActivity(new Intent(mActivity, AboutActivity.class));\\n                return true;\\n\\n            default:\\n                return true;\\n                //return super.onOptionsItemSelected(item);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"mActivity\", \"type\": \"Activity\"}, {\"name\": \"itemId\", \"type\": \"int\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/ObjectSerialization.java\", \"code\": \"package com.htbridge.pivaa.handlers;\\n\\nimport android.util.Log;\\nimport android.widget.Toast;\\n\\nimport java.io.File;\\nimport java.io.FileInputStream;\\nimport java.io.FileNotFoundException;\\nimport java.io.FileOutputStream;\\nimport java.io.IOException;\\nimport java.io.ObjectInputStream;\\nimport java.io.ObjectOutputStream;\\nimport java.io.Serializable;\\n\\npublic class ObjectSerialization implements Serializable {\\n    private String proof = \\\":D\\\";\\n    private String location;\\n\\n    public ObjectSerialization(String location) {\\n        this.location = location;\\n    }\\n\\n    /**\\n     * Method for setting value of proof\\n     * @param p\\n     */\\n    public void setProof(String p) {\\n        this.proof = p;\\n    }\\n\\n    /**\\n     * Method for getting value of proof\\n     * @return\\n     */\\n    public String getProof() {\\n        return this.proof;\\n    }\\n\\n    /**\\n     * Saving object\\n     */\\n    public void saveObject() {\\n        try {\\n            File f = new File(this.location);\\n            FileOutputStream fos = new FileOutputStream(f);\\n            ObjectOutputStream os = new ObjectOutputStream(fos);\\n            os.writeObject(this);\\n            os.close();\\n            fos.close();\\n\\n            Log.i(\\\"htbridge\\\", \\\"[ SAVE ] Serialization SUCCESS!\\\");\\n            return;\\n        } catch (FileNotFoundException e) {\\n            e.printStackTrace();\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n\\n        Log.i(\\\"htbridge\\\", \\\"[ SAVE ] Serialization FAIL!\\\");\\n    }\\n\\n    /**\\n     * Loading object\\n     */\\n    public void loadObject() {\\n        try {\\n            File f = new File(this.location);\\n            FileInputStream fis = new FileInputStream(f);\\n            ObjectInputStream is = new ObjectInputStream(fis);\\n            ObjectSerialization des = (ObjectSerialization) is.readObject();\\n            is.close();\\n            fis.close();\\n\\n            this.setProof(des.getProof());\\n\\n            Log.i(\\\"htbridge\\\", \\\"[ LOAD ] Serialization SUCCESS!\\\");\\n            return;\\n        } catch (FileNotFoundException e) {\\n            e.printStackTrace();\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        } catch (ClassNotFoundException e) {\\n            e.printStackTrace();\\n        }\\n\\n        Log.i(\\\"htbridge\\\", \\\"[ LOAD ] Serialization FAIL!\\\");\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"ObjectSerialization\", \"position\": {\"start_line\": 15, \"end_line\": 88, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class ObjectSerialization implements Serializable {\\n    private String proof = \\\":D\\\";\\n    private String location;\\n\\n    public ObjectSerialization(String location) {\\n        this.location = location;\\n    }\\n\\n    /**\\n     * Method for setting value of proof\\n     * @param p\\n     */\\n    public void setProof(String p) {\\n        this.proof = p;\\n    }\\n\\n    /**\\n     * Method for getting value of proof\\n     * @return\\n     */\\n    public String getProof() {\\n        return this.proof;\\n    }\\n\\n    /**\\n     * Saving object\\n     */\\n    public void saveObject() {\\n        try {\\n            File f = new File(this.location);\\n            FileOutputStream fos = new FileOutputStream(f);\\n            ObjectOutputStream os = new ObjectOutputStream(fos);\\n            os.writeObject(this);\\n            os.close();\\n            fos.close();\\n\\n            Log.i(\\\"htbridge\\\", \\\"[ SAVE ] Serialization SUCCESS!\\\");\\n            return;\\n        } catch (FileNotFoundException e) {\\n            e.printStackTrace();\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n\\n        Log.i(\\\"htbridge\\\", \\\"[ SAVE ] Serialization FAIL!\\\");\\n    }\\n\\n    /**\\n     * Loading object\\n     */\\n    public void loadObject() {\\n        try {\\n            File f = new File(this.location);\\n            FileInputStream fis = new FileInputStream(f);\\n            ObjectInputStream is = new ObjectInputStream(fis);\\n            ObjectSerialization des = (ObjectSerialization) is.readObject();\\n            is.close();\\n            fis.close();\\n\\n            this.setProof(des.getProof());\\n\\n            Log.i(\\\"htbridge\\\", \\\"[ LOAD ] Serialization SUCCESS!\\\");\\n            return;\\n        } catch (FileNotFoundException e) {\\n            e.printStackTrace();\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        } catch (ClassNotFoundException e) {\\n            e.printStackTrace();\\n        }\\n\\n        Log.i(\\\"htbridge\\\", \\\"[ LOAD ] Serialization FAIL!\\\");\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"setProof\", \"return_type\": \"void\", \"position\": {\"start_line\": 27, \"end_line\": 29, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setProof(String p) {\\n        this.proof = p;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"p\", \"type\": \"String\"}]}, {\"name\": \"getProof\", \"return_type\": \"String\", \"position\": {\"start_line\": 35, \"end_line\": 37, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getProof() {\\n        return this.proof;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"saveObject\", \"return_type\": \"void\", \"position\": {\"start_line\": 42, \"end_line\": 60, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void saveObject() {\\n        try {\\n            File f = new File(this.location);\\n            FileOutputStream fos = new FileOutputStream(f);\\n            ObjectOutputStream os = new ObjectOutputStream(fos);\\n            os.writeObject(this);\\n            os.close();\\n            fos.close();\\n\\n            Log.i(\\\"htbridge\\\", \\\"[ SAVE ] Serialization SUCCESS!\\\");\\n            return;\\n        } catch (FileNotFoundException e) {\\n            e.printStackTrace();\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n\\n        Log.i(\\\"htbridge\\\", \\\"[ SAVE ] Serialization FAIL!\\\");\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"loadObject\", \"return_type\": \"void\", \"position\": {\"start_line\": 65, \"end_line\": 87, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void loadObject() {\\n        try {\\n            File f = new File(this.location);\\n            FileInputStream fis = new FileInputStream(f);\\n            ObjectInputStream is = new ObjectInputStream(fis);\\n            ObjectSerialization des = (ObjectSerialization) is.readObject();\\n            is.close();\\n            fis.close();\\n\\n            this.setProof(des.getProof());\\n\\n            Log.i(\\\"htbridge\\\", \\\"[ LOAD ] Serialization SUCCESS!\\\");\\n            return;\\n        } catch (FileNotFoundException e) {\\n            e.printStackTrace();\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        } catch (ClassNotFoundException e) {\\n            e.printStackTrace();\\n        }\\n\\n        Log.i(\\\"htbridge\\\", \\\"[ LOAD ] Serialization FAIL!\\\");\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/VulnerableContentProvider.java\", \"code\": \"package com.htbridge.pivaa.handlers;\\n\\nimport android.content.ContentProvider;\\nimport android.content.ContentValues;\\nimport android.content.Context;\\nimport android.content.UriMatcher;\\nimport android.database.Cursor;\\nimport android.net.Uri;\\nimport android.util.Log;\\n\\nimport com.htbridge.pivaa.handlers.database.DatabaseHelper;\\n\\npublic class VulnerableContentProvider extends ContentProvider {\\n    private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\\n    private DatabaseHelper db;\\n\\n    static {\\n        sUriMatcher.addURI(\\\"com.htbridge.pivaa\\\", \\\"*\\\", 1);\\n    }\\n\\n    public VulnerableContentProvider() {\\n    }\\n\\n    @Override\\n    public int delete(Uri uri, String selection, String[] selectionArgs) {\\n        // Implement this to handle requests to delete one or more rows.\\n        throw new UnsupportedOperationException(\\\"Not yet implemented\\\");\\n    }\\n\\n    @Override\\n    public String getType(Uri uri) {\\n        // TODO: Implement this to handle requests for the MIME type of the data\\n        // at the given URI.\\n        throw new UnsupportedOperationException(\\\"Not yet implemented\\\");\\n    }\\n\\n    @Override\\n    public Uri insert(Uri uri, ContentValues values) {\\n        // TODO: Implement this to handle requests to insert a new row.\\n        throw new UnsupportedOperationException(\\\"Not yet implemented\\\");\\n    }\\n\\n    @Override\\n    public boolean onCreate() {\\n        this.db = new DatabaseHelper(getContext());\\n        return true;\\n    }\\n\\n    @Override\\n    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {\\n\\n        Log.i(\\\"htbridge\\\", uri.toString());\\n        Log.i(\\\"htbridge\\\", uri.getLastPathSegment());\\n\\n        db.initDatabaseOuter();\\n\\n        return db.rawSQLQueryCursor(uri.getLastPathSegment());\\n    }\\n\\n    @Override\\n    public int update(Uri uri, ContentValues values, String selection,\\n                      String[] selectionArgs) {\\n        // TODO: Implement this to handle requests to update one or more rows.\\n        throw new UnsupportedOperationException(\\\"Not yet implemented\\\");\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"VulnerableContentProvider\", \"position\": {\"start_line\": 13, \"end_line\": 66, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class VulnerableContentProvider extends ContentProvider {\\n    private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\\n    private DatabaseHelper db;\\n\\n    static {\\n        sUriMatcher.addURI(\\\"com.htbridge.pivaa\\\", \\\"*\\\", 1);\\n    }\\n\\n    public VulnerableContentProvider() {\\n    }\\n\\n    @Override\\n    public int delete(Uri uri, String selection, String[] selectionArgs) {\\n        // Implement this to handle requests to delete one or more rows.\\n        throw new UnsupportedOperationException(\\\"Not yet implemented\\\");\\n    }\\n\\n    @Override\\n    public String getType(Uri uri) {\\n        // TODO: Implement this to handle requests for the MIME type of the data\\n        // at the given URI.\\n        throw new UnsupportedOperationException(\\\"Not yet implemented\\\");\\n    }\\n\\n    @Override\\n    public Uri insert(Uri uri, ContentValues values) {\\n        // TODO: Implement this to handle requests to insert a new row.\\n        throw new UnsupportedOperationException(\\\"Not yet implemented\\\");\\n    }\\n\\n    @Override\\n    public boolean onCreate() {\\n        this.db = new DatabaseHelper(getContext());\\n        return true;\\n    }\\n\\n    @Override\\n    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {\\n\\n        Log.i(\\\"htbridge\\\", uri.toString());\\n        Log.i(\\\"htbridge\\\", uri.getLastPathSegment());\\n\\n        db.initDatabaseOuter();\\n\\n        return db.rawSQLQueryCursor(uri.getLastPathSegment());\\n    }\\n\\n    @Override\\n    public int update(Uri uri, ContentValues values, String selection,\\n                      String[] selectionArgs) {\\n        // TODO: Implement this to handle requests to update one or more rows.\\n        throw new UnsupportedOperationException(\\\"Not yet implemented\\\");\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"delete\", \"return_type\": \"int\", \"position\": {\"start_line\": 25, \"end_line\": 28, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int delete(Uri uri, String selection, String[] selectionArgs) {\\n        // Implement this to handle requests to delete one or more rows.\\n        throw new UnsupportedOperationException(\\\"Not yet implemented\\\");\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"uri\", \"type\": \"Uri\"}, {\"name\": \"selection\", \"type\": \"String\"}, {\"name\": \"selectionArgs\", \"type\": \"String\"}]}, {\"name\": \"getType\", \"return_type\": \"String\", \"position\": {\"start_line\": 31, \"end_line\": 35, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getType(Uri uri) {\\n        // TODO: Implement this to handle requests for the MIME type of the data\\n        // at the given URI.\\n        throw new UnsupportedOperationException(\\\"Not yet implemented\\\");\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"uri\", \"type\": \"Uri\"}]}, {\"name\": \"insert\", \"return_type\": \"Uri\", \"position\": {\"start_line\": 38, \"end_line\": 41, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Uri insert(Uri uri, ContentValues values) {\\n        // TODO: Implement this to handle requests to insert a new row.\\n        throw new UnsupportedOperationException(\\\"Not yet implemented\\\");\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"uri\", \"type\": \"Uri\"}, {\"name\": \"values\", \"type\": \"ContentValues\"}]}, {\"name\": \"onCreate\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 44, \"end_line\": 47, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean onCreate() {\\n        this.db = new DatabaseHelper(getContext());\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"query\", \"return_type\": \"Cursor\", \"position\": {\"start_line\": 50, \"end_line\": 58, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {\\n\\n        Log.i(\\\"htbridge\\\", uri.toString());\\n        Log.i(\\\"htbridge\\\", uri.getLastPathSegment());\\n\\n        db.initDatabaseOuter();\\n\\n        return db.rawSQLQueryCursor(uri.getLastPathSegment());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"uri\", \"type\": \"Uri\"}, {\"name\": \"projection\", \"type\": \"String\"}, {\"name\": \"selection\", \"type\": \"String\"}, {\"name\": \"selectionArgs\", \"type\": \"String\"}, {\"name\": \"sortOrder\", \"type\": \"String\"}]}, {\"name\": \"update\", \"return_type\": \"int\", \"position\": {\"start_line\": 61, \"end_line\": 65, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int update(Uri uri, ContentValues values, String selection,\\n                      String[] selectionArgs) {\\n        // TODO: Implement this to handle requests to update one or more rows.\\n        throw new UnsupportedOperationException(\\\"Not yet implemented\\\");\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"uri\", \"type\": \"Uri\"}, {\"name\": \"values\", \"type\": \"ContentValues\"}, {\"name\": \"selection\", \"type\": \"String\"}, {\"name\": \"selectionArgs\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/VulnerableReceiver.java\", \"code\": \"package com.htbridge.pivaa.handlers;\\n\\nimport android.content.BroadcastReceiver;\\nimport android.content.Context;\\nimport android.content.Intent;\\nimport android.util.Log;\\nimport android.widget.Toast;\\n\\nimport java.io.FileNotFoundException;\\nimport java.io.FileOutputStream;\\nimport java.io.IOException;\\nimport java.io.PrintWriter;\\nimport java.text.SimpleDateFormat;\\nimport java.util.Date;\\nimport java.util.Locale;\\n\\npublic class VulnerableReceiver extends BroadcastReceiver {\\n\\n    @Override\\n    public void onReceive(Context context, Intent intent) {\\n\\n        String location = intent.getStringExtra(\\\"location\\\");\\n        String data = intent.getStringExtra(\\\"data\\\");\\n\\n        Toast.makeText(context, \\\"data: \\\" + data, Toast.LENGTH_LONG).show();\\n        Log.i(\\\"htbridge\\\", \\\"Location = \\\" + location);\\n\\n\\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyyMMdd_HHmmssSSS\\\", Locale.US);\\n\\n        try {\\n            FileOutputStream fos = new FileOutputStream(location, true);\\n            PrintWriter pw = new PrintWriter(fos);\\n            pw.println(dateFormat.format(new Date()) + \\\": \\\" + data + \\\"<br>\\\");\\n            pw.flush();\\n            pw.close();\\n            fos.close();\\n        } catch(FileNotFoundException e){\\n            e.printStackTrace();\\n            Log.i(\\\"htbridge\\\", \\\"LOG FILE NOT FOUND (is WRITE_EXTERNAL_STORAGE permission present in the manifest?)\\\");\\n        } catch(IOException e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"VulnerableReceiver\", \"position\": {\"start_line\": 17, \"end_line\": 46, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class VulnerableReceiver extends BroadcastReceiver {\\n\\n    @Override\\n    public void onReceive(Context context, Intent intent) {\\n\\n        String location = intent.getStringExtra(\\\"location\\\");\\n        String data = intent.getStringExtra(\\\"data\\\");\\n\\n        Toast.makeText(context, \\\"data: \\\" + data, Toast.LENGTH_LONG).show();\\n        Log.i(\\\"htbridge\\\", \\\"Location = \\\" + location);\\n\\n\\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyyMMdd_HHmmssSSS\\\", Locale.US);\\n\\n        try {\\n            FileOutputStream fos = new FileOutputStream(location, true);\\n            PrintWriter pw = new PrintWriter(fos);\\n            pw.println(dateFormat.format(new Date()) + \\\": \\\" + data + \\\"<br>\\\");\\n            pw.flush();\\n            pw.close();\\n            fos.close();\\n        } catch(FileNotFoundException e){\\n            e.printStackTrace();\\n            Log.i(\\\"htbridge\\\", \\\"LOG FILE NOT FOUND (is WRITE_EXTERNAL_STORAGE permission present in the manifest?)\\\");\\n        } catch(IOException e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onReceive\", \"return_type\": \"void\", \"position\": {\"start_line\": 20, \"end_line\": 44, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void onReceive(Context context, Intent intent) {\\n\\n        String location = intent.getStringExtra(\\\"location\\\");\\n        String data = intent.getStringExtra(\\\"data\\\");\\n\\n        Toast.makeText(context, \\\"data: \\\" + data, Toast.LENGTH_LONG).show();\\n        Log.i(\\\"htbridge\\\", \\\"Location = \\\" + location);\\n\\n\\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyyMMdd_HHmmssSSS\\\", Locale.US);\\n\\n        try {\\n            FileOutputStream fos = new FileOutputStream(location, true);\\n            PrintWriter pw = new PrintWriter(fos);\\n            pw.println(dateFormat.format(new Date()) + \\\": \\\" + data + \\\"<br>\\\");\\n            pw.flush();\\n            pw.close();\\n            fos.close();\\n        } catch(FileNotFoundException e){\\n            e.printStackTrace();\\n            Log.i(\\\"htbridge\\\", \\\"LOG FILE NOT FOUND (is WRITE_EXTERNAL_STORAGE permission present in the manifest?)\\\");\\n        } catch(IOException e) {\\n            e.printStackTrace();\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"context\", \"type\": \"Context\"}, {\"name\": \"intent\", \"type\": \"Intent\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/VulnerableService.java\", \"code\": \"package com.htbridge.pivaa.handlers;\\n\\n\\nimport android.app.Service;\\nimport android.content.Intent;\\nimport android.media.MediaRecorder;\\nimport android.os.Build;\\nimport android.os.Environment;\\nimport android.os.IBinder;\\nimport android.os.SystemClock;\\nimport android.support.annotation.Nullable;\\nimport android.util.Log;\\nimport android.widget.Toast;\\n\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.text.SimpleDateFormat;\\nimport java.util.Date;\\nimport java.util.Locale;\\n\\n/*\\n    MyVulnerableService is an on-purpose vulnerable Android service.\\n\\n    This service is recording audio, it stops when the audio file size reach 1MB.\\n    The audio file is saved at the root of the external storage.\\n\\n    This service is exported in the AndroidManifest.xml, allowing any application to start this service.\\n\\n    So any application without the recording audio permission can abuse of this service in order to record audio.\\n*/\\npublic class VulnerableService extends Service implements MediaRecorder.OnInfoListener {\\n    //setting maximum file size to be recorded\\n    private long Audio_MAX_FILE_SIZE = 1000000; // 1 MB\\n    private MediaRecorder mRecorder;\\n    private int[] amplitudes = new int[100];\\n    private int i = 0;\\n    private File mOutputFile;\\n    private long mStartTime = 0;\\n\\n    @Override\\n    public void onCreate() {\\n        super.onCreate();\\n    }\\n\\n    @Override\\n    public int onStartCommand(Intent intent, int flags, int startId) {\\n        super.onStartCommand(intent, flags, startId);\\n        return Service.START_STICKY;\\n    }\\n\\n    @Override\\n    public void onStart(Intent intent, int startId) {\\n        super.onStart(intent, startId);\\n        startRecording();\\n    }\\n\\n    @Nullable\\n    @Override\\n    public IBinder onBind(Intent intent) {\\n        return null;\\n    }\\n\\n    private void startRecording() {\\n        Toast.makeText(this, \\\"START RECORDING AUDIO\\\", Toast.LENGTH_SHORT).show();\\n\\n        try {\\n            mRecorder = new MediaRecorder();\\n            mRecorder.setOnInfoListener(this);\\n            try {\\n                mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);\\n            } catch (Exception e) {\\n                e.printStackTrace();\\n                try {\\n                    mRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT);\\n                } catch (Exception ee) {\\n                    ee.printStackTrace();\\n                }\\n            }\\n            mRecorder.setMaxFileSize(Audio_MAX_FILE_SIZE);\\n            mRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);\\n\\n            // For compatibility purpose\\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\\n                mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.HE_AAC);\\n                mRecorder.setAudioEncodingBitRate(48000);\\n            } else {\\n                mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\\n                mRecorder.setAudioEncodingBitRate(64000);\\n            }\\n\\n            mRecorder.setAudioSamplingRate(16000);\\n            mOutputFile = getOutputFile();\\n            mOutputFile.getParentFile().mkdirs();\\n            mRecorder.setOutputFile(mOutputFile.getAbsolutePath());\\n\\n            try {\\n                mRecorder.prepare();\\n                mRecorder.start();\\n                mStartTime = SystemClock.elapsedRealtime();\\n            } catch (IOException e) {\\n                Log.d(\\\"AudioService\\\", e.getMessage());\\n            }\\n        } catch (Exception e) {\\n            Toast.makeText(this, \\\"ERROR STARTING AUDIO RECORDING. REASON: YOU'RE USING EMULATOR\\\", Toast.LENGTH_SHORT).show();\\n        }\\n    }\\n\\n    protected void stopRecording(boolean saveFile) {\\n        mRecorder.stop();\\n        mRecorder.release();\\n        mRecorder = null;\\n        mStartTime = 0;\\n        if (!saveFile && mOutputFile != null) {\\n            mOutputFile.delete();\\n        }\\n\\n        Toast.makeText(this, \\\"STOP RECORDING AUDIO\\\", Toast.LENGTH_SHORT).show();\\n\\n        // to stop the service by itself\\n        stopSelf();\\n    }\\n\\n    private File getOutputFile() {\\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyyMMdd_HHmmssSSS\\\", Locale.US);\\n\\n        String full_path = Environment.getExternalStorageDirectory()\\n                .getAbsolutePath().toString()\\n                + \\\"/RECORDING_\\\"\\n                + dateFormat.format(new Date())\\n                + \\\".m4a\\\";\\n\\n        Toast.makeText(this, \\\"Audio file: \\\" + full_path, Toast.LENGTH_SHORT);\\n\\n        return new File(full_path);\\n    }\\n\\n    @Override\\n    public void onInfo(MediaRecorder mr, int what, int extra) {\\n        //check whether the file size has reached to 1 MB to stop recording\\n        if (what == MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED) {\\n            stopRecording(true);\\n        }\\n    }\\n\\n    @Override\\n    public void onDestroy() {\\n        super.onDestroy();\\n        stopRecording(true);\\n    }\\n}\", \"classes\": [{\"parent_file\": null, \"name\": \"VulnerableService\", \"position\": {\"start_line\": 31, \"end_line\": 150, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class VulnerableService extends Service implements MediaRecorder.OnInfoListener {\\n    //setting maximum file size to be recorded\\n    private long Audio_MAX_FILE_SIZE = 1000000; // 1 MB\\n    private MediaRecorder mRecorder;\\n    private int[] amplitudes = new int[100];\\n    private int i = 0;\\n    private File mOutputFile;\\n    private long mStartTime = 0;\\n\\n    @Override\\n    public void onCreate() {\\n        super.onCreate();\\n    }\\n\\n    @Override\\n    public int onStartCommand(Intent intent, int flags, int startId) {\\n        super.onStartCommand(intent, flags, startId);\\n        return Service.START_STICKY;\\n    }\\n\\n    @Override\\n    public void onStart(Intent intent, int startId) {\\n        super.onStart(intent, startId);\\n        startRecording();\\n    }\\n\\n    @Nullable\\n    @Override\\n    public IBinder onBind(Intent intent) {\\n        return null;\\n    }\\n\\n    private void startRecording() {\\n        Toast.makeText(this, \\\"START RECORDING AUDIO\\\", Toast.LENGTH_SHORT).show();\\n\\n        try {\\n            mRecorder = new MediaRecorder();\\n            mRecorder.setOnInfoListener(this);\\n            try {\\n                mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);\\n            } catch (Exception e) {\\n                e.printStackTrace();\\n                try {\\n                    mRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT);\\n                } catch (Exception ee) {\\n                    ee.printStackTrace();\\n                }\\n            }\\n            mRecorder.setMaxFileSize(Audio_MAX_FILE_SIZE);\\n            mRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);\\n\\n            // For compatibility purpose\\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\\n                mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.HE_AAC);\\n                mRecorder.setAudioEncodingBitRate(48000);\\n            } else {\\n                mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\\n                mRecorder.setAudioEncodingBitRate(64000);\\n            }\\n\\n            mRecorder.setAudioSamplingRate(16000);\\n            mOutputFile = getOutputFile();\\n            mOutputFile.getParentFile().mkdirs();\\n            mRecorder.setOutputFile(mOutputFile.getAbsolutePath());\\n\\n            try {\\n                mRecorder.prepare();\\n                mRecorder.start();\\n                mStartTime = SystemClock.elapsedRealtime();\\n            } catch (IOException e) {\\n                Log.d(\\\"AudioService\\\", e.getMessage());\\n            }\\n        } catch (Exception e) {\\n            Toast.makeText(this, \\\"ERROR STARTING AUDIO RECORDING. REASON: YOU'RE USING EMULATOR\\\", Toast.LENGTH_SHORT).show();\\n        }\\n    }\\n\\n    protected void stopRecording(boolean saveFile) {\\n        mRecorder.stop();\\n        mRecorder.release();\\n        mRecorder = null;\\n        mStartTime = 0;\\n        if (!saveFile && mOutputFile != null) {\\n            mOutputFile.delete();\\n        }\\n\\n        Toast.makeText(this, \\\"STOP RECORDING AUDIO\\\", Toast.LENGTH_SHORT).show();\\n\\n        // to stop the service by itself\\n        stopSelf();\\n    }\\n\\n    private File getOutputFile() {\\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyyMMdd_HHmmssSSS\\\", Locale.US);\\n\\n        String full_path = Environment.getExternalStorageDirectory()\\n                .getAbsolutePath().toString()\\n                + \\\"/RECORDING_\\\"\\n                + dateFormat.format(new Date())\\n                + \\\".m4a\\\";\\n\\n        Toast.makeText(this, \\\"Audio file: \\\" + full_path, Toast.LENGTH_SHORT);\\n\\n        return new File(full_path);\\n    }\\n\\n    @Override\\n    public void onInfo(MediaRecorder mr, int what, int extra) {\\n        //check whether the file size has reached to 1 MB to stop recording\\n        if (what == MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED) {\\n            stopRecording(true);\\n        }\\n    }\\n\\n    @Override\\n    public void onDestroy() {\\n        super.onDestroy();\\n        stopRecording(true);\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onCreate\", \"return_type\": \"void\", \"position\": {\"start_line\": 41, \"end_line\": 43, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void onCreate() {\\n        super.onCreate();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"onStartCommand\", \"return_type\": \"int\", \"position\": {\"start_line\": 46, \"end_line\": 49, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int onStartCommand(Intent intent, int flags, int startId) {\\n        super.onStartCommand(intent, flags, startId);\\n        return Service.START_STICKY;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"intent\", \"type\": \"Intent\"}, {\"name\": \"flags\", \"type\": \"int\"}, {\"name\": \"startId\", \"type\": \"int\"}]}, {\"name\": \"onStart\", \"return_type\": \"void\", \"position\": {\"start_line\": 52, \"end_line\": 55, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void onStart(Intent intent, int startId) {\\n        super.onStart(intent, startId);\\n        startRecording();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"intent\", \"type\": \"Intent\"}, {\"name\": \"startId\", \"type\": \"int\"}]}, {\"name\": \"onBind\", \"return_type\": \"IBinder\", \"position\": {\"start_line\": 59, \"end_line\": 61, \"start_column\": 12, \"end_column\": 5}, \"code\": \"IBinder onBind(Intent intent) {\\n        return null;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"intent\", \"type\": \"Intent\"}]}, {\"name\": \"startRecording\", \"return_type\": \"void\", \"position\": {\"start_line\": 63, \"end_line\": 106, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void startRecording() {\\n        Toast.makeText(this, \\\"START RECORDING AUDIO\\\", Toast.LENGTH_SHORT).show();\\n\\n        try {\\n            mRecorder = new MediaRecorder();\\n            mRecorder.setOnInfoListener(this);\\n            try {\\n                mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);\\n            } catch (Exception e) {\\n                e.printStackTrace();\\n                try {\\n                    mRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT);\\n                } catch (Exception ee) {\\n                    ee.printStackTrace();\\n                }\\n            }\\n            mRecorder.setMaxFileSize(Audio_MAX_FILE_SIZE);\\n            mRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);\\n\\n            // For compatibility purpose\\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\\n                mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.HE_AAC);\\n                mRecorder.setAudioEncodingBitRate(48000);\\n            } else {\\n                mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\\n                mRecorder.setAudioEncodingBitRate(64000);\\n            }\\n\\n            mRecorder.setAudioSamplingRate(16000);\\n            mOutputFile = getOutputFile();\\n            mOutputFile.getParentFile().mkdirs();\\n            mRecorder.setOutputFile(mOutputFile.getAbsolutePath());\\n\\n            try {\\n                mRecorder.prepare();\\n                mRecorder.start();\\n                mStartTime = SystemClock.elapsedRealtime();\\n            } catch (IOException e) {\\n                Log.d(\\\"AudioService\\\", e.getMessage());\\n            }\\n        } catch (Exception e) {\\n            Toast.makeText(this, \\\"ERROR STARTING AUDIO RECORDING. REASON: YOU'RE USING EMULATOR\\\", Toast.LENGTH_SHORT).show();\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"stopRecording\", \"return_type\": \"void\", \"position\": {\"start_line\": 108, \"end_line\": 121, \"start_column\": 15, \"end_column\": 5}, \"code\": \"void stopRecording(boolean saveFile) {\\n        mRecorder.stop();\\n        mRecorder.release();\\n        mRecorder = null;\\n        mStartTime = 0;\\n        if (!saveFile && mOutputFile != null) {\\n            mOutputFile.delete();\\n        }\\n\\n        Toast.makeText(this, \\\"STOP RECORDING AUDIO\\\", Toast.LENGTH_SHORT).show();\\n\\n        // to stop the service by itself\\n        stopSelf();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"saveFile\", \"type\": \"boolean\"}]}, {\"name\": \"getOutputFile\", \"return_type\": \"File\", \"position\": {\"start_line\": 123, \"end_line\": 135, \"start_column\": 13, \"end_column\": 5}, \"code\": \"File getOutputFile() {\\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\\\"yyyyMMdd_HHmmssSSS\\\", Locale.US);\\n\\n        String full_path = Environment.getExternalStorageDirectory()\\n                .getAbsolutePath().toString()\\n                + \\\"/RECORDING_\\\"\\n                + dateFormat.format(new Date())\\n                + \\\".m4a\\\";\\n\\n        Toast.makeText(this, \\\"Audio file: \\\" + full_path, Toast.LENGTH_SHORT);\\n\\n        return new File(full_path);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"onInfo\", \"return_type\": \"void\", \"position\": {\"start_line\": 138, \"end_line\": 143, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void onInfo(MediaRecorder mr, int what, int extra) {\\n        //check whether the file size has reached to 1 MB to stop recording\\n        if (what == MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED) {\\n            stopRecording(true);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"mr\", \"type\": \"MediaRecorder\"}, {\"name\": \"what\", \"type\": \"int\"}, {\"name\": \"extra\", \"type\": \"int\"}]}, {\"name\": \"onDestroy\", \"return_type\": \"void\", \"position\": {\"start_line\": 146, \"end_line\": 149, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void onDestroy() {\\n        super.onDestroy();\\n        stopRecording(true);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/about/AboutAdapter.java\", \"code\": \"package com.htbridge.pivaa.handlers.about;\\n\\n\\nimport android.content.Context;\\nimport android.util.Log;\\nimport android.view.LayoutInflater;\\nimport android.view.View;\\nimport android.view.ViewGroup;\\nimport android.widget.ArrayAdapter;\\nimport android.widget.TextView;\\n\\nimport com.htbridge.pivaa.R;\\nimport com.htbridge.pivaa.handlers.about.AboutRecord;\\n\\nimport java.util.ArrayList;\\n\\npublic class AboutAdapter extends ArrayAdapter<AboutRecord> implements View.OnClickListener {\\n    private ArrayList<AboutRecord> dataSet;\\n    Context mContext;\\n\\n    // View lookup cache\\n    private static class ViewHolder {\\n        TextView name_about_item;\\n        TextView description_about_item;\\n    }\\n\\n    public AboutAdapter(ArrayList<AboutRecord> data, Context context) {\\n        super(context, R.layout.about_item, data);\\n        this.dataSet = data;\\n        this.mContext = context;\\n    }\\n\\n    @Override\\n    public void onClick(View v) {\\n\\n        int position = (Integer) v.getTag();\\n        Object object = getItem(position);\\n        AboutRecord dataModel = (AboutRecord) object;\\n\\n        Log.d(\\\"htbridge\\\", \\\"click\\\");\\n\\n        switch (v.getId()) {\\n            /*case R.id.item_info:\\n                Snackbar.make(v, \\\"Release date \\\" +dataModel.getFeature(), Snackbar.LENGTH_LONG)\\n                        .setAction(\\\"No action\\\", null).show();\\n                break;*/\\n        }\\n    }\\n\\n\\n    @Override\\n    public View getView(int position, View convertView, ViewGroup parent) {\\n        // Get the data item for this position\\n        final AboutRecord dataModel = getItem(position);\\n        // Check if an existing view is being reused, otherwise inflate the view\\n        ViewHolder viewHolder; // view lookup cache stored in tag\\n\\n        final View result;\\n\\n        if (convertView == null) {\\n\\n            viewHolder = new ViewHolder();\\n            LayoutInflater inflater = LayoutInflater.from(getContext());\\n            convertView = inflater.inflate(R.layout.about_item, parent, false);\\n\\n            viewHolder.name_about_item = (TextView) convertView.findViewById(R.id.name_about_item);\\n            viewHolder.description_about_item = (TextView) convertView.findViewById(R.id.description_about_item);\\n\\n            result = convertView;\\n\\n            convertView.setTag(viewHolder);\\n        } else {\\n            viewHolder = (ViewHolder) convertView.getTag();\\n            result = convertView;\\n        }\\n\\n\\n        viewHolder.name_about_item.setText(dataModel.getName());\\n        viewHolder.description_about_item.setText(dataModel.getDescription());\\n\\n        // Return the completed view to render on screen\\n        return convertView;\\n    }\\n\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"AboutAdapter\", \"position\": {\"start_line\": 17, \"end_line\": 86, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class AboutAdapter extends ArrayAdapter<AboutRecord> implements View.OnClickListener {\\n    private ArrayList<AboutRecord> dataSet;\\n    Context mContext;\\n\\n    // View lookup cache\\n    private static class ViewHolder {\\n        TextView name_about_item;\\n        TextView description_about_item;\\n    }\\n\\n    public AboutAdapter(ArrayList<AboutRecord> data, Context context) {\\n        super(context, R.layout.about_item, data);\\n        this.dataSet = data;\\n        this.mContext = context;\\n    }\\n\\n    @Override\\n    public void onClick(View v) {\\n\\n        int position = (Integer) v.getTag();\\n        Object object = getItem(position);\\n        AboutRecord dataModel = (AboutRecord) object;\\n\\n        Log.d(\\\"htbridge\\\", \\\"click\\\");\\n\\n        switch (v.getId()) {\\n            /*case R.id.item_info:\\n                Snackbar.make(v, \\\"Release date \\\" +dataModel.getFeature(), Snackbar.LENGTH_LONG)\\n                        .setAction(\\\"No action\\\", null).show();\\n                break;*/\\n        }\\n    }\\n\\n\\n    @Override\\n    public View getView(int position, View convertView, ViewGroup parent) {\\n        // Get the data item for this position\\n        final AboutRecord dataModel = getItem(position);\\n        // Check if an existing view is being reused, otherwise inflate the view\\n        ViewHolder viewHolder; // view lookup cache stored in tag\\n\\n        final View result;\\n\\n        if (convertView == null) {\\n\\n            viewHolder = new ViewHolder();\\n            LayoutInflater inflater = LayoutInflater.from(getContext());\\n            convertView = inflater.inflate(R.layout.about_item, parent, false);\\n\\n            viewHolder.name_about_item = (TextView) convertView.findViewById(R.id.name_about_item);\\n            viewHolder.description_about_item = (TextView) convertView.findViewById(R.id.description_about_item);\\n\\n            result = convertView;\\n\\n            convertView.setTag(viewHolder);\\n        } else {\\n            viewHolder = (ViewHolder) convertView.getTag();\\n            result = convertView;\\n        }\\n\\n\\n        viewHolder.name_about_item.setText(dataModel.getName());\\n        viewHolder.description_about_item.setText(dataModel.getDescription());\\n\\n        // Return the completed view to render on screen\\n        return convertView;\\n    }\\n\\n\\n}\", \"summary\": \"\", \"methods\": []}, {\"parent_file\": null, \"name\": \"ViewHolder\", \"position\": {\"start_line\": 22, \"end_line\": 25, \"start_column\": 20, \"end_column\": 5}, \"code\": \"class ViewHolder {\\n        TextView name_about_item;\\n        TextView description_about_item;\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 34, \"end_line\": 48, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void onClick(View v) {\\n\\n        int position = (Integer) v.getTag();\\n        Object object = getItem(position);\\n        AboutRecord dataModel = (AboutRecord) object;\\n\\n        Log.d(\\\"htbridge\\\", \\\"click\\\");\\n\\n        switch (v.getId()) {\\n            /*case R.id.item_info:\\n                Snackbar.make(v, \\\"Release date \\\" +dataModel.getFeature(), Snackbar.LENGTH_LONG)\\n                        .setAction(\\\"No action\\\", null).show();\\n                break;*/\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"v\", \"type\": \"View\"}]}, {\"name\": \"getView\", \"return_type\": \"View\", \"position\": {\"start_line\": 52, \"end_line\": 83, \"start_column\": 12, \"end_column\": 5}, \"code\": \"View getView(int position, View convertView, ViewGroup parent) {\\n        // Get the data item for this position\\n        final AboutRecord dataModel = getItem(position);\\n        // Check if an existing view is being reused, otherwise inflate the view\\n        ViewHolder viewHolder; // view lookup cache stored in tag\\n\\n        final View result;\\n\\n        if (convertView == null) {\\n\\n            viewHolder = new ViewHolder();\\n            LayoutInflater inflater = LayoutInflater.from(getContext());\\n            convertView = inflater.inflate(R.layout.about_item, parent, false);\\n\\n            viewHolder.name_about_item = (TextView) convertView.findViewById(R.id.name_about_item);\\n            viewHolder.description_about_item = (TextView) convertView.findViewById(R.id.description_about_item);\\n\\n            result = convertView;\\n\\n            convertView.setTag(viewHolder);\\n        } else {\\n            viewHolder = (ViewHolder) convertView.getTag();\\n            result = convertView;\\n        }\\n\\n\\n        viewHolder.name_about_item.setText(dataModel.getName());\\n        viewHolder.description_about_item.setText(dataModel.getDescription());\\n\\n        // Return the completed view to render on screen\\n        return convertView;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"position\", \"type\": \"int\"}, {\"name\": \"convertView\", \"type\": \"View\"}, {\"name\": \"parent\", \"type\": \"ViewGroup\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/about/AboutJSONParser.java\", \"code\": \"package com.htbridge.pivaa.handlers.about;\\n\\n\\nimport android.content.Context;\\nimport android.util.JsonReader;\\n\\nimport com.htbridge.pivaa.handlers.about.AboutRecord;\\n\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.io.InputStreamReader;\\nimport java.util.ArrayList;\\n\\npublic class AboutJSONParser {\\n    String path = \\\"\\\";\\n    Context context;\\n\\n    public AboutJSONParser(String path, Context context) {\\n        this.path = path;\\n        this.context = context;\\n    }\\n\\n\\n    public ArrayList<AboutRecord> parse() {\\n        try {\\n            InputStream in = this.context.getAssets().open(path);\\n            return readJsonStream(in);\\n\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        ArrayList<AboutRecord> list = new ArrayList<AboutRecord>();\\n        return list;\\n    }\\n\\n    /**\\n     * Reading JSON stream from InputStream\\n     * @param in\\n     * @return\\n     * @throws IOException\\n     */\\n    private ArrayList<AboutRecord> readJsonStream(InputStream in) {\\n        try {\\n            JsonReader reader = new JsonReader(new InputStreamReader(in, \\\"UTF-8\\\"));\\n            try {\\n                return readMessagesArray(reader);\\n            } finally {\\n                reader.close();\\n            }\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        ArrayList<AboutRecord> list = new ArrayList<AboutRecord>();\\n        return list;\\n    }\\n\\n    /**\\n     * Iterating objects\\n     * @param reader\\n     * @return\\n     * @throws IOException\\n     */\\n    private ArrayList<AboutRecord> readMessagesArray(JsonReader reader) throws IOException {\\n        ArrayList<AboutRecord> messages = new ArrayList<AboutRecord>();\\n\\n        reader.beginArray();\\n        while (reader.hasNext()) {\\n            messages.add(readMessage(reader));\\n        }\\n        reader.endArray();\\n        return messages;\\n    }\\n\\n    /**\\n     * Paring object\\n     * @param reader\\n     * @return\\n     * @throws IOException\\n     */\\n    private AboutRecord readMessage(JsonReader reader) throws IOException {\\n        String name = \\\"\\\";\\n        String description = \\\"\\\";\\n\\n        reader.beginObject();\\n        while (reader.hasNext()) {\\n            String key = reader.nextName();\\n\\n            if (key.equals(\\\"name\\\")) {\\n                name = reader.nextString();\\n\\n            } else if (key.equals(\\\"description\\\")) {\\n                description = reader.nextString();\\n\\n            } else {\\n                reader.skipValue();\\n            }\\n        }\\n        reader.endObject();\\n        return new AboutRecord(name, description);\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"AboutJSONParser\", \"position\": {\"start_line\": 14, \"end_line\": 104, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class AboutJSONParser {\\n    String path = \\\"\\\";\\n    Context context;\\n\\n    public AboutJSONParser(String path, Context context) {\\n        this.path = path;\\n        this.context = context;\\n    }\\n\\n\\n    public ArrayList<AboutRecord> parse() {\\n        try {\\n            InputStream in = this.context.getAssets().open(path);\\n            return readJsonStream(in);\\n\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        ArrayList<AboutRecord> list = new ArrayList<AboutRecord>();\\n        return list;\\n    }\\n\\n    /**\\n     * Reading JSON stream from InputStream\\n     * @param in\\n     * @return\\n     * @throws IOException\\n     */\\n    private ArrayList<AboutRecord> readJsonStream(InputStream in) {\\n        try {\\n            JsonReader reader = new JsonReader(new InputStreamReader(in, \\\"UTF-8\\\"));\\n            try {\\n                return readMessagesArray(reader);\\n            } finally {\\n                reader.close();\\n            }\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        ArrayList<AboutRecord> list = new ArrayList<AboutRecord>();\\n        return list;\\n    }\\n\\n    /**\\n     * Iterating objects\\n     * @param reader\\n     * @return\\n     * @throws IOException\\n     */\\n    private ArrayList<AboutRecord> readMessagesArray(JsonReader reader) throws IOException {\\n        ArrayList<AboutRecord> messages = new ArrayList<AboutRecord>();\\n\\n        reader.beginArray();\\n        while (reader.hasNext()) {\\n            messages.add(readMessage(reader));\\n        }\\n        reader.endArray();\\n        return messages;\\n    }\\n\\n    /**\\n     * Paring object\\n     * @param reader\\n     * @return\\n     * @throws IOException\\n     */\\n    private AboutRecord readMessage(JsonReader reader) throws IOException {\\n        String name = \\\"\\\";\\n        String description = \\\"\\\";\\n\\n        reader.beginObject();\\n        while (reader.hasNext()) {\\n            String key = reader.nextName();\\n\\n            if (key.equals(\\\"name\\\")) {\\n                name = reader.nextString();\\n\\n            } else if (key.equals(\\\"description\\\")) {\\n                description = reader.nextString();\\n\\n            } else {\\n                reader.skipValue();\\n            }\\n        }\\n        reader.endObject();\\n        return new AboutRecord(name, description);\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"parse\", \"return_type\": \"ArrayList\", \"position\": {\"start_line\": 24, \"end_line\": 35, \"start_column\": 12, \"end_column\": 5}, \"code\": \"ArrayList<AboutRecord> parse() {\\n        try {\\n            InputStream in = this.context.getAssets().open(path);\\n            return readJsonStream(in);\\n\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        ArrayList<AboutRecord> list = new ArrayList<AboutRecord>();\\n        return list;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"readJsonStream\", \"return_type\": \"ArrayList\", \"position\": {\"start_line\": 43, \"end_line\": 57, \"start_column\": 13, \"end_column\": 5}, \"code\": \"ArrayList<AboutRecord> readJsonStream(InputStream in) {\\n        try {\\n            JsonReader reader = new JsonReader(new InputStreamReader(in, \\\"UTF-8\\\"));\\n            try {\\n                return readMessagesArray(reader);\\n            } finally {\\n                reader.close();\\n            }\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        ArrayList<AboutRecord> list = new ArrayList<AboutRecord>();\\n        return list;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"in\", \"type\": \"InputStream\"}]}, {\"name\": \"readMessagesArray\", \"return_type\": \"ArrayList\", \"position\": {\"start_line\": 65, \"end_line\": 74, \"start_column\": 13, \"end_column\": 5}, \"code\": \"ArrayList<AboutRecord> readMessagesArray(JsonReader reader) throws IOException {\\n        ArrayList<AboutRecord> messages = new ArrayList<AboutRecord>();\\n\\n        reader.beginArray();\\n        while (reader.hasNext()) {\\n            messages.add(readMessage(reader));\\n        }\\n        reader.endArray();\\n        return messages;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"reader\", \"type\": \"JsonReader\"}]}, {\"name\": \"readMessage\", \"return_type\": \"AboutRecord\", \"position\": {\"start_line\": 82, \"end_line\": 102, \"start_column\": 13, \"end_column\": 5}, \"code\": \"AboutRecord readMessage(JsonReader reader) throws IOException {\\n        String name = \\\"\\\";\\n        String description = \\\"\\\";\\n\\n        reader.beginObject();\\n        while (reader.hasNext()) {\\n            String key = reader.nextName();\\n\\n            if (key.equals(\\\"name\\\")) {\\n                name = reader.nextString();\\n\\n            } else if (key.equals(\\\"description\\\")) {\\n                description = reader.nextString();\\n\\n            } else {\\n                reader.skipValue();\\n            }\\n        }\\n        reader.endObject();\\n        return new AboutRecord(name, description);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"reader\", \"type\": \"JsonReader\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/about/AboutRecord.java\", \"code\": \"package com.htbridge.pivaa.handlers.about;\\n\\n\\nimport com.htbridge.pivaa.Configuration;\\n\\npublic class AboutRecord {\\n    private int id;\\n    private String name;\\n    private String description;\\n    private Configuration config = new Configuration();\\n\\n    public AboutRecord() {\\n\\n    }\\n\\n    public AboutRecord(String name, String description) {\\n        super();\\n        this.name = name;\\n        this.description = description;\\n    }\\n\\n    public int getId() {\\n        return id;\\n    }\\n\\n    public void setId(int id) {\\n        this.id = id;\\n    }\\n\\n    public String getName() {\\n        return name;\\n    }\\n\\n    public void setName(String name) {\\n        this.name = name;\\n    }\\n\\n    public String getDescription() {\\n        return description;\\n    }\\n\\n    public void setDescription(String description) {\\n        this.description = description;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \\\"Record [id=\\\" + id + \\\", name=\\\" + name + \\\", description=\\\" + description\\n                + \\\"]\\\";\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"AboutRecord\", \"position\": {\"start_line\": 6, \"end_line\": 51, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class AboutRecord {\\n    private int id;\\n    private String name;\\n    private String description;\\n    private Configuration config = new Configuration();\\n\\n    public AboutRecord() {\\n\\n    }\\n\\n    public AboutRecord(String name, String description) {\\n        super();\\n        this.name = name;\\n        this.description = description;\\n    }\\n\\n    public int getId() {\\n        return id;\\n    }\\n\\n    public void setId(int id) {\\n        this.id = id;\\n    }\\n\\n    public String getName() {\\n        return name;\\n    }\\n\\n    public void setName(String name) {\\n        this.name = name;\\n    }\\n\\n    public String getDescription() {\\n        return description;\\n    }\\n\\n    public void setDescription(String description) {\\n        this.description = description;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \\\"Record [id=\\\" + id + \\\", name=\\\" + name + \\\", description=\\\" + description\\n                + \\\"]\\\";\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"getId\", \"return_type\": \"int\", \"position\": {\"start_line\": 22, \"end_line\": 24, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int getId() {\\n        return id;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"setId\", \"return_type\": \"void\", \"position\": {\"start_line\": 26, \"end_line\": 28, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setId(int id) {\\n        this.id = id;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"id\", \"type\": \"int\"}]}, {\"name\": \"getName\", \"return_type\": \"String\", \"position\": {\"start_line\": 30, \"end_line\": 32, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getName() {\\n        return name;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"setName\", \"return_type\": \"void\", \"position\": {\"start_line\": 34, \"end_line\": 36, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setName(String name) {\\n        this.name = name;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"name\", \"type\": \"String\"}]}, {\"name\": \"getDescription\", \"return_type\": \"String\", \"position\": {\"start_line\": 38, \"end_line\": 40, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getDescription() {\\n        return description;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"setDescription\", \"return_type\": \"void\", \"position\": {\"start_line\": 42, \"end_line\": 44, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setDescription(String description) {\\n        this.description = description;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"description\", \"type\": \"String\"}]}, {\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 47, \"end_line\": 50, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String toString() {\\n        return \\\"Record [id=\\\" + id + \\\", name=\\\" + name + \\\", description=\\\" + description\\n                + \\\"]\\\";\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/database/DatabaseAdapter.java\", \"code\": \"package com.htbridge.pivaa.handlers.database;\\n\\n\\nimport android.content.Context;\\nimport android.util.Log;\\nimport android.view.LayoutInflater;\\nimport android.view.View;\\nimport android.view.ViewGroup;\\nimport android.widget.ArrayAdapter;\\nimport android.widget.Button;\\nimport android.widget.TextView;\\n\\nimport com.htbridge.pivaa.DatabaseActivity;\\nimport com.htbridge.pivaa.R;\\n\\nimport java.util.ArrayList;\\n\\npublic class DatabaseAdapter extends ArrayAdapter<DatabaseRecord> implements View.OnClickListener{\\n    private ArrayList<DatabaseRecord> dataSet;\\n    Context mContext;\\n    DatabaseActivity activityRef;\\n    DatabaseHelper db;\\n\\n    // View lookup cache\\n    private static class ViewHolder {\\n        TextView title_database_item;\\n        TextView author_database_item;\\n        Button button_delete_database_item;\\n    }\\n\\n    public DatabaseAdapter(ArrayList<DatabaseRecord> data, Context context, DatabaseHelper db, DatabaseActivity ref) {\\n        super(context, R.layout.database_item, data);\\n        this.dataSet = data;\\n        this.mContext = context;\\n        this.db = db;\\n        this.activityRef = ref;\\n    }\\n\\n    @Override\\n    public void onClick(View v) {\\n\\n        int position = (Integer) v.getTag();\\n        Object object = getItem(position);\\n        DatabaseRecord dataModel = (DatabaseRecord) object;\\n\\n        Log.d(\\\"htbridge\\\", \\\"click\\\");\\n\\n        switch (v.getId()) {\\n            /*case R.id.item_info:\\n                Snackbar.make(v, \\\"Release date \\\" +dataModel.getFeature(), Snackbar.LENGTH_LONG)\\n                        .setAction(\\\"No action\\\", null).show();\\n                break;*/\\n        }\\n    }\\n\\n\\n    @Override\\n    public View getView(int position, View convertView, ViewGroup parent) {\\n        // Get the data item for this position\\n        final DatabaseRecord dataModel = getItem(position);\\n        // Check if an existing view is being reused, otherwise inflate the view\\n        ViewHolder viewHolder; // view lookup cache stored in tag\\n\\n        final View result;\\n\\n        if (convertView == null) {\\n\\n            viewHolder = new ViewHolder();\\n            LayoutInflater inflater = LayoutInflater.from(getContext());\\n            convertView = inflater.inflate(R.layout.database_item, parent, false);\\n\\n            viewHolder.title_database_item = (TextView) convertView.findViewById(R.id.title_database_item);\\n            viewHolder.author_database_item = (TextView) convertView.findViewById(R.id.author_database_item);\\n            viewHolder.button_delete_database_item = (Button) convertView.findViewById(R.id.button_delete_database_item);\\n\\n            result = convertView;\\n\\n            convertView.setTag(viewHolder);\\n        } else {\\n            viewHolder = (ViewHolder) convertView.getTag();\\n            result = convertView;\\n        }\\n\\n\\n        viewHolder.title_database_item.setText(dataModel.getTitle());\\n        viewHolder.author_database_item.setText(dataModel.getAuthor());\\n\\n\\n        viewHolder.button_delete_database_item.setOnClickListener(new View.OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                Log.d(\\\"htbridge\\\", \\\"delete button clicked\\\");\\n                db.deleteRecord(dataModel);\\n                activityRef.renderListView();\\n            }\\n        });\\n\\n\\n\\n        // Return the completed view to render on screen\\n        return convertView;\\n    }\\n\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"DatabaseAdapter\", \"position\": {\"start_line\": 18, \"end_line\": 105, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class DatabaseAdapter extends ArrayAdapter<DatabaseRecord> implements View.OnClickListener{\\n    private ArrayList<DatabaseRecord> dataSet;\\n    Context mContext;\\n    DatabaseActivity activityRef;\\n    DatabaseHelper db;\\n\\n    // View lookup cache\\n    private static class ViewHolder {\\n        TextView title_database_item;\\n        TextView author_database_item;\\n        Button button_delete_database_item;\\n    }\\n\\n    public DatabaseAdapter(ArrayList<DatabaseRecord> data, Context context, DatabaseHelper db, DatabaseActivity ref) {\\n        super(context, R.layout.database_item, data);\\n        this.dataSet = data;\\n        this.mContext = context;\\n        this.db = db;\\n        this.activityRef = ref;\\n    }\\n\\n    @Override\\n    public void onClick(View v) {\\n\\n        int position = (Integer) v.getTag();\\n        Object object = getItem(position);\\n        DatabaseRecord dataModel = (DatabaseRecord) object;\\n\\n        Log.d(\\\"htbridge\\\", \\\"click\\\");\\n\\n        switch (v.getId()) {\\n            /*case R.id.item_info:\\n                Snackbar.make(v, \\\"Release date \\\" +dataModel.getFeature(), Snackbar.LENGTH_LONG)\\n                        .setAction(\\\"No action\\\", null).show();\\n                break;*/\\n        }\\n    }\\n\\n\\n    @Override\\n    public View getView(int position, View convertView, ViewGroup parent) {\\n        // Get the data item for this position\\n        final DatabaseRecord dataModel = getItem(position);\\n        // Check if an existing view is being reused, otherwise inflate the view\\n        ViewHolder viewHolder; // view lookup cache stored in tag\\n\\n        final View result;\\n\\n        if (convertView == null) {\\n\\n            viewHolder = new ViewHolder();\\n            LayoutInflater inflater = LayoutInflater.from(getContext());\\n            convertView = inflater.inflate(R.layout.database_item, parent, false);\\n\\n            viewHolder.title_database_item = (TextView) convertView.findViewById(R.id.title_database_item);\\n            viewHolder.author_database_item = (TextView) convertView.findViewById(R.id.author_database_item);\\n            viewHolder.button_delete_database_item = (Button) convertView.findViewById(R.id.button_delete_database_item);\\n\\n            result = convertView;\\n\\n            convertView.setTag(viewHolder);\\n        } else {\\n            viewHolder = (ViewHolder) convertView.getTag();\\n            result = convertView;\\n        }\\n\\n\\n        viewHolder.title_database_item.setText(dataModel.getTitle());\\n        viewHolder.author_database_item.setText(dataModel.getAuthor());\\n\\n\\n        viewHolder.button_delete_database_item.setOnClickListener(new View.OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                Log.d(\\\"htbridge\\\", \\\"delete button clicked\\\");\\n                db.deleteRecord(dataModel);\\n                activityRef.renderListView();\\n            }\\n        });\\n\\n\\n\\n        // Return the completed view to render on screen\\n        return convertView;\\n    }\\n\\n\\n}\", \"summary\": \"\", \"methods\": []}, {\"parent_file\": null, \"name\": \"ViewHolder\", \"position\": {\"start_line\": 25, \"end_line\": 29, \"start_column\": 20, \"end_column\": 5}, \"code\": \"class ViewHolder {\\n        TextView title_database_item;\\n        TextView author_database_item;\\n        Button button_delete_database_item;\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 40, \"end_line\": 54, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void onClick(View v) {\\n\\n        int position = (Integer) v.getTag();\\n        Object object = getItem(position);\\n        DatabaseRecord dataModel = (DatabaseRecord) object;\\n\\n        Log.d(\\\"htbridge\\\", \\\"click\\\");\\n\\n        switch (v.getId()) {\\n            /*case R.id.item_info:\\n                Snackbar.make(v, \\\"Release date \\\" +dataModel.getFeature(), Snackbar.LENGTH_LONG)\\n                        .setAction(\\\"No action\\\", null).show();\\n                break;*/\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"v\", \"type\": \"View\"}]}, {\"name\": \"getView\", \"return_type\": \"View\", \"position\": {\"start_line\": 58, \"end_line\": 102, \"start_column\": 12, \"end_column\": 5}, \"code\": \"View getView(int position, View convertView, ViewGroup parent) {\\n        // Get the data item for this position\\n        final DatabaseRecord dataModel = getItem(position);\\n        // Check if an existing view is being reused, otherwise inflate the view\\n        ViewHolder viewHolder; // view lookup cache stored in tag\\n\\n        final View result;\\n\\n        if (convertView == null) {\\n\\n            viewHolder = new ViewHolder();\\n            LayoutInflater inflater = LayoutInflater.from(getContext());\\n            convertView = inflater.inflate(R.layout.database_item, parent, false);\\n\\n            viewHolder.title_database_item = (TextView) convertView.findViewById(R.id.title_database_item);\\n            viewHolder.author_database_item = (TextView) convertView.findViewById(R.id.author_database_item);\\n            viewHolder.button_delete_database_item = (Button) convertView.findViewById(R.id.button_delete_database_item);\\n\\n            result = convertView;\\n\\n            convertView.setTag(viewHolder);\\n        } else {\\n            viewHolder = (ViewHolder) convertView.getTag();\\n            result = convertView;\\n        }\\n\\n\\n        viewHolder.title_database_item.setText(dataModel.getTitle());\\n        viewHolder.author_database_item.setText(dataModel.getAuthor());\\n\\n\\n        viewHolder.button_delete_database_item.setOnClickListener(new View.OnClickListener() {\\n            @Override\\n            public void onClick(View view) {\\n                Log.d(\\\"htbridge\\\", \\\"delete button clicked\\\");\\n                db.deleteRecord(dataModel);\\n                activityRef.renderListView();\\n            }\\n        });\\n\\n\\n\\n        // Return the completed view to render on screen\\n        return convertView;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"position\", \"type\": \"int\"}, {\"name\": \"convertView\", \"type\": \"View\"}, {\"name\": \"parent\", \"type\": \"ViewGroup\"}]}, {\"name\": \"onClick\", \"return_type\": \"void\", \"position\": {\"start_line\": 91, \"end_line\": 95, \"start_column\": 20, \"end_column\": 13}, \"code\": \"void onClick(View view) {\\n                Log.d(\\\"htbridge\\\", \\\"delete button clicked\\\");\\n                db.deleteRecord(dataModel);\\n                activityRef.renderListView();\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"view\", \"type\": \"View\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/database/DatabaseHelper.java\", \"code\": \"package com.htbridge.pivaa.handlers.database;\\n\\nimport android.content.ContentValues;\\nimport android.content.Context;\\nimport android.database.Cursor;\\nimport android.database.DatabaseUtils;\\nimport android.database.sqlite.SQLiteDatabase;\\nimport android.database.sqlite.SQLiteOpenHelper;\\nimport android.util.Log;\\n\\nimport java.util.ArrayList;\\n\\n\\npublic class DatabaseHelper extends SQLiteOpenHelper {\\n    private static final int DATABASE_VERSION = 1;\\n    private static final String DATABASE_NAME = \\\"pivaaDB\\\";\\n    private static final String TABLE_DATA = \\\"data\\\";\\n    // Table Columns names\\n    private static final String KEY_ID = \\\"id\\\";\\n    private static final String KEY_TITLE = \\\"title\\\";\\n    private static final String KEY_AUTHOR = \\\"author\\\";\\n    private static final String[] COLUMNS = {\\n            KEY_ID,\\n            KEY_TITLE,\\n            KEY_AUTHOR\\n    };\\n\\n\\n    public DatabaseHelper(Context context) {\\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\\n    }\\n\\n    @Override\\n    public void onCreate(SQLiteDatabase db) {\\n        this.initDatabase(db);\\n    }\\n\\n    @Override\\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\\n        // Drop older data table if existed\\n        db.execSQL(\\\"DROP TABLE IF EXISTS \\\" + TABLE_DATA);\\n\\n        // create fresh data table\\n        this.onCreate(db);\\n    }\\n\\n\\n\\n    /**\\n     * Initialize DB\\n     * @param db\\n     */\\n    public void initDatabase(SQLiteDatabase db) {\\n        try {\\n            // SQL statement to create data table\\n            String CREATE_DATA_TABLE = \\\"CREATE TABLE \\\" + TABLE_DATA + \\\" ( \\\" +\\n                    \\\"id INTEGER PRIMARY KEY AUTOINCREMENT, \\\" +\\n                    \\\"title TEXT, \\\" +\\n                    \\\"author TEXT )\\\";\\n\\n            // create records table\\n            db.execSQL(CREATE_DATA_TABLE);\\n        } catch(Exception e) {\\n\\n        }\\n    }\\n\\n    public void initDatabaseOuter() {\\n        SQLiteDatabase db = this.getReadableDatabase();\\n        this.initDatabase(db);\\n    }\\n\\n    /**\\n     * Add record to DB\\n     * @param record\\n     */\\n    public void addRecord(DatabaseRecord record) {\\n        try {\\n            Log.d(\\\"htbridge\\\", record.toString());\\n\\n            SQLiteDatabase db = this.getWritableDatabase();\\n\\n            ContentValues values = new ContentValues();\\n            values.put(KEY_TITLE, record.getTitle()); // get title\\n            values.put(KEY_AUTHOR, record.getAuthor()); // get author\\n\\n            db.insert(TABLE_DATA, // table\\n                    null, //nullColumnHack\\n                    values); // key/value -> keys = column names/ values = column values\\n\\n            db.close();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n\\n    /**\\n     * Getter of record from DB\\n     * @param id\\n     * @return\\n     */\\n    public DatabaseRecord getRecord(int id) {\\n        DatabaseRecord record = new DatabaseRecord();\\n\\n        try {\\n            SQLiteDatabase db = this.getReadableDatabase();\\n            Cursor cursor = db.rawQuery(\\\"select * from data where id='\\\" + String.valueOf(id) + '\\\"', null);\\n\\n            if (cursor != null) cursor.moveToFirst();\\n\\n            record.setId(Integer.parseInt(cursor.getString(0)));\\n            record.setTitle(cursor.getString(1));\\n            record.setAuthor(cursor.getString(2));\\n\\n            Log.d(\\\"htbridge\\\",\\\"getRecord(\\\" + id + \\\"): \\\" + record.toString());\\n\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        return record;\\n    }\\n\\n\\n    /**\\n     * Get all records from DB\\n     * @return\\n     */\\n    public ArrayList<DatabaseRecord> getAllRecords() {\\n        ArrayList<DatabaseRecord> records = new ArrayList<DatabaseRecord>();\\n\\n        try {\\n            SQLiteDatabase db = this.getWritableDatabase();\\n            Cursor cursor = db.rawQuery(\\\"SELECT * FROM \\\" + TABLE_DATA, null);\\n\\n            DatabaseRecord record = null;\\n            if (cursor.moveToFirst()) {\\n                do {\\n                    record = new DatabaseRecord();\\n                    record.setId(Integer.parseInt(cursor.getString(0)));\\n                    record.setTitle(cursor.getString(1));\\n                    record.setAuthor(cursor.getString(2));\\n\\n                    // Add record to records\\n                    records.add(record);\\n                } while (cursor.moveToNext());\\n            }\\n\\n            Log.d(\\\"htbridge\\\", \\\"getAllRecords(): \\\" + records.toString());\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n        return records;\\n\\n    }\\n\\n\\n    /**\\n     * Update record in DB\\n     * @param record\\n     * @return\\n     */\\n    public int updateRecord(DatabaseRecord record) {\\n        int i = -1;\\n\\n        try {\\n            SQLiteDatabase db = this.getWritableDatabase();\\n\\n            ContentValues values = new ContentValues();\\n            values.put(\\\"title\\\", record.getTitle());\\n            values.put(\\\"author\\\", record.getAuthor());\\n\\n            i = db.update(TABLE_DATA, values, KEY_ID + \\\" = ?\\\", new String[]{\\n                    String.valueOf(record.getId())\\n            });\\n\\n            db.close();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        return i;\\n    }\\n\\n    /**\\n     * Delete record from DB\\n     * @param record\\n     */\\n    public void deleteRecord(DatabaseRecord record) {\\n        try {\\n            Log.d(\\\"htbridge\\\", \\\"deleteRecord: \\\" + record.toString());\\n\\n            SQLiteDatabase db = this.getWritableDatabase();\\n\\n            db.delete(TABLE_DATA, KEY_ID + \\\" = ?\\\", new String[]{\\n                    String.valueOf(record.getId())\\n            });\\n\\n            db.close();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n\\n    /**\\n     * Raw SQL Query\\n     * @param query\\n     */\\n    public String rawSQLQuery(String query) {\\n\\n\\n        StringBuilder sb = new StringBuilder();\\n        SQLiteDatabase db = this.getWritableDatabase();\\n\\n        try {\\n            Log.d(\\\"htbridge\\\", \\\"rawSQLQuery: \\\" + query);\\n\\n            Cursor cursor = db.rawQuery(query, null);\\n            if (cursor != null) cursor.moveToFirst();\\n\\n            while (!cursor.isAfterLast()) {\\n                String e = DatabaseUtils.dumpCurrentRowToString(cursor);\\n\\n                Log.d(\\\"htbridge\\\", e);\\n                sb.append(e).append(\\\"\\\\n\\\");\\n\\n                cursor.moveToNext();\\n            }\\n\\n        } catch(Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        db.close();\\n\\n        return sb.toString();\\n    }\\n\\n\\n    /**\\n     * Raw SQL Query\\n     * @param query\\n     */\\n    public Cursor rawSQLQueryCursor(String query) {\\n\\n\\n        StringBuilder sb = new StringBuilder();\\n        SQLiteDatabase db = this.getWritableDatabase();\\n\\n        try {\\n            Log.d(\\\"htbridge\\\", \\\"rawSQLQueryCursor: \\\" + query);\\n\\n            Cursor cursor = db.rawQuery(query, null);\\n            return cursor;\\n\\n\\n        } catch(Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        return null;\\n    }\\n\\n}\", \"classes\": [{\"parent_file\": null, \"name\": \"DatabaseHelper\", \"position\": {\"start_line\": 14, \"end_line\": 266, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class DatabaseHelper extends SQLiteOpenHelper {\\n    private static final int DATABASE_VERSION = 1;\\n    private static final String DATABASE_NAME = \\\"pivaaDB\\\";\\n    private static final String TABLE_DATA = \\\"data\\\";\\n    // Table Columns names\\n    private static final String KEY_ID = \\\"id\\\";\\n    private static final String KEY_TITLE = \\\"title\\\";\\n    private static final String KEY_AUTHOR = \\\"author\\\";\\n    private static final String[] COLUMNS = {\\n            KEY_ID,\\n            KEY_TITLE,\\n            KEY_AUTHOR\\n    };\\n\\n\\n    public DatabaseHelper(Context context) {\\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\\n    }\\n\\n    @Override\\n    public void onCreate(SQLiteDatabase db) {\\n        this.initDatabase(db);\\n    }\\n\\n    @Override\\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\\n        // Drop older data table if existed\\n        db.execSQL(\\\"DROP TABLE IF EXISTS \\\" + TABLE_DATA);\\n\\n        // create fresh data table\\n        this.onCreate(db);\\n    }\\n\\n\\n\\n    /**\\n     * Initialize DB\\n     * @param db\\n     */\\n    public void initDatabase(SQLiteDatabase db) {\\n        try {\\n            // SQL statement to create data table\\n            String CREATE_DATA_TABLE = \\\"CREATE TABLE \\\" + TABLE_DATA + \\\" ( \\\" +\\n                    \\\"id INTEGER PRIMARY KEY AUTOINCREMENT, \\\" +\\n                    \\\"title TEXT, \\\" +\\n                    \\\"author TEXT )\\\";\\n\\n            // create records table\\n            db.execSQL(CREATE_DATA_TABLE);\\n        } catch(Exception e) {\\n\\n        }\\n    }\\n\\n    public void initDatabaseOuter() {\\n        SQLiteDatabase db = this.getReadableDatabase();\\n        this.initDatabase(db);\\n    }\\n\\n    /**\\n     * Add record to DB\\n     * @param record\\n     */\\n    public void addRecord(DatabaseRecord record) {\\n        try {\\n            Log.d(\\\"htbridge\\\", record.toString());\\n\\n            SQLiteDatabase db = this.getWritableDatabase();\\n\\n            ContentValues values = new ContentValues();\\n            values.put(KEY_TITLE, record.getTitle()); // get title\\n            values.put(KEY_AUTHOR, record.getAuthor()); // get author\\n\\n            db.insert(TABLE_DATA, // table\\n                    null, //nullColumnHack\\n                    values); // key/value -> keys = column names/ values = column values\\n\\n            db.close();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n\\n    /**\\n     * Getter of record from DB\\n     * @param id\\n     * @return\\n     */\\n    public DatabaseRecord getRecord(int id) {\\n        DatabaseRecord record = new DatabaseRecord();\\n\\n        try {\\n            SQLiteDatabase db = this.getReadableDatabase();\\n            Cursor cursor = db.rawQuery(\\\"select * from data where id='\\\" + String.valueOf(id) + '\\\"', null);\\n\\n            if (cursor != null) cursor.moveToFirst();\\n\\n            record.setId(Integer.parseInt(cursor.getString(0)));\\n            record.setTitle(cursor.getString(1));\\n            record.setAuthor(cursor.getString(2));\\n\\n            Log.d(\\\"htbridge\\\",\\\"getRecord(\\\" + id + \\\"): \\\" + record.toString());\\n\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        return record;\\n    }\\n\\n\\n    /**\\n     * Get all records from DB\\n     * @return\\n     */\\n    public ArrayList<DatabaseRecord> getAllRecords() {\\n        ArrayList<DatabaseRecord> records = new ArrayList<DatabaseRecord>();\\n\\n        try {\\n            SQLiteDatabase db = this.getWritableDatabase();\\n            Cursor cursor = db.rawQuery(\\\"SELECT * FROM \\\" + TABLE_DATA, null);\\n\\n            DatabaseRecord record = null;\\n            if (cursor.moveToFirst()) {\\n                do {\\n                    record = new DatabaseRecord();\\n                    record.setId(Integer.parseInt(cursor.getString(0)));\\n                    record.setTitle(cursor.getString(1));\\n                    record.setAuthor(cursor.getString(2));\\n\\n                    // Add record to records\\n                    records.add(record);\\n                } while (cursor.moveToNext());\\n            }\\n\\n            Log.d(\\\"htbridge\\\", \\\"getAllRecords(): \\\" + records.toString());\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n        return records;\\n\\n    }\\n\\n\\n    /**\\n     * Update record in DB\\n     * @param record\\n     * @return\\n     */\\n    public int updateRecord(DatabaseRecord record) {\\n        int i = -1;\\n\\n        try {\\n            SQLiteDatabase db = this.getWritableDatabase();\\n\\n            ContentValues values = new ContentValues();\\n            values.put(\\\"title\\\", record.getTitle());\\n            values.put(\\\"author\\\", record.getAuthor());\\n\\n            i = db.update(TABLE_DATA, values, KEY_ID + \\\" = ?\\\", new String[]{\\n                    String.valueOf(record.getId())\\n            });\\n\\n            db.close();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        return i;\\n    }\\n\\n    /**\\n     * Delete record from DB\\n     * @param record\\n     */\\n    public void deleteRecord(DatabaseRecord record) {\\n        try {\\n            Log.d(\\\"htbridge\\\", \\\"deleteRecord: \\\" + record.toString());\\n\\n            SQLiteDatabase db = this.getWritableDatabase();\\n\\n            db.delete(TABLE_DATA, KEY_ID + \\\" = ?\\\", new String[]{\\n                    String.valueOf(record.getId())\\n            });\\n\\n            db.close();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n\\n    /**\\n     * Raw SQL Query\\n     * @param query\\n     */\\n    public String rawSQLQuery(String query) {\\n\\n\\n        StringBuilder sb = new StringBuilder();\\n        SQLiteDatabase db = this.getWritableDatabase();\\n\\n        try {\\n            Log.d(\\\"htbridge\\\", \\\"rawSQLQuery: \\\" + query);\\n\\n            Cursor cursor = db.rawQuery(query, null);\\n            if (cursor != null) cursor.moveToFirst();\\n\\n            while (!cursor.isAfterLast()) {\\n                String e = DatabaseUtils.dumpCurrentRowToString(cursor);\\n\\n                Log.d(\\\"htbridge\\\", e);\\n                sb.append(e).append(\\\"\\\\n\\\");\\n\\n                cursor.moveToNext();\\n            }\\n\\n        } catch(Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        db.close();\\n\\n        return sb.toString();\\n    }\\n\\n\\n    /**\\n     * Raw SQL Query\\n     * @param query\\n     */\\n    public Cursor rawSQLQueryCursor(String query) {\\n\\n\\n        StringBuilder sb = new StringBuilder();\\n        SQLiteDatabase db = this.getWritableDatabase();\\n\\n        try {\\n            Log.d(\\\"htbridge\\\", \\\"rawSQLQueryCursor: \\\" + query);\\n\\n            Cursor cursor = db.rawQuery(query, null);\\n            return cursor;\\n\\n\\n        } catch(Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        return null;\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"onCreate\", \"return_type\": \"void\", \"position\": {\"start_line\": 34, \"end_line\": 36, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void onCreate(SQLiteDatabase db) {\\n        this.initDatabase(db);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"db\", \"type\": \"SQLiteDatabase\"}]}, {\"name\": \"onUpgrade\", \"return_type\": \"void\", \"position\": {\"start_line\": 39, \"end_line\": 45, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\\n        // Drop older data table if existed\\n        db.execSQL(\\\"DROP TABLE IF EXISTS \\\" + TABLE_DATA);\\n\\n        // create fresh data table\\n        this.onCreate(db);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"db\", \"type\": \"SQLiteDatabase\"}, {\"name\": \"oldVersion\", \"type\": \"int\"}, {\"name\": \"newVersion\", \"type\": \"int\"}]}, {\"name\": \"initDatabase\", \"return_type\": \"void\", \"position\": {\"start_line\": 53, \"end_line\": 66, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void initDatabase(SQLiteDatabase db) {\\n        try {\\n            // SQL statement to create data table\\n            String CREATE_DATA_TABLE = \\\"CREATE TABLE \\\" + TABLE_DATA + \\\" ( \\\" +\\n                    \\\"id INTEGER PRIMARY KEY AUTOINCREMENT, \\\" +\\n                    \\\"title TEXT, \\\" +\\n                    \\\"author TEXT )\\\";\\n\\n            // create records table\\n            db.execSQL(CREATE_DATA_TABLE);\\n        } catch(Exception e) {\\n\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"db\", \"type\": \"SQLiteDatabase\"}]}, {\"name\": \"initDatabaseOuter\", \"return_type\": \"void\", \"position\": {\"start_line\": 68, \"end_line\": 71, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void initDatabaseOuter() {\\n        SQLiteDatabase db = this.getReadableDatabase();\\n        this.initDatabase(db);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"addRecord\", \"return_type\": \"void\", \"position\": {\"start_line\": 77, \"end_line\": 95, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void addRecord(DatabaseRecord record) {\\n        try {\\n            Log.d(\\\"htbridge\\\", record.toString());\\n\\n            SQLiteDatabase db = this.getWritableDatabase();\\n\\n            ContentValues values = new ContentValues();\\n            values.put(KEY_TITLE, record.getTitle()); // get title\\n            values.put(KEY_AUTHOR, record.getAuthor()); // get author\\n\\n            db.insert(TABLE_DATA, // table\\n                    null, //nullColumnHack\\n                    values); // key/value -> keys = column names/ values = column values\\n\\n            db.close();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"record\", \"type\": \"DatabaseRecord\"}]}, {\"name\": \"getRecord\", \"return_type\": \"DatabaseRecord\", \"position\": {\"start_line\": 103, \"end_line\": 123, \"start_column\": 12, \"end_column\": 5}, \"code\": \"DatabaseRecord getRecord(int id) {\\n        DatabaseRecord record = new DatabaseRecord();\\n\\n        try {\\n            SQLiteDatabase db = this.getReadableDatabase();\\n            Cursor cursor = db.rawQuery(\\\"select * from data where id='\\\" + String.valueOf(id) + '\\\"', null);\\n\\n            if (cursor != null) cursor.moveToFirst();\\n\\n            record.setId(Integer.parseInt(cursor.getString(0)));\\n            record.setTitle(cursor.getString(1));\\n            record.setAuthor(cursor.getString(2));\\n\\n            Log.d(\\\"htbridge\\\",\\\"getRecord(\\\" + id + \\\"): \\\" + record.toString());\\n\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        return record;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"id\", \"type\": \"int\"}]}, {\"name\": \"getAllRecords\", \"return_type\": \"ArrayList\", \"position\": {\"start_line\": 130, \"end_line\": 156, \"start_column\": 12, \"end_column\": 5}, \"code\": \"ArrayList<DatabaseRecord> getAllRecords() {\\n        ArrayList<DatabaseRecord> records = new ArrayList<DatabaseRecord>();\\n\\n        try {\\n            SQLiteDatabase db = this.getWritableDatabase();\\n            Cursor cursor = db.rawQuery(\\\"SELECT * FROM \\\" + TABLE_DATA, null);\\n\\n            DatabaseRecord record = null;\\n            if (cursor.moveToFirst()) {\\n                do {\\n                    record = new DatabaseRecord();\\n                    record.setId(Integer.parseInt(cursor.getString(0)));\\n                    record.setTitle(cursor.getString(1));\\n                    record.setAuthor(cursor.getString(2));\\n\\n                    // Add record to records\\n                    records.add(record);\\n                } while (cursor.moveToNext());\\n            }\\n\\n            Log.d(\\\"htbridge\\\", \\\"getAllRecords(): \\\" + records.toString());\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n        return records;\\n\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"updateRecord\", \"return_type\": \"int\", \"position\": {\"start_line\": 164, \"end_line\": 184, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int updateRecord(DatabaseRecord record) {\\n        int i = -1;\\n\\n        try {\\n            SQLiteDatabase db = this.getWritableDatabase();\\n\\n            ContentValues values = new ContentValues();\\n            values.put(\\\"title\\\", record.getTitle());\\n            values.put(\\\"author\\\", record.getAuthor());\\n\\n            i = db.update(TABLE_DATA, values, KEY_ID + \\\" = ?\\\", new String[]{\\n                    String.valueOf(record.getId())\\n            });\\n\\n            db.close();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        return i;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"record\", \"type\": \"DatabaseRecord\"}]}, {\"name\": \"deleteRecord\", \"return_type\": \"void\", \"position\": {\"start_line\": 190, \"end_line\": 204, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void deleteRecord(DatabaseRecord record) {\\n        try {\\n            Log.d(\\\"htbridge\\\", \\\"deleteRecord: \\\" + record.toString());\\n\\n            SQLiteDatabase db = this.getWritableDatabase();\\n\\n            db.delete(TABLE_DATA, KEY_ID + \\\" = ?\\\", new String[]{\\n                    String.valueOf(record.getId())\\n            });\\n\\n            db.close();\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"record\", \"type\": \"DatabaseRecord\"}]}, {\"name\": \"rawSQLQuery\", \"return_type\": \"String\", \"position\": {\"start_line\": 211, \"end_line\": 239, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String rawSQLQuery(String query) {\\n\\n\\n        StringBuilder sb = new StringBuilder();\\n        SQLiteDatabase db = this.getWritableDatabase();\\n\\n        try {\\n            Log.d(\\\"htbridge\\\", \\\"rawSQLQuery: \\\" + query);\\n\\n            Cursor cursor = db.rawQuery(query, null);\\n            if (cursor != null) cursor.moveToFirst();\\n\\n            while (!cursor.isAfterLast()) {\\n                String e = DatabaseUtils.dumpCurrentRowToString(cursor);\\n\\n                Log.d(\\\"htbridge\\\", e);\\n                sb.append(e).append(\\\"\\\\n\\\");\\n\\n                cursor.moveToNext();\\n            }\\n\\n        } catch(Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        db.close();\\n\\n        return sb.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"query\", \"type\": \"String\"}]}, {\"name\": \"rawSQLQueryCursor\", \"return_type\": \"Cursor\", \"position\": {\"start_line\": 246, \"end_line\": 264, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Cursor rawSQLQueryCursor(String query) {\\n\\n\\n        StringBuilder sb = new StringBuilder();\\n        SQLiteDatabase db = this.getWritableDatabase();\\n\\n        try {\\n            Log.d(\\\"htbridge\\\", \\\"rawSQLQueryCursor: \\\" + query);\\n\\n            Cursor cursor = db.rawQuery(query, null);\\n            return cursor;\\n\\n\\n        } catch(Exception e) {\\n            e.printStackTrace();\\n        }\\n\\n        return null;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"query\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/com/htbridge/pivaa/handlers/database/DatabaseRecord.java\", \"code\": \"package com.htbridge.pivaa.handlers.database;\\n\\n\\nimport com.htbridge.pivaa.Configuration;\\n\\npublic class DatabaseRecord {\\n    private int id;\\n    private String title;\\n    private String author;\\n    private Configuration config = new Configuration();\\n\\n    public DatabaseRecord() {\\n\\n    }\\n\\n    public DatabaseRecord(String title, String author) {\\n        super();\\n        this.title = title;\\n        this.author = author;\\n    }\\n\\n    public int getId() {\\n        return id;\\n    }\\n\\n    public void setId(int id) {\\n        this.id = id;\\n    }\\n\\n    public String getTitle() {\\n        return title;\\n    }\\n\\n    public void setTitle(String title) {\\n        if (new String(\\\"\\\").equals(title)) {\\n            title = config.default_title_database_item;\\n        }\\n        this.title = title;\\n    }\\n\\n    public String getAuthor() {\\n        return author;\\n    }\\n\\n    public void setAuthor(String author) {\\n        if (new String(\\\"\\\").equals(author)) {\\n            author = config.default_author_database_item;\\n        }\\n        this.author = author;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \\\"Record [id=\\\" + id + \\\", title=\\\" + title + \\\", author=\\\" + author\\n                + \\\"]\\\";\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"DatabaseRecord\", \"position\": {\"start_line\": 6, \"end_line\": 57, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class DatabaseRecord {\\n    private int id;\\n    private String title;\\n    private String author;\\n    private Configuration config = new Configuration();\\n\\n    public DatabaseRecord() {\\n\\n    }\\n\\n    public DatabaseRecord(String title, String author) {\\n        super();\\n        this.title = title;\\n        this.author = author;\\n    }\\n\\n    public int getId() {\\n        return id;\\n    }\\n\\n    public void setId(int id) {\\n        this.id = id;\\n    }\\n\\n    public String getTitle() {\\n        return title;\\n    }\\n\\n    public void setTitle(String title) {\\n        if (new String(\\\"\\\").equals(title)) {\\n            title = config.default_title_database_item;\\n        }\\n        this.title = title;\\n    }\\n\\n    public String getAuthor() {\\n        return author;\\n    }\\n\\n    public void setAuthor(String author) {\\n        if (new String(\\\"\\\").equals(author)) {\\n            author = config.default_author_database_item;\\n        }\\n        this.author = author;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \\\"Record [id=\\\" + id + \\\", title=\\\" + title + \\\", author=\\\" + author\\n                + \\\"]\\\";\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"getId\", \"return_type\": \"int\", \"position\": {\"start_line\": 22, \"end_line\": 24, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int getId() {\\n        return id;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"setId\", \"return_type\": \"void\", \"position\": {\"start_line\": 26, \"end_line\": 28, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setId(int id) {\\n        this.id = id;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"id\", \"type\": \"int\"}]}, {\"name\": \"getTitle\", \"return_type\": \"String\", \"position\": {\"start_line\": 30, \"end_line\": 32, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getTitle() {\\n        return title;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"setTitle\", \"return_type\": \"void\", \"position\": {\"start_line\": 34, \"end_line\": 39, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setTitle(String title) {\\n        if (new String(\\\"\\\").equals(title)) {\\n            title = config.default_title_database_item;\\n        }\\n        this.title = title;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"title\", \"type\": \"String\"}]}, {\"name\": \"getAuthor\", \"return_type\": \"String\", \"position\": {\"start_line\": 41, \"end_line\": 43, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getAuthor() {\\n        return author;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"setAuthor\", \"return_type\": \"void\", \"position\": {\"start_line\": 45, \"end_line\": 50, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setAuthor(String author) {\\n        if (new String(\\\"\\\").equals(author)) {\\n            author = config.default_author_database_item;\\n        }\\n        this.author = author;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"author\", \"type\": \"String\"}]}, {\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 53, \"end_line\": 56, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String toString() {\\n        return \\\"Record [id=\\\" + id + \\\", title=\\\" + title + \\\", author=\\\" + author\\n                + \\\"]\\\";\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/BinaryDecoder.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec;\\n\\n/**\\n * Defines common decoding methods for byte array decoders.\\n *\\n * @version $Id: BinaryDecoder.java 1379145 2012-08-30 21:02:52Z tn $\\n */\\npublic interface BinaryDecoder extends Decoder {\\n\\n    /**\\n     * Decodes a byte array and returns the results as a byte array.\\n     *\\n     * @param source\\n     *            A byte array which has been encoded with the appropriate encoder\\n     * @return a byte array that contains decoded content\\n     * @throws DecoderException\\n     *             A decoder exception is thrown if a Decoder encounters a failure condition during the decode process.\\n     */\\n    byte[] decode(byte[] source) throws DecoderException;\\n}\\n\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"BinaryDecoder\", \"position\": {\"start_line\": 25, \"end_line\": 37, \"start_column\": 8, \"end_column\": 1}, \"code\": \"interface BinaryDecoder extends Decoder {\\n\\n    /**\\n     * Decodes a byte array and returns the results as a byte array.\\n     *\\n     * @param source\\n     *            A byte array which has been encoded with the appropriate encoder\\n     * @return a byte array that contains decoded content\\n     * @throws DecoderException\\n     *             A decoder exception is thrown if a Decoder encounters a failure condition during the decode process.\\n     */\\n    byte[] decode(byte[] source) throws DecoderException;\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"decode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 36, \"end_line\": 36, \"start_column\": 5, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"byte\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/BinaryEncoder.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec;\\n\\n/**\\n * Defines common encoding methods for byte array encoders.\\n *\\n * @version $Id: BinaryEncoder.java 1379145 2012-08-30 21:02:52Z tn $\\n */\\npublic interface BinaryEncoder extends Encoder {\\n\\n    /**\\n     * Encodes a byte array and return the encoded data as a byte array.\\n     *\\n     * @param source\\n     *            Data to be encoded\\n     * @return A byte array containing the encoded data\\n     * @throws EncoderException\\n     *             thrown if the Encoder encounters a failure condition during the encoding process.\\n     */\\n    byte[] encode(byte[] source) throws EncoderException;\\n}\\n\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"BinaryEncoder\", \"position\": {\"start_line\": 25, \"end_line\": 37, \"start_column\": 8, \"end_column\": 1}, \"code\": \"interface BinaryEncoder extends Encoder {\\n\\n    /**\\n     * Encodes a byte array and return the encoded data as a byte array.\\n     *\\n     * @param source\\n     *            Data to be encoded\\n     * @return A byte array containing the encoded data\\n     * @throws EncoderException\\n     *             thrown if the Encoder encounters a failure condition during the encoding process.\\n     */\\n    byte[] encode(byte[] source) throws EncoderException;\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"encode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 36, \"end_line\": 36, \"start_column\": 5, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"byte\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/CharEncoding.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec;\\n\\n/**\\n * Character encoding names required of every implementation of the Java platform.\\n *\\n * From the Java documentation <a\\n * href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>:\\n * <p>\\n * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\\n * release documentation for your implementation to see if any other encodings are supported. Consult the release\\n * documentation for your implementation to see if any other encodings are supported.</cite>\\n * </p>\\n *\\n * <ul>\\n * <li><code>US-ASCII</code><br>\\n * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</li>\\n * <li><code>ISO-8859-1</code><br>\\n * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</li>\\n * <li><code>UTF-8</code><br>\\n * Eight-bit Unicode Transformation Format.</li>\\n * <li><code>UTF-16BE</code><br>\\n * Sixteen-bit Unicode Transformation Format, big-endian byte order.</li>\\n * <li><code>UTF-16LE</code><br>\\n * Sixteen-bit Unicode Transformation Format, little-endian byte order.</li>\\n * <li><code>UTF-16</code><br>\\n * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\\n * accepted on input, big-endian used on output.)</li>\\n * </ul>\\n *\\n * This perhaps would best belong in the [lang] project. Even if a similar interface is defined in [lang], it is not\\n * foreseen that [codec] would be made to depend on [lang].\\n *\\n * <p>\\n * This class is immutable and thread-safe.\\n * </p>\\n *\\n * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n * @since 1.4\\n * @version $Id: CharEncoding.java 1563226 2014-01-31 19:38:06Z ggregory $\\n */\\npublic class CharEncoding {\\n    /**\\n     * CharEncodingISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final String ISO_8859_1 = \\\"ISO-8859-1\\\";\\n\\n    /**\\n     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final String US_ASCII = \\\"US-ASCII\\\";\\n\\n    /**\\n     * Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\\n     * (either order accepted on input, big-endian used on output)\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final String UTF_16 = \\\"UTF-16\\\";\\n\\n    /**\\n     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final String UTF_16BE = \\\"UTF-16BE\\\";\\n\\n    /**\\n     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final String UTF_16LE = \\\"UTF-16LE\\\";\\n\\n    /**\\n     * Eight-bit Unicode Transformation Format.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final String UTF_8 = \\\"UTF-8\\\";\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"CharEncoding\", \"position\": {\"start_line\": 58, \"end_line\": 113, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class CharEncoding {\\n    /**\\n     * CharEncodingISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final String ISO_8859_1 = \\\"ISO-8859-1\\\";\\n\\n    /**\\n     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final String US_ASCII = \\\"US-ASCII\\\";\\n\\n    /**\\n     * Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\\n     * (either order accepted on input, big-endian used on output)\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final String UTF_16 = \\\"UTF-16\\\";\\n\\n    /**\\n     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final String UTF_16BE = \\\"UTF-16BE\\\";\\n\\n    /**\\n     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final String UTF_16LE = \\\"UTF-16LE\\\";\\n\\n    /**\\n     * Eight-bit Unicode Transformation Format.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final String UTF_8 = \\\"UTF-8\\\";\\n}\", \"summary\": \"\", \"methods\": []}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/Charsets.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npackage org.apache.commons.codec;\\n\\nimport java.nio.charset.Charset;\\n\\n/**\\n * Charsets required of every implementation of the Java platform.\\n *\\n * From the Java documentation <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard\\n * charsets</a>:\\n * <p>\\n * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\\n * release documentation for your implementation to see if any other encodings are supported. Consult the release\\n * documentation for your implementation to see if any other encodings are supported. </cite>\\n * </p>\\n *\\n * <ul>\\n * <li><code>US-ASCII</code><br>\\n * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</li>\\n * <li><code>ISO-8859-1</code><br>\\n * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</li>\\n * <li><code>UTF-8</code><br>\\n * Eight-bit Unicode Transformation Format.</li>\\n * <li><code>UTF-16BE</code><br>\\n * Sixteen-bit Unicode Transformation Format, big-endian byte order.</li>\\n * <li><code>UTF-16LE</code><br>\\n * Sixteen-bit Unicode Transformation Format, little-endian byte order.</li>\\n * <li><code>UTF-16</code><br>\\n * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\\n * accepted on input, big-endian used on output.)</li>\\n * </ul>\\n *\\n * This perhaps would best belong in the Commons Lang project. Even if a similar class is defined in Commons Lang, it is\\n * not foreseen that Commons Codec would be made to depend on Commons Lang.\\n *\\n * <p>\\n * This class is immutable and thread-safe.\\n * </p>\\n *\\n * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n * @since 1.7\\n * @version $Id: CharEncoding.java 1173287 2011-09-20 18:16:19Z ggregory $\\n */\\npublic class Charsets {\\n\\n    //\\n    // This class should only contain Charset instances for required encodings. This guarantees that it will load\\n    // correctly and without delay on all Java platforms.\\n    //\\n\\n    /**\\n     * Returns the given Charset or the default Charset if the given Charset is null.\\n     *\\n     * @param charset\\n     *            A charset or null.\\n     * @return the given Charset or the default Charset if the given Charset is null\\n     */\\n    public static Charset toCharset(final Charset charset) {\\n        return charset == null ? Charset.defaultCharset() : charset;\\n    }\\n\\n    /**\\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\\n     *\\n     * @param charset\\n     *            The name of the requested charset, may be null.\\n     * @return a Charset for the named charset\\n     * @throws java.nio.charset.UnsupportedCharsetException\\n     *             If the named charset is unavailable\\n     */\\n    public static Charset toCharset(final String charset) {\\n        return charset == null ? Charset.defaultCharset() : Charset.forName(charset);\\n    }\\n\\n    /**\\n     * CharEncodingISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     * </p>\\n     * <p>\\n     * On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final Charset ISO_8859_1 = Charset.forName(CharEncoding.ISO_8859_1);\\n\\n    /**\\n     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     * </p>\\n     * <p>\\n     * On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final Charset US_ASCII = Charset.forName(CharEncoding.US_ASCII);\\n\\n    /**\\n     * Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\\n     * (either order accepted on input, big-endian used on output)\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     * </p>\\n     * <p>\\n     * On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final Charset UTF_16 = Charset.forName(CharEncoding.UTF_16);\\n\\n    /**\\n     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     * </p>\\n     * <p>\\n     * On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final Charset UTF_16BE = Charset.forName(CharEncoding.UTF_16BE);\\n\\n    /**\\n     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     * </p>\\n     * <p>\\n     * On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final Charset UTF_16LE = Charset.forName(CharEncoding.UTF_16LE);\\n\\n    /**\\n     * Eight-bit Unicode Transformation Format.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     * </p>\\n     * <p>\\n     * On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final Charset UTF_8 = Charset.forName(CharEncoding.UTF_8);\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Charsets\", \"position\": {\"start_line\": 59, \"end_line\": 168, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Charsets {\\n\\n    //\\n    // This class should only contain Charset instances for required encodings. This guarantees that it will load\\n    // correctly and without delay on all Java platforms.\\n    //\\n\\n    /**\\n     * Returns the given Charset or the default Charset if the given Charset is null.\\n     *\\n     * @param charset\\n     *            A charset or null.\\n     * @return the given Charset or the default Charset if the given Charset is null\\n     */\\n    public static Charset toCharset(final Charset charset) {\\n        return charset == null ? Charset.defaultCharset() : charset;\\n    }\\n\\n    /**\\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\\n     *\\n     * @param charset\\n     *            The name of the requested charset, may be null.\\n     * @return a Charset for the named charset\\n     * @throws java.nio.charset.UnsupportedCharsetException\\n     *             If the named charset is unavailable\\n     */\\n    public static Charset toCharset(final String charset) {\\n        return charset == null ? Charset.defaultCharset() : Charset.forName(charset);\\n    }\\n\\n    /**\\n     * CharEncodingISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     * </p>\\n     * <p>\\n     * On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final Charset ISO_8859_1 = Charset.forName(CharEncoding.ISO_8859_1);\\n\\n    /**\\n     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     * </p>\\n     * <p>\\n     * On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final Charset US_ASCII = Charset.forName(CharEncoding.US_ASCII);\\n\\n    /**\\n     * Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\\n     * (either order accepted on input, big-endian used on output)\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     * </p>\\n     * <p>\\n     * On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final Charset UTF_16 = Charset.forName(CharEncoding.UTF_16);\\n\\n    /**\\n     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     * </p>\\n     * <p>\\n     * On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final Charset UTF_16BE = Charset.forName(CharEncoding.UTF_16BE);\\n\\n    /**\\n     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     * </p>\\n     * <p>\\n     * On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final Charset UTF_16LE = Charset.forName(CharEncoding.UTF_16LE);\\n\\n    /**\\n     * Eight-bit Unicode Transformation Format.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this character encoding.\\n     * </p>\\n     * <p>\\n     * On Java 7 or later, use {@link java.nio.charset.StandardCharsets#ISO_8859_1} instead.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public static final Charset UTF_8 = Charset.forName(CharEncoding.UTF_8);\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"toCharset\", \"return_type\": \"Charset\", \"position\": {\"start_line\": 73, \"end_line\": 75, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Charset toCharset(final Charset charset) {\\n        return charset == null ? Charset.defaultCharset() : charset;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"charset\", \"type\": \"Charset\"}]}, {\"name\": \"toCharset\", \"return_type\": \"Charset\", \"position\": {\"start_line\": 86, \"end_line\": 88, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Charset toCharset(final String charset) {\\n        return charset == null ? Charset.defaultCharset() : Charset.forName(charset);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"charset\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/Decoder.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec;\\n\\n/**\\n * Provides the highest level of abstraction for Decoders.\\n * <p>\\n * This is the sister interface of {@link Encoder}. All Decoders implement this common generic interface.\\n * Allows a user to pass a generic Object to any Decoder implementation in the codec package.\\n * <p>\\n * One of the two interfaces at the center of the codec package.\\n *\\n * @version $Id: Decoder.java 1379145 2012-08-30 21:02:52Z tn $\\n */\\npublic interface Decoder {\\n\\n    /**\\n     * Decodes an \\\"encoded\\\" Object and returns a \\\"decoded\\\" Object. Note that the implementation of this interface will\\n     * try to cast the Object parameter to the specific type expected by a particular Decoder implementation. If a\\n     * {@link ClassCastException} occurs this decode method will throw a DecoderException.\\n     *\\n     * @param source\\n     *            the object to decode\\n     * @return a 'decoded\\\" object\\n     * @throws DecoderException\\n     *             a decoder exception can be thrown for any number of reasons. Some good candidates are that the\\n     *             parameter passed to this method is null, a param cannot be cast to the appropriate type for a\\n     *             specific encoder.\\n     */\\n    Object decode(Object source) throws DecoderException;\\n}\\n\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Decoder\", \"position\": {\"start_line\": 30, \"end_line\": 46, \"start_column\": 8, \"end_column\": 1}, \"code\": \"interface Decoder {\\n\\n    /**\\n     * Decodes an \\\"encoded\\\" Object and returns a \\\"decoded\\\" Object. Note that the implementation of this interface will\\n     * try to cast the Object parameter to the specific type expected by a particular Decoder implementation. If a\\n     * {@link ClassCastException} occurs this decode method will throw a DecoderException.\\n     *\\n     * @param source\\n     *            the object to decode\\n     * @return a 'decoded\\\" object\\n     * @throws DecoderException\\n     *             a decoder exception can be thrown for any number of reasons. Some good candidates are that the\\n     *             parameter passed to this method is null, a param cannot be cast to the appropriate type for a\\n     *             specific encoder.\\n     */\\n    Object decode(Object source) throws DecoderException;\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"decode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 45, \"end_line\": 45, \"start_column\": 5, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"Object\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/DecoderException.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec;\\n\\n/**\\n * Thrown when there is a failure condition during the decoding process. This exception is thrown when a {@link Decoder}\\n * encounters a decoding specific exception such as invalid data, or characters outside of the expected range.\\n *\\n * @version $Id: DecoderException.java 1619948 2014-08-22 22:53:55Z ggregory $\\n */\\npublic class DecoderException extends Exception {\\n\\n    /**\\n     * Declares the Serial Version Uid.\\n     *\\n     * @see <a href=\\\"http://c2.com/cgi/wiki?AlwaysDeclareSerialVersionUid\\\">Always Declare Serial Version Uid</a>\\n     */\\n    private static final long serialVersionUID = 1L;\\n\\n    /**\\n     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\\n     * subsequently be initialized by a call to {@link #initCause}.\\n     *\\n     * @since 1.4\\n     */\\n    public DecoderException() {\\n        super();\\n    }\\n\\n    /**\\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\\n     * be initialized by a call to {@link #initCause}.\\n     *\\n     * @param message\\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\\n     */\\n    public DecoderException(final String message) {\\n        super(message);\\n    }\\n\\n    /**\\n     * Constructs a new exception with the specified detail message and cause.\\n     * <p>\\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\\n     * exception's detail message.\\n     *\\n     * @param message\\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\\n     * @param cause\\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\\n     * @since 1.4\\n     */\\n    public DecoderException(final String message, final Throwable cause) {\\n        super(message, cause);\\n    }\\n\\n    /**\\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\\n     *\\n     * @param cause\\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\\n     * @since 1.4\\n     */\\n    public DecoderException(final Throwable cause) {\\n        super(cause);\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"DecoderException\", \"position\": {\"start_line\": 26, \"end_line\": 86, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class DecoderException extends Exception {\\n\\n    /**\\n     * Declares the Serial Version Uid.\\n     *\\n     * @see <a href=\\\"http://c2.com/cgi/wiki?AlwaysDeclareSerialVersionUid\\\">Always Declare Serial Version Uid</a>\\n     */\\n    private static final long serialVersionUID = 1L;\\n\\n    /**\\n     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\\n     * subsequently be initialized by a call to {@link #initCause}.\\n     *\\n     * @since 1.4\\n     */\\n    public DecoderException() {\\n        super();\\n    }\\n\\n    /**\\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\\n     * be initialized by a call to {@link #initCause}.\\n     *\\n     * @param message\\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\\n     */\\n    public DecoderException(final String message) {\\n        super(message);\\n    }\\n\\n    /**\\n     * Constructs a new exception with the specified detail message and cause.\\n     * <p>\\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\\n     * exception's detail message.\\n     *\\n     * @param message\\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\\n     * @param cause\\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\\n     * @since 1.4\\n     */\\n    public DecoderException(final String message, final Throwable cause) {\\n        super(message, cause);\\n    }\\n\\n    /**\\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\\n     *\\n     * @param cause\\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\\n     * @since 1.4\\n     */\\n    public DecoderException(final Throwable cause) {\\n        super(cause);\\n    }\\n}\", \"summary\": \"\", \"methods\": []}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/Encoder.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec;\\n\\n/**\\n * Provides the highest level of abstraction for Encoders.\\n * <p>\\n * This is the sister interface of {@link Decoder}.  Every implementation of Encoder provides this\\n * common generic interface which allows a user to pass a generic Object to any Encoder implementation\\n * in the codec package.\\n *\\n * @version $Id: Encoder.java 1379145 2012-08-30 21:02:52Z tn $\\n */\\npublic interface Encoder {\\n\\n    /**\\n     * Encodes an \\\"Object\\\" and returns the encoded content as an Object. The Objects here may just be\\n     * <code>byte[]</code> or <code>String</code>s depending on the implementation used.\\n     *\\n     * @param source\\n     *            An object to encode\\n     * @return An \\\"encoded\\\" Object\\n     * @throws EncoderException\\n     *             An encoder exception is thrown if the encoder experiences a failure condition during the encoding\\n     *             process.\\n     */\\n    Object encode(Object source) throws EncoderException;\\n}\\n\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Encoder\", \"position\": {\"start_line\": 29, \"end_line\": 43, \"start_column\": 8, \"end_column\": 1}, \"code\": \"interface Encoder {\\n\\n    /**\\n     * Encodes an \\\"Object\\\" and returns the encoded content as an Object. The Objects here may just be\\n     * <code>byte[]</code> or <code>String</code>s depending on the implementation used.\\n     *\\n     * @param source\\n     *            An object to encode\\n     * @return An \\\"encoded\\\" Object\\n     * @throws EncoderException\\n     *             An encoder exception is thrown if the encoder experiences a failure condition during the encoding\\n     *             process.\\n     */\\n    Object encode(Object source) throws EncoderException;\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 42, \"end_line\": 42, \"start_column\": 5, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"Object\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/EncoderException.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec;\\n\\n/**\\n * Thrown when there is a failure condition during the encoding process. This exception is thrown when an\\n * {@link Encoder} encounters a encoding specific exception such as invalid data, inability to calculate a checksum,\\n * characters outside of the expected range.\\n *\\n * @version $Id: EncoderException.java 1619948 2014-08-22 22:53:55Z ggregory $\\n */\\npublic class EncoderException extends Exception {\\n\\n    /**\\n     * Declares the Serial Version Uid.\\n     *\\n     * @see <a href=\\\"http://c2.com/cgi/wiki?AlwaysDeclareSerialVersionUid\\\">Always Declare Serial Version Uid</a>\\n     */\\n    private static final long serialVersionUID = 1L;\\n\\n    /**\\n     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\\n     * subsequently be initialized by a call to {@link #initCause}.\\n     *\\n     * @since 1.4\\n     */\\n    public EncoderException() {\\n        super();\\n    }\\n\\n    /**\\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\\n     * be initialized by a call to {@link #initCause}.\\n     *\\n     * @param message\\n     *            a useful message relating to the encoder specific error.\\n     */\\n    public EncoderException(final String message) {\\n        super(message);\\n    }\\n\\n    /**\\n     * Constructs a new exception with the specified detail message and cause.\\n     *\\n     * <p>\\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\\n     * exception's detail message.\\n     * </p>\\n     *\\n     * @param message\\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\\n     * @param cause\\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\\n     * @since 1.4\\n     */\\n    public EncoderException(final String message, final Throwable cause) {\\n        super(message, cause);\\n    }\\n\\n    /**\\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\\n     *\\n     * @param cause\\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\\n     * @since 1.4\\n     */\\n    public EncoderException(final Throwable cause) {\\n        super(cause);\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"EncoderException\", \"position\": {\"start_line\": 27, \"end_line\": 89, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class EncoderException extends Exception {\\n\\n    /**\\n     * Declares the Serial Version Uid.\\n     *\\n     * @see <a href=\\\"http://c2.com/cgi/wiki?AlwaysDeclareSerialVersionUid\\\">Always Declare Serial Version Uid</a>\\n     */\\n    private static final long serialVersionUID = 1L;\\n\\n    /**\\n     * Constructs a new exception with <code>null</code> as its detail message. The cause is not initialized, and may\\n     * subsequently be initialized by a call to {@link #initCause}.\\n     *\\n     * @since 1.4\\n     */\\n    public EncoderException() {\\n        super();\\n    }\\n\\n    /**\\n     * Constructs a new exception with the specified detail message. The cause is not initialized, and may subsequently\\n     * be initialized by a call to {@link #initCause}.\\n     *\\n     * @param message\\n     *            a useful message relating to the encoder specific error.\\n     */\\n    public EncoderException(final String message) {\\n        super(message);\\n    }\\n\\n    /**\\n     * Constructs a new exception with the specified detail message and cause.\\n     *\\n     * <p>\\n     * Note that the detail message associated with <code>cause</code> is not automatically incorporated into this\\n     * exception's detail message.\\n     * </p>\\n     *\\n     * @param message\\n     *            The detail message which is saved for later retrieval by the {@link #getMessage()} method.\\n     * @param cause\\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\\n     * @since 1.4\\n     */\\n    public EncoderException(final String message, final Throwable cause) {\\n        super(message, cause);\\n    }\\n\\n    /**\\n     * Constructs a new exception with the specified cause and a detail message of <code>(cause==null ?\\n     * null : cause.toString())</code> (which typically contains the class and detail message of <code>cause</code>).\\n     * This constructor is useful for exceptions that are little more than wrappers for other throwables.\\n     *\\n     * @param cause\\n     *            The cause which is saved for later retrieval by the {@link #getCause()} method. A <code>null</code>\\n     *            value is permitted, and indicates that the cause is nonexistent or unknown.\\n     * @since 1.4\\n     */\\n    public EncoderException(final Throwable cause) {\\n        super(cause);\\n    }\\n}\", \"summary\": \"\", \"methods\": []}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/StringDecoder.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec;\\n\\n/**\\n * Defines common decoding methods for String decoders.\\n *\\n * @version $Id: StringDecoder.java 1379145 2012-08-30 21:02:52Z tn $\\n */\\npublic interface StringDecoder extends Decoder {\\n\\n    /**\\n     * Decodes a String and returns a String.\\n     *\\n     * @param source\\n     *            the String to decode\\n     * @return the encoded String\\n     * @throws DecoderException\\n     *             thrown if there is an error condition during the Encoding process.\\n     */\\n    String decode(String source) throws DecoderException;\\n}\\n\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"StringDecoder\", \"position\": {\"start_line\": 25, \"end_line\": 37, \"start_column\": 8, \"end_column\": 1}, \"code\": \"interface StringDecoder extends Decoder {\\n\\n    /**\\n     * Decodes a String and returns a String.\\n     *\\n     * @param source\\n     *            the String to decode\\n     * @return the encoded String\\n     * @throws DecoderException\\n     *             thrown if there is an error condition during the Encoding process.\\n     */\\n    String decode(String source) throws DecoderException;\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"decode\", \"return_type\": \"String\", \"position\": {\"start_line\": 36, \"end_line\": 36, \"start_column\": 5, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/StringEncoder.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec;\\n\\n/**\\n * Defines common encoding methods for String encoders.\\n *\\n * @version $Id: StringEncoder.java 1379145 2012-08-30 21:02:52Z tn $\\n */\\npublic interface StringEncoder extends Encoder {\\n\\n    /**\\n     * Encodes a String and returns a String.\\n     *\\n     * @param source\\n     *            the String to encode\\n     * @return the encoded String\\n     * @throws EncoderException\\n     *             thrown if there is an error condition during the encoding process.\\n     */\\n    String encode(String source) throws EncoderException;\\n}\\n\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"StringEncoder\", \"position\": {\"start_line\": 25, \"end_line\": 37, \"start_column\": 8, \"end_column\": 1}, \"code\": \"interface StringEncoder extends Encoder {\\n\\n    /**\\n     * Encodes a String and returns a String.\\n     *\\n     * @param source\\n     *            the String to encode\\n     * @return the encoded String\\n     * @throws EncoderException\\n     *             thrown if there is an error condition during the encoding process.\\n     */\\n    String encode(String source) throws EncoderException;\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 36, \"end_line\": 36, \"start_column\": 5, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/StringEncoderComparator.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec;\\n\\nimport java.util.Comparator;\\n\\n/**\\n * Compares Strings using a {@link StringEncoder}. This comparator is used to sort Strings by an encoding scheme such as\\n * Soundex, Metaphone, etc. This class can come in handy if one need to sort Strings by an encoded form of a name such\\n * as Soundex.\\n *\\n * <p>This class is immutable and thread-safe.</p>\\n *\\n * @version $Id: StringEncoderComparator.java 1468177 2013-04-15 18:35:15Z ggregory $\\n */\\n@SuppressWarnings(\\\"rawtypes\\\")\\n// TODO ought to implement Comparator<String> but that's not possible whilst maintaining binary compatibility.\\npublic class StringEncoderComparator implements Comparator {\\n\\n    /**\\n     * Internal encoder instance.\\n     */\\n    private final StringEncoder stringEncoder;\\n\\n    /**\\n     * Constructs a new instance.\\n     *\\n     * @deprecated Creating an instance without a {@link StringEncoder} leads to a {@link NullPointerException}. Will be\\n     *             removed in 2.0.\\n     */\\n    @Deprecated\\n    public StringEncoderComparator() {\\n        this.stringEncoder = null; // Trying to use this will cause things to break\\n    }\\n\\n    /**\\n     * Constructs a new instance with the given algorithm.\\n     *\\n     * @param stringEncoder\\n     *            the StringEncoder used for comparisons.\\n     */\\n    public StringEncoderComparator(final StringEncoder stringEncoder) {\\n        this.stringEncoder = stringEncoder;\\n    }\\n\\n    /**\\n     * Compares two strings based not on the strings themselves, but on an encoding of the two strings using the\\n     * StringEncoder this Comparator was created with.\\n     *\\n     * If an {@link EncoderException} is encountered, return <code>0</code>.\\n     *\\n     * @param o1\\n     *            the object to compare\\n     * @param o2\\n     *            the object to compare to\\n     * @return the Comparable.compareTo() return code or 0 if an encoding error was caught.\\n     * @see Comparable\\n     */\\n    @Override\\n    public int compare(final Object o1, final Object o2) {\\n\\n        int compareCode = 0;\\n\\n        try {\\n            @SuppressWarnings(\\\"unchecked\\\") // May fail with CCE if encode returns something that is not Comparable\\n            // However this was always the case.\\n            final Comparable<Comparable<?>> s1 = (Comparable<Comparable<?>>) this.stringEncoder.encode(o1);\\n            final Comparable<?> s2 = (Comparable<?>) this.stringEncoder.encode(o2);\\n            compareCode = s1.compareTo(s2);\\n        } catch (final EncoderException ee) {\\n            compareCode = 0;\\n        }\\n        return compareCode;\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"StringEncoderComparator\", \"position\": {\"start_line\": 33, \"end_line\": 91, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class StringEncoderComparator implements Comparator {\\n\\n    /**\\n     * Internal encoder instance.\\n     */\\n    private final StringEncoder stringEncoder;\\n\\n    /**\\n     * Constructs a new instance.\\n     *\\n     * @deprecated Creating an instance without a {@link StringEncoder} leads to a {@link NullPointerException}. Will be\\n     *             removed in 2.0.\\n     */\\n    @Deprecated\\n    public StringEncoderComparator() {\\n        this.stringEncoder = null; // Trying to use this will cause things to break\\n    }\\n\\n    /**\\n     * Constructs a new instance with the given algorithm.\\n     *\\n     * @param stringEncoder\\n     *            the StringEncoder used for comparisons.\\n     */\\n    public StringEncoderComparator(final StringEncoder stringEncoder) {\\n        this.stringEncoder = stringEncoder;\\n    }\\n\\n    /**\\n     * Compares two strings based not on the strings themselves, but on an encoding of the two strings using the\\n     * StringEncoder this Comparator was created with.\\n     *\\n     * If an {@link EncoderException} is encountered, return <code>0</code>.\\n     *\\n     * @param o1\\n     *            the object to compare\\n     * @param o2\\n     *            the object to compare to\\n     * @return the Comparable.compareTo() return code or 0 if an encoding error was caught.\\n     * @see Comparable\\n     */\\n    @Override\\n    public int compare(final Object o1, final Object o2) {\\n\\n        int compareCode = 0;\\n\\n        try {\\n            @SuppressWarnings(\\\"unchecked\\\") // May fail with CCE if encode returns something that is not Comparable\\n            // However this was always the case.\\n            final Comparable<Comparable<?>> s1 = (Comparable<Comparable<?>>) this.stringEncoder.encode(o1);\\n            final Comparable<?> s2 = (Comparable<?>) this.stringEncoder.encode(o2);\\n            compareCode = s1.compareTo(s2);\\n        } catch (final EncoderException ee) {\\n            compareCode = 0;\\n        }\\n        return compareCode;\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"compare\", \"return_type\": \"int\", \"position\": {\"start_line\": 75, \"end_line\": 89, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int compare(final Object o1, final Object o2) {\\n\\n        int compareCode = 0;\\n\\n        try {\\n            @SuppressWarnings(\\\"unchecked\\\") // May fail with CCE if encode returns something that is not Comparable\\n            // However this was always the case.\\n            final Comparable<Comparable<?>> s1 = (Comparable<Comparable<?>>) this.stringEncoder.encode(o1);\\n            final Comparable<?> s2 = (Comparable<?>) this.stringEncoder.encode(o2);\\n            compareCode = s1.compareTo(s2);\\n        } catch (final EncoderException ee) {\\n            compareCode = 0;\\n        }\\n        return compareCode;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"o1\", \"type\": \"Object\"}, {\"name\": \"o2\", \"type\": \"Object\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/Base32.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.binary;\\n\\n/**\\n * Provides Base32 encoding and decoding as defined by <a href=\\\"http://www.ietf.org/rfc/rfc4648.txt\\\">RFC 4648</a>.\\n *\\n * <p>\\n * The class can be parameterized in the following manner with various constructors:\\n * </p>\\n * <ul>\\n * <li>Whether to use the \\\"base32hex\\\" variant instead of the default \\\"base32\\\"</li>\\n * <li>Line length: Default 76. Line length that aren't multiples of 8 will still essentially end up being multiples of\\n * 8 in the encoded data.\\n * <li>Line separator: Default is CRLF (\\\"\\\\r\\\\n\\\")</li>\\n * </ul>\\n * <p>\\n * This class operates directly on byte streams, and not character streams.\\n * </p>\\n * <p>\\n * This class is thread-safe.\\n * </p>\\n *\\n * @see <a href=\\\"http://www.ietf.org/rfc/rfc4648.txt\\\">RFC 4648</a>\\n *\\n * @since 1.5\\n * @version $Id: Base32.java 1809441 2017-09-23 16:41:53Z ggregory $\\n */\\npublic class Base32 extends BaseNCodec {\\n\\n    /**\\n     * BASE32 characters are 5 bits in length.\\n     * They are formed by taking a block of five octets to form a 40-bit string,\\n     * which is converted into eight BASE32 characters.\\n     */\\n    private static final int BITS_PER_ENCODED_BYTE = 5;\\n    private static final int BYTES_PER_ENCODED_BLOCK = 8;\\n    private static final int BYTES_PER_UNENCODED_BLOCK = 5;\\n\\n    /**\\n     * Chunk separator per RFC 2045 section 2.1.\\n     *\\n     * @see <a href=\\\"http://www.ietf.org/rfc/rfc2045.txt\\\">RFC 2045 section 2.1</a>\\n     */\\n    private static final byte[] CHUNK_SEPARATOR = {'\\\\r', '\\\\n'};\\n\\n    /**\\n     * This array is a lookup table that translates Unicode characters drawn from the \\\"Base32 Alphabet\\\" (as specified\\n     * in Table 3 of RFC 4648) into their 5-bit positive integer equivalents. Characters that are not in the Base32\\n     * alphabet but fall within the bounds of the array are translated to -1.\\n     */\\n    private static final byte[] DECODE_TABLE = {\\n         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\\n            -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\\n            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 40-4f A-O\\n            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,                     // 50-5a P-Z\\n                                                        -1, -1, -1, -1, -1, // 5b - 5f\\n            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 60 - 6f a-o\\n            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,                     // 70 - 7a p-z/**/\\n    };\\n\\n    /**\\n     * This array is a lookup table that translates 5-bit positive integer index values into their \\\"Base32 Alphabet\\\"\\n     * equivalents as specified in Table 3 of RFC 4648.\\n     */\\n    private static final byte[] ENCODE_TABLE = {\\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\\n            '2', '3', '4', '5', '6', '7',\\n    };\\n\\n    /**\\n     * This array is a lookup table that translates Unicode characters drawn from the \\\"Base32 Hex Alphabet\\\" (as\\n     * specified in Table 4 of RFC 4648) into their 5-bit positive integer equivalents. Characters that are not in the\\n     * Base32 Hex alphabet but fall within the bounds of the array are translated to -1.\\n     */\\n    private static final byte[] HEX_DECODE_TABLE = {\\n         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\\n             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\\n            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\\n            25, 26, 27, 28, 29, 30, 31,                                     // 50-56 P-V\\n                                        -1, -1, -1, -1, -1, -1, -1, -1, -1, // 57-5f Z-_\\n            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 60-6f `-o\\n            25, 26, 27, 28, 29, 30, 31                                      // 70-76 p-v\\n    };\\n\\n    /**\\n     * This array is a lookup table that translates 5-bit positive integer index values into their\\n     * \\\"Base32 Hex Alphabet\\\" equivalents as specified in Table 4 of RFC 4648.\\n     */\\n    private static final byte[] HEX_ENCODE_TABLE = {\\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\\n    };\\n\\n    /** Mask used to extract 5 bits, used when encoding Base32 bytes */\\n    private static final int MASK_5BITS = 0x1f;\\n\\n    // The static final fields above are used for the original static byte[] methods on Base32.\\n    // The private member fields below are used with the new streaming approach, which requires\\n    // some state be preserved between calls of encode() and decode().\\n\\n    /**\\n     * Place holder for the bytes we're dealing with for our based logic.\\n     * Bitwise operations store and extract the encoding or decoding from this variable.\\n     */\\n\\n    /**\\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\\n     * <code>decodeSize = {@link #BYTES_PER_ENCODED_BLOCK} - 1 + lineSeparator.length;</code>\\n     */\\n    private final int decodeSize;\\n\\n    /**\\n     * Decode table to use.\\n     */\\n    private final byte[] decodeTable;\\n\\n    /**\\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\\n     * <code>encodeSize = {@link #BYTES_PER_ENCODED_BLOCK} + lineSeparator.length;</code>\\n     */\\n    private final int encodeSize;\\n\\n    /**\\n     * Encode table to use.\\n     */\\n    private final byte[] encodeTable;\\n\\n    /**\\n     * Line separator for encoding. Not used when decoding. Only used if lineLength &gt; 0.\\n     */\\n    private final byte[] lineSeparator;\\n\\n    /**\\n     * Creates a Base32 codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length is 0 (no chunking).\\n     * </p>\\n     *\\n     */\\n    public Base32() {\\n        this(false);\\n    }\\n\\n    /**\\n     * Creates a Base32 codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length is 0 (no chunking).\\n     * </p>\\n     * @param pad byte used as padding byte.\\n     */\\n    public Base32(final byte pad) {\\n        this(false, pad);\\n    }\\n\\n    /**\\n     * Creates a Base32 codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length is 0 (no chunking).\\n     * </p>\\n     * @param useHex if {@code true} then use Base32 Hex alphabet\\n     */\\n    public Base32(final boolean useHex) {\\n        this(0, null, useHex, PAD_DEFAULT);\\n    }\\n\\n    /**\\n     * Creates a Base32 codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length is 0 (no chunking).\\n     * </p>\\n     * @param useHex if {@code true} then use Base32 Hex alphabet\\n     * @param pad byte used as padding byte.\\n     */\\n    public Base32(final boolean useHex, final byte pad) {\\n        this(0, null, useHex, pad);\\n    }\\n\\n    /**\\n     * Creates a Base32 codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length is given in the constructor, the line separator is CRLF.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     */\\n    public Base32(final int lineLength) {\\n        this(lineLength, CHUNK_SEPARATOR);\\n    }\\n\\n    /**\\n     * Creates a Base32 codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length and line separator are given in the constructor.\\n     * </p>\\n     * <p>\\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     * @param lineSeparator\\n     *            Each line of encoded data will end with this sequence of bytes.\\n     * @throws IllegalArgumentException\\n     *             The provided lineSeparator included some Base32 characters. That's not going to work!\\n     */\\n    public Base32(final int lineLength, final byte[] lineSeparator) {\\n        this(lineLength, lineSeparator, false, PAD_DEFAULT);\\n    }\\n\\n    /**\\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length and line separator are given in the constructor.\\n     * </p>\\n     * <p>\\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     * @param lineSeparator\\n     *            Each line of encoded data will end with this sequence of bytes.\\n     * @param useHex\\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\\n     * @throws IllegalArgumentException\\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\\n     *             lineLength &gt; 0 and lineSeparator is null.\\n     */\\n    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\\n        this(lineLength, lineSeparator, useHex, PAD_DEFAULT);\\n    }\\n\\n    /**\\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length and line separator are given in the constructor.\\n     * </p>\\n     * <p>\\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     * @param lineSeparator\\n     *            Each line of encoded data will end with this sequence of bytes.\\n     * @param useHex\\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\\n     * @param pad byte used as padding byte.\\n     * @throws IllegalArgumentException\\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\\n     *             lineLength &gt; 0 and lineSeparator is null.\\n     */\\n    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\\n                lineSeparator == null ? 0 : lineSeparator.length, pad);\\n        if (useHex) {\\n            this.encodeTable = HEX_ENCODE_TABLE;\\n            this.decodeTable = HEX_DECODE_TABLE;\\n        } else {\\n            this.encodeTable = ENCODE_TABLE;\\n            this.decodeTable = DECODE_TABLE;\\n        }\\n        if (lineLength > 0) {\\n            if (lineSeparator == null) {\\n                throw new IllegalArgumentException(\\\"lineLength \\\" + lineLength + \\\" > 0, but lineSeparator is null\\\");\\n            }\\n            // Must be done after initializing the tables\\n            if (containsAlphabetOrPad(lineSeparator)) {\\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\\n                throw new IllegalArgumentException(\\\"lineSeparator must not contain Base32 characters: [\\\" + sep + \\\"]\\\");\\n            }\\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\\n            this.lineSeparator = new byte[lineSeparator.length];\\n            System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\\n        } else {\\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\\n            this.lineSeparator = null;\\n        }\\n        this.decodeSize = this.encodeSize - 1;\\n\\n        if (isInAlphabet(pad) || isWhiteSpace(pad)) {\\n            throw new IllegalArgumentException(\\\"pad must not be in alphabet or whitespace\\\");\\n        }\\n    }\\n\\n    /**\\n     * <p>\\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\\n     * with the data to decode, and once with inAvail set to \\\"-1\\\" to alert decoder that EOF has been reached. The \\\"-1\\\"\\n     * call is not necessary when decoding, but it doesn't hurt, either.\\n     * </p>\\n     * <p>\\n     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\\n     * garbage-out philosophy: it will not check the provided data for validity.\\n     * </p>\\n     *\\n     * @param in\\n     *            byte[] array of ascii data to Base32 decode.\\n     * @param inPos\\n     *            Position to start reading data from.\\n     * @param inAvail\\n     *            Amount of bytes available from input for encoding.\\n     * @param context the context to be used\\n     *\\n     * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position\\n     */\\n    @Override\\n    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\\n        // package protected for access from I/O streams\\n\\n        if (context.eof) {\\n            return;\\n        }\\n        if (inAvail < 0) {\\n            context.eof = true;\\n        }\\n        for (int i = 0; i < inAvail; i++) {\\n            final byte b = in[inPos++];\\n            if (b == pad) {\\n                // We're done.\\n                context.eof = true;\\n                break;\\n            }\\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\\n            if (b >= 0 && b < this.decodeTable.length) {\\n                final int result = this.decodeTable[b];\\n                if (result >= 0) {\\n                    context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\\n                    // collect decoded bytes\\n                    context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\\n                    if (context.modulus == 0) { // we can output the 5 bytes\\n                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Two forms of EOF as far as Base32 decoder is concerned: actual\\n        // EOF (-1) and first time '=' character is encountered in stream.\\n        // This approach makes the '=' padding characters completely optional.\\n        if (context.eof && context.modulus >= 2) { // if modulus < 2, nothing to do\\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\\n\\n            //  we ignore partial bytes, i.e. only multiples of 8 count\\n            switch (context.modulus) {\\n                case 2 : // 10 bits, drop 2 and output one byte\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);\\n                    break;\\n                case 3 : // 15 bits, drop 7 and output 1 byte\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);\\n                    break;\\n                case 4 : // 20 bits = 2*8 + 4\\n                    context.lbitWorkArea = context.lbitWorkArea >> 4; // drop 4 bits\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\\n                    break;\\n                case 5 : // 25bits = 3*8 + 1\\n                    context.lbitWorkArea = context.lbitWorkArea >> 1;\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\\n                    break;\\n                case 6 : // 30bits = 3*8 + 6\\n                    context.lbitWorkArea = context.lbitWorkArea >> 6;\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\\n                    break;\\n                case 7 : // 35 = 4*8 +3\\n                    context.lbitWorkArea = context.lbitWorkArea >> 3;\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\\n                    break;\\n                default:\\n                    // modulus can be 0-7, and we excluded 0,1 already\\n                    throw new IllegalStateException(\\\"Impossible modulus \\\"+context.modulus);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * <p>\\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\\n     * the data to encode, and once with inAvail set to \\\"-1\\\" to alert encoder that EOF has been reached, so flush last\\n     * remaining bytes (if not multiple of 5).\\n     * </p>\\n     *\\n     * @param in\\n     *            byte[] array of binary data to Base32 encode.\\n     * @param inPos\\n     *            Position to start reading data from.\\n     * @param inAvail\\n     *            Amount of bytes available from input for encoding.\\n     * @param context the context to be used\\n     */\\n    @Override\\n    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\\n        // package protected for access from I/O streams\\n\\n        if (context.eof) {\\n            return;\\n        }\\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\\n        // encoding.\\n        if (inAvail < 0) {\\n            context.eof = true;\\n            if (0 == context.modulus && lineLength == 0) {\\n                return; // no leftovers to process and not using chunking\\n            }\\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\\n            final int savedPos = context.pos;\\n            switch (context.modulus) { // % 5\\n                case 0 :\\n                    break;\\n                case 1 : // Only 1 octet; take top 5 bits then remainder\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; // 5-3=2\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    break;\\n                case 2 : // 2 octets = 16 bits to use\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    break;\\n                case 3 : // 3 octets = 24 bits to use\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    break;\\n                case 4 : // 4 octets = 32 bits to use\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\\n                    buffer[context.pos++] = pad;\\n                    break;\\n                default:\\n                    throw new IllegalStateException(\\\"Impossible modulus \\\"+context.modulus);\\n            }\\n            context.currentLinePos += context.pos - savedPos; // keep track of current line position\\n            // if currentPos == 0 we are at the start of a line, so don't add CRLF\\n            if (lineLength > 0 && context.currentLinePos > 0){ // add chunk separator if required\\n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\\n                context.pos += lineSeparator.length;\\n            }\\n        } else {\\n            for (int i = 0; i < inAvail; i++) {\\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\\n                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\\n                int b = in[inPos++];\\n                if (b < 0) {\\n                    b += 256;\\n                }\\n                context.lbitWorkArea = (context.lbitWorkArea << 8) + b; // BITS_PER_BYTE\\n                if (0 == context.modulus) { // we have enough bytes to create our output\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 35) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 30) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 25) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 20) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 15) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 10) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 5) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)context.lbitWorkArea & MASK_5BITS];\\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\\n                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\\n                        context.pos += lineSeparator.length;\\n                        context.currentLinePos = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Returns whether or not the {@code octet} is in the Base32 alphabet.\\n     *\\n     * @param octet\\n     *            The value to test\\n     * @return {@code true} if the value is defined in the the Base32 alphabet {@code false} otherwise.\\n     */\\n    @Override\\n    public boolean isInAlphabet(final byte octet) {\\n        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Base32\", \"position\": {\"start_line\": 44, \"end_line\": 544, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Base32 extends BaseNCodec {\\n\\n    /**\\n     * BASE32 characters are 5 bits in length.\\n     * They are formed by taking a block of five octets to form a 40-bit string,\\n     * which is converted into eight BASE32 characters.\\n     */\\n    private static final int BITS_PER_ENCODED_BYTE = 5;\\n    private static final int BYTES_PER_ENCODED_BLOCK = 8;\\n    private static final int BYTES_PER_UNENCODED_BLOCK = 5;\\n\\n    /**\\n     * Chunk separator per RFC 2045 section 2.1.\\n     *\\n     * @see <a href=\\\"http://www.ietf.org/rfc/rfc2045.txt\\\">RFC 2045 section 2.1</a>\\n     */\\n    private static final byte[] CHUNK_SEPARATOR = {'\\\\r', '\\\\n'};\\n\\n    /**\\n     * This array is a lookup table that translates Unicode characters drawn from the \\\"Base32 Alphabet\\\" (as specified\\n     * in Table 3 of RFC 4648) into their 5-bit positive integer equivalents. Characters that are not in the Base32\\n     * alphabet but fall within the bounds of the array are translated to -1.\\n     */\\n    private static final byte[] DECODE_TABLE = {\\n         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\\n            -1, -1, 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\\n            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 40-4f A-O\\n            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,                     // 50-5a P-Z\\n                                                        -1, -1, -1, -1, -1, // 5b - 5f\\n            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 60 - 6f a-o\\n            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,                     // 70 - 7a p-z/**/\\n    };\\n\\n    /**\\n     * This array is a lookup table that translates 5-bit positive integer index values into their \\\"Base32 Alphabet\\\"\\n     * equivalents as specified in Table 3 of RFC 4648.\\n     */\\n    private static final byte[] ENCODE_TABLE = {\\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\\n            '2', '3', '4', '5', '6', '7',\\n    };\\n\\n    /**\\n     * This array is a lookup table that translates Unicode characters drawn from the \\\"Base32 Hex Alphabet\\\" (as\\n     * specified in Table 4 of RFC 4648) into their 5-bit positive integer equivalents. Characters that are not in the\\n     * Base32 Hex alphabet but fall within the bounds of the array are translated to -1.\\n     */\\n    private static final byte[] HEX_DECODE_TABLE = {\\n         //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\\n             0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\\n            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\\n            25, 26, 27, 28, 29, 30, 31,                                     // 50-56 P-V\\n                                        -1, -1, -1, -1, -1, -1, -1, -1, -1, // 57-5f Z-_\\n            -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 60-6f `-o\\n            25, 26, 27, 28, 29, 30, 31                                      // 70-76 p-v\\n    };\\n\\n    /**\\n     * This array is a lookup table that translates 5-bit positive integer index values into their\\n     * \\\"Base32 Hex Alphabet\\\" equivalents as specified in Table 4 of RFC 4648.\\n     */\\n    private static final byte[] HEX_ENCODE_TABLE = {\\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\\n    };\\n\\n    /** Mask used to extract 5 bits, used when encoding Base32 bytes */\\n    private static final int MASK_5BITS = 0x1f;\\n\\n    // The static final fields above are used for the original static byte[] methods on Base32.\\n    // The private member fields below are used with the new streaming approach, which requires\\n    // some state be preserved between calls of encode() and decode().\\n\\n    /**\\n     * Place holder for the bytes we're dealing with for our based logic.\\n     * Bitwise operations store and extract the encoding or decoding from this variable.\\n     */\\n\\n    /**\\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\\n     * <code>decodeSize = {@link #BYTES_PER_ENCODED_BLOCK} - 1 + lineSeparator.length;</code>\\n     */\\n    private final int decodeSize;\\n\\n    /**\\n     * Decode table to use.\\n     */\\n    private final byte[] decodeTable;\\n\\n    /**\\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\\n     * <code>encodeSize = {@link #BYTES_PER_ENCODED_BLOCK} + lineSeparator.length;</code>\\n     */\\n    private final int encodeSize;\\n\\n    /**\\n     * Encode table to use.\\n     */\\n    private final byte[] encodeTable;\\n\\n    /**\\n     * Line separator for encoding. Not used when decoding. Only used if lineLength &gt; 0.\\n     */\\n    private final byte[] lineSeparator;\\n\\n    /**\\n     * Creates a Base32 codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length is 0 (no chunking).\\n     * </p>\\n     *\\n     */\\n    public Base32() {\\n        this(false);\\n    }\\n\\n    /**\\n     * Creates a Base32 codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length is 0 (no chunking).\\n     * </p>\\n     * @param pad byte used as padding byte.\\n     */\\n    public Base32(final byte pad) {\\n        this(false, pad);\\n    }\\n\\n    /**\\n     * Creates a Base32 codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length is 0 (no chunking).\\n     * </p>\\n     * @param useHex if {@code true} then use Base32 Hex alphabet\\n     */\\n    public Base32(final boolean useHex) {\\n        this(0, null, useHex, PAD_DEFAULT);\\n    }\\n\\n    /**\\n     * Creates a Base32 codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length is 0 (no chunking).\\n     * </p>\\n     * @param useHex if {@code true} then use Base32 Hex alphabet\\n     * @param pad byte used as padding byte.\\n     */\\n    public Base32(final boolean useHex, final byte pad) {\\n        this(0, null, useHex, pad);\\n    }\\n\\n    /**\\n     * Creates a Base32 codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length is given in the constructor, the line separator is CRLF.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     */\\n    public Base32(final int lineLength) {\\n        this(lineLength, CHUNK_SEPARATOR);\\n    }\\n\\n    /**\\n     * Creates a Base32 codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length and line separator are given in the constructor.\\n     * </p>\\n     * <p>\\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     * @param lineSeparator\\n     *            Each line of encoded data will end with this sequence of bytes.\\n     * @throws IllegalArgumentException\\n     *             The provided lineSeparator included some Base32 characters. That's not going to work!\\n     */\\n    public Base32(final int lineLength, final byte[] lineSeparator) {\\n        this(lineLength, lineSeparator, false, PAD_DEFAULT);\\n    }\\n\\n    /**\\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length and line separator are given in the constructor.\\n     * </p>\\n     * <p>\\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     * @param lineSeparator\\n     *            Each line of encoded data will end with this sequence of bytes.\\n     * @param useHex\\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\\n     * @throws IllegalArgumentException\\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\\n     *             lineLength &gt; 0 and lineSeparator is null.\\n     */\\n    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex) {\\n        this(lineLength, lineSeparator, useHex, PAD_DEFAULT);\\n    }\\n\\n    /**\\n     * Creates a Base32 / Base32 Hex codec used for decoding and encoding.\\n     * <p>\\n     * When encoding the line length and line separator are given in the constructor.\\n     * </p>\\n     * <p>\\n     * Line lengths that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            8). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     * @param lineSeparator\\n     *            Each line of encoded data will end with this sequence of bytes.\\n     * @param useHex\\n     *            if {@code true}, then use Base32 Hex alphabet, otherwise use Base32 alphabet\\n     * @param pad byte used as padding byte.\\n     * @throws IllegalArgumentException\\n     *             The provided lineSeparator included some Base32 characters. That's not going to work! Or the\\n     *             lineLength &gt; 0 and lineSeparator is null.\\n     */\\n    public Base32(final int lineLength, final byte[] lineSeparator, final boolean useHex, final byte pad) {\\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, lineLength,\\n                lineSeparator == null ? 0 : lineSeparator.length, pad);\\n        if (useHex) {\\n            this.encodeTable = HEX_ENCODE_TABLE;\\n            this.decodeTable = HEX_DECODE_TABLE;\\n        } else {\\n            this.encodeTable = ENCODE_TABLE;\\n            this.decodeTable = DECODE_TABLE;\\n        }\\n        if (lineLength > 0) {\\n            if (lineSeparator == null) {\\n                throw new IllegalArgumentException(\\\"lineLength \\\" + lineLength + \\\" > 0, but lineSeparator is null\\\");\\n            }\\n            // Must be done after initializing the tables\\n            if (containsAlphabetOrPad(lineSeparator)) {\\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\\n                throw new IllegalArgumentException(\\\"lineSeparator must not contain Base32 characters: [\\\" + sep + \\\"]\\\");\\n            }\\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\\n            this.lineSeparator = new byte[lineSeparator.length];\\n            System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\\n        } else {\\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\\n            this.lineSeparator = null;\\n        }\\n        this.decodeSize = this.encodeSize - 1;\\n\\n        if (isInAlphabet(pad) || isWhiteSpace(pad)) {\\n            throw new IllegalArgumentException(\\\"pad must not be in alphabet or whitespace\\\");\\n        }\\n    }\\n\\n    /**\\n     * <p>\\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\\n     * with the data to decode, and once with inAvail set to \\\"-1\\\" to alert decoder that EOF has been reached. The \\\"-1\\\"\\n     * call is not necessary when decoding, but it doesn't hurt, either.\\n     * </p>\\n     * <p>\\n     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\\n     * garbage-out philosophy: it will not check the provided data for validity.\\n     * </p>\\n     *\\n     * @param in\\n     *            byte[] array of ascii data to Base32 decode.\\n     * @param inPos\\n     *            Position to start reading data from.\\n     * @param inAvail\\n     *            Amount of bytes available from input for encoding.\\n     * @param context the context to be used\\n     *\\n     * Output is written to {@link Context#buffer} as 8-bit octets, using {@link Context#pos} as the buffer position\\n     */\\n    @Override\\n    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\\n        // package protected for access from I/O streams\\n\\n        if (context.eof) {\\n            return;\\n        }\\n        if (inAvail < 0) {\\n            context.eof = true;\\n        }\\n        for (int i = 0; i < inAvail; i++) {\\n            final byte b = in[inPos++];\\n            if (b == pad) {\\n                // We're done.\\n                context.eof = true;\\n                break;\\n            }\\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\\n            if (b >= 0 && b < this.decodeTable.length) {\\n                final int result = this.decodeTable[b];\\n                if (result >= 0) {\\n                    context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\\n                    // collect decoded bytes\\n                    context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\\n                    if (context.modulus == 0) { // we can output the 5 bytes\\n                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Two forms of EOF as far as Base32 decoder is concerned: actual\\n        // EOF (-1) and first time '=' character is encountered in stream.\\n        // This approach makes the '=' padding characters completely optional.\\n        if (context.eof && context.modulus >= 2) { // if modulus < 2, nothing to do\\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\\n\\n            //  we ignore partial bytes, i.e. only multiples of 8 count\\n            switch (context.modulus) {\\n                case 2 : // 10 bits, drop 2 and output one byte\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);\\n                    break;\\n                case 3 : // 15 bits, drop 7 and output 1 byte\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);\\n                    break;\\n                case 4 : // 20 bits = 2*8 + 4\\n                    context.lbitWorkArea = context.lbitWorkArea >> 4; // drop 4 bits\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\\n                    break;\\n                case 5 : // 25bits = 3*8 + 1\\n                    context.lbitWorkArea = context.lbitWorkArea >> 1;\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\\n                    break;\\n                case 6 : // 30bits = 3*8 + 6\\n                    context.lbitWorkArea = context.lbitWorkArea >> 6;\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\\n                    break;\\n                case 7 : // 35 = 4*8 +3\\n                    context.lbitWorkArea = context.lbitWorkArea >> 3;\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\\n                    break;\\n                default:\\n                    // modulus can be 0-7, and we excluded 0,1 already\\n                    throw new IllegalStateException(\\\"Impossible modulus \\\"+context.modulus);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * <p>\\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\\n     * the data to encode, and once with inAvail set to \\\"-1\\\" to alert encoder that EOF has been reached, so flush last\\n     * remaining bytes (if not multiple of 5).\\n     * </p>\\n     *\\n     * @param in\\n     *            byte[] array of binary data to Base32 encode.\\n     * @param inPos\\n     *            Position to start reading data from.\\n     * @param inAvail\\n     *            Amount of bytes available from input for encoding.\\n     * @param context the context to be used\\n     */\\n    @Override\\n    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\\n        // package protected for access from I/O streams\\n\\n        if (context.eof) {\\n            return;\\n        }\\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\\n        // encoding.\\n        if (inAvail < 0) {\\n            context.eof = true;\\n            if (0 == context.modulus && lineLength == 0) {\\n                return; // no leftovers to process and not using chunking\\n            }\\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\\n            final int savedPos = context.pos;\\n            switch (context.modulus) { // % 5\\n                case 0 :\\n                    break;\\n                case 1 : // Only 1 octet; take top 5 bits then remainder\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; // 5-3=2\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    break;\\n                case 2 : // 2 octets = 16 bits to use\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    break;\\n                case 3 : // 3 octets = 24 bits to use\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    break;\\n                case 4 : // 4 octets = 32 bits to use\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\\n                    buffer[context.pos++] = pad;\\n                    break;\\n                default:\\n                    throw new IllegalStateException(\\\"Impossible modulus \\\"+context.modulus);\\n            }\\n            context.currentLinePos += context.pos - savedPos; // keep track of current line position\\n            // if currentPos == 0 we are at the start of a line, so don't add CRLF\\n            if (lineLength > 0 && context.currentLinePos > 0){ // add chunk separator if required\\n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\\n                context.pos += lineSeparator.length;\\n            }\\n        } else {\\n            for (int i = 0; i < inAvail; i++) {\\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\\n                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\\n                int b = in[inPos++];\\n                if (b < 0) {\\n                    b += 256;\\n                }\\n                context.lbitWorkArea = (context.lbitWorkArea << 8) + b; // BITS_PER_BYTE\\n                if (0 == context.modulus) { // we have enough bytes to create our output\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 35) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 30) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 25) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 20) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 15) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 10) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 5) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)context.lbitWorkArea & MASK_5BITS];\\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\\n                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\\n                        context.pos += lineSeparator.length;\\n                        context.currentLinePos = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Returns whether or not the {@code octet} is in the Base32 alphabet.\\n     *\\n     * @param octet\\n     *            The value to test\\n     * @return {@code true} if the value is defined in the the Base32 alphabet {@code false} otherwise.\\n     */\\n    @Override\\n    public boolean isInAlphabet(final byte octet) {\\n        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"decode\", \"return_type\": \"void\", \"position\": {\"start_line\": 342, \"end_line\": 419, \"start_column\": 5, \"end_column\": 5}, \"code\": \"void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\\n        // package protected for access from I/O streams\\n\\n        if (context.eof) {\\n            return;\\n        }\\n        if (inAvail < 0) {\\n            context.eof = true;\\n        }\\n        for (int i = 0; i < inAvail; i++) {\\n            final byte b = in[inPos++];\\n            if (b == pad) {\\n                // We're done.\\n                context.eof = true;\\n                break;\\n            }\\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\\n            if (b >= 0 && b < this.decodeTable.length) {\\n                final int result = this.decodeTable[b];\\n                if (result >= 0) {\\n                    context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\\n                    // collect decoded bytes\\n                    context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\\n                    if (context.modulus == 0) { // we can output the 5 bytes\\n                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Two forms of EOF as far as Base32 decoder is concerned: actual\\n        // EOF (-1) and first time '=' character is encountered in stream.\\n        // This approach makes the '=' padding characters completely optional.\\n        if (context.eof && context.modulus >= 2) { // if modulus < 2, nothing to do\\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\\n\\n            //  we ignore partial bytes, i.e. only multiples of 8 count\\n            switch (context.modulus) {\\n                case 2 : // 10 bits, drop 2 and output one byte\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);\\n                    break;\\n                case 3 : // 15 bits, drop 7 and output 1 byte\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);\\n                    break;\\n                case 4 : // 20 bits = 2*8 + 4\\n                    context.lbitWorkArea = context.lbitWorkArea >> 4; // drop 4 bits\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\\n                    break;\\n                case 5 : // 25bits = 3*8 + 1\\n                    context.lbitWorkArea = context.lbitWorkArea >> 1;\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\\n                    break;\\n                case 6 : // 30bits = 3*8 + 6\\n                    context.lbitWorkArea = context.lbitWorkArea >> 6;\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\\n                    break;\\n                case 7 : // 35 = 4*8 +3\\n                    context.lbitWorkArea = context.lbitWorkArea >> 3;\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\\n                    break;\\n                default:\\n                    // modulus can be 0-7, and we excluded 0,1 already\\n                    throw new IllegalStateException(\\\"Impossible modulus \\\"+context.modulus);\\n            }\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"in\", \"type\": \"byte\"}, {\"name\": \"inPos\", \"type\": \"int\"}, {\"name\": \"inAvail\", \"type\": \"int\"}, {\"name\": \"context\", \"type\": \"Context\"}]}, {\"name\": \"encode\", \"return_type\": \"void\", \"position\": {\"start_line\": 437, \"end_line\": 531, \"start_column\": 5, \"end_column\": 5}, \"code\": \"void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\\n        // package protected for access from I/O streams\\n\\n        if (context.eof) {\\n            return;\\n        }\\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\\n        // encoding.\\n        if (inAvail < 0) {\\n            context.eof = true;\\n            if (0 == context.modulus && lineLength == 0) {\\n                return; // no leftovers to process and not using chunking\\n            }\\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\\n            final int savedPos = context.pos;\\n            switch (context.modulus) { // % 5\\n                case 0 :\\n                    break;\\n                case 1 : // Only 1 octet; take top 5 bits then remainder\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; // 5-3=2\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    break;\\n                case 2 : // 2 octets = 16 bits to use\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    break;\\n                case 3 : // 3 octets = 24 bits to use\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    buffer[context.pos++] = pad;\\n                    break;\\n                case 4 : // 4 octets = 32 bits to use\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3\\n                    buffer[context.pos++] = pad;\\n                    break;\\n                default:\\n                    throw new IllegalStateException(\\\"Impossible modulus \\\"+context.modulus);\\n            }\\n            context.currentLinePos += context.pos - savedPos; // keep track of current line position\\n            // if currentPos == 0 we are at the start of a line, so don't add CRLF\\n            if (lineLength > 0 && context.currentLinePos > 0){ // add chunk separator if required\\n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\\n                context.pos += lineSeparator.length;\\n            }\\n        } else {\\n            for (int i = 0; i < inAvail; i++) {\\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\\n                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\\n                int b = in[inPos++];\\n                if (b < 0) {\\n                    b += 256;\\n                }\\n                context.lbitWorkArea = (context.lbitWorkArea << 8) + b; // BITS_PER_BYTE\\n                if (0 == context.modulus) { // we have enough bytes to create our output\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 35) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 30) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 25) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 20) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 15) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 10) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 5) & MASK_5BITS];\\n                    buffer[context.pos++] = encodeTable[(int)context.lbitWorkArea & MASK_5BITS];\\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\\n                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\\n                        context.pos += lineSeparator.length;\\n                        context.currentLinePos = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"in\", \"type\": \"byte\"}, {\"name\": \"inPos\", \"type\": \"int\"}, {\"name\": \"inAvail\", \"type\": \"int\"}, {\"name\": \"context\", \"type\": \"Context\"}]}, {\"name\": \"isInAlphabet\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 541, \"end_line\": 543, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isInAlphabet(final byte octet) {\\n        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"octet\", \"type\": \"byte\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/Base32InputStream.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.binary;\\n\\nimport java.io.InputStream;\\n\\n/**\\n * Provides Base32 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\\n * constructor.\\n * <p>\\n * The default behaviour of the Base32InputStream is to DECODE, whereas the default behaviour of the Base32OutputStream\\n * is to ENCODE, but this behaviour can be overridden by using a different constructor.\\n * </p>\\n * <p>\\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\\n * </p>\\n *\\n * @version $Id: Base32InputStream.java 1586299 2014-04-10 13:50:21Z ggregory $\\n * @see <a href=\\\"http://www.ietf.org/rfc/rfc4648.txt\\\">RFC 4648</a>\\n * @since 1.5\\n */\\npublic class Base32InputStream extends BaseNCodecInputStream {\\n\\n    /**\\n     * Creates a Base32InputStream such that all data read is Base32-decoded from the original provided InputStream.\\n     *\\n     * @param in\\n     *            InputStream to wrap.\\n     */\\n    public Base32InputStream(final InputStream in) {\\n        this(in, false);\\n    }\\n\\n    /**\\n     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\\n     * provided InputStream.\\n     *\\n     * @param in\\n     *            InputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data read from us, false if we should decode.\\n     */\\n    public Base32InputStream(final InputStream in, final boolean doEncode) {\\n        super(in, new Base32(false), doEncode);\\n    }\\n\\n    /**\\n     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\\n     * provided InputStream.\\n     *\\n     * @param in\\n     *            InputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data read from us, false if we should decode.\\n     * @param lineLength\\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\\n     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode\\n     *            is false, lineLength is ignored.\\n     * @param lineSeparator\\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\\\r\\\\n).\\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\\n     */\\n    public Base32InputStream(final InputStream in, final boolean doEncode,\\n                             final int lineLength, final byte[] lineSeparator) {\\n        super(in, new Base32(lineLength, lineSeparator), doEncode);\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Base32InputStream\", \"position\": {\"start_line\": 39, \"end_line\": 85, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Base32InputStream extends BaseNCodecInputStream {\\n\\n    /**\\n     * Creates a Base32InputStream such that all data read is Base32-decoded from the original provided InputStream.\\n     *\\n     * @param in\\n     *            InputStream to wrap.\\n     */\\n    public Base32InputStream(final InputStream in) {\\n        this(in, false);\\n    }\\n\\n    /**\\n     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\\n     * provided InputStream.\\n     *\\n     * @param in\\n     *            InputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data read from us, false if we should decode.\\n     */\\n    public Base32InputStream(final InputStream in, final boolean doEncode) {\\n        super(in, new Base32(false), doEncode);\\n    }\\n\\n    /**\\n     * Creates a Base32InputStream such that all data read is either Base32-encoded or Base32-decoded from the original\\n     * provided InputStream.\\n     *\\n     * @param in\\n     *            InputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data read from us, false if we should decode.\\n     * @param lineLength\\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\\n     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode\\n     *            is false, lineLength is ignored.\\n     * @param lineSeparator\\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\\\r\\\\n).\\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\\n     */\\n    public Base32InputStream(final InputStream in, final boolean doEncode,\\n                             final int lineLength, final byte[] lineSeparator) {\\n        super(in, new Base32(lineLength, lineSeparator), doEncode);\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": []}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/Base32OutputStream.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.binary;\\n\\nimport java.io.OutputStream;\\n\\n/**\\n * Provides Base32 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\\n * constructor.\\n * <p>\\n * The default behaviour of the Base32OutputStream is to ENCODE, whereas the default behaviour of the Base32InputStream\\n * is to DECODE. But this behaviour can be overridden by using a different constructor.\\n * </p>\\n * <p>\\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\\n * </p>\\n * <p>\\n * <b>Note:</b> It is mandatory to close the stream after the last byte has been written to it, otherwise the\\n * final padding will be omitted and the resulting data will be incomplete/inconsistent.\\n * </p>\\n *\\n * @version $Id: Base32OutputStream.java 1635952 2014-11-01 14:19:04Z tn $\\n * @see <a href=\\\"http://www.ietf.org/rfc/rfc4648.txt\\\">RFC 4648</a>\\n * @since 1.5\\n */\\npublic class Base32OutputStream extends BaseNCodecOutputStream {\\n\\n    /**\\n     * Creates a Base32OutputStream such that all data written is Base32-encoded to the original provided OutputStream.\\n     *\\n     * @param out\\n     *            OutputStream to wrap.\\n     */\\n    public Base32OutputStream(final OutputStream out) {\\n        this(out, true);\\n    }\\n\\n    /**\\n     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\\n     * original provided OutputStream.\\n     *\\n     * @param out\\n     *            OutputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data written to us, false if we should decode.\\n     */\\n    public Base32OutputStream(final OutputStream out, final boolean doEncode) {\\n        super(out, new Base32(false), doEncode);\\n    }\\n\\n    /**\\n     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\\n     * original provided OutputStream.\\n     *\\n     * @param out\\n     *            OutputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data written to us, false if we should decode.\\n     * @param lineLength\\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\\n     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode\\n     *            is false, lineLength is ignored.\\n     * @param lineSeparator\\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\\\r\\\\n).\\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\\n     */\\n    public Base32OutputStream(final OutputStream out, final boolean doEncode,\\n                              final int lineLength, final byte[] lineSeparator) {\\n        super(out, new Base32(lineLength, lineSeparator), doEncode);\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Base32OutputStream\", \"position\": {\"start_line\": 43, \"end_line\": 89, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Base32OutputStream extends BaseNCodecOutputStream {\\n\\n    /**\\n     * Creates a Base32OutputStream such that all data written is Base32-encoded to the original provided OutputStream.\\n     *\\n     * @param out\\n     *            OutputStream to wrap.\\n     */\\n    public Base32OutputStream(final OutputStream out) {\\n        this(out, true);\\n    }\\n\\n    /**\\n     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\\n     * original provided OutputStream.\\n     *\\n     * @param out\\n     *            OutputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data written to us, false if we should decode.\\n     */\\n    public Base32OutputStream(final OutputStream out, final boolean doEncode) {\\n        super(out, new Base32(false), doEncode);\\n    }\\n\\n    /**\\n     * Creates a Base32OutputStream such that all data written is either Base32-encoded or Base32-decoded to the\\n     * original provided OutputStream.\\n     *\\n     * @param out\\n     *            OutputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data written to us, false if we should decode.\\n     * @param lineLength\\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\\n     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode\\n     *            is false, lineLength is ignored.\\n     * @param lineSeparator\\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\\\r\\\\n).\\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\\n     */\\n    public Base32OutputStream(final OutputStream out, final boolean doEncode,\\n                              final int lineLength, final byte[] lineSeparator) {\\n        super(out, new Base32(lineLength, lineSeparator), doEncode);\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": []}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/Base64.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.binary;\\n\\nimport java.math.BigInteger;\\n\\n/**\\n * Provides Base64 encoding and decoding as defined by <a href=\\\"http://www.ietf.org/rfc/rfc2045.txt\\\">RFC 2045</a>.\\n *\\n * <p>\\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\\n * </p>\\n * <p>\\n * The class can be parameterized in the following manner with various constructors:\\n * </p>\\n * <ul>\\n * <li>URL-safe mode: Default off.</li>\\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\\n * 4 in the encoded data.\\n * <li>Line separator: Default is CRLF (\\\"\\\\r\\\\n\\\")</li>\\n * </ul>\\n * <p>\\n * The URL-safe parameter is only applied to encode operations. Decoding seamlessly handles both modes.\\n * </p>\\n * <p>\\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only\\n * encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252,\\n * UTF-8, etc).\\n * </p>\\n * <p>\\n * This class is thread-safe.\\n * </p>\\n *\\n * @see <a href=\\\"http://www.ietf.org/rfc/rfc2045.txt\\\">RFC 2045</a>\\n * @since 1.0\\n * @version $Id: Base64.java 1789158 2017-03-28 15:04:58Z sebb $\\n */\\npublic class Base64 extends BaseNCodec {\\n\\n    /**\\n     * BASE32 characters are 6 bits in length.\\n     * They are formed by taking a block of 3 octets to form a 24-bit string,\\n     * which is converted into 4 BASE64 characters.\\n     */\\n    private static final int BITS_PER_ENCODED_BYTE = 6;\\n    private static final int BYTES_PER_UNENCODED_BLOCK = 3;\\n    private static final int BYTES_PER_ENCODED_BLOCK = 4;\\n\\n    /**\\n     * Chunk separator per RFC 2045 section 2.1.\\n     *\\n     * <p>\\n     * N.B. The next major release may break compatibility and make this field private.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://www.ietf.org/rfc/rfc2045.txt\\\">RFC 2045 section 2.1</a>\\n     */\\n    static final byte[] CHUNK_SEPARATOR = {'\\\\r', '\\\\n'};\\n\\n    /**\\n     * This array is a lookup table that translates 6-bit positive integer index values into their \\\"Base64 Alphabet\\\"\\n     * equivalents as specified in Table 1 of RFC 2045.\\n     *\\n     * Thanks to \\\"commons\\\" project in ws.apache.org for this code.\\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\\n     */\\n    private static final byte[] STANDARD_ENCODE_TABLE = {\\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\\n    };\\n\\n    /**\\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\\n     * This table is only used when the Base64's mode is set to URL-SAFE.\\n     */\\n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\\n    };\\n\\n    /**\\n     * This array is a lookup table that translates Unicode characters drawn from the \\\"Base64 Alphabet\\\" (as specified\\n     * in Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\\n     * alphabet but fall within the bounds of the array are translated to -1.\\n     *\\n     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\\n     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\\n     *\\n     * Thanks to \\\"commons\\\" project in ws.apache.org for this code.\\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\\n     */\\n    private static final byte[] DECODE_TABLE = {\\n        //   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, // 20-2f + - /\\n            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, // 30-3f 0-9\\n            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 40-4f A-O\\n            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63, // 50-5f P-Z _\\n            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, // 60-6f a-o\\n            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51                      // 70-7a p-z\\n    };\\n\\n    /**\\n     * Base64 uses 6-bit fields.\\n     */\\n    /** Mask used to extract 6 bits, used when encoding */\\n    private static final int MASK_6BITS = 0x3f;\\n\\n    // The static final fields above are used for the original static byte[] methods on Base64.\\n    // The private member fields below are used with the new streaming approach, which requires\\n    // some state be preserved between calls of encode() and decode().\\n\\n    /**\\n     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\\n     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\\n     * between the two modes.\\n     */\\n    private final byte[] encodeTable;\\n\\n    // Only one decode table currently; keep for consistency with Base32 code\\n    private final byte[] decodeTable = DECODE_TABLE;\\n\\n    /**\\n     * Line separator for encoding. Not used when decoding. Only used if lineLength &gt; 0.\\n     */\\n    private final byte[] lineSeparator;\\n\\n    /**\\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\\n     * <code>decodeSize = 3 + lineSeparator.length;</code>\\n     */\\n    private final int decodeSize;\\n\\n    /**\\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\\n     * <code>encodeSize = 4 + lineSeparator.length;</code>\\n     */\\n    private final int encodeSize;\\n\\n    /**\\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\\n     * <p>\\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\\n     * </p>\\n     *\\n     * <p>\\n     * When decoding all variants are supported.\\n     * </p>\\n     */\\n    public Base64() {\\n        this(0);\\n    }\\n\\n    /**\\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\\n     * <p>\\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\\n     * </p>\\n     *\\n     * <p>\\n     * When decoding all variants are supported.\\n     * </p>\\n     *\\n     * @param urlSafe\\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\\n     *            <code>false</code>.\\n     * @since 1.4\\n     */\\n    public Base64(final boolean urlSafe) {\\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\\n    }\\n\\n    /**\\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\\n     * <p>\\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\\n     * STANDARD_ENCODE_TABLE.\\n     * </p>\\n     * <p>\\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\\n     * </p>\\n     * <p>\\n     * When decoding all variants are supported.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     * @since 1.4\\n     */\\n    public Base64(final int lineLength) {\\n        this(lineLength, CHUNK_SEPARATOR);\\n    }\\n\\n    /**\\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\\n     * <p>\\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\\n     * STANDARD_ENCODE_TABLE.\\n     * </p>\\n     * <p>\\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\\n     * </p>\\n     * <p>\\n     * When decoding all variants are supported.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     * @param lineSeparator\\n     *            Each line of encoded data will end with this sequence of bytes.\\n     * @throws IllegalArgumentException\\n     *             Thrown when the provided lineSeparator included some base64 characters.\\n     * @since 1.4\\n     */\\n    public Base64(final int lineLength, final byte[] lineSeparator) {\\n        this(lineLength, lineSeparator, false);\\n    }\\n\\n    /**\\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\\n     * <p>\\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\\n     * STANDARD_ENCODE_TABLE.\\n     * </p>\\n     * <p>\\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\\n     * </p>\\n     * <p>\\n     * When decoding all variants are supported.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     * @param lineSeparator\\n     *            Each line of encoded data will end with this sequence of bytes.\\n     * @param urlSafe\\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\\n     *            operations. Decoding seamlessly handles both modes.\\n     *            <b>Note: no padding is added when using the URL-safe alphabet.</b>\\n     * @throws IllegalArgumentException\\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\\n     * @since 1.4\\n     */\\n    public Base64(final int lineLength, final byte[] lineSeparator, final boolean urlSafe) {\\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK,\\n                lineLength,\\n                lineSeparator == null ? 0 : lineSeparator.length);\\n        // TODO could be simplified if there is no requirement to reject invalid line sep when length <=0\\n        // @see test case Base64Test.testConstructors()\\n        if (lineSeparator != null) {\\n            if (containsAlphabetOrPad(lineSeparator)) {\\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\\n                throw new IllegalArgumentException(\\\"lineSeparator must not contain base64 characters: [\\\" + sep + \\\"]\\\");\\n            }\\n            if (lineLength > 0){ // null line-sep forces no chunking rather than throwing IAE\\n                this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\\n                this.lineSeparator = new byte[lineSeparator.length];\\n                System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\\n            } else {\\n                this.encodeSize = BYTES_PER_ENCODED_BLOCK;\\n                this.lineSeparator = null;\\n            }\\n        } else {\\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\\n            this.lineSeparator = null;\\n        }\\n        this.decodeSize = this.encodeSize - 1;\\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\\n    }\\n\\n    /**\\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\\n     *\\n     * @return true if we're in URL-SAFE mode, false otherwise.\\n     * @since 1.4\\n     */\\n    public boolean isUrlSafe() {\\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\\n    }\\n\\n    /**\\n     * <p>\\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\\n     * the data to encode, and once with inAvail set to \\\"-1\\\" to alert encoder that EOF has been reached, to flush last\\n     * remaining bytes (if not multiple of 3).\\n     * </p>\\n     * <p><b>Note: no padding is added when encoding using the URL-safe alphabet.</b></p>\\n     * <p>\\n     * Thanks to \\\"commons\\\" project in ws.apache.org for the bitwise operations, and general approach.\\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\\n     * </p>\\n     *\\n     * @param in\\n     *            byte[] array of binary data to base64 encode.\\n     * @param inPos\\n     *            Position to start reading data from.\\n     * @param inAvail\\n     *            Amount of bytes available from input for encoding.\\n     * @param context\\n     *            the context to be used\\n     */\\n    @Override\\n    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\\n        if (context.eof) {\\n            return;\\n        }\\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\\n        // encoding.\\n        if (inAvail < 0) {\\n            context.eof = true;\\n            if (0 == context.modulus && lineLength == 0) {\\n                return; // no leftovers to process and not using chunking\\n            }\\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\\n            final int savedPos = context.pos;\\n            switch (context.modulus) { // 0-2\\n                case 0 : // nothing to do here\\n                    break;\\n                case 1 : // 8 bits = 6 + 2\\n                    // top 6 bits:\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];\\n                    // remaining 2:\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];\\n                    // URL-SAFE skips the padding to further reduce size.\\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\\n                        buffer[context.pos++] = pad;\\n                        buffer[context.pos++] = pad;\\n                    }\\n                    break;\\n\\n                case 2 : // 16 bits = 6 + 6 + 4\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];\\n                    // URL-SAFE skips the padding to further reduce size.\\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\\n                        buffer[context.pos++] = pad;\\n                    }\\n                    break;\\n                default:\\n                    throw new IllegalStateException(\\\"Impossible modulus \\\"+context.modulus);\\n            }\\n            context.currentLinePos += context.pos - savedPos; // keep track of current line position\\n            // if currentPos == 0 we are at the start of a line, so don't add CRLF\\n            if (lineLength > 0 && context.currentLinePos > 0) {\\n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\\n                context.pos += lineSeparator.length;\\n            }\\n        } else {\\n            for (int i = 0; i < inAvail; i++) {\\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\\n                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\\n                int b = in[inPos++];\\n                if (b < 0) {\\n                    b += 256;\\n                }\\n                context.ibitWorkArea = (context.ibitWorkArea << 8) + b; //  BITS_PER_BYTE\\n                if (0 == context.modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];\\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\\n                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\\n                        context.pos += lineSeparator.length;\\n                        context.currentLinePos = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * <p>\\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\\n     * with the data to decode, and once with inAvail set to \\\"-1\\\" to alert decoder that EOF has been reached. The \\\"-1\\\"\\n     * call is not necessary when decoding, but it doesn't hurt, either.\\n     * </p>\\n     * <p>\\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\\n     * garbage-out philosophy: it will not check the provided data for validity.\\n     * </p>\\n     * <p>\\n     * Thanks to \\\"commons\\\" project in ws.apache.org for the bitwise operations, and general approach.\\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\\n     * </p>\\n     *\\n     * @param in\\n     *            byte[] array of ascii data to base64 decode.\\n     * @param inPos\\n     *            Position to start reading data from.\\n     * @param inAvail\\n     *            Amount of bytes available from input for encoding.\\n     * @param context\\n     *            the context to be used\\n     */\\n    @Override\\n    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\\n        if (context.eof) {\\n            return;\\n        }\\n        if (inAvail < 0) {\\n            context.eof = true;\\n        }\\n        for (int i = 0; i < inAvail; i++) {\\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\\n            final byte b = in[inPos++];\\n            if (b == pad) {\\n                // We're done.\\n                context.eof = true;\\n                break;\\n            }\\n            if (b >= 0 && b < DECODE_TABLE.length) {\\n                final int result = DECODE_TABLE[b];\\n                if (result >= 0) {\\n                    context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\\n                    context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;\\n                    if (context.modulus == 0) {\\n                        buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Two forms of EOF as far as base64 decoder is concerned: actual\\n        // EOF (-1) and first time '=' character is encountered in stream.\\n        // This approach makes the '=' padding characters completely optional.\\n        if (context.eof && context.modulus != 0) {\\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\\n\\n            // We have some spare bits remaining\\n            // Output all whole multiples of 8 bits and ignore the rest\\n            switch (context.modulus) {\\n//              case 0 : // impossible, as excluded above\\n                case 1 : // 6 bits - ignore entirely\\n                    // TODO not currently tested; perhaps it is impossible?\\n                    break;\\n                case 2 : // 12 bits = 8 + 4\\n                    context.ibitWorkArea = context.ibitWorkArea >> 4; // dump the extra 4 bits\\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\\n                    break;\\n                case 3 : // 18 bits = 8 + 8 + 2\\n                    context.ibitWorkArea = context.ibitWorkArea >> 2; // dump 2 bits\\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\\n                    break;\\n                default:\\n                    throw new IllegalStateException(\\\"Impossible modulus \\\"+context.modulus);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\\n     * method treats whitespace as valid.\\n     *\\n     * @param arrayOctet\\n     *            byte array to test\\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\\n     *         <code>false</code>, otherwise\\n     * @deprecated 1.5 Use {@link #isBase64(byte[])}, will be removed in 2.0.\\n     */\\n    @Deprecated\\n    public static boolean isArrayByteBase64(final byte[] arrayOctet) {\\n        return isBase64(arrayOctet);\\n    }\\n\\n    /**\\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\\n     *\\n     * @param octet\\n     *            The value to test\\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\\n     * @since 1.4\\n     */\\n    public static boolean isBase64(final byte octet) {\\n        return octet == PAD_DEFAULT || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\\n    }\\n\\n    /**\\n     * Tests a given String to see if it contains only valid characters within the Base64 alphabet. Currently the\\n     * method treats whitespace as valid.\\n     *\\n     * @param base64\\n     *            String to test\\n     * @return <code>true</code> if all characters in the String are valid characters in the Base64 alphabet or if\\n     *         the String is empty; <code>false</code>, otherwise\\n     *  @since 1.5\\n     */\\n    public static boolean isBase64(final String base64) {\\n        return isBase64(StringUtils.getBytesUtf8(base64));\\n    }\\n\\n    /**\\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\\n     * method treats whitespace as valid.\\n     *\\n     * @param arrayOctet\\n     *            byte array to test\\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\\n     *         <code>false</code>, otherwise\\n     * @since 1.5\\n     */\\n    public static boolean isBase64(final byte[] arrayOctet) {\\n        for (int i = 0; i < arrayOctet.length; i++) {\\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\\n     *\\n     * @param binaryData\\n     *            binary data to encode\\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\\n     */\\n    public static byte[] encodeBase64(final byte[] binaryData) {\\n        return encodeBase64(binaryData, false);\\n    }\\n\\n    /**\\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\\n     *\\n     * NOTE:  We changed the behaviour of this method from multi-line chunking (commons-codec-1.4) to\\n     * single-line non-chunking (commons-codec-1.5).\\n     *\\n     * @param binaryData\\n     *            binary data to encode\\n     * @return String containing Base64 characters.\\n     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).\\n     */\\n    public static String encodeBase64String(final byte[] binaryData) {\\n        return StringUtils.newStringUsAscii(encodeBase64(binaryData, false));\\n    }\\n\\n    /**\\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\\n     * url-safe variation emits - and _ instead of + and / characters.\\n     * <b>Note: no padding is added.</b>\\n     * @param binaryData\\n     *            binary data to encode\\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\\n     * @since 1.4\\n     */\\n    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {\\n        return encodeBase64(binaryData, false, true);\\n    }\\n\\n    /**\\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\\n     * url-safe variation emits - and _ instead of + and / characters.\\n     * <b>Note: no padding is added.</b>\\n     * @param binaryData\\n     *            binary data to encode\\n     * @return String containing Base64 characters\\n     * @since 1.4\\n     */\\n    public static String encodeBase64URLSafeString(final byte[] binaryData) {\\n        return StringUtils.newStringUsAscii(encodeBase64(binaryData, false, true));\\n    }\\n\\n    /**\\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\\n     *\\n     * @param binaryData\\n     *            binary data to encode\\n     * @return Base64 characters chunked in 76 character blocks\\n     */\\n    public static byte[] encodeBase64Chunked(final byte[] binaryData) {\\n        return encodeBase64(binaryData, true);\\n    }\\n\\n    /**\\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\\n     *\\n     * @param binaryData\\n     *            Array containing binary data to encode.\\n     * @param isChunked\\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\\n     * @return Base64-encoded data.\\n     * @throws IllegalArgumentException\\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\\n     */\\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked) {\\n        return encodeBase64(binaryData, isChunked, false);\\n    }\\n\\n    /**\\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\\n     *\\n     * @param binaryData\\n     *            Array containing binary data to encode.\\n     * @param isChunked\\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\\n     * @param urlSafe\\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\\n     * @return Base64-encoded data.\\n     * @throws IllegalArgumentException\\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\\n     * @since 1.4\\n     */\\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe) {\\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\\n    }\\n\\n    /**\\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\\n     *\\n     * @param binaryData\\n     *            Array containing binary data to encode.\\n     * @param isChunked\\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\\n     * @param urlSafe\\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\\n     * @param maxResultSize\\n     *            The maximum result size to accept.\\n     * @return Base64-encoded data.\\n     * @throws IllegalArgumentException\\n     *             Thrown when the input array needs an output array bigger than maxResultSize\\n     * @since 1.4\\n     */\\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked,\\n                                      final boolean urlSafe, final int maxResultSize) {\\n        if (binaryData == null || binaryData.length == 0) {\\n            return binaryData;\\n        }\\n\\n        // Create this so can use the super-class method\\n        // Also ensures that the same roundings are performed by the ctor and the code\\n        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\\n        final long len = b64.getEncodedLength(binaryData);\\n        if (len > maxResultSize) {\\n            throw new IllegalArgumentException(\\\"Input array too big, the output array would be bigger (\\\" +\\n                len +\\n                \\\") than the specified maximum size of \\\" +\\n                maxResultSize);\\n        }\\n\\n        return b64.encode(binaryData);\\n    }\\n\\n    /**\\n     * Decodes a Base64 String into octets.\\n     * <p>\\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\\n     * </p>\\n     *\\n     * @param base64String\\n     *            String containing Base64 data\\n     * @return Array containing decoded data.\\n     * @since 1.4\\n     */\\n    public static byte[] decodeBase64(final String base64String) {\\n        return new Base64().decode(base64String);\\n    }\\n\\n    /**\\n     * Decodes Base64 data into octets.\\n     * <p>\\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\\n     * </p>\\n     *\\n     * @param base64Data\\n     *            Byte array containing Base64 data\\n     * @return Array containing decoded data.\\n     */\\n    public static byte[] decodeBase64(final byte[] base64Data) {\\n        return new Base64().decode(base64Data);\\n    }\\n\\n    // Implementation of the Encoder Interface\\n\\n    // Implementation of integer encoding used for crypto\\n    /**\\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\\n     *\\n     * @param pArray\\n     *            a byte array containing base64 character data\\n     * @return A BigInteger\\n     * @since 1.4\\n     */\\n    public static BigInteger decodeInteger(final byte[] pArray) {\\n        return new BigInteger(1, decodeBase64(pArray));\\n    }\\n\\n    /**\\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\\n     *\\n     * @param bigInt\\n     *            a BigInteger\\n     * @return A byte array containing base64 character data\\n     * @throws NullPointerException\\n     *             if null is passed in\\n     * @since 1.4\\n     */\\n    public static byte[] encodeInteger(final BigInteger bigInt) {\\n        if (bigInt == null) {\\n            throw new NullPointerException(\\\"encodeInteger called with null parameter\\\");\\n        }\\n        return encodeBase64(toIntegerBytes(bigInt), false);\\n    }\\n\\n    /**\\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\\n     *\\n     * @param bigInt\\n     *            <code>BigInteger</code> to be converted\\n     * @return a byte array representation of the BigInteger parameter\\n     */\\n    static byte[] toIntegerBytes(final BigInteger bigInt) {\\n        int bitlen = bigInt.bitLength();\\n        // round bitlen\\n        bitlen = ((bitlen + 7) >> 3) << 3;\\n        final byte[] bigBytes = bigInt.toByteArray();\\n\\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\\n            return bigBytes;\\n        }\\n        // set up params for copying everything but sign bit\\n        int startSrc = 0;\\n        int len = bigBytes.length;\\n\\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\\n        if ((bigInt.bitLength() % 8) == 0) {\\n            startSrc = 1;\\n            len--;\\n        }\\n        final int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\\n        final byte[] resizedBytes = new byte[bitlen / 8];\\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\\n        return resizedBytes;\\n    }\\n\\n    /**\\n     * Returns whether or not the <code>octet</code> is in the Base64 alphabet.\\n     *\\n     * @param octet\\n     *            The value to test\\n     * @return <code>true</code> if the value is defined in the the Base64 alphabet <code>false</code> otherwise.\\n     */\\n    @Override\\n    protected boolean isInAlphabet(final byte octet) {\\n        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Base64\", \"position\": {\"start_line\": 54, \"end_line\": 785, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Base64 extends BaseNCodec {\\n\\n    /**\\n     * BASE32 characters are 6 bits in length.\\n     * They are formed by taking a block of 3 octets to form a 24-bit string,\\n     * which is converted into 4 BASE64 characters.\\n     */\\n    private static final int BITS_PER_ENCODED_BYTE = 6;\\n    private static final int BYTES_PER_UNENCODED_BLOCK = 3;\\n    private static final int BYTES_PER_ENCODED_BLOCK = 4;\\n\\n    /**\\n     * Chunk separator per RFC 2045 section 2.1.\\n     *\\n     * <p>\\n     * N.B. The next major release may break compatibility and make this field private.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://www.ietf.org/rfc/rfc2045.txt\\\">RFC 2045 section 2.1</a>\\n     */\\n    static final byte[] CHUNK_SEPARATOR = {'\\\\r', '\\\\n'};\\n\\n    /**\\n     * This array is a lookup table that translates 6-bit positive integer index values into their \\\"Base64 Alphabet\\\"\\n     * equivalents as specified in Table 1 of RFC 2045.\\n     *\\n     * Thanks to \\\"commons\\\" project in ws.apache.org for this code.\\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\\n     */\\n    private static final byte[] STANDARD_ENCODE_TABLE = {\\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\\n    };\\n\\n    /**\\n     * This is a copy of the STANDARD_ENCODE_TABLE above, but with + and /\\n     * changed to - and _ to make the encoded Base64 results more URL-SAFE.\\n     * This table is only used when the Base64's mode is set to URL-SAFE.\\n     */\\n    private static final byte[] URL_SAFE_ENCODE_TABLE = {\\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\\n    };\\n\\n    /**\\n     * This array is a lookup table that translates Unicode characters drawn from the \\\"Base64 Alphabet\\\" (as specified\\n     * in Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\\n     * alphabet but fall within the bounds of the array are translated to -1.\\n     *\\n     * Note: '+' and '-' both decode to 62. '/' and '_' both decode to 63. This means decoder seamlessly handles both\\n     * URL_SAFE and STANDARD base64. (The encoder, on the other hand, needs to know ahead of time what to emit).\\n     *\\n     * Thanks to \\\"commons\\\" project in ws.apache.org for this code.\\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\\n     */\\n    private static final byte[] DECODE_TABLE = {\\n        //   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\\n            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63, // 20-2f + - /\\n            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, // 30-3f 0-9\\n            -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, // 40-4f A-O\\n            15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63, // 50-5f P-Z _\\n            -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, // 60-6f a-o\\n            41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51                      // 70-7a p-z\\n    };\\n\\n    /**\\n     * Base64 uses 6-bit fields.\\n     */\\n    /** Mask used to extract 6 bits, used when encoding */\\n    private static final int MASK_6BITS = 0x3f;\\n\\n    // The static final fields above are used for the original static byte[] methods on Base64.\\n    // The private member fields below are used with the new streaming approach, which requires\\n    // some state be preserved between calls of encode() and decode().\\n\\n    /**\\n     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\\n     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\\n     * between the two modes.\\n     */\\n    private final byte[] encodeTable;\\n\\n    // Only one decode table currently; keep for consistency with Base32 code\\n    private final byte[] decodeTable = DECODE_TABLE;\\n\\n    /**\\n     * Line separator for encoding. Not used when decoding. Only used if lineLength &gt; 0.\\n     */\\n    private final byte[] lineSeparator;\\n\\n    /**\\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\\n     * <code>decodeSize = 3 + lineSeparator.length;</code>\\n     */\\n    private final int decodeSize;\\n\\n    /**\\n     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\\n     * <code>encodeSize = 4 + lineSeparator.length;</code>\\n     */\\n    private final int encodeSize;\\n\\n    /**\\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\\n     * <p>\\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\\n     * </p>\\n     *\\n     * <p>\\n     * When decoding all variants are supported.\\n     * </p>\\n     */\\n    public Base64() {\\n        this(0);\\n    }\\n\\n    /**\\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\\n     * <p>\\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\\n     * </p>\\n     *\\n     * <p>\\n     * When decoding all variants are supported.\\n     * </p>\\n     *\\n     * @param urlSafe\\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\\n     *            <code>false</code>.\\n     * @since 1.4\\n     */\\n    public Base64(final boolean urlSafe) {\\n        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\\n    }\\n\\n    /**\\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\\n     * <p>\\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\\n     * STANDARD_ENCODE_TABLE.\\n     * </p>\\n     * <p>\\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\\n     * </p>\\n     * <p>\\n     * When decoding all variants are supported.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     * @since 1.4\\n     */\\n    public Base64(final int lineLength) {\\n        this(lineLength, CHUNK_SEPARATOR);\\n    }\\n\\n    /**\\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\\n     * <p>\\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\\n     * STANDARD_ENCODE_TABLE.\\n     * </p>\\n     * <p>\\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\\n     * </p>\\n     * <p>\\n     * When decoding all variants are supported.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     * @param lineSeparator\\n     *            Each line of encoded data will end with this sequence of bytes.\\n     * @throws IllegalArgumentException\\n     *             Thrown when the provided lineSeparator included some base64 characters.\\n     * @since 1.4\\n     */\\n    public Base64(final int lineLength, final byte[] lineSeparator) {\\n        this(lineLength, lineSeparator, false);\\n    }\\n\\n    /**\\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\\n     * <p>\\n     * When encoding the line length and line separator are given in the constructor, and the encoding table is\\n     * STANDARD_ENCODE_TABLE.\\n     * </p>\\n     * <p>\\n     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\\n     * </p>\\n     * <p>\\n     * When decoding all variants are supported.\\n     * </p>\\n     *\\n     * @param lineLength\\n     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of\\n     *            4). If lineLength &lt;= 0, then the output will not be divided into lines (chunks). Ignored when\\n     *            decoding.\\n     * @param lineSeparator\\n     *            Each line of encoded data will end with this sequence of bytes.\\n     * @param urlSafe\\n     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\\n     *            operations. Decoding seamlessly handles both modes.\\n     *            <b>Note: no padding is added when using the URL-safe alphabet.</b>\\n     * @throws IllegalArgumentException\\n     *             The provided lineSeparator included some base64 characters. That's not going to work!\\n     * @since 1.4\\n     */\\n    public Base64(final int lineLength, final byte[] lineSeparator, final boolean urlSafe) {\\n        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK,\\n                lineLength,\\n                lineSeparator == null ? 0 : lineSeparator.length);\\n        // TODO could be simplified if there is no requirement to reject invalid line sep when length <=0\\n        // @see test case Base64Test.testConstructors()\\n        if (lineSeparator != null) {\\n            if (containsAlphabetOrPad(lineSeparator)) {\\n                final String sep = StringUtils.newStringUtf8(lineSeparator);\\n                throw new IllegalArgumentException(\\\"lineSeparator must not contain base64 characters: [\\\" + sep + \\\"]\\\");\\n            }\\n            if (lineLength > 0){ // null line-sep forces no chunking rather than throwing IAE\\n                this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\\n                this.lineSeparator = new byte[lineSeparator.length];\\n                System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\\n            } else {\\n                this.encodeSize = BYTES_PER_ENCODED_BLOCK;\\n                this.lineSeparator = null;\\n            }\\n        } else {\\n            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\\n            this.lineSeparator = null;\\n        }\\n        this.decodeSize = this.encodeSize - 1;\\n        this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\\n    }\\n\\n    /**\\n     * Returns our current encode mode. True if we're URL-SAFE, false otherwise.\\n     *\\n     * @return true if we're in URL-SAFE mode, false otherwise.\\n     * @since 1.4\\n     */\\n    public boolean isUrlSafe() {\\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\\n    }\\n\\n    /**\\n     * <p>\\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\\n     * the data to encode, and once with inAvail set to \\\"-1\\\" to alert encoder that EOF has been reached, to flush last\\n     * remaining bytes (if not multiple of 3).\\n     * </p>\\n     * <p><b>Note: no padding is added when encoding using the URL-safe alphabet.</b></p>\\n     * <p>\\n     * Thanks to \\\"commons\\\" project in ws.apache.org for the bitwise operations, and general approach.\\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\\n     * </p>\\n     *\\n     * @param in\\n     *            byte[] array of binary data to base64 encode.\\n     * @param inPos\\n     *            Position to start reading data from.\\n     * @param inAvail\\n     *            Amount of bytes available from input for encoding.\\n     * @param context\\n     *            the context to be used\\n     */\\n    @Override\\n    void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\\n        if (context.eof) {\\n            return;\\n        }\\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\\n        // encoding.\\n        if (inAvail < 0) {\\n            context.eof = true;\\n            if (0 == context.modulus && lineLength == 0) {\\n                return; // no leftovers to process and not using chunking\\n            }\\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\\n            final int savedPos = context.pos;\\n            switch (context.modulus) { // 0-2\\n                case 0 : // nothing to do here\\n                    break;\\n                case 1 : // 8 bits = 6 + 2\\n                    // top 6 bits:\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];\\n                    // remaining 2:\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];\\n                    // URL-SAFE skips the padding to further reduce size.\\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\\n                        buffer[context.pos++] = pad;\\n                        buffer[context.pos++] = pad;\\n                    }\\n                    break;\\n\\n                case 2 : // 16 bits = 6 + 6 + 4\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];\\n                    // URL-SAFE skips the padding to further reduce size.\\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\\n                        buffer[context.pos++] = pad;\\n                    }\\n                    break;\\n                default:\\n                    throw new IllegalStateException(\\\"Impossible modulus \\\"+context.modulus);\\n            }\\n            context.currentLinePos += context.pos - savedPos; // keep track of current line position\\n            // if currentPos == 0 we are at the start of a line, so don't add CRLF\\n            if (lineLength > 0 && context.currentLinePos > 0) {\\n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\\n                context.pos += lineSeparator.length;\\n            }\\n        } else {\\n            for (int i = 0; i < inAvail; i++) {\\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\\n                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\\n                int b = in[inPos++];\\n                if (b < 0) {\\n                    b += 256;\\n                }\\n                context.ibitWorkArea = (context.ibitWorkArea << 8) + b; //  BITS_PER_BYTE\\n                if (0 == context.modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];\\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\\n                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\\n                        context.pos += lineSeparator.length;\\n                        context.currentLinePos = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * <p>\\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\\n     * with the data to decode, and once with inAvail set to \\\"-1\\\" to alert decoder that EOF has been reached. The \\\"-1\\\"\\n     * call is not necessary when decoding, but it doesn't hurt, either.\\n     * </p>\\n     * <p>\\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\\n     * garbage-out philosophy: it will not check the provided data for validity.\\n     * </p>\\n     * <p>\\n     * Thanks to \\\"commons\\\" project in ws.apache.org for the bitwise operations, and general approach.\\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\\n     * </p>\\n     *\\n     * @param in\\n     *            byte[] array of ascii data to base64 decode.\\n     * @param inPos\\n     *            Position to start reading data from.\\n     * @param inAvail\\n     *            Amount of bytes available from input for encoding.\\n     * @param context\\n     *            the context to be used\\n     */\\n    @Override\\n    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\\n        if (context.eof) {\\n            return;\\n        }\\n        if (inAvail < 0) {\\n            context.eof = true;\\n        }\\n        for (int i = 0; i < inAvail; i++) {\\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\\n            final byte b = in[inPos++];\\n            if (b == pad) {\\n                // We're done.\\n                context.eof = true;\\n                break;\\n            }\\n            if (b >= 0 && b < DECODE_TABLE.length) {\\n                final int result = DECODE_TABLE[b];\\n                if (result >= 0) {\\n                    context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\\n                    context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;\\n                    if (context.modulus == 0) {\\n                        buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Two forms of EOF as far as base64 decoder is concerned: actual\\n        // EOF (-1) and first time '=' character is encountered in stream.\\n        // This approach makes the '=' padding characters completely optional.\\n        if (context.eof && context.modulus != 0) {\\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\\n\\n            // We have some spare bits remaining\\n            // Output all whole multiples of 8 bits and ignore the rest\\n            switch (context.modulus) {\\n//              case 0 : // impossible, as excluded above\\n                case 1 : // 6 bits - ignore entirely\\n                    // TODO not currently tested; perhaps it is impossible?\\n                    break;\\n                case 2 : // 12 bits = 8 + 4\\n                    context.ibitWorkArea = context.ibitWorkArea >> 4; // dump the extra 4 bits\\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\\n                    break;\\n                case 3 : // 18 bits = 8 + 8 + 2\\n                    context.ibitWorkArea = context.ibitWorkArea >> 2; // dump 2 bits\\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\\n                    break;\\n                default:\\n                    throw new IllegalStateException(\\\"Impossible modulus \\\"+context.modulus);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\\n     * method treats whitespace as valid.\\n     *\\n     * @param arrayOctet\\n     *            byte array to test\\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\\n     *         <code>false</code>, otherwise\\n     * @deprecated 1.5 Use {@link #isBase64(byte[])}, will be removed in 2.0.\\n     */\\n    @Deprecated\\n    public static boolean isArrayByteBase64(final byte[] arrayOctet) {\\n        return isBase64(arrayOctet);\\n    }\\n\\n    /**\\n     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.\\n     *\\n     * @param octet\\n     *            The value to test\\n     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.\\n     * @since 1.4\\n     */\\n    public static boolean isBase64(final byte octet) {\\n        return octet == PAD_DEFAULT || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\\n    }\\n\\n    /**\\n     * Tests a given String to see if it contains only valid characters within the Base64 alphabet. Currently the\\n     * method treats whitespace as valid.\\n     *\\n     * @param base64\\n     *            String to test\\n     * @return <code>true</code> if all characters in the String are valid characters in the Base64 alphabet or if\\n     *         the String is empty; <code>false</code>, otherwise\\n     *  @since 1.5\\n     */\\n    public static boolean isBase64(final String base64) {\\n        return isBase64(StringUtils.getBytesUtf8(base64));\\n    }\\n\\n    /**\\n     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\\n     * method treats whitespace as valid.\\n     *\\n     * @param arrayOctet\\n     *            byte array to test\\n     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\\n     *         <code>false</code>, otherwise\\n     * @since 1.5\\n     */\\n    public static boolean isBase64(final byte[] arrayOctet) {\\n        for (int i = 0; i < arrayOctet.length; i++) {\\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\\n     *\\n     * @param binaryData\\n     *            binary data to encode\\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\\n     */\\n    public static byte[] encodeBase64(final byte[] binaryData) {\\n        return encodeBase64(binaryData, false);\\n    }\\n\\n    /**\\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\\n     *\\n     * NOTE:  We changed the behaviour of this method from multi-line chunking (commons-codec-1.4) to\\n     * single-line non-chunking (commons-codec-1.5).\\n     *\\n     * @param binaryData\\n     *            binary data to encode\\n     * @return String containing Base64 characters.\\n     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not).\\n     */\\n    public static String encodeBase64String(final byte[] binaryData) {\\n        return StringUtils.newStringUsAscii(encodeBase64(binaryData, false));\\n    }\\n\\n    /**\\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\\n     * url-safe variation emits - and _ instead of + and / characters.\\n     * <b>Note: no padding is added.</b>\\n     * @param binaryData\\n     *            binary data to encode\\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\\n     * @since 1.4\\n     */\\n    public static byte[] encodeBase64URLSafe(final byte[] binaryData) {\\n        return encodeBase64(binaryData, false, true);\\n    }\\n\\n    /**\\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\\n     * url-safe variation emits - and _ instead of + and / characters.\\n     * <b>Note: no padding is added.</b>\\n     * @param binaryData\\n     *            binary data to encode\\n     * @return String containing Base64 characters\\n     * @since 1.4\\n     */\\n    public static String encodeBase64URLSafeString(final byte[] binaryData) {\\n        return StringUtils.newStringUsAscii(encodeBase64(binaryData, false, true));\\n    }\\n\\n    /**\\n     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\\n     *\\n     * @param binaryData\\n     *            binary data to encode\\n     * @return Base64 characters chunked in 76 character blocks\\n     */\\n    public static byte[] encodeBase64Chunked(final byte[] binaryData) {\\n        return encodeBase64(binaryData, true);\\n    }\\n\\n    /**\\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\\n     *\\n     * @param binaryData\\n     *            Array containing binary data to encode.\\n     * @param isChunked\\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\\n     * @return Base64-encoded data.\\n     * @throws IllegalArgumentException\\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\\n     */\\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked) {\\n        return encodeBase64(binaryData, isChunked, false);\\n    }\\n\\n    /**\\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\\n     *\\n     * @param binaryData\\n     *            Array containing binary data to encode.\\n     * @param isChunked\\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\\n     * @param urlSafe\\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\\n     * @return Base64-encoded data.\\n     * @throws IllegalArgumentException\\n     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}\\n     * @since 1.4\\n     */\\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe) {\\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\\n    }\\n\\n    /**\\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\\n     *\\n     * @param binaryData\\n     *            Array containing binary data to encode.\\n     * @param isChunked\\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\\n     * @param urlSafe\\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\\n     * @param maxResultSize\\n     *            The maximum result size to accept.\\n     * @return Base64-encoded data.\\n     * @throws IllegalArgumentException\\n     *             Thrown when the input array needs an output array bigger than maxResultSize\\n     * @since 1.4\\n     */\\n    public static byte[] encodeBase64(final byte[] binaryData, final boolean isChunked,\\n                                      final boolean urlSafe, final int maxResultSize) {\\n        if (binaryData == null || binaryData.length == 0) {\\n            return binaryData;\\n        }\\n\\n        // Create this so can use the super-class method\\n        // Also ensures that the same roundings are performed by the ctor and the code\\n        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\\n        final long len = b64.getEncodedLength(binaryData);\\n        if (len > maxResultSize) {\\n            throw new IllegalArgumentException(\\\"Input array too big, the output array would be bigger (\\\" +\\n                len +\\n                \\\") than the specified maximum size of \\\" +\\n                maxResultSize);\\n        }\\n\\n        return b64.encode(binaryData);\\n    }\\n\\n    /**\\n     * Decodes a Base64 String into octets.\\n     * <p>\\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\\n     * </p>\\n     *\\n     * @param base64String\\n     *            String containing Base64 data\\n     * @return Array containing decoded data.\\n     * @since 1.4\\n     */\\n    public static byte[] decodeBase64(final String base64String) {\\n        return new Base64().decode(base64String);\\n    }\\n\\n    /**\\n     * Decodes Base64 data into octets.\\n     * <p>\\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\\n     * </p>\\n     *\\n     * @param base64Data\\n     *            Byte array containing Base64 data\\n     * @return Array containing decoded data.\\n     */\\n    public static byte[] decodeBase64(final byte[] base64Data) {\\n        return new Base64().decode(base64Data);\\n    }\\n\\n    // Implementation of the Encoder Interface\\n\\n    // Implementation of integer encoding used for crypto\\n    /**\\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\\n     *\\n     * @param pArray\\n     *            a byte array containing base64 character data\\n     * @return A BigInteger\\n     * @since 1.4\\n     */\\n    public static BigInteger decodeInteger(final byte[] pArray) {\\n        return new BigInteger(1, decodeBase64(pArray));\\n    }\\n\\n    /**\\n     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\\n     *\\n     * @param bigInt\\n     *            a BigInteger\\n     * @return A byte array containing base64 character data\\n     * @throws NullPointerException\\n     *             if null is passed in\\n     * @since 1.4\\n     */\\n    public static byte[] encodeInteger(final BigInteger bigInt) {\\n        if (bigInt == null) {\\n            throw new NullPointerException(\\\"encodeInteger called with null parameter\\\");\\n        }\\n        return encodeBase64(toIntegerBytes(bigInt), false);\\n    }\\n\\n    /**\\n     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\\n     *\\n     * @param bigInt\\n     *            <code>BigInteger</code> to be converted\\n     * @return a byte array representation of the BigInteger parameter\\n     */\\n    static byte[] toIntegerBytes(final BigInteger bigInt) {\\n        int bitlen = bigInt.bitLength();\\n        // round bitlen\\n        bitlen = ((bitlen + 7) >> 3) << 3;\\n        final byte[] bigBytes = bigInt.toByteArray();\\n\\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\\n            return bigBytes;\\n        }\\n        // set up params for copying everything but sign bit\\n        int startSrc = 0;\\n        int len = bigBytes.length;\\n\\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\\n        if ((bigInt.bitLength() % 8) == 0) {\\n            startSrc = 1;\\n            len--;\\n        }\\n        final int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\\n        final byte[] resizedBytes = new byte[bitlen / 8];\\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\\n        return resizedBytes;\\n    }\\n\\n    /**\\n     * Returns whether or not the <code>octet</code> is in the Base64 alphabet.\\n     *\\n     * @param octet\\n     *            The value to test\\n     * @return <code>true</code> if the value is defined in the the Base64 alphabet <code>false</code> otherwise.\\n     */\\n    @Override\\n    protected boolean isInAlphabet(final byte octet) {\\n        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"isUrlSafe\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 307, \"end_line\": 309, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isUrlSafe() {\\n        return this.encodeTable == URL_SAFE_ENCODE_TABLE;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"encode\", \"return_type\": \"void\", \"position\": {\"start_line\": 333, \"end_line\": 402, \"start_column\": 5, \"end_column\": 5}, \"code\": \"void encode(final byte[] in, int inPos, final int inAvail, final Context context) {\\n        if (context.eof) {\\n            return;\\n        }\\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\\n        // encoding.\\n        if (inAvail < 0) {\\n            context.eof = true;\\n            if (0 == context.modulus && lineLength == 0) {\\n                return; // no leftovers to process and not using chunking\\n            }\\n            final byte[] buffer = ensureBufferSize(encodeSize, context);\\n            final int savedPos = context.pos;\\n            switch (context.modulus) { // 0-2\\n                case 0 : // nothing to do here\\n                    break;\\n                case 1 : // 8 bits = 6 + 2\\n                    // top 6 bits:\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS];\\n                    // remaining 2:\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS];\\n                    // URL-SAFE skips the padding to further reduce size.\\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\\n                        buffer[context.pos++] = pad;\\n                        buffer[context.pos++] = pad;\\n                    }\\n                    break;\\n\\n                case 2 : // 16 bits = 6 + 6 + 4\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];\\n                    // URL-SAFE skips the padding to further reduce size.\\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\\n                        buffer[context.pos++] = pad;\\n                    }\\n                    break;\\n                default:\\n                    throw new IllegalStateException(\\\"Impossible modulus \\\"+context.modulus);\\n            }\\n            context.currentLinePos += context.pos - savedPos; // keep track of current line position\\n            // if currentPos == 0 we are at the start of a line, so don't add CRLF\\n            if (lineLength > 0 && context.currentLinePos > 0) {\\n                System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\\n                context.pos += lineSeparator.length;\\n            }\\n        } else {\\n            for (int i = 0; i < inAvail; i++) {\\n                final byte[] buffer = ensureBufferSize(encodeSize, context);\\n                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;\\n                int b = in[inPos++];\\n                if (b < 0) {\\n                    b += 256;\\n                }\\n                context.ibitWorkArea = (context.ibitWorkArea << 8) + b; //  BITS_PER_BYTE\\n                if (0 == context.modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];\\n                    buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];\\n                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;\\n                    if (lineLength > 0 && lineLength <= context.currentLinePos) {\\n                        System.arraycopy(lineSeparator, 0, buffer, context.pos, lineSeparator.length);\\n                        context.pos += lineSeparator.length;\\n                        context.currentLinePos = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"in\", \"type\": \"byte\"}, {\"name\": \"inPos\", \"type\": \"int\"}, {\"name\": \"inAvail\", \"type\": \"int\"}, {\"name\": \"context\", \"type\": \"Context\"}]}, {\"name\": \"decode\", \"return_type\": \"void\", \"position\": {\"start_line\": 430, \"end_line\": 485, \"start_column\": 5, \"end_column\": 5}, \"code\": \"void decode(final byte[] in, int inPos, final int inAvail, final Context context) {\\n        if (context.eof) {\\n            return;\\n        }\\n        if (inAvail < 0) {\\n            context.eof = true;\\n        }\\n        for (int i = 0; i < inAvail; i++) {\\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\\n            final byte b = in[inPos++];\\n            if (b == pad) {\\n                // We're done.\\n                context.eof = true;\\n                break;\\n            }\\n            if (b >= 0 && b < DECODE_TABLE.length) {\\n                final int result = DECODE_TABLE[b];\\n                if (result >= 0) {\\n                    context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;\\n                    context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;\\n                    if (context.modulus == 0) {\\n                        buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\\n                        buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Two forms of EOF as far as base64 decoder is concerned: actual\\n        // EOF (-1) and first time '=' character is encountered in stream.\\n        // This approach makes the '=' padding characters completely optional.\\n        if (context.eof && context.modulus != 0) {\\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\\n\\n            // We have some spare bits remaining\\n            // Output all whole multiples of 8 bits and ignore the rest\\n            switch (context.modulus) {\\n//              case 0 : // impossible, as excluded above\\n                case 1 : // 6 bits - ignore entirely\\n                    // TODO not currently tested; perhaps it is impossible?\\n                    break;\\n                case 2 : // 12 bits = 8 + 4\\n                    context.ibitWorkArea = context.ibitWorkArea >> 4; // dump the extra 4 bits\\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\\n                    break;\\n                case 3 : // 18 bits = 8 + 8 + 2\\n                    context.ibitWorkArea = context.ibitWorkArea >> 2; // dump 2 bits\\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\\n                    break;\\n                default:\\n                    throw new IllegalStateException(\\\"Impossible modulus \\\"+context.modulus);\\n            }\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"in\", \"type\": \"byte\"}, {\"name\": \"inPos\", \"type\": \"int\"}, {\"name\": \"inAvail\", \"type\": \"int\"}, {\"name\": \"context\", \"type\": \"Context\"}]}, {\"name\": \"isArrayByteBase64\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 498, \"end_line\": 500, \"start_column\": 19, \"end_column\": 5}, \"code\": \"boolean isArrayByteBase64(final byte[] arrayOctet) {\\n        return isBase64(arrayOctet);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"arrayOctet\", \"type\": \"byte\"}]}, {\"name\": \"isBase64\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 510, \"end_line\": 512, \"start_column\": 19, \"end_column\": 5}, \"code\": \"boolean isBase64(final byte octet) {\\n        return octet == PAD_DEFAULT || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"octet\", \"type\": \"byte\"}]}, {\"name\": \"isBase64\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 524, \"end_line\": 526, \"start_column\": 19, \"end_column\": 5}, \"code\": \"boolean isBase64(final String base64) {\\n        return isBase64(StringUtils.getBytesUtf8(base64));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"base64\", \"type\": \"String\"}]}, {\"name\": \"isBase64\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 538, \"end_line\": 545, \"start_column\": 19, \"end_column\": 5}, \"code\": \"boolean isBase64(final byte[] arrayOctet) {\\n        for (int i = 0; i < arrayOctet.length; i++) {\\n            if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"arrayOctet\", \"type\": \"byte\"}]}, {\"name\": \"encodeBase64\", \"return_type\": \"byte\", \"position\": {\"start_line\": 554, \"end_line\": 556, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] encodeBase64(final byte[] binaryData) {\\n        return encodeBase64(binaryData, false);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"binaryData\", \"type\": \"byte\"}]}, {\"name\": \"encodeBase64String\", \"return_type\": \"String\", \"position\": {\"start_line\": 569, \"end_line\": 571, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String encodeBase64String(final byte[] binaryData) {\\n        return StringUtils.newStringUsAscii(encodeBase64(binaryData, false));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"binaryData\", \"type\": \"byte\"}]}, {\"name\": \"encodeBase64URLSafe\", \"return_type\": \"byte\", \"position\": {\"start_line\": 582, \"end_line\": 584, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] encodeBase64URLSafe(final byte[] binaryData) {\\n        return encodeBase64(binaryData, false, true);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"binaryData\", \"type\": \"byte\"}]}, {\"name\": \"encodeBase64URLSafeString\", \"return_type\": \"String\", \"position\": {\"start_line\": 595, \"end_line\": 597, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String encodeBase64URLSafeString(final byte[] binaryData) {\\n        return StringUtils.newStringUsAscii(encodeBase64(binaryData, false, true));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"binaryData\", \"type\": \"byte\"}]}, {\"name\": \"encodeBase64Chunked\", \"return_type\": \"byte\", \"position\": {\"start_line\": 606, \"end_line\": 608, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] encodeBase64Chunked(final byte[] binaryData) {\\n        return encodeBase64(binaryData, true);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"binaryData\", \"type\": \"byte\"}]}, {\"name\": \"encodeBase64\", \"return_type\": \"byte\", \"position\": {\"start_line\": 621, \"end_line\": 623, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] encodeBase64(final byte[] binaryData, final boolean isChunked) {\\n        return encodeBase64(binaryData, isChunked, false);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"binaryData\", \"type\": \"byte\"}, {\"name\": \"isChunked\", \"type\": \"boolean\"}]}, {\"name\": \"encodeBase64\", \"return_type\": \"byte\", \"position\": {\"start_line\": 640, \"end_line\": 642, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] encodeBase64(final byte[] binaryData, final boolean isChunked, final boolean urlSafe) {\\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"binaryData\", \"type\": \"byte\"}, {\"name\": \"isChunked\", \"type\": \"boolean\"}, {\"name\": \"urlSafe\", \"type\": \"boolean\"}]}, {\"name\": \"encodeBase64\", \"return_type\": \"byte\", \"position\": {\"start_line\": 661, \"end_line\": 679, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] encodeBase64(final byte[] binaryData, final boolean isChunked,\\n                                      final boolean urlSafe, final int maxResultSize) {\\n        if (binaryData == null || binaryData.length == 0) {\\n            return binaryData;\\n        }\\n\\n        // Create this so can use the super-class method\\n        // Also ensures that the same roundings are performed by the ctor and the code\\n        final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\\n        final long len = b64.getEncodedLength(binaryData);\\n        if (len > maxResultSize) {\\n            throw new IllegalArgumentException(\\\"Input array too big, the output array would be bigger (\\\" +\\n                len +\\n                \\\") than the specified maximum size of \\\" +\\n                maxResultSize);\\n        }\\n\\n        return b64.encode(binaryData);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"binaryData\", \"type\": \"byte\"}, {\"name\": \"isChunked\", \"type\": \"boolean\"}, {\"name\": \"urlSafe\", \"type\": \"boolean\"}, {\"name\": \"maxResultSize\", \"type\": \"int\"}]}, {\"name\": \"decodeBase64\", \"return_type\": \"byte\", \"position\": {\"start_line\": 692, \"end_line\": 694, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] decodeBase64(final String base64String) {\\n        return new Base64().decode(base64String);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"base64String\", \"type\": \"String\"}]}, {\"name\": \"decodeBase64\", \"return_type\": \"byte\", \"position\": {\"start_line\": 706, \"end_line\": 708, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] decodeBase64(final byte[] base64Data) {\\n        return new Base64().decode(base64Data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"base64Data\", \"type\": \"byte\"}]}, {\"name\": \"decodeInteger\", \"return_type\": \"BigInteger\", \"position\": {\"start_line\": 721, \"end_line\": 723, \"start_column\": 19, \"end_column\": 5}, \"code\": \"BigInteger decodeInteger(final byte[] pArray) {\\n        return new BigInteger(1, decodeBase64(pArray));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"pArray\", \"type\": \"byte\"}]}, {\"name\": \"encodeInteger\", \"return_type\": \"byte\", \"position\": {\"start_line\": 735, \"end_line\": 740, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] encodeInteger(final BigInteger bigInt) {\\n        if (bigInt == null) {\\n            throw new NullPointerException(\\\"encodeInteger called with null parameter\\\");\\n        }\\n        return encodeBase64(toIntegerBytes(bigInt), false);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bigInt\", \"type\": \"BigInteger\"}]}, {\"name\": \"toIntegerBytes\", \"return_type\": \"byte\", \"position\": {\"start_line\": 749, \"end_line\": 771, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] toIntegerBytes(final BigInteger bigInt) {\\n        int bitlen = bigInt.bitLength();\\n        // round bitlen\\n        bitlen = ((bitlen + 7) >> 3) << 3;\\n        final byte[] bigBytes = bigInt.toByteArray();\\n\\n        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\\n            return bigBytes;\\n        }\\n        // set up params for copying everything but sign bit\\n        int startSrc = 0;\\n        int len = bigBytes.length;\\n\\n        // if bigInt is exactly byte-aligned, just skip signbit in copy\\n        if ((bigInt.bitLength() % 8) == 0) {\\n            startSrc = 1;\\n            len--;\\n        }\\n        final int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec\\n        final byte[] resizedBytes = new byte[bitlen / 8];\\n        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\\n        return resizedBytes;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bigInt\", \"type\": \"BigInteger\"}]}, {\"name\": \"isInAlphabet\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 781, \"end_line\": 783, \"start_column\": 15, \"end_column\": 5}, \"code\": \"boolean isInAlphabet(final byte octet) {\\n        return octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"octet\", \"type\": \"byte\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/Base64InputStream.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.binary;\\n\\nimport java.io.InputStream;\\n\\n/**\\n * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\\n * constructor.\\n * <p>\\n * The default behaviour of the Base64InputStream is to DECODE, whereas the default behaviour of the Base64OutputStream\\n * is to ENCODE, but this behaviour can be overridden by using a different constructor.\\n * </p>\\n * <p>\\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\\n * </p>\\n * <p>\\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\\n * </p>\\n *\\n * @version $Id: Base64InputStream.java 1634429 2014-10-27 01:08:36Z ggregory $\\n * @see <a href=\\\"http://www.ietf.org/rfc/rfc2045.txt\\\">RFC 2045</a>\\n * @since 1.4\\n */\\npublic class Base64InputStream extends BaseNCodecInputStream {\\n\\n    /**\\n     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\\n     *\\n     * @param in\\n     *            InputStream to wrap.\\n     */\\n    public Base64InputStream(final InputStream in) {\\n        this(in, false);\\n    }\\n\\n    /**\\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\\n     * provided InputStream.\\n     *\\n     * @param in\\n     *            InputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data read from us, false if we should decode.\\n     */\\n    public Base64InputStream(final InputStream in, final boolean doEncode) {\\n        super(in, new Base64(false), doEncode);\\n    }\\n\\n    /**\\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\\n     * provided InputStream.\\n     *\\n     * @param in\\n     *            InputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data read from us, false if we should decode.\\n     * @param lineLength\\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\\n     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode\\n     *            is false, lineLength is ignored.\\n     * @param lineSeparator\\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\\\r\\\\n).\\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\\n     */\\n    public Base64InputStream(final InputStream in, final boolean doEncode,\\n                             final int lineLength, final byte[] lineSeparator) {\\n        super(in, new Base64(lineLength, lineSeparator), doEncode);\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Base64InputStream\", \"position\": {\"start_line\": 43, \"end_line\": 88, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Base64InputStream extends BaseNCodecInputStream {\\n\\n    /**\\n     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\\n     *\\n     * @param in\\n     *            InputStream to wrap.\\n     */\\n    public Base64InputStream(final InputStream in) {\\n        this(in, false);\\n    }\\n\\n    /**\\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\\n     * provided InputStream.\\n     *\\n     * @param in\\n     *            InputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data read from us, false if we should decode.\\n     */\\n    public Base64InputStream(final InputStream in, final boolean doEncode) {\\n        super(in, new Base64(false), doEncode);\\n    }\\n\\n    /**\\n     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\\n     * provided InputStream.\\n     *\\n     * @param in\\n     *            InputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data read from us, false if we should decode.\\n     * @param lineLength\\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\\n     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode\\n     *            is false, lineLength is ignored.\\n     * @param lineSeparator\\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\\\r\\\\n).\\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\\n     */\\n    public Base64InputStream(final InputStream in, final boolean doEncode,\\n                             final int lineLength, final byte[] lineSeparator) {\\n        super(in, new Base64(lineLength, lineSeparator), doEncode);\\n    }\\n}\", \"summary\": \"\", \"methods\": []}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/Base64OutputStream.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.binary;\\n\\nimport java.io.OutputStream;\\n\\n/**\\n * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\\n * constructor.\\n * <p>\\n * The default behaviour of the Base64OutputStream is to ENCODE, whereas the default behaviour of the Base64InputStream\\n * is to DECODE. But this behaviour can be overridden by using a different constructor.\\n * </p>\\n * <p>\\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\\n * </p>\\n * <p>\\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\\n * </p>\\n * <p>\\n * <b>Note:</b> It is mandatory to close the stream after the last byte has been written to it, otherwise the\\n * final padding will be omitted and the resulting data will be incomplete/inconsistent.\\n * </p>\\n *\\n * @version $Id: Base64OutputStream.java 1635952 2014-11-01 14:19:04Z tn $\\n * @see <a href=\\\"http://www.ietf.org/rfc/rfc2045.txt\\\">RFC 2045</a>\\n * @since 1.4\\n */\\npublic class Base64OutputStream extends BaseNCodecOutputStream {\\n\\n    /**\\n     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\\n     *\\n     * @param out\\n     *            OutputStream to wrap.\\n     */\\n    public Base64OutputStream(final OutputStream out) {\\n        this(out, true);\\n    }\\n\\n    /**\\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\\n     * original provided OutputStream.\\n     *\\n     * @param out\\n     *            OutputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data written to us, false if we should decode.\\n     */\\n    public Base64OutputStream(final OutputStream out, final boolean doEncode) {\\n        super(out,new Base64(false), doEncode);\\n    }\\n\\n    /**\\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\\n     * original provided OutputStream.\\n     *\\n     * @param out\\n     *            OutputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data written to us, false if we should decode.\\n     * @param lineLength\\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\\n     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode\\n     *            is false, lineLength is ignored.\\n     * @param lineSeparator\\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\\\r\\\\n).\\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\\n     */\\n    public Base64OutputStream(final OutputStream out, final boolean doEncode,\\n                              final int lineLength, final byte[] lineSeparator) {\\n        super(out, new Base64(lineLength, lineSeparator), doEncode);\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Base64OutputStream\", \"position\": {\"start_line\": 47, \"end_line\": 92, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Base64OutputStream extends BaseNCodecOutputStream {\\n\\n    /**\\n     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\\n     *\\n     * @param out\\n     *            OutputStream to wrap.\\n     */\\n    public Base64OutputStream(final OutputStream out) {\\n        this(out, true);\\n    }\\n\\n    /**\\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\\n     * original provided OutputStream.\\n     *\\n     * @param out\\n     *            OutputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data written to us, false if we should decode.\\n     */\\n    public Base64OutputStream(final OutputStream out, final boolean doEncode) {\\n        super(out,new Base64(false), doEncode);\\n    }\\n\\n    /**\\n     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\\n     * original provided OutputStream.\\n     *\\n     * @param out\\n     *            OutputStream to wrap.\\n     * @param doEncode\\n     *            true if we should encode all data written to us, false if we should decode.\\n     * @param lineLength\\n     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\\n     *            nearest multiple of 4). If lineLength &lt;= 0, the encoded data is not divided into lines. If doEncode\\n     *            is false, lineLength is ignored.\\n     * @param lineSeparator\\n     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\\\r\\\\n).\\n     *            If lineLength &lt;= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\\n     */\\n    public Base64OutputStream(final OutputStream out, final boolean doEncode,\\n                              final int lineLength, final byte[] lineSeparator) {\\n        super(out, new Base64(lineLength, lineSeparator), doEncode);\\n    }\\n}\", \"summary\": \"\", \"methods\": []}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.binary;\\n\\nimport java.util.Arrays;\\n\\nimport org.apache.commons.codec.BinaryDecoder;\\nimport org.apache.commons.codec.BinaryEncoder;\\nimport org.apache.commons.codec.DecoderException;\\nimport org.apache.commons.codec.EncoderException;\\n\\n/**\\n * Abstract superclass for Base-N encoders and decoders.\\n *\\n * <p>\\n * This class is thread-safe.\\n * </p>\\n *\\n * @version $Id: BaseNCodec.java 1811344 2017-10-06 15:19:57Z ggregory $\\n */\\npublic abstract class BaseNCodec implements BinaryEncoder, BinaryDecoder {\\n\\n    /**\\n     * Holds thread context so classes can be thread-safe.\\n     *\\n     * This class is not itself thread-safe; each thread must allocate its own copy.\\n     *\\n     * @since 1.7\\n     */\\n    static class Context {\\n\\n        /**\\n         * Place holder for the bytes we're dealing with for our based logic.\\n         * Bitwise operations store and extract the encoding or decoding from this variable.\\n         */\\n        int ibitWorkArea;\\n\\n        /**\\n         * Place holder for the bytes we're dealing with for our based logic.\\n         * Bitwise operations store and extract the encoding or decoding from this variable.\\n         */\\n        long lbitWorkArea;\\n\\n        /**\\n         * Buffer for streaming.\\n         */\\n        byte[] buffer;\\n\\n        /**\\n         * Position where next character should be written in the buffer.\\n         */\\n        int pos;\\n\\n        /**\\n         * Position where next character should be read from the buffer.\\n         */\\n        int readPos;\\n\\n        /**\\n         * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,\\n         * and must be thrown away.\\n         */\\n        boolean eof;\\n\\n        /**\\n         * Variable tracks how many characters have been written to the current line. Only used when encoding. We use\\n         * it to make sure each encoded line never goes beyond lineLength (if lineLength &gt; 0).\\n         */\\n        int currentLinePos;\\n\\n        /**\\n         * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding. This\\n         * variable helps track that.\\n         */\\n        int modulus;\\n\\n        Context() {\\n        }\\n\\n        /**\\n         * Returns a String useful for debugging (especially within a debugger.)\\n         *\\n         * @return a String useful for debugging.\\n         */\\n        @SuppressWarnings(\\\"boxing\\\") // OK to ignore boxing here\\n        @Override\\n        public String toString() {\\n            return String.format(\\\"%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, \\\" +\\n                    \\\"modulus=%s, pos=%s, readPos=%s]\\\", this.getClass().getSimpleName(), Arrays.toString(buffer),\\n                    currentLinePos, eof, ibitWorkArea, lbitWorkArea, modulus, pos, readPos);\\n        }\\n    }\\n\\n    /**\\n     * EOF\\n     *\\n     * @since 1.7\\n     */\\n    static final int EOF = -1;\\n\\n    /**\\n     *  MIME chunk size per RFC 2045 section 6.8.\\n     *\\n     * <p>\\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\\n     * equal signs.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://www.ietf.org/rfc/rfc2045.txt\\\">RFC 2045 section 6.8</a>\\n     */\\n    public static final int MIME_CHUNK_SIZE = 76;\\n\\n    /**\\n     * PEM chunk size per RFC 1421 section 4.3.2.4.\\n     *\\n     * <p>\\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\\n     * equal signs.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://tools.ietf.org/html/rfc1421\\\">RFC 1421 section 4.3.2.4</a>\\n     */\\n    public static final int PEM_CHUNK_SIZE = 64;\\n\\n    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\\n\\n    /**\\n     * Defines the default buffer size - currently {@value}\\n     * - must be large enough for at least one encoded block+separator\\n     */\\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\\n\\n    /** Mask used to extract 8 bits, used in decoding bytes */\\n    protected static final int MASK_8BITS = 0xff;\\n\\n    /**\\n     * Byte used to pad output.\\n     */\\n    protected static final byte PAD_DEFAULT = '='; // Allow static access to default\\n\\n    /**\\n     * @deprecated Use {@link #pad}. Will be removed in 2.0.\\n     */\\n    @Deprecated\\n    protected final byte PAD = PAD_DEFAULT; // instance variable just in case it needs to vary later\\n\\n    protected final byte pad; // instance variable just in case it needs to vary later\\n\\n    /** Number of bytes in each full block of unencoded data, e.g. 4 for Base64 and 5 for Base32 */\\n    private final int unencodedBlockSize;\\n\\n    /** Number of bytes in each full block of encoded data, e.g. 3 for Base64 and 8 for Base32 */\\n    private final int encodedBlockSize;\\n\\n    /**\\n     * Chunksize for encoding. Not used when decoding.\\n     * A value of zero or less implies no chunking of the encoded data.\\n     * Rounded down to nearest multiple of encodedBlockSize.\\n     */\\n    protected final int lineLength;\\n\\n    /**\\n     * Size of chunk separator. Not used unless {@link #lineLength} &gt; 0.\\n     */\\n    private final int chunkSeparatorLength;\\n\\n    /**\\n     * Note <code>lineLength</code> is rounded down to the nearest multiple of {@link #encodedBlockSize}\\n     * If <code>chunkSeparatorLength</code> is zero, then chunking is disabled.\\n     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)\\n     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)\\n     * @param lineLength if &gt; 0, use chunking with a length <code>lineLength</code>\\n     * @param chunkSeparatorLength the chunk separator length, if relevant\\n     */\\n    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize,\\n                         final int lineLength, final int chunkSeparatorLength) {\\n        this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, PAD_DEFAULT);\\n    }\\n\\n    /**\\n     * Note <code>lineLength</code> is rounded down to the nearest multiple of {@link #encodedBlockSize}\\n     * If <code>chunkSeparatorLength</code> is zero, then chunking is disabled.\\n     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)\\n     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)\\n     * @param lineLength if &gt; 0, use chunking with a length <code>lineLength</code>\\n     * @param chunkSeparatorLength the chunk separator length, if relevant\\n     * @param pad byte used as padding byte.\\n     */\\n    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize,\\n                         final int lineLength, final int chunkSeparatorLength, final byte pad) {\\n        this.unencodedBlockSize = unencodedBlockSize;\\n        this.encodedBlockSize = encodedBlockSize;\\n        final boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;\\n        this.lineLength = useChunking ? (lineLength / encodedBlockSize) * encodedBlockSize : 0;\\n        this.chunkSeparatorLength = chunkSeparatorLength;\\n\\n        this.pad = pad;\\n    }\\n\\n    /**\\n     * Returns true if this object has buffered data for reading.\\n     *\\n     * @param context the context to be used\\n     * @return true if there is data still available for reading.\\n     */\\n    boolean hasData(final Context context) {  // package protected for access from I/O streams\\n        return context.buffer != null;\\n    }\\n\\n    /**\\n     * Returns the amount of buffered data available for reading.\\n     *\\n     * @param context the context to be used\\n     * @return The amount of buffered data available for reading.\\n     */\\n    int available(final Context context) {  // package protected for access from I/O streams\\n        return context.buffer != null ? context.pos - context.readPos : 0;\\n    }\\n\\n    /**\\n     * Get the default buffer size. Can be overridden.\\n     *\\n     * @return {@link #DEFAULT_BUFFER_SIZE}\\n     */\\n    protected int getDefaultBufferSize() {\\n        return DEFAULT_BUFFER_SIZE;\\n    }\\n\\n    /**\\n     * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.\\n     * @param context the context to be used\\n     */\\n    private byte[] resizeBuffer(final Context context) {\\n        if (context.buffer == null) {\\n            context.buffer = new byte[getDefaultBufferSize()];\\n            context.pos = 0;\\n            context.readPos = 0;\\n        } else {\\n            final byte[] b = new byte[context.buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\\n            System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);\\n            context.buffer = b;\\n        }\\n        return context.buffer;\\n    }\\n\\n    /**\\n     * Ensure that the buffer has room for <code>size</code> bytes\\n     *\\n     * @param size minimum spare space required\\n     * @param context the context to be used\\n     * @return the buffer\\n     */\\n    protected byte[] ensureBufferSize(final int size, final Context context){\\n        if ((context.buffer == null) || (context.buffer.length < context.pos + size)){\\n            return resizeBuffer(context);\\n        }\\n        return context.buffer;\\n    }\\n\\n    /**\\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\\n     * bytes. Returns how many bytes were actually extracted.\\n     * <p>\\n     * Package protected for access from I/O streams.\\n     *\\n     * @param b\\n     *            byte[] array to extract the buffered data into.\\n     * @param bPos\\n     *            position in byte[] array to start extraction at.\\n     * @param bAvail\\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\\n     * @param context\\n     *            the context to be used\\n     * @return The number of bytes successfully extracted into the provided byte[] array.\\n     */\\n    int readResults(final byte[] b, final int bPos, final int bAvail, final Context context) {\\n        if (context.buffer != null) {\\n            final int len = Math.min(available(context), bAvail);\\n            System.arraycopy(context.buffer, context.readPos, b, bPos, len);\\n            context.readPos += len;\\n            if (context.readPos >= context.pos) {\\n                context.buffer = null; // so hasData() will return false, and this method can return -1\\n            }\\n            return len;\\n        }\\n        return context.eof ? EOF : 0;\\n    }\\n\\n    /**\\n     * Checks if a byte value is whitespace or not.\\n     * Whitespace is taken to mean: space, tab, CR, LF\\n     * @param byteToCheck\\n     *            the byte to check\\n     * @return true if byte is whitespace, false otherwise\\n     */\\n    protected static boolean isWhiteSpace(final byte byteToCheck) {\\n        switch (byteToCheck) {\\n            case ' ' :\\n            case '\\\\n' :\\n            case '\\\\r' :\\n            case '\\\\t' :\\n                return true;\\n            default :\\n                return false;\\n        }\\n    }\\n\\n    /**\\n     * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of\\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\\n     *\\n     * @param obj\\n     *            Object to encode\\n     * @return An object (of type byte[]) containing the Base-N encoded data which corresponds to the byte[] supplied.\\n     * @throws EncoderException\\n     *             if the parameter supplied is not of type byte[]\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof byte[])) {\\n            throw new EncoderException(\\\"Parameter supplied to Base-N encode is not a byte[]\\\");\\n        }\\n        return encode((byte[]) obj);\\n    }\\n\\n    /**\\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.\\n     * Uses UTF8 encoding.\\n     *\\n     * @param pArray\\n     *            a byte array containing binary data\\n     * @return A String containing only Base-N character data\\n     */\\n    public String encodeToString(final byte[] pArray) {\\n        return StringUtils.newStringUtf8(encode(pArray));\\n    }\\n\\n    /**\\n     * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.\\n     * Uses UTF8 encoding.\\n     *\\n     * @param pArray a byte array containing binary data\\n     * @return String containing only character data in the appropriate alphabet.\\n     * @since 1.5\\n     * This is a duplicate of {@link #encodeToString(byte[])}; it was merged during refactoring.\\n    */\\n    public String encodeAsString(final byte[] pArray){\\n        return StringUtils.newStringUtf8(encode(pArray));\\n    }\\n\\n    /**\\n     * Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of\\n     * the Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\\n     *\\n     * @param obj\\n     *            Object to decode\\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String\\n     *         supplied.\\n     * @throws DecoderException\\n     *             if the parameter supplied is not of type byte[]\\n     */\\n    @Override\\n    public Object decode(final Object obj) throws DecoderException {\\n        if (obj instanceof byte[]) {\\n            return decode((byte[]) obj);\\n        } else if (obj instanceof String) {\\n            return decode((String) obj);\\n        } else {\\n            throw new DecoderException(\\\"Parameter supplied to Base-N decode is not a byte[] or a String\\\");\\n        }\\n    }\\n\\n    /**\\n     * Decodes a String containing characters in the Base-N alphabet.\\n     *\\n     * @param pArray\\n     *            A String containing Base-N character data\\n     * @return a byte array containing binary data\\n     */\\n    public byte[] decode(final String pArray) {\\n        return decode(StringUtils.getBytesUtf8(pArray));\\n    }\\n\\n    /**\\n     * Decodes a byte[] containing characters in the Base-N alphabet.\\n     *\\n     * @param pArray\\n     *            A byte array containing Base-N character data\\n     * @return a byte array containing binary data\\n     */\\n    @Override\\n    public byte[] decode(final byte[] pArray) {\\n        if (pArray == null || pArray.length == 0) {\\n            return pArray;\\n        }\\n        final Context context = new Context();\\n        decode(pArray, 0, pArray.length, context);\\n        decode(pArray, 0, EOF, context); // Notify decoder of EOF.\\n        final byte[] result = new byte[context.pos];\\n        readResults(result, 0, result.length, context);\\n        return result;\\n    }\\n\\n    /**\\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the alphabet.\\n     *\\n     * @param pArray\\n     *            a byte array containing binary data\\n     * @return A byte array containing only the base N alphabetic character data\\n     */\\n    @Override\\n    public byte[] encode(final byte[] pArray) {\\n        if (pArray == null || pArray.length == 0) {\\n            return pArray;\\n        }\\n        return encode(pArray, 0, pArray.length);\\n    }\\n\\n    /**\\n     * Encodes a byte[] containing binary data, into a byte[] containing\\n     * characters in the alphabet.\\n     *\\n     * @param pArray\\n     *            a byte array containing binary data\\n     * @param offset\\n     *            initial offset of the subarray.\\n     * @param length\\n     *            length of the subarray.\\n     * @return A byte array containing only the base N alphabetic character data\\n     * @since 1.11\\n     */\\n    public byte[] encode(final byte[] pArray, final int offset, final int length) {\\n        if (pArray == null || pArray.length == 0) {\\n            return pArray;\\n        }\\n        final Context context = new Context();\\n        encode(pArray, offset, length, context);\\n        encode(pArray, offset, EOF, context); // Notify encoder of EOF.\\n        final byte[] buf = new byte[context.pos - context.readPos];\\n        readResults(buf, 0, buf.length, context);\\n        return buf;\\n    }\\n\\n    // package protected for access from I/O streams\\n    abstract void encode(byte[] pArray, int i, int length, Context context);\\n\\n    // package protected for access from I/O streams\\n    abstract void decode(byte[] pArray, int i, int length, Context context);\\n\\n    /**\\n     * Returns whether or not the <code>octet</code> is in the current alphabet.\\n     * Does not allow whitespace or pad.\\n     *\\n     * @param value The value to test\\n     *\\n     * @return <code>true</code> if the value is defined in the current alphabet, <code>false</code> otherwise.\\n     */\\n    protected abstract boolean isInAlphabet(byte value);\\n\\n    /**\\n     * Tests a given byte array to see if it contains only valid characters within the alphabet.\\n     * The method optionally treats whitespace and pad as valid.\\n     *\\n     * @param arrayOctet byte array to test\\n     * @param allowWSPad if <code>true</code>, then whitespace and PAD are also allowed\\n     *\\n     * @return <code>true</code> if all bytes are valid characters in the alphabet or if the byte array is empty;\\n     *         <code>false</code>, otherwise\\n     */\\n    public boolean isInAlphabet(final byte[] arrayOctet, final boolean allowWSPad) {\\n        for (final byte octet : arrayOctet) {\\n            if (!isInAlphabet(octet) &&\\n                    (!allowWSPad || (octet != pad) && !isWhiteSpace(octet))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * Tests a given String to see if it contains only valid characters within the alphabet.\\n     * The method treats whitespace and PAD as valid.\\n     *\\n     * @param basen String to test\\n     * @return <code>true</code> if all characters in the String are valid characters in the alphabet or if\\n     *         the String is empty; <code>false</code>, otherwise\\n     * @see #isInAlphabet(byte[], boolean)\\n     */\\n    public boolean isInAlphabet(final String basen) {\\n        return isInAlphabet(StringUtils.getBytesUtf8(basen), true);\\n    }\\n\\n    /**\\n     * Tests a given byte array to see if it contains any characters within the alphabet or PAD.\\n     *\\n     * Intended for use in checking line-ending arrays\\n     *\\n     * @param arrayOctet\\n     *            byte array to test\\n     * @return <code>true</code> if any byte is a valid character in the alphabet or PAD; <code>false</code> otherwise\\n     */\\n    protected boolean containsAlphabetOrPad(final byte[] arrayOctet) {\\n        if (arrayOctet == null) {\\n            return false;\\n        }\\n        for (final byte element : arrayOctet) {\\n            if (pad == element || isInAlphabet(element)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * Calculates the amount of space needed to encode the supplied array.\\n     *\\n     * @param pArray byte[] array which will later be encoded\\n     *\\n     * @return amount of space needed to encoded the supplied array.\\n     * Returns a long since a max-len array will require &gt; Integer.MAX_VALUE\\n     */\\n    public long getEncodedLength(final byte[] pArray) {\\n        // Calculate non-chunked size - rounded up to allow for padding\\n        // cast to long is needed to avoid possibility of overflow\\n        long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * (long) encodedBlockSize;\\n        if (lineLength > 0) { // We're using chunking\\n            // Round up to nearest multiple\\n            len += ((len + lineLength-1) / lineLength) * chunkSeparatorLength;\\n        }\\n        return len;\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"BaseNCodec\", \"position\": {\"start_line\": 36, \"end_line\": 547, \"start_column\": 17, \"end_column\": 1}, \"code\": \"class BaseNCodec implements BinaryEncoder, BinaryDecoder {\\n\\n    /**\\n     * Holds thread context so classes can be thread-safe.\\n     *\\n     * This class is not itself thread-safe; each thread must allocate its own copy.\\n     *\\n     * @since 1.7\\n     */\\n    static class Context {\\n\\n        /**\\n         * Place holder for the bytes we're dealing with for our based logic.\\n         * Bitwise operations store and extract the encoding or decoding from this variable.\\n         */\\n        int ibitWorkArea;\\n\\n        /**\\n         * Place holder for the bytes we're dealing with for our based logic.\\n         * Bitwise operations store and extract the encoding or decoding from this variable.\\n         */\\n        long lbitWorkArea;\\n\\n        /**\\n         * Buffer for streaming.\\n         */\\n        byte[] buffer;\\n\\n        /**\\n         * Position where next character should be written in the buffer.\\n         */\\n        int pos;\\n\\n        /**\\n         * Position where next character should be read from the buffer.\\n         */\\n        int readPos;\\n\\n        /**\\n         * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,\\n         * and must be thrown away.\\n         */\\n        boolean eof;\\n\\n        /**\\n         * Variable tracks how many characters have been written to the current line. Only used when encoding. We use\\n         * it to make sure each encoded line never goes beyond lineLength (if lineLength &gt; 0).\\n         */\\n        int currentLinePos;\\n\\n        /**\\n         * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding. This\\n         * variable helps track that.\\n         */\\n        int modulus;\\n\\n        Context() {\\n        }\\n\\n        /**\\n         * Returns a String useful for debugging (especially within a debugger.)\\n         *\\n         * @return a String useful for debugging.\\n         */\\n        @SuppressWarnings(\\\"boxing\\\") // OK to ignore boxing here\\n        @Override\\n        public String toString() {\\n            return String.format(\\\"%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, \\\" +\\n                    \\\"modulus=%s, pos=%s, readPos=%s]\\\", this.getClass().getSimpleName(), Arrays.toString(buffer),\\n                    currentLinePos, eof, ibitWorkArea, lbitWorkArea, modulus, pos, readPos);\\n        }\\n    }\\n\\n    /**\\n     * EOF\\n     *\\n     * @since 1.7\\n     */\\n    static final int EOF = -1;\\n\\n    /**\\n     *  MIME chunk size per RFC 2045 section 6.8.\\n     *\\n     * <p>\\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\\n     * equal signs.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://www.ietf.org/rfc/rfc2045.txt\\\">RFC 2045 section 6.8</a>\\n     */\\n    public static final int MIME_CHUNK_SIZE = 76;\\n\\n    /**\\n     * PEM chunk size per RFC 1421 section 4.3.2.4.\\n     *\\n     * <p>\\n     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\\n     * equal signs.\\n     * </p>\\n     *\\n     * @see <a href=\\\"http://tools.ietf.org/html/rfc1421\\\">RFC 1421 section 4.3.2.4</a>\\n     */\\n    public static final int PEM_CHUNK_SIZE = 64;\\n\\n    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\\n\\n    /**\\n     * Defines the default buffer size - currently {@value}\\n     * - must be large enough for at least one encoded block+separator\\n     */\\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\\n\\n    /** Mask used to extract 8 bits, used in decoding bytes */\\n    protected static final int MASK_8BITS = 0xff;\\n\\n    /**\\n     * Byte used to pad output.\\n     */\\n    protected static final byte PAD_DEFAULT = '='; // Allow static access to default\\n\\n    /**\\n     * @deprecated Use {@link #pad}. Will be removed in 2.0.\\n     */\\n    @Deprecated\\n    protected final byte PAD = PAD_DEFAULT; // instance variable just in case it needs to vary later\\n\\n    protected final byte pad; // instance variable just in case it needs to vary later\\n\\n    /** Number of bytes in each full block of unencoded data, e.g. 4 for Base64 and 5 for Base32 */\\n    private final int unencodedBlockSize;\\n\\n    /** Number of bytes in each full block of encoded data, e.g. 3 for Base64 and 8 for Base32 */\\n    private final int encodedBlockSize;\\n\\n    /**\\n     * Chunksize for encoding. Not used when decoding.\\n     * A value of zero or less implies no chunking of the encoded data.\\n     * Rounded down to nearest multiple of encodedBlockSize.\\n     */\\n    protected final int lineLength;\\n\\n    /**\\n     * Size of chunk separator. Not used unless {@link #lineLength} &gt; 0.\\n     */\\n    private final int chunkSeparatorLength;\\n\\n    /**\\n     * Note <code>lineLength</code> is rounded down to the nearest multiple of {@link #encodedBlockSize}\\n     * If <code>chunkSeparatorLength</code> is zero, then chunking is disabled.\\n     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)\\n     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)\\n     * @param lineLength if &gt; 0, use chunking with a length <code>lineLength</code>\\n     * @param chunkSeparatorLength the chunk separator length, if relevant\\n     */\\n    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize,\\n                         final int lineLength, final int chunkSeparatorLength) {\\n        this(unencodedBlockSize, encodedBlockSize, lineLength, chunkSeparatorLength, PAD_DEFAULT);\\n    }\\n\\n    /**\\n     * Note <code>lineLength</code> is rounded down to the nearest multiple of {@link #encodedBlockSize}\\n     * If <code>chunkSeparatorLength</code> is zero, then chunking is disabled.\\n     * @param unencodedBlockSize the size of an unencoded block (e.g. Base64 = 3)\\n     * @param encodedBlockSize the size of an encoded block (e.g. Base64 = 4)\\n     * @param lineLength if &gt; 0, use chunking with a length <code>lineLength</code>\\n     * @param chunkSeparatorLength the chunk separator length, if relevant\\n     * @param pad byte used as padding byte.\\n     */\\n    protected BaseNCodec(final int unencodedBlockSize, final int encodedBlockSize,\\n                         final int lineLength, final int chunkSeparatorLength, final byte pad) {\\n        this.unencodedBlockSize = unencodedBlockSize;\\n        this.encodedBlockSize = encodedBlockSize;\\n        final boolean useChunking = lineLength > 0 && chunkSeparatorLength > 0;\\n        this.lineLength = useChunking ? (lineLength / encodedBlockSize) * encodedBlockSize : 0;\\n        this.chunkSeparatorLength = chunkSeparatorLength;\\n\\n        this.pad = pad;\\n    }\\n\\n    /**\\n     * Returns true if this object has buffered data for reading.\\n     *\\n     * @param context the context to be used\\n     * @return true if there is data still available for reading.\\n     */\\n    boolean hasData(final Context context) {  // package protected for access from I/O streams\\n        return context.buffer != null;\\n    }\\n\\n    /**\\n     * Returns the amount of buffered data available for reading.\\n     *\\n     * @param context the context to be used\\n     * @return The amount of buffered data available for reading.\\n     */\\n    int available(final Context context) {  // package protected for access from I/O streams\\n        return context.buffer != null ? context.pos - context.readPos : 0;\\n    }\\n\\n    /**\\n     * Get the default buffer size. Can be overridden.\\n     *\\n     * @return {@link #DEFAULT_BUFFER_SIZE}\\n     */\\n    protected int getDefaultBufferSize() {\\n        return DEFAULT_BUFFER_SIZE;\\n    }\\n\\n    /**\\n     * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.\\n     * @param context the context to be used\\n     */\\n    private byte[] resizeBuffer(final Context context) {\\n        if (context.buffer == null) {\\n            context.buffer = new byte[getDefaultBufferSize()];\\n            context.pos = 0;\\n            context.readPos = 0;\\n        } else {\\n            final byte[] b = new byte[context.buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\\n            System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);\\n            context.buffer = b;\\n        }\\n        return context.buffer;\\n    }\\n\\n    /**\\n     * Ensure that the buffer has room for <code>size</code> bytes\\n     *\\n     * @param size minimum spare space required\\n     * @param context the context to be used\\n     * @return the buffer\\n     */\\n    protected byte[] ensureBufferSize(final int size, final Context context){\\n        if ((context.buffer == null) || (context.buffer.length < context.pos + size)){\\n            return resizeBuffer(context);\\n        }\\n        return context.buffer;\\n    }\\n\\n    /**\\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\\n     * bytes. Returns how many bytes were actually extracted.\\n     * <p>\\n     * Package protected for access from I/O streams.\\n     *\\n     * @param b\\n     *            byte[] array to extract the buffered data into.\\n     * @param bPos\\n     *            position in byte[] array to start extraction at.\\n     * @param bAvail\\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\\n     * @param context\\n     *            the context to be used\\n     * @return The number of bytes successfully extracted into the provided byte[] array.\\n     */\\n    int readResults(final byte[] b, final int bPos, final int bAvail, final Context context) {\\n        if (context.buffer != null) {\\n            final int len = Math.min(available(context), bAvail);\\n            System.arraycopy(context.buffer, context.readPos, b, bPos, len);\\n            context.readPos += len;\\n            if (context.readPos >= context.pos) {\\n                context.buffer = null; // so hasData() will return false, and this method can return -1\\n            }\\n            return len;\\n        }\\n        return context.eof ? EOF : 0;\\n    }\\n\\n    /**\\n     * Checks if a byte value is whitespace or not.\\n     * Whitespace is taken to mean: space, tab, CR, LF\\n     * @param byteToCheck\\n     *            the byte to check\\n     * @return true if byte is whitespace, false otherwise\\n     */\\n    protected static boolean isWhiteSpace(final byte byteToCheck) {\\n        switch (byteToCheck) {\\n            case ' ' :\\n            case '\\\\n' :\\n            case '\\\\r' :\\n            case '\\\\t' :\\n                return true;\\n            default :\\n                return false;\\n        }\\n    }\\n\\n    /**\\n     * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of\\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\\n     *\\n     * @param obj\\n     *            Object to encode\\n     * @return An object (of type byte[]) containing the Base-N encoded data which corresponds to the byte[] supplied.\\n     * @throws EncoderException\\n     *             if the parameter supplied is not of type byte[]\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof byte[])) {\\n            throw new EncoderException(\\\"Parameter supplied to Base-N encode is not a byte[]\\\");\\n        }\\n        return encode((byte[]) obj);\\n    }\\n\\n    /**\\n     * Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.\\n     * Uses UTF8 encoding.\\n     *\\n     * @param pArray\\n     *            a byte array containing binary data\\n     * @return A String containing only Base-N character data\\n     */\\n    public String encodeToString(final byte[] pArray) {\\n        return StringUtils.newStringUtf8(encode(pArray));\\n    }\\n\\n    /**\\n     * Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.\\n     * Uses UTF8 encoding.\\n     *\\n     * @param pArray a byte array containing binary data\\n     * @return String containing only character data in the appropriate alphabet.\\n     * @since 1.5\\n     * This is a duplicate of {@link #encodeToString(byte[])}; it was merged during refactoring.\\n    */\\n    public String encodeAsString(final byte[] pArray){\\n        return StringUtils.newStringUtf8(encode(pArray));\\n    }\\n\\n    /**\\n     * Decodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of\\n     * the Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\\n     *\\n     * @param obj\\n     *            Object to decode\\n     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String\\n     *         supplied.\\n     * @throws DecoderException\\n     *             if the parameter supplied is not of type byte[]\\n     */\\n    @Override\\n    public Object decode(final Object obj) throws DecoderException {\\n        if (obj instanceof byte[]) {\\n            return decode((byte[]) obj);\\n        } else if (obj instanceof String) {\\n            return decode((String) obj);\\n        } else {\\n            throw new DecoderException(\\\"Parameter supplied to Base-N decode is not a byte[] or a String\\\");\\n        }\\n    }\\n\\n    /**\\n     * Decodes a String containing characters in the Base-N alphabet.\\n     *\\n     * @param pArray\\n     *            A String containing Base-N character data\\n     * @return a byte array containing binary data\\n     */\\n    public byte[] decode(final String pArray) {\\n        return decode(StringUtils.getBytesUtf8(pArray));\\n    }\\n\\n    /**\\n     * Decodes a byte[] containing characters in the Base-N alphabet.\\n     *\\n     * @param pArray\\n     *            A byte array containing Base-N character data\\n     * @return a byte array containing binary data\\n     */\\n    @Override\\n    public byte[] decode(final byte[] pArray) {\\n        if (pArray == null || pArray.length == 0) {\\n            return pArray;\\n        }\\n        final Context context = new Context();\\n        decode(pArray, 0, pArray.length, context);\\n        decode(pArray, 0, EOF, context); // Notify decoder of EOF.\\n        final byte[] result = new byte[context.pos];\\n        readResults(result, 0, result.length, context);\\n        return result;\\n    }\\n\\n    /**\\n     * Encodes a byte[] containing binary data, into a byte[] containing characters in the alphabet.\\n     *\\n     * @param pArray\\n     *            a byte array containing binary data\\n     * @return A byte array containing only the base N alphabetic character data\\n     */\\n    @Override\\n    public byte[] encode(final byte[] pArray) {\\n        if (pArray == null || pArray.length == 0) {\\n            return pArray;\\n        }\\n        return encode(pArray, 0, pArray.length);\\n    }\\n\\n    /**\\n     * Encodes a byte[] containing binary data, into a byte[] containing\\n     * characters in the alphabet.\\n     *\\n     * @param pArray\\n     *            a byte array containing binary data\\n     * @param offset\\n     *            initial offset of the subarray.\\n     * @param length\\n     *            length of the subarray.\\n     * @return A byte array containing only the base N alphabetic character data\\n     * @since 1.11\\n     */\\n    public byte[] encode(final byte[] pArray, final int offset, final int length) {\\n        if (pArray == null || pArray.length == 0) {\\n            return pArray;\\n        }\\n        final Context context = new Context();\\n        encode(pArray, offset, length, context);\\n        encode(pArray, offset, EOF, context); // Notify encoder of EOF.\\n        final byte[] buf = new byte[context.pos - context.readPos];\\n        readResults(buf, 0, buf.length, context);\\n        return buf;\\n    }\\n\\n    // package protected for access from I/O streams\\n    abstract void encode(byte[] pArray, int i, int length, Context context);\\n\\n    // package protected for access from I/O streams\\n    abstract void decode(byte[] pArray, int i, int length, Context context);\\n\\n    /**\\n     * Returns whether or not the <code>octet</code> is in the current alphabet.\\n     * Does not allow whitespace or pad.\\n     *\\n     * @param value The value to test\\n     *\\n     * @return <code>true</code> if the value is defined in the current alphabet, <code>false</code> otherwise.\\n     */\\n    protected abstract boolean isInAlphabet(byte value);\\n\\n    /**\\n     * Tests a given byte array to see if it contains only valid characters within the alphabet.\\n     * The method optionally treats whitespace and pad as valid.\\n     *\\n     * @param arrayOctet byte array to test\\n     * @param allowWSPad if <code>true</code>, then whitespace and PAD are also allowed\\n     *\\n     * @return <code>true</code> if all bytes are valid characters in the alphabet or if the byte array is empty;\\n     *         <code>false</code>, otherwise\\n     */\\n    public boolean isInAlphabet(final byte[] arrayOctet, final boolean allowWSPad) {\\n        for (final byte octet : arrayOctet) {\\n            if (!isInAlphabet(octet) &&\\n                    (!allowWSPad || (octet != pad) && !isWhiteSpace(octet))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * Tests a given String to see if it contains only valid characters within the alphabet.\\n     * The method treats whitespace and PAD as valid.\\n     *\\n     * @param basen String to test\\n     * @return <code>true</code> if all characters in the String are valid characters in the alphabet or if\\n     *         the String is empty; <code>false</code>, otherwise\\n     * @see #isInAlphabet(byte[], boolean)\\n     */\\n    public boolean isInAlphabet(final String basen) {\\n        return isInAlphabet(StringUtils.getBytesUtf8(basen), true);\\n    }\\n\\n    /**\\n     * Tests a given byte array to see if it contains any characters within the alphabet or PAD.\\n     *\\n     * Intended for use in checking line-ending arrays\\n     *\\n     * @param arrayOctet\\n     *            byte array to test\\n     * @return <code>true</code> if any byte is a valid character in the alphabet or PAD; <code>false</code> otherwise\\n     */\\n    protected boolean containsAlphabetOrPad(final byte[] arrayOctet) {\\n        if (arrayOctet == null) {\\n            return false;\\n        }\\n        for (final byte element : arrayOctet) {\\n            if (pad == element || isInAlphabet(element)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * Calculates the amount of space needed to encode the supplied array.\\n     *\\n     * @param pArray byte[] array which will later be encoded\\n     *\\n     * @return amount of space needed to encoded the supplied array.\\n     * Returns a long since a max-len array will require &gt; Integer.MAX_VALUE\\n     */\\n    public long getEncodedLength(final byte[] pArray) {\\n        // Calculate non-chunked size - rounded up to allow for padding\\n        // cast to long is needed to avoid possibility of overflow\\n        long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * (long) encodedBlockSize;\\n        if (lineLength > 0) { // We're using chunking\\n            // Round up to nearest multiple\\n            len += ((len + lineLength-1) / lineLength) * chunkSeparatorLength;\\n        }\\n        return len;\\n    }\\n}\", \"summary\": \"\", \"methods\": []}, {\"parent_file\": null, \"name\": \"Context\", \"position\": {\"start_line\": 45, \"end_line\": 107, \"start_column\": 12, \"end_column\": 5}, \"code\": \"class Context {\\n\\n        /**\\n         * Place holder for the bytes we're dealing with for our based logic.\\n         * Bitwise operations store and extract the encoding or decoding from this variable.\\n         */\\n        int ibitWorkArea;\\n\\n        /**\\n         * Place holder for the bytes we're dealing with for our based logic.\\n         * Bitwise operations store and extract the encoding or decoding from this variable.\\n         */\\n        long lbitWorkArea;\\n\\n        /**\\n         * Buffer for streaming.\\n         */\\n        byte[] buffer;\\n\\n        /**\\n         * Position where next character should be written in the buffer.\\n         */\\n        int pos;\\n\\n        /**\\n         * Position where next character should be read from the buffer.\\n         */\\n        int readPos;\\n\\n        /**\\n         * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,\\n         * and must be thrown away.\\n         */\\n        boolean eof;\\n\\n        /**\\n         * Variable tracks how many characters have been written to the current line. Only used when encoding. We use\\n         * it to make sure each encoded line never goes beyond lineLength (if lineLength &gt; 0).\\n         */\\n        int currentLinePos;\\n\\n        /**\\n         * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding. This\\n         * variable helps track that.\\n         */\\n        int modulus;\\n\\n        Context() {\\n        }\\n\\n        /**\\n         * Returns a String useful for debugging (especially within a debugger.)\\n         *\\n         * @return a String useful for debugging.\\n         */\\n        @SuppressWarnings(\\\"boxing\\\") // OK to ignore boxing here\\n        @Override\\n        public String toString() {\\n            return String.format(\\\"%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, \\\" +\\n                    \\\"modulus=%s, pos=%s, readPos=%s]\\\", this.getClass().getSimpleName(), Arrays.toString(buffer),\\n                    currentLinePos, eof, ibitWorkArea, lbitWorkArea, modulus, pos, readPos);\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 102, \"end_line\": 106, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String toString() {\\n            return String.format(\\\"%s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, \\\" +\\n                    \\\"modulus=%s, pos=%s, readPos=%s]\\\", this.getClass().getSimpleName(), Arrays.toString(buffer),\\n                    currentLinePos, eof, ibitWorkArea, lbitWorkArea, modulus, pos, readPos);\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"hasData\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 221, \"end_line\": 223, \"start_column\": 5, \"end_column\": 5}, \"code\": \"boolean hasData(final Context context) {  // package protected for access from I/O streams\\n        return context.buffer != null;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"context\", \"type\": \"Context\"}]}, {\"name\": \"available\", \"return_type\": \"int\", \"position\": {\"start_line\": 231, \"end_line\": 233, \"start_column\": 5, \"end_column\": 5}, \"code\": \"int available(final Context context) {  // package protected for access from I/O streams\\n        return context.buffer != null ? context.pos - context.readPos : 0;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"context\", \"type\": \"Context\"}]}, {\"name\": \"getDefaultBufferSize\", \"return_type\": \"int\", \"position\": {\"start_line\": 240, \"end_line\": 242, \"start_column\": 15, \"end_column\": 5}, \"code\": \"int getDefaultBufferSize() {\\n        return DEFAULT_BUFFER_SIZE;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"resizeBuffer\", \"return_type\": \"byte\", \"position\": {\"start_line\": 248, \"end_line\": 259, \"start_column\": 13, \"end_column\": 5}, \"code\": \"byte[] resizeBuffer(final Context context) {\\n        if (context.buffer == null) {\\n            context.buffer = new byte[getDefaultBufferSize()];\\n            context.pos = 0;\\n            context.readPos = 0;\\n        } else {\\n            final byte[] b = new byte[context.buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\\n            System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);\\n            context.buffer = b;\\n        }\\n        return context.buffer;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"context\", \"type\": \"Context\"}]}, {\"name\": \"ensureBufferSize\", \"return_type\": \"byte\", \"position\": {\"start_line\": 268, \"end_line\": 273, \"start_column\": 15, \"end_column\": 5}, \"code\": \"byte[] ensureBufferSize(final int size, final Context context){\\n        if ((context.buffer == null) || (context.buffer.length < context.pos + size)){\\n            return resizeBuffer(context);\\n        }\\n        return context.buffer;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"size\", \"type\": \"int\"}, {\"name\": \"context\", \"type\": \"Context\"}]}, {\"name\": \"readResults\", \"return_type\": \"int\", \"position\": {\"start_line\": 291, \"end_line\": 302, \"start_column\": 5, \"end_column\": 5}, \"code\": \"int readResults(final byte[] b, final int bPos, final int bAvail, final Context context) {\\n        if (context.buffer != null) {\\n            final int len = Math.min(available(context), bAvail);\\n            System.arraycopy(context.buffer, context.readPos, b, bPos, len);\\n            context.readPos += len;\\n            if (context.readPos >= context.pos) {\\n                context.buffer = null; // so hasData() will return false, and this method can return -1\\n            }\\n            return len;\\n        }\\n        return context.eof ? EOF : 0;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"byte\"}, {\"name\": \"bPos\", \"type\": \"int\"}, {\"name\": \"bAvail\", \"type\": \"int\"}, {\"name\": \"context\", \"type\": \"Context\"}]}, {\"name\": \"isWhiteSpace\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 311, \"end_line\": 321, \"start_column\": 22, \"end_column\": 5}, \"code\": \"boolean isWhiteSpace(final byte byteToCheck) {\\n        switch (byteToCheck) {\\n            case ' ' :\\n            case '\\\\n' :\\n            case '\\\\r' :\\n            case '\\\\t' :\\n                return true;\\n            default :\\n                return false;\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"byteToCheck\", \"type\": \"byte\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 334, \"end_line\": 339, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof byte[])) {\\n            throw new EncoderException(\\\"Parameter supplied to Base-N encode is not a byte[]\\\");\\n        }\\n        return encode((byte[]) obj);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"encodeToString\", \"return_type\": \"String\", \"position\": {\"start_line\": 349, \"end_line\": 351, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encodeToString(final byte[] pArray) {\\n        return StringUtils.newStringUtf8(encode(pArray));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"pArray\", \"type\": \"byte\"}]}, {\"name\": \"encodeAsString\", \"return_type\": \"String\", \"position\": {\"start_line\": 362, \"end_line\": 364, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encodeAsString(final byte[] pArray){\\n        return StringUtils.newStringUtf8(encode(pArray));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"pArray\", \"type\": \"byte\"}]}, {\"name\": \"decode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 378, \"end_line\": 386, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object decode(final Object obj) throws DecoderException {\\n        if (obj instanceof byte[]) {\\n            return decode((byte[]) obj);\\n        } else if (obj instanceof String) {\\n            return decode((String) obj);\\n        } else {\\n            throw new DecoderException(\\\"Parameter supplied to Base-N decode is not a byte[] or a String\\\");\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"decode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 395, \"end_line\": 397, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] decode(final String pArray) {\\n        return decode(StringUtils.getBytesUtf8(pArray));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"pArray\", \"type\": \"String\"}]}, {\"name\": \"decode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 407, \"end_line\": 417, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] decode(final byte[] pArray) {\\n        if (pArray == null || pArray.length == 0) {\\n            return pArray;\\n        }\\n        final Context context = new Context();\\n        decode(pArray, 0, pArray.length, context);\\n        decode(pArray, 0, EOF, context); // Notify decoder of EOF.\\n        final byte[] result = new byte[context.pos];\\n        readResults(result, 0, result.length, context);\\n        return result;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"pArray\", \"type\": \"byte\"}]}, {\"name\": \"encode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 427, \"end_line\": 432, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] encode(final byte[] pArray) {\\n        if (pArray == null || pArray.length == 0) {\\n            return pArray;\\n        }\\n        return encode(pArray, 0, pArray.length);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"pArray\", \"type\": \"byte\"}]}, {\"name\": \"encode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 447, \"end_line\": 457, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] encode(final byte[] pArray, final int offset, final int length) {\\n        if (pArray == null || pArray.length == 0) {\\n            return pArray;\\n        }\\n        final Context context = new Context();\\n        encode(pArray, offset, length, context);\\n        encode(pArray, offset, EOF, context); // Notify encoder of EOF.\\n        final byte[] buf = new byte[context.pos - context.readPos];\\n        readResults(buf, 0, buf.length, context);\\n        return buf;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"pArray\", \"type\": \"byte\"}, {\"name\": \"offset\", \"type\": \"int\"}, {\"name\": \"length\", \"type\": \"int\"}]}, {\"name\": \"encode\", \"return_type\": \"void\", \"position\": {\"start_line\": 460, \"end_line\": 460, \"start_column\": 14, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"pArray\", \"type\": \"byte\"}, {\"name\": \"i\", \"type\": \"int\"}, {\"name\": \"length\", \"type\": \"int\"}, {\"name\": \"context\", \"type\": \"Context\"}]}, {\"name\": \"decode\", \"return_type\": \"void\", \"position\": {\"start_line\": 463, \"end_line\": 463, \"start_column\": 14, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"pArray\", \"type\": \"byte\"}, {\"name\": \"i\", \"type\": \"int\"}, {\"name\": \"length\", \"type\": \"int\"}, {\"name\": \"context\", \"type\": \"Context\"}]}, {\"name\": \"isInAlphabet\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 473, \"end_line\": 473, \"start_column\": 24, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"byte\"}]}, {\"name\": \"isInAlphabet\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 485, \"end_line\": 493, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isInAlphabet(final byte[] arrayOctet, final boolean allowWSPad) {\\n        for (final byte octet : arrayOctet) {\\n            if (!isInAlphabet(octet) &&\\n                    (!allowWSPad || (octet != pad) && !isWhiteSpace(octet))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"arrayOctet\", \"type\": \"byte\"}, {\"name\": \"allowWSPad\", \"type\": \"boolean\"}]}, {\"name\": \"isInAlphabet\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 504, \"end_line\": 506, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isInAlphabet(final String basen) {\\n        return isInAlphabet(StringUtils.getBytesUtf8(basen), true);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"basen\", \"type\": \"String\"}]}, {\"name\": \"containsAlphabetOrPad\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 517, \"end_line\": 527, \"start_column\": 15, \"end_column\": 5}, \"code\": \"boolean containsAlphabetOrPad(final byte[] arrayOctet) {\\n        if (arrayOctet == null) {\\n            return false;\\n        }\\n        for (final byte element : arrayOctet) {\\n            if (pad == element || isInAlphabet(element)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"arrayOctet\", \"type\": \"byte\"}]}, {\"name\": \"getEncodedLength\", \"return_type\": \"long\", \"position\": {\"start_line\": 537, \"end_line\": 546, \"start_column\": 12, \"end_column\": 5}, \"code\": \"long getEncodedLength(final byte[] pArray) {\\n        // Calculate non-chunked size - rounded up to allow for padding\\n        // cast to long is needed to avoid possibility of overflow\\n        long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * (long) encodedBlockSize;\\n        if (lineLength > 0) { // We're using chunking\\n            // Round up to nearest multiple\\n            len += ((len + lineLength-1) / lineLength) * chunkSeparatorLength;\\n        }\\n        return len;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"pArray\", \"type\": \"byte\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.binary;\\n\\nimport static org.apache.commons.codec.binary.BaseNCodec.EOF;\\n\\nimport java.io.FilterInputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\n\\nimport org.apache.commons.codec.binary.BaseNCodec.Context;\\n\\n/**\\n * Abstract superclass for Base-N input streams.\\n *\\n * @since 1.5\\n * @version $Id: BaseNCodecInputStream.java 1429868 2013-01-07 16:08:05Z ggregory $\\n */\\npublic class BaseNCodecInputStream extends FilterInputStream {\\n\\n    private final BaseNCodec baseNCodec;\\n\\n    private final boolean doEncode;\\n\\n    private final byte[] singleByte = new byte[1];\\n\\n    private final Context context = new Context();\\n\\n    protected BaseNCodecInputStream(final InputStream in, final BaseNCodec baseNCodec, final boolean doEncode) {\\n        super(in);\\n        this.doEncode = doEncode;\\n        this.baseNCodec = baseNCodec;\\n    }\\n\\n    /**\\n     * {@inheritDoc}\\n     *\\n     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,\\n     * <code>1</code> otherwise\\n     * @since 1.7\\n     */\\n    @Override\\n    public int available() throws IOException {\\n        // Note: the logic is similar to the InflaterInputStream:\\n        //       as long as we have not reached EOF, indicate that there is more\\n        //       data available. As we do not know for sure how much data is left,\\n        //       just return 1 as a safe guess.\\n\\n        return context.eof ? 0 : 1;\\n    }\\n\\n    /**\\n     * Marks the current position in this input stream.\\n     * <p>The {@link #mark} method of {@link BaseNCodecInputStream} does nothing.</p>\\n     *\\n     * @param readLimit the maximum limit of bytes that can be read before the mark position becomes invalid.\\n     * @since 1.7\\n     */\\n    @Override\\n    public synchronized void mark(final int readLimit) {\\n    }\\n\\n    /**\\n     * {@inheritDoc}\\n     *\\n     * @return always returns <code>false</code>\\n     */\\n    @Override\\n    public boolean markSupported() {\\n        return false; // not an easy job to support marks\\n    }\\n\\n    /**\\n     * Reads one <code>byte</code> from this input stream.\\n     *\\n     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     */\\n    @Override\\n    public int read() throws IOException {\\n        int r = read(singleByte, 0, 1);\\n        while (r == 0) {\\n            r = read(singleByte, 0, 1);\\n        }\\n        if (r > 0) {\\n            final byte b = singleByte[0];\\n            return b < 0 ? 256 + b : b;\\n        }\\n        return EOF;\\n    }\\n\\n    /**\\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\\n     * from this InputStream.\\n     *\\n     * @param b\\n     *            destination byte array\\n     * @param offset\\n     *            where to start writing the bytes\\n     * @param len\\n     *            maximum number of bytes to read\\n     *\\n     * @return number of bytes read\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     * @throws NullPointerException\\n     *             if the byte array parameter is null\\n     * @throws IndexOutOfBoundsException\\n     *             if offset, len or buffer size are invalid\\n     */\\n    @Override\\n    public int read(final byte b[], final int offset, final int len) throws IOException {\\n        if (b == null) {\\n            throw new NullPointerException();\\n        } else if (offset < 0 || len < 0) {\\n            throw new IndexOutOfBoundsException();\\n        } else if (offset > b.length || offset + len > b.length) {\\n            throw new IndexOutOfBoundsException();\\n        } else if (len == 0) {\\n            return 0;\\n        } else {\\n            int readLen = 0;\\n            /*\\n             Rationale for while-loop on (readLen == 0):\\n             -----\\n             Base32.readResults() usually returns > 0 or EOF (-1).  In the\\n             rare case where it returns 0, we just keep trying.\\n\\n             This is essentially an undocumented contract for InputStream\\n             implementors that want their code to work properly with\\n             java.io.InputStreamReader, since the latter hates it when\\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\\n             readResults() call must return 0 if a large amount of the data\\n             being decoded was non-base32, so this while-loop enables proper\\n             interop with InputStreamReader for that scenario.\\n             -----\\n             This is a fix for CODEC-101\\n            */\\n            while (readLen == 0) {\\n                if (!baseNCodec.hasData(context)) {\\n                    final byte[] buf = new byte[doEncode ? 4096 : 8192];\\n                    final int c = in.read(buf);\\n                    if (doEncode) {\\n                        baseNCodec.encode(buf, 0, c, context);\\n                    } else {\\n                        baseNCodec.decode(buf, 0, c, context);\\n                    }\\n                }\\n                readLen = baseNCodec.readResults(b, offset, len, context);\\n            }\\n            return readLen;\\n        }\\n    }\\n\\n    /**\\n     * Repositions this stream to the position at the time the mark method was last called on this input stream.\\n     * <p>\\n     * The {@link #reset} method of {@link BaseNCodecInputStream} does nothing except throw an {@link IOException}.\\n     *\\n     * @throws IOException if this method is invoked\\n     * @since 1.7\\n     */\\n    @Override\\n    public synchronized void reset() throws IOException {\\n        throw new IOException(\\\"mark/reset not supported\\\");\\n    }\\n\\n    /**\\n     * {@inheritDoc}\\n     *\\n     * @throws IllegalArgumentException if the provided skip length is negative\\n     * @since 1.7\\n     */\\n    @Override\\n    public long skip(final long n) throws IOException {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\\\"Negative skip length: \\\" + n);\\n        }\\n\\n        // skip in chunks of 512 bytes\\n        final byte[] b = new byte[512];\\n        long todo = n;\\n\\n        while (todo > 0) {\\n            int len = (int) Math.min(b.length, todo);\\n            len = this.read(b, 0, len);\\n            if (len == EOF) {\\n                break;\\n            }\\n            todo -= len;\\n        }\\n\\n        return n - todo;\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"BaseNCodecInputStream\", \"position\": {\"start_line\": 34, \"end_line\": 211, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class BaseNCodecInputStream extends FilterInputStream {\\n\\n    private final BaseNCodec baseNCodec;\\n\\n    private final boolean doEncode;\\n\\n    private final byte[] singleByte = new byte[1];\\n\\n    private final Context context = new Context();\\n\\n    protected BaseNCodecInputStream(final InputStream in, final BaseNCodec baseNCodec, final boolean doEncode) {\\n        super(in);\\n        this.doEncode = doEncode;\\n        this.baseNCodec = baseNCodec;\\n    }\\n\\n    /**\\n     * {@inheritDoc}\\n     *\\n     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,\\n     * <code>1</code> otherwise\\n     * @since 1.7\\n     */\\n    @Override\\n    public int available() throws IOException {\\n        // Note: the logic is similar to the InflaterInputStream:\\n        //       as long as we have not reached EOF, indicate that there is more\\n        //       data available. As we do not know for sure how much data is left,\\n        //       just return 1 as a safe guess.\\n\\n        return context.eof ? 0 : 1;\\n    }\\n\\n    /**\\n     * Marks the current position in this input stream.\\n     * <p>The {@link #mark} method of {@link BaseNCodecInputStream} does nothing.</p>\\n     *\\n     * @param readLimit the maximum limit of bytes that can be read before the mark position becomes invalid.\\n     * @since 1.7\\n     */\\n    @Override\\n    public synchronized void mark(final int readLimit) {\\n    }\\n\\n    /**\\n     * {@inheritDoc}\\n     *\\n     * @return always returns <code>false</code>\\n     */\\n    @Override\\n    public boolean markSupported() {\\n        return false; // not an easy job to support marks\\n    }\\n\\n    /**\\n     * Reads one <code>byte</code> from this input stream.\\n     *\\n     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     */\\n    @Override\\n    public int read() throws IOException {\\n        int r = read(singleByte, 0, 1);\\n        while (r == 0) {\\n            r = read(singleByte, 0, 1);\\n        }\\n        if (r > 0) {\\n            final byte b = singleByte[0];\\n            return b < 0 ? 256 + b : b;\\n        }\\n        return EOF;\\n    }\\n\\n    /**\\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\\n     * from this InputStream.\\n     *\\n     * @param b\\n     *            destination byte array\\n     * @param offset\\n     *            where to start writing the bytes\\n     * @param len\\n     *            maximum number of bytes to read\\n     *\\n     * @return number of bytes read\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     * @throws NullPointerException\\n     *             if the byte array parameter is null\\n     * @throws IndexOutOfBoundsException\\n     *             if offset, len or buffer size are invalid\\n     */\\n    @Override\\n    public int read(final byte b[], final int offset, final int len) throws IOException {\\n        if (b == null) {\\n            throw new NullPointerException();\\n        } else if (offset < 0 || len < 0) {\\n            throw new IndexOutOfBoundsException();\\n        } else if (offset > b.length || offset + len > b.length) {\\n            throw new IndexOutOfBoundsException();\\n        } else if (len == 0) {\\n            return 0;\\n        } else {\\n            int readLen = 0;\\n            /*\\n             Rationale for while-loop on (readLen == 0):\\n             -----\\n             Base32.readResults() usually returns > 0 or EOF (-1).  In the\\n             rare case where it returns 0, we just keep trying.\\n\\n             This is essentially an undocumented contract for InputStream\\n             implementors that want their code to work properly with\\n             java.io.InputStreamReader, since the latter hates it when\\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\\n             readResults() call must return 0 if a large amount of the data\\n             being decoded was non-base32, so this while-loop enables proper\\n             interop with InputStreamReader for that scenario.\\n             -----\\n             This is a fix for CODEC-101\\n            */\\n            while (readLen == 0) {\\n                if (!baseNCodec.hasData(context)) {\\n                    final byte[] buf = new byte[doEncode ? 4096 : 8192];\\n                    final int c = in.read(buf);\\n                    if (doEncode) {\\n                        baseNCodec.encode(buf, 0, c, context);\\n                    } else {\\n                        baseNCodec.decode(buf, 0, c, context);\\n                    }\\n                }\\n                readLen = baseNCodec.readResults(b, offset, len, context);\\n            }\\n            return readLen;\\n        }\\n    }\\n\\n    /**\\n     * Repositions this stream to the position at the time the mark method was last called on this input stream.\\n     * <p>\\n     * The {@link #reset} method of {@link BaseNCodecInputStream} does nothing except throw an {@link IOException}.\\n     *\\n     * @throws IOException if this method is invoked\\n     * @since 1.7\\n     */\\n    @Override\\n    public synchronized void reset() throws IOException {\\n        throw new IOException(\\\"mark/reset not supported\\\");\\n    }\\n\\n    /**\\n     * {@inheritDoc}\\n     *\\n     * @throws IllegalArgumentException if the provided skip length is negative\\n     * @since 1.7\\n     */\\n    @Override\\n    public long skip(final long n) throws IOException {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\\\"Negative skip length: \\\" + n);\\n        }\\n\\n        // skip in chunks of 512 bytes\\n        final byte[] b = new byte[512];\\n        long todo = n;\\n\\n        while (todo > 0) {\\n            int len = (int) Math.min(b.length, todo);\\n            len = this.read(b, 0, len);\\n            if (len == EOF) {\\n                break;\\n            }\\n            todo -= len;\\n        }\\n\\n        return n - todo;\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"available\", \"return_type\": \"int\", \"position\": {\"start_line\": 58, \"end_line\": 65, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int available() throws IOException {\\n        // Note: the logic is similar to the InflaterInputStream:\\n        //       as long as we have not reached EOF, indicate that there is more\\n        //       data available. As we do not know for sure how much data is left,\\n        //       just return 1 as a safe guess.\\n\\n        return context.eof ? 0 : 1;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"mark\", \"return_type\": \"void\", \"position\": {\"start_line\": 75, \"end_line\": 76, \"start_column\": 25, \"end_column\": 5}, \"code\": \"void mark(final int readLimit) {\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"readLimit\", \"type\": \"int\"}]}, {\"name\": \"markSupported\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 84, \"end_line\": 86, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean markSupported() {\\n        return false; // not an easy job to support marks\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"read\", \"return_type\": \"int\", \"position\": {\"start_line\": 96, \"end_line\": 106, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int read() throws IOException {\\n        int r = read(singleByte, 0, 1);\\n        while (r == 0) {\\n            r = read(singleByte, 0, 1);\\n        }\\n        if (r > 0) {\\n            final byte b = singleByte[0];\\n            return b < 0 ? 256 + b : b;\\n        }\\n        return EOF;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"read\", \"return_type\": \"int\", \"position\": {\"start_line\": 128, \"end_line\": 169, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int read(final byte b[], final int offset, final int len) throws IOException {\\n        if (b == null) {\\n            throw new NullPointerException();\\n        } else if (offset < 0 || len < 0) {\\n            throw new IndexOutOfBoundsException();\\n        } else if (offset > b.length || offset + len > b.length) {\\n            throw new IndexOutOfBoundsException();\\n        } else if (len == 0) {\\n            return 0;\\n        } else {\\n            int readLen = 0;\\n            /*\\n             Rationale for while-loop on (readLen == 0):\\n             -----\\n             Base32.readResults() usually returns > 0 or EOF (-1).  In the\\n             rare case where it returns 0, we just keep trying.\\n\\n             This is essentially an undocumented contract for InputStream\\n             implementors that want their code to work properly with\\n             java.io.InputStreamReader, since the latter hates it when\\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\\n             readResults() call must return 0 if a large amount of the data\\n             being decoded was non-base32, so this while-loop enables proper\\n             interop with InputStreamReader for that scenario.\\n             -----\\n             This is a fix for CODEC-101\\n            */\\n            while (readLen == 0) {\\n                if (!baseNCodec.hasData(context)) {\\n                    final byte[] buf = new byte[doEncode ? 4096 : 8192];\\n                    final int c = in.read(buf);\\n                    if (doEncode) {\\n                        baseNCodec.encode(buf, 0, c, context);\\n                    } else {\\n                        baseNCodec.decode(buf, 0, c, context);\\n                    }\\n                }\\n                readLen = baseNCodec.readResults(b, offset, len, context);\\n            }\\n            return readLen;\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"byte\"}, {\"name\": \"offset\", \"type\": \"int\"}, {\"name\": \"len\", \"type\": \"int\"}]}, {\"name\": \"reset\", \"return_type\": \"void\", \"position\": {\"start_line\": 180, \"end_line\": 182, \"start_column\": 25, \"end_column\": 5}, \"code\": \"void reset() throws IOException {\\n        throw new IOException(\\\"mark/reset not supported\\\");\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"skip\", \"return_type\": \"long\", \"position\": {\"start_line\": 191, \"end_line\": 210, \"start_column\": 12, \"end_column\": 5}, \"code\": \"long skip(final long n) throws IOException {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\\\"Negative skip length: \\\" + n);\\n        }\\n\\n        // skip in chunks of 512 bytes\\n        final byte[] b = new byte[512];\\n        long todo = n;\\n\\n        while (todo > 0) {\\n            int len = (int) Math.min(b.length, todo);\\n            len = this.read(b, 0, len);\\n            if (len == EOF) {\\n                break;\\n            }\\n            todo -= len;\\n        }\\n\\n        return n - todo;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"n\", \"type\": \"long\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.binary;\\n\\nimport static org.apache.commons.codec.binary.BaseNCodec.EOF;\\n\\nimport java.io.FilterOutputStream;\\nimport java.io.IOException;\\nimport java.io.OutputStream;\\n\\nimport org.apache.commons.codec.binary.BaseNCodec.Context;\\n\\n/**\\n * Abstract superclass for Base-N output streams.\\n * <p>\\n * To write the EOF marker without closing the stream, call {@link #eof()} or use an <a\\n * href=\\\"https://commons.apache.org/proper/commons-io/\\\">Apache Commons IO</a> <a href=\\n * \\\"https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/output/CloseShieldOutputStream.html\\\"\\n * >CloseShieldOutputStream</a>.\\n * </p>\\n *\\n * @since 1.5\\n * @version $Id: BaseNCodecOutputStream.java 1744727 2016-05-20 12:43:52Z sebb $\\n */\\npublic class BaseNCodecOutputStream extends FilterOutputStream {\\n\\n    private final boolean doEncode;\\n\\n    private final BaseNCodec baseNCodec;\\n\\n    private final byte[] singleByte = new byte[1];\\n\\n    private final Context context = new Context();\\n\\n    // TODO should this be protected?\\n    public BaseNCodecOutputStream(final OutputStream out, final BaseNCodec basedCodec, final boolean doEncode) {\\n        super(out);\\n        this.baseNCodec = basedCodec;\\n        this.doEncode = doEncode;\\n    }\\n\\n    /**\\n     * Writes the specified <code>byte</code> to this output stream.\\n     *\\n     * @param i\\n     *            source byte\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     */\\n    @Override\\n    public void write(final int i) throws IOException {\\n        singleByte[0] = (byte) i;\\n        write(singleByte, 0, 1);\\n    }\\n\\n    /**\\n     * Writes <code>len</code> bytes from the specified <code>b</code> array starting at <code>offset</code> to this\\n     * output stream.\\n     *\\n     * @param b\\n     *            source byte array\\n     * @param offset\\n     *            where to start reading the bytes\\n     * @param len\\n     *            maximum number of bytes to write\\n     *\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     * @throws NullPointerException\\n     *             if the byte array parameter is null\\n     * @throws IndexOutOfBoundsException\\n     *             if offset, len or buffer size are invalid\\n     */\\n    @Override\\n    public void write(final byte b[], final int offset, final int len) throws IOException {\\n        if (b == null) {\\n            throw new NullPointerException();\\n        } else if (offset < 0 || len < 0) {\\n            throw new IndexOutOfBoundsException();\\n        } else if (offset > b.length || offset + len > b.length) {\\n            throw new IndexOutOfBoundsException();\\n        } else if (len > 0) {\\n            if (doEncode) {\\n                baseNCodec.encode(b, offset, len, context);\\n            } else {\\n                baseNCodec.decode(b, offset, len, context);\\n            }\\n            flush(false);\\n        }\\n    }\\n\\n    /**\\n     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propagate is\\n     * true, the wrapped stream will also be flushed.\\n     *\\n     * @param propagate\\n     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     */\\n    private void flush(final boolean propagate) throws IOException {\\n        final int avail = baseNCodec.available(context);\\n        if (avail > 0) {\\n            final byte[] buf = new byte[avail];\\n            final int c = baseNCodec.readResults(buf, 0, avail, context);\\n            if (c > 0) {\\n                out.write(buf, 0, c);\\n            }\\n        }\\n        if (propagate) {\\n            out.flush();\\n        }\\n    }\\n\\n    /**\\n     * Flushes this output stream and forces any buffered output bytes to be written out to the stream.\\n     *\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     */\\n    @Override\\n    public void flush() throws IOException {\\n        flush(true);\\n    }\\n\\n    /**\\n     * Closes this output stream and releases any system resources associated with the stream.\\n     * <p>\\n     * To write the EOF marker without closing the stream, call {@link #eof()} or use an\\n     * <a href=\\\"https://commons.apache.org/proper/commons-io/\\\">Apache Commons IO</a> <a href=\\n     * \\\"https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/output/CloseShieldOutputStream.html\\\"\\n     * >CloseShieldOutputStream</a>.\\n     * </p>\\n     *\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     */\\n    @Override\\n    public void close() throws IOException {\\n        eof();\\n        flush();\\n        out.close();\\n    }\\n\\n    /**\\n     * Writes EOF.\\n     *\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     * @since 1.11\\n     */\\n    public void eof() throws IOException {\\n        // Notify encoder of EOF (-1).\\n        if (doEncode) {\\n            baseNCodec.encode(singleByte, 0, EOF, context);\\n        } else {\\n            baseNCodec.decode(singleByte, 0, EOF, context);\\n        }\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"BaseNCodecOutputStream\", \"position\": {\"start_line\": 40, \"end_line\": 176, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class BaseNCodecOutputStream extends FilterOutputStream {\\n\\n    private final boolean doEncode;\\n\\n    private final BaseNCodec baseNCodec;\\n\\n    private final byte[] singleByte = new byte[1];\\n\\n    private final Context context = new Context();\\n\\n    // TODO should this be protected?\\n    public BaseNCodecOutputStream(final OutputStream out, final BaseNCodec basedCodec, final boolean doEncode) {\\n        super(out);\\n        this.baseNCodec = basedCodec;\\n        this.doEncode = doEncode;\\n    }\\n\\n    /**\\n     * Writes the specified <code>byte</code> to this output stream.\\n     *\\n     * @param i\\n     *            source byte\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     */\\n    @Override\\n    public void write(final int i) throws IOException {\\n        singleByte[0] = (byte) i;\\n        write(singleByte, 0, 1);\\n    }\\n\\n    /**\\n     * Writes <code>len</code> bytes from the specified <code>b</code> array starting at <code>offset</code> to this\\n     * output stream.\\n     *\\n     * @param b\\n     *            source byte array\\n     * @param offset\\n     *            where to start reading the bytes\\n     * @param len\\n     *            maximum number of bytes to write\\n     *\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     * @throws NullPointerException\\n     *             if the byte array parameter is null\\n     * @throws IndexOutOfBoundsException\\n     *             if offset, len or buffer size are invalid\\n     */\\n    @Override\\n    public void write(final byte b[], final int offset, final int len) throws IOException {\\n        if (b == null) {\\n            throw new NullPointerException();\\n        } else if (offset < 0 || len < 0) {\\n            throw new IndexOutOfBoundsException();\\n        } else if (offset > b.length || offset + len > b.length) {\\n            throw new IndexOutOfBoundsException();\\n        } else if (len > 0) {\\n            if (doEncode) {\\n                baseNCodec.encode(b, offset, len, context);\\n            } else {\\n                baseNCodec.decode(b, offset, len, context);\\n            }\\n            flush(false);\\n        }\\n    }\\n\\n    /**\\n     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propagate is\\n     * true, the wrapped stream will also be flushed.\\n     *\\n     * @param propagate\\n     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     */\\n    private void flush(final boolean propagate) throws IOException {\\n        final int avail = baseNCodec.available(context);\\n        if (avail > 0) {\\n            final byte[] buf = new byte[avail];\\n            final int c = baseNCodec.readResults(buf, 0, avail, context);\\n            if (c > 0) {\\n                out.write(buf, 0, c);\\n            }\\n        }\\n        if (propagate) {\\n            out.flush();\\n        }\\n    }\\n\\n    /**\\n     * Flushes this output stream and forces any buffered output bytes to be written out to the stream.\\n     *\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     */\\n    @Override\\n    public void flush() throws IOException {\\n        flush(true);\\n    }\\n\\n    /**\\n     * Closes this output stream and releases any system resources associated with the stream.\\n     * <p>\\n     * To write the EOF marker without closing the stream, call {@link #eof()} or use an\\n     * <a href=\\\"https://commons.apache.org/proper/commons-io/\\\">Apache Commons IO</a> <a href=\\n     * \\\"https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/output/CloseShieldOutputStream.html\\\"\\n     * >CloseShieldOutputStream</a>.\\n     * </p>\\n     *\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     */\\n    @Override\\n    public void close() throws IOException {\\n        eof();\\n        flush();\\n        out.close();\\n    }\\n\\n    /**\\n     * Writes EOF.\\n     *\\n     * @throws IOException\\n     *             if an I/O error occurs.\\n     * @since 1.11\\n     */\\n    public void eof() throws IOException {\\n        // Notify encoder of EOF (-1).\\n        if (doEncode) {\\n            baseNCodec.encode(singleByte, 0, EOF, context);\\n        } else {\\n            baseNCodec.decode(singleByte, 0, EOF, context);\\n        }\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"write\", \"return_type\": \"void\", \"position\": {\"start_line\": 66, \"end_line\": 69, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void write(final int i) throws IOException {\\n        singleByte[0] = (byte) i;\\n        write(singleByte, 0, 1);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"i\", \"type\": \"int\"}]}, {\"name\": \"write\", \"return_type\": \"void\", \"position\": {\"start_line\": 90, \"end_line\": 105, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void write(final byte b[], final int offset, final int len) throws IOException {\\n        if (b == null) {\\n            throw new NullPointerException();\\n        } else if (offset < 0 || len < 0) {\\n            throw new IndexOutOfBoundsException();\\n        } else if (offset > b.length || offset + len > b.length) {\\n            throw new IndexOutOfBoundsException();\\n        } else if (len > 0) {\\n            if (doEncode) {\\n                baseNCodec.encode(b, offset, len, context);\\n            } else {\\n                baseNCodec.decode(b, offset, len, context);\\n            }\\n            flush(false);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"byte\"}, {\"name\": \"offset\", \"type\": \"int\"}, {\"name\": \"len\", \"type\": \"int\"}]}, {\"name\": \"flush\", \"return_type\": \"void\", \"position\": {\"start_line\": 116, \"end_line\": 128, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void flush(final boolean propagate) throws IOException {\\n        final int avail = baseNCodec.available(context);\\n        if (avail > 0) {\\n            final byte[] buf = new byte[avail];\\n            final int c = baseNCodec.readResults(buf, 0, avail, context);\\n            if (c > 0) {\\n                out.write(buf, 0, c);\\n            }\\n        }\\n        if (propagate) {\\n            out.flush();\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"propagate\", \"type\": \"boolean\"}]}, {\"name\": \"flush\", \"return_type\": \"void\", \"position\": {\"start_line\": 137, \"end_line\": 139, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void flush() throws IOException {\\n        flush(true);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"close\", \"return_type\": \"void\", \"position\": {\"start_line\": 154, \"end_line\": 158, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void close() throws IOException {\\n        eof();\\n        flush();\\n        out.close();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"eof\", \"return_type\": \"void\", \"position\": {\"start_line\": 167, \"end_line\": 174, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void eof() throws IOException {\\n        // Notify encoder of EOF (-1).\\n        if (doEncode) {\\n            baseNCodec.encode(singleByte, 0, EOF, context);\\n        } else {\\n            baseNCodec.decode(singleByte, 0, EOF, context);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/BinaryCodec.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.binary;\\n\\nimport org.apache.commons.codec.BinaryDecoder;\\nimport org.apache.commons.codec.BinaryEncoder;\\nimport org.apache.commons.codec.DecoderException;\\nimport org.apache.commons.codec.EncoderException;\\n\\n/**\\n * Converts between byte arrays and strings of \\\"0\\\"s and \\\"1\\\"s.\\n *\\n * <p>This class is immutable and thread-safe.</p>\\n *\\n * TODO: may want to add more bit vector functions like and/or/xor/nand\\n * TODO: also might be good to generate boolean[] from byte[] et cetera.\\n *\\n * @since 1.3\\n * @version $Id: BinaryCodec.java 1619948 2014-08-22 22:53:55Z ggregory $\\n */\\npublic class BinaryCodec implements BinaryDecoder, BinaryEncoder {\\n    /*\\n     * tried to avoid using ArrayUtils to minimize dependencies while using these empty arrays - dep is just not worth\\n     * it.\\n     */\\n    /** Empty char array. */\\n    private static final char[] EMPTY_CHAR_ARRAY = new char[0];\\n\\n    /** Empty byte array. */\\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\\n\\n    /** Mask for bit 0 of a byte. */\\n    private static final int BIT_0 = 1;\\n\\n    /** Mask for bit 1 of a byte. */\\n    private static final int BIT_1 = 0x02;\\n\\n    /** Mask for bit 2 of a byte. */\\n    private static final int BIT_2 = 0x04;\\n\\n    /** Mask for bit 3 of a byte. */\\n    private static final int BIT_3 = 0x08;\\n\\n    /** Mask for bit 4 of a byte. */\\n    private static final int BIT_4 = 0x10;\\n\\n    /** Mask for bit 5 of a byte. */\\n    private static final int BIT_5 = 0x20;\\n\\n    /** Mask for bit 6 of a byte. */\\n    private static final int BIT_6 = 0x40;\\n\\n    /** Mask for bit 7 of a byte. */\\n    private static final int BIT_7 = 0x80;\\n\\n    private static final int[] BITS = {BIT_0, BIT_1, BIT_2, BIT_3, BIT_4, BIT_5, BIT_6, BIT_7};\\n\\n    /**\\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\\n     *\\n     * @param raw\\n     *                  the raw binary data to convert\\n     * @return 0 and 1 ASCII character bytes one for each bit of the argument\\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\\n     */\\n    @Override\\n    public byte[] encode(final byte[] raw) {\\n        return toAsciiBytes(raw);\\n    }\\n\\n    /**\\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 chars.\\n     *\\n     * @param raw\\n     *                  the raw binary data to convert\\n     * @return 0 and 1 ASCII character chars one for each bit of the argument\\n     * @throws EncoderException\\n     *                  if the argument is not a byte[]\\n     * @see org.apache.commons.codec.Encoder#encode(Object)\\n     */\\n    @Override\\n    public Object encode(final Object raw) throws EncoderException {\\n        if (!(raw instanceof byte[])) {\\n            throw new EncoderException(\\\"argument not a byte array\\\");\\n        }\\n        return toAsciiChars((byte[]) raw);\\n    }\\n\\n    /**\\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\\n     *\\n     * @param ascii\\n     *                  each byte represents an ASCII '0' or '1'\\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\\n     * @throws DecoderException\\n     *                  if argument is not a byte[], char[] or String\\n     * @see org.apache.commons.codec.Decoder#decode(Object)\\n     */\\n    @Override\\n    public Object decode(final Object ascii) throws DecoderException {\\n        if (ascii == null) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        if (ascii instanceof byte[]) {\\n            return fromAscii((byte[]) ascii);\\n        }\\n        if (ascii instanceof char[]) {\\n            return fromAscii((char[]) ascii);\\n        }\\n        if (ascii instanceof String) {\\n            return fromAscii(((String) ascii).toCharArray());\\n        }\\n        throw new DecoderException(\\\"argument not a byte array\\\");\\n    }\\n\\n    /**\\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\\n     *\\n     * @param ascii\\n     *                  each byte represents an ASCII '0' or '1'\\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\\n     * @see org.apache.commons.codec.Decoder#decode(Object)\\n     */\\n    @Override\\n    public byte[] decode(final byte[] ascii) {\\n        return fromAscii(ascii);\\n    }\\n\\n    /**\\n     * Decodes a String where each char of the String represents an ASCII '0' or '1'.\\n     *\\n     * @param ascii\\n     *                  String of '0' and '1' characters\\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\\n     * @see org.apache.commons.codec.Decoder#decode(Object)\\n     */\\n    public byte[] toByteArray(final String ascii) {\\n        if (ascii == null) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        return fromAscii(ascii.toCharArray());\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    //\\n    // static codec operations\\n    //\\n    // ------------------------------------------------------------------------\\n    /**\\n     * Decodes a char array where each char represents an ASCII '0' or '1'.\\n     *\\n     * @param ascii\\n     *                  each char represents an ASCII '0' or '1'\\n     * @return the raw encoded binary where each bit corresponds to a char in the char array argument\\n     */\\n    public static byte[] fromAscii(final char[] ascii) {\\n        if (ascii == null || ascii.length == 0) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        // get length/8 times bytes with 3 bit shifts to the right of the length\\n        final byte[] l_raw = new byte[ascii.length >> 3];\\n        /*\\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\\n         * loop.\\n         */\\n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\\n            for (int bits = 0; bits < BITS.length; ++bits) {\\n                if (ascii[jj - bits] == '1') {\\n                    l_raw[ii] |= BITS[bits];\\n                }\\n            }\\n        }\\n        return l_raw;\\n    }\\n\\n    /**\\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\\n     *\\n     * @param ascii\\n     *                  each byte represents an ASCII '0' or '1'\\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\\n     */\\n    public static byte[] fromAscii(final byte[] ascii) {\\n        if (isEmpty(ascii)) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        // get length/8 times bytes with 3 bit shifts to the right of the length\\n        final byte[] l_raw = new byte[ascii.length >> 3];\\n        /*\\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\\n         * loop.\\n         */\\n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\\n            for (int bits = 0; bits < BITS.length; ++bits) {\\n                if (ascii[jj - bits] == '1') {\\n                    l_raw[ii] |= BITS[bits];\\n                }\\n            }\\n        }\\n        return l_raw;\\n    }\\n\\n    /**\\n     * Returns <code>true</code> if the given array is <code>null</code> or empty (size 0.)\\n     *\\n     * @param array\\n     *            the source array\\n     * @return <code>true</code> if the given array is <code>null</code> or empty (size 0.)\\n     */\\n    private static boolean isEmpty(final byte[] array) {\\n        return array == null || array.length == 0;\\n    }\\n\\n    /**\\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated\\n     * char.\\n     *\\n     * @param raw\\n     *                  the raw binary data to convert\\n     * @return an array of 0 and 1 character bytes for each bit of the argument\\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\\n     */\\n    public static byte[] toAsciiBytes(final byte[] raw) {\\n        if (isEmpty(raw)) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        // get 8 times the bytes with 3 bit shifts to the left of the length\\n        final byte[] l_ascii = new byte[raw.length << 3];\\n        /*\\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\\n         * loop.\\n         */\\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\\n            for (int bits = 0; bits < BITS.length; ++bits) {\\n                if ((raw[ii] & BITS[bits]) == 0) {\\n                    l_ascii[jj - bits] = '0';\\n                } else {\\n                    l_ascii[jj - bits] = '1';\\n                }\\n            }\\n        }\\n        return l_ascii;\\n    }\\n\\n    /**\\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\\n     *\\n     * @param raw\\n     *                  the raw binary data to convert\\n     * @return an array of 0 and 1 characters for each bit of the argument\\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\\n     */\\n    public static char[] toAsciiChars(final byte[] raw) {\\n        if (isEmpty(raw)) {\\n            return EMPTY_CHAR_ARRAY;\\n        }\\n        // get 8 times the bytes with 3 bit shifts to the left of the length\\n        final char[] l_ascii = new char[raw.length << 3];\\n        /*\\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\\n         * loop.\\n         */\\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\\n            for (int bits = 0; bits < BITS.length; ++bits) {\\n                if ((raw[ii] & BITS[bits]) == 0) {\\n                    l_ascii[jj - bits] = '0';\\n                } else {\\n                    l_ascii[jj - bits] = '1';\\n                }\\n            }\\n        }\\n        return l_ascii;\\n    }\\n\\n    /**\\n     * Converts an array of raw binary data into a String of ASCII 0 and 1 characters.\\n     *\\n     * @param raw\\n     *                  the raw binary data to convert\\n     * @return a String of 0 and 1 characters representing the binary data\\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\\n     */\\n    public static String toAsciiString(final byte[] raw) {\\n        return new String(toAsciiChars(raw));\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"BinaryCodec\", \"position\": {\"start_line\": 36, \"end_line\": 301, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class BinaryCodec implements BinaryDecoder, BinaryEncoder {\\n    /*\\n     * tried to avoid using ArrayUtils to minimize dependencies while using these empty arrays - dep is just not worth\\n     * it.\\n     */\\n    /** Empty char array. */\\n    private static final char[] EMPTY_CHAR_ARRAY = new char[0];\\n\\n    /** Empty byte array. */\\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\\n\\n    /** Mask for bit 0 of a byte. */\\n    private static final int BIT_0 = 1;\\n\\n    /** Mask for bit 1 of a byte. */\\n    private static final int BIT_1 = 0x02;\\n\\n    /** Mask for bit 2 of a byte. */\\n    private static final int BIT_2 = 0x04;\\n\\n    /** Mask for bit 3 of a byte. */\\n    private static final int BIT_3 = 0x08;\\n\\n    /** Mask for bit 4 of a byte. */\\n    private static final int BIT_4 = 0x10;\\n\\n    /** Mask for bit 5 of a byte. */\\n    private static final int BIT_5 = 0x20;\\n\\n    /** Mask for bit 6 of a byte. */\\n    private static final int BIT_6 = 0x40;\\n\\n    /** Mask for bit 7 of a byte. */\\n    private static final int BIT_7 = 0x80;\\n\\n    private static final int[] BITS = {BIT_0, BIT_1, BIT_2, BIT_3, BIT_4, BIT_5, BIT_6, BIT_7};\\n\\n    /**\\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\\n     *\\n     * @param raw\\n     *                  the raw binary data to convert\\n     * @return 0 and 1 ASCII character bytes one for each bit of the argument\\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\\n     */\\n    @Override\\n    public byte[] encode(final byte[] raw) {\\n        return toAsciiBytes(raw);\\n    }\\n\\n    /**\\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 chars.\\n     *\\n     * @param raw\\n     *                  the raw binary data to convert\\n     * @return 0 and 1 ASCII character chars one for each bit of the argument\\n     * @throws EncoderException\\n     *                  if the argument is not a byte[]\\n     * @see org.apache.commons.codec.Encoder#encode(Object)\\n     */\\n    @Override\\n    public Object encode(final Object raw) throws EncoderException {\\n        if (!(raw instanceof byte[])) {\\n            throw new EncoderException(\\\"argument not a byte array\\\");\\n        }\\n        return toAsciiChars((byte[]) raw);\\n    }\\n\\n    /**\\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\\n     *\\n     * @param ascii\\n     *                  each byte represents an ASCII '0' or '1'\\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\\n     * @throws DecoderException\\n     *                  if argument is not a byte[], char[] or String\\n     * @see org.apache.commons.codec.Decoder#decode(Object)\\n     */\\n    @Override\\n    public Object decode(final Object ascii) throws DecoderException {\\n        if (ascii == null) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        if (ascii instanceof byte[]) {\\n            return fromAscii((byte[]) ascii);\\n        }\\n        if (ascii instanceof char[]) {\\n            return fromAscii((char[]) ascii);\\n        }\\n        if (ascii instanceof String) {\\n            return fromAscii(((String) ascii).toCharArray());\\n        }\\n        throw new DecoderException(\\\"argument not a byte array\\\");\\n    }\\n\\n    /**\\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\\n     *\\n     * @param ascii\\n     *                  each byte represents an ASCII '0' or '1'\\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\\n     * @see org.apache.commons.codec.Decoder#decode(Object)\\n     */\\n    @Override\\n    public byte[] decode(final byte[] ascii) {\\n        return fromAscii(ascii);\\n    }\\n\\n    /**\\n     * Decodes a String where each char of the String represents an ASCII '0' or '1'.\\n     *\\n     * @param ascii\\n     *                  String of '0' and '1' characters\\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\\n     * @see org.apache.commons.codec.Decoder#decode(Object)\\n     */\\n    public byte[] toByteArray(final String ascii) {\\n        if (ascii == null) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        return fromAscii(ascii.toCharArray());\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    //\\n    // static codec operations\\n    //\\n    // ------------------------------------------------------------------------\\n    /**\\n     * Decodes a char array where each char represents an ASCII '0' or '1'.\\n     *\\n     * @param ascii\\n     *                  each char represents an ASCII '0' or '1'\\n     * @return the raw encoded binary where each bit corresponds to a char in the char array argument\\n     */\\n    public static byte[] fromAscii(final char[] ascii) {\\n        if (ascii == null || ascii.length == 0) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        // get length/8 times bytes with 3 bit shifts to the right of the length\\n        final byte[] l_raw = new byte[ascii.length >> 3];\\n        /*\\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\\n         * loop.\\n         */\\n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\\n            for (int bits = 0; bits < BITS.length; ++bits) {\\n                if (ascii[jj - bits] == '1') {\\n                    l_raw[ii] |= BITS[bits];\\n                }\\n            }\\n        }\\n        return l_raw;\\n    }\\n\\n    /**\\n     * Decodes a byte array where each byte represents an ASCII '0' or '1'.\\n     *\\n     * @param ascii\\n     *                  each byte represents an ASCII '0' or '1'\\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\\n     */\\n    public static byte[] fromAscii(final byte[] ascii) {\\n        if (isEmpty(ascii)) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        // get length/8 times bytes with 3 bit shifts to the right of the length\\n        final byte[] l_raw = new byte[ascii.length >> 3];\\n        /*\\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\\n         * loop.\\n         */\\n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\\n            for (int bits = 0; bits < BITS.length; ++bits) {\\n                if (ascii[jj - bits] == '1') {\\n                    l_raw[ii] |= BITS[bits];\\n                }\\n            }\\n        }\\n        return l_raw;\\n    }\\n\\n    /**\\n     * Returns <code>true</code> if the given array is <code>null</code> or empty (size 0.)\\n     *\\n     * @param array\\n     *            the source array\\n     * @return <code>true</code> if the given array is <code>null</code> or empty (size 0.)\\n     */\\n    private static boolean isEmpty(final byte[] array) {\\n        return array == null || array.length == 0;\\n    }\\n\\n    /**\\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated\\n     * char.\\n     *\\n     * @param raw\\n     *                  the raw binary data to convert\\n     * @return an array of 0 and 1 character bytes for each bit of the argument\\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\\n     */\\n    public static byte[] toAsciiBytes(final byte[] raw) {\\n        if (isEmpty(raw)) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        // get 8 times the bytes with 3 bit shifts to the left of the length\\n        final byte[] l_ascii = new byte[raw.length << 3];\\n        /*\\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\\n         * loop.\\n         */\\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\\n            for (int bits = 0; bits < BITS.length; ++bits) {\\n                if ((raw[ii] & BITS[bits]) == 0) {\\n                    l_ascii[jj - bits] = '0';\\n                } else {\\n                    l_ascii[jj - bits] = '1';\\n                }\\n            }\\n        }\\n        return l_ascii;\\n    }\\n\\n    /**\\n     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\\n     *\\n     * @param raw\\n     *                  the raw binary data to convert\\n     * @return an array of 0 and 1 characters for each bit of the argument\\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\\n     */\\n    public static char[] toAsciiChars(final byte[] raw) {\\n        if (isEmpty(raw)) {\\n            return EMPTY_CHAR_ARRAY;\\n        }\\n        // get 8 times the bytes with 3 bit shifts to the left of the length\\n        final char[] l_ascii = new char[raw.length << 3];\\n        /*\\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\\n         * loop.\\n         */\\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\\n            for (int bits = 0; bits < BITS.length; ++bits) {\\n                if ((raw[ii] & BITS[bits]) == 0) {\\n                    l_ascii[jj - bits] = '0';\\n                } else {\\n                    l_ascii[jj - bits] = '1';\\n                }\\n            }\\n        }\\n        return l_ascii;\\n    }\\n\\n    /**\\n     * Converts an array of raw binary data into a String of ASCII 0 and 1 characters.\\n     *\\n     * @param raw\\n     *                  the raw binary data to convert\\n     * @return a String of 0 and 1 characters representing the binary data\\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])\\n     */\\n    public static String toAsciiString(final byte[] raw) {\\n        return new String(toAsciiChars(raw));\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"encode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 82, \"end_line\": 84, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] encode(final byte[] raw) {\\n        return toAsciiBytes(raw);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"raw\", \"type\": \"byte\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 97, \"end_line\": 102, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object raw) throws EncoderException {\\n        if (!(raw instanceof byte[])) {\\n            throw new EncoderException(\\\"argument not a byte array\\\");\\n        }\\n        return toAsciiChars((byte[]) raw);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"raw\", \"type\": \"Object\"}]}, {\"name\": \"decode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 115, \"end_line\": 129, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object decode(final Object ascii) throws DecoderException {\\n        if (ascii == null) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        if (ascii instanceof byte[]) {\\n            return fromAscii((byte[]) ascii);\\n        }\\n        if (ascii instanceof char[]) {\\n            return fromAscii((char[]) ascii);\\n        }\\n        if (ascii instanceof String) {\\n            return fromAscii(((String) ascii).toCharArray());\\n        }\\n        throw new DecoderException(\\\"argument not a byte array\\\");\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ascii\", \"type\": \"Object\"}]}, {\"name\": \"decode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 140, \"end_line\": 142, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] decode(final byte[] ascii) {\\n        return fromAscii(ascii);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ascii\", \"type\": \"byte\"}]}, {\"name\": \"toByteArray\", \"return_type\": \"byte\", \"position\": {\"start_line\": 152, \"end_line\": 157, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] toByteArray(final String ascii) {\\n        if (ascii == null) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        return fromAscii(ascii.toCharArray());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ascii\", \"type\": \"String\"}]}, {\"name\": \"fromAscii\", \"return_type\": \"byte\", \"position\": {\"start_line\": 171, \"end_line\": 189, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] fromAscii(final char[] ascii) {\\n        if (ascii == null || ascii.length == 0) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        // get length/8 times bytes with 3 bit shifts to the right of the length\\n        final byte[] l_raw = new byte[ascii.length >> 3];\\n        /*\\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\\n         * loop.\\n         */\\n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\\n            for (int bits = 0; bits < BITS.length; ++bits) {\\n                if (ascii[jj - bits] == '1') {\\n                    l_raw[ii] |= BITS[bits];\\n                }\\n            }\\n        }\\n        return l_raw;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ascii\", \"type\": \"char\"}]}, {\"name\": \"fromAscii\", \"return_type\": \"byte\", \"position\": {\"start_line\": 198, \"end_line\": 216, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] fromAscii(final byte[] ascii) {\\n        if (isEmpty(ascii)) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        // get length/8 times bytes with 3 bit shifts to the right of the length\\n        final byte[] l_raw = new byte[ascii.length >> 3];\\n        /*\\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\\n         * loop.\\n         */\\n        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {\\n            for (int bits = 0; bits < BITS.length; ++bits) {\\n                if (ascii[jj - bits] == '1') {\\n                    l_raw[ii] |= BITS[bits];\\n                }\\n            }\\n        }\\n        return l_raw;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ascii\", \"type\": \"byte\"}]}, {\"name\": \"isEmpty\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 225, \"end_line\": 227, \"start_column\": 20, \"end_column\": 5}, \"code\": \"boolean isEmpty(final byte[] array) {\\n        return array == null || array.length == 0;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"array\", \"type\": \"byte\"}]}, {\"name\": \"toAsciiBytes\", \"return_type\": \"byte\", \"position\": {\"start_line\": 238, \"end_line\": 258, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] toAsciiBytes(final byte[] raw) {\\n        if (isEmpty(raw)) {\\n            return EMPTY_BYTE_ARRAY;\\n        }\\n        // get 8 times the bytes with 3 bit shifts to the left of the length\\n        final byte[] l_ascii = new byte[raw.length << 3];\\n        /*\\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\\n         * loop.\\n         */\\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\\n            for (int bits = 0; bits < BITS.length; ++bits) {\\n                if ((raw[ii] & BITS[bits]) == 0) {\\n                    l_ascii[jj - bits] = '0';\\n                } else {\\n                    l_ascii[jj - bits] = '1';\\n                }\\n            }\\n        }\\n        return l_ascii;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"raw\", \"type\": \"byte\"}]}, {\"name\": \"toAsciiChars\", \"return_type\": \"char\", \"position\": {\"start_line\": 268, \"end_line\": 288, \"start_column\": 19, \"end_column\": 5}, \"code\": \"char[] toAsciiChars(final byte[] raw) {\\n        if (isEmpty(raw)) {\\n            return EMPTY_CHAR_ARRAY;\\n        }\\n        // get 8 times the bytes with 3 bit shifts to the left of the length\\n        final char[] l_ascii = new char[raw.length << 3];\\n        /*\\n         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the\\n         * loop.\\n         */\\n        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {\\n            for (int bits = 0; bits < BITS.length; ++bits) {\\n                if ((raw[ii] & BITS[bits]) == 0) {\\n                    l_ascii[jj - bits] = '0';\\n                } else {\\n                    l_ascii[jj - bits] = '1';\\n                }\\n            }\\n        }\\n        return l_ascii;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"raw\", \"type\": \"byte\"}]}, {\"name\": \"toAsciiString\", \"return_type\": \"String\", \"position\": {\"start_line\": 298, \"end_line\": 300, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String toAsciiString(final byte[] raw) {\\n        return new String(toAsciiChars(raw));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"raw\", \"type\": \"byte\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/CharSequenceUtils.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npackage org.apache.commons.codec.binary;\\n\\n/**\\n * <p>\\n * Operations on {@link CharSequence} that are <code>null</code> safe.\\n * </p>\\n * <p>\\n * Copied from Apache Commons Lang r1586295 on April 10, 2014 (day of 3.3.2 release).\\n * </p>\\n *\\n * @see CharSequence\\n * @since 1.10\\n */\\npublic class CharSequenceUtils {\\n\\n    /**\\n     * Green implementation of regionMatches.\\n     *\\n     * @param cs\\n     *            the <code>CharSequence</code> to be processed\\n     * @param ignoreCase\\n     *            whether or not to be case insensitive\\n     * @param thisStart\\n     *            the index to start on the <code>cs</code> CharSequence\\n     * @param substring\\n     *            the <code>CharSequence</code> to be looked for\\n     * @param start\\n     *            the index to start on the <code>substring</code> CharSequence\\n     * @param length\\n     *            character length of the region\\n     * @return whether the region matched\\n     */\\n    static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,\\n            final CharSequence substring, final int start, final int length) {\\n        if (cs instanceof String && substring instanceof String) {\\n            return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);\\n        }\\n        int index1 = thisStart;\\n        int index2 = start;\\n        int tmpLen = length;\\n\\n        while (tmpLen-- > 0) {\\n            final char c1 = cs.charAt(index1++);\\n            final char c2 = substring.charAt(index2++);\\n\\n            if (c1 == c2) {\\n                continue;\\n            }\\n\\n            if (!ignoreCase) {\\n                return false;\\n            }\\n\\n            // The same check as in String.regionMatches():\\n            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) &&\\n                    Character.toLowerCase(c1) != Character.toLowerCase(c2)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"CharSequenceUtils\", \"position\": {\"start_line\": 30, \"end_line\": 79, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class CharSequenceUtils {\\n\\n    /**\\n     * Green implementation of regionMatches.\\n     *\\n     * @param cs\\n     *            the <code>CharSequence</code> to be processed\\n     * @param ignoreCase\\n     *            whether or not to be case insensitive\\n     * @param thisStart\\n     *            the index to start on the <code>cs</code> CharSequence\\n     * @param substring\\n     *            the <code>CharSequence</code> to be looked for\\n     * @param start\\n     *            the index to start on the <code>substring</code> CharSequence\\n     * @param length\\n     *            character length of the region\\n     * @return whether the region matched\\n     */\\n    static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,\\n            final CharSequence substring, final int start, final int length) {\\n        if (cs instanceof String && substring instanceof String) {\\n            return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);\\n        }\\n        int index1 = thisStart;\\n        int index2 = start;\\n        int tmpLen = length;\\n\\n        while (tmpLen-- > 0) {\\n            final char c1 = cs.charAt(index1++);\\n            final char c2 = substring.charAt(index2++);\\n\\n            if (c1 == c2) {\\n                continue;\\n            }\\n\\n            if (!ignoreCase) {\\n                return false;\\n            }\\n\\n            // The same check as in String.regionMatches():\\n            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) &&\\n                    Character.toLowerCase(c1) != Character.toLowerCase(c2)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"regionMatches\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 49, \"end_line\": 78, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,\\n            final CharSequence substring, final int start, final int length) {\\n        if (cs instanceof String && substring instanceof String) {\\n            return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);\\n        }\\n        int index1 = thisStart;\\n        int index2 = start;\\n        int tmpLen = length;\\n\\n        while (tmpLen-- > 0) {\\n            final char c1 = cs.charAt(index1++);\\n            final char c2 = substring.charAt(index2++);\\n\\n            if (c1 == c2) {\\n                continue;\\n            }\\n\\n            if (!ignoreCase) {\\n                return false;\\n            }\\n\\n            // The same check as in String.regionMatches():\\n            if (Character.toUpperCase(c1) != Character.toUpperCase(c2) &&\\n                    Character.toLowerCase(c1) != Character.toLowerCase(c2)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"cs\", \"type\": \"CharSequence\"}, {\"name\": \"ignoreCase\", \"type\": \"boolean\"}, {\"name\": \"thisStart\", \"type\": \"int\"}, {\"name\": \"substring\", \"type\": \"CharSequence\"}, {\"name\": \"start\", \"type\": \"int\"}, {\"name\": \"length\", \"type\": \"int\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/Hex.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.binary;\\n\\nimport java.nio.ByteBuffer;\\nimport java.nio.charset.Charset;\\n\\nimport org.apache.commons.codec.BinaryDecoder;\\nimport org.apache.commons.codec.BinaryEncoder;\\nimport org.apache.commons.codec.CharEncoding;\\nimport org.apache.commons.codec.Charsets;\\nimport org.apache.commons.codec.DecoderException;\\nimport org.apache.commons.codec.EncoderException;\\n\\n/**\\n * Converts hexadecimal Strings. The charset used for certain operation can be set, the default is set in\\n * {@link #DEFAULT_CHARSET_NAME}\\n *\\n * This class is thread-safe.\\n *\\n * @since 1.1\\n * @version $Id: Hex.java 1811344 2017-10-06 15:19:57Z ggregory $\\n */\\npublic class Hex implements BinaryEncoder, BinaryDecoder {\\n\\n    /**\\n     * Default charset is {@link Charsets#UTF_8}\\n     *\\n     * @since 1.7\\n     */\\n    public static final Charset DEFAULT_CHARSET = Charsets.UTF_8;\\n\\n    /**\\n     * Default charset name is {@link CharEncoding#UTF_8}\\n     *\\n     * @since 1.4\\n     */\\n    public static final String DEFAULT_CHARSET_NAME = CharEncoding.UTF_8;\\n\\n    /**\\n     * Used to build output as Hex\\n     */\\n    private static final char[] DIGITS_LOWER =\\n        {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\\n\\n    /**\\n     * Used to build output as Hex\\n     */\\n    private static final char[] DIGITS_UPPER =\\n        {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\\n\\n    /**\\n     * Converts a String representing hexadecimal values into an array of bytes of those same values. The\\n     * returned array will be half the length of the passed String, as it takes two characters to represent any given\\n     * byte. An exception is thrown if the passed String has an odd number of elements.\\n     *\\n     * @param data\\n     *            A String containing hexadecimal digits\\n     * @return A byte array containing binary data decoded from the supplied char array.\\n     * @throws DecoderException\\n     *             Thrown if an odd number or illegal of characters is supplied\\n     * @since 1.11\\n     */\\n    public static byte[] decodeHex(final String data) throws DecoderException {\\n        return decodeHex(data.toCharArray());\\n    }\\n\\n    /**\\n     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The\\n     * returned array will be half the length of the passed array, as it takes two characters to represent any given\\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\\n     *\\n     * @param data\\n     *            An array of characters containing hexadecimal digits\\n     * @return A byte array containing binary data decoded from the supplied char array.\\n     * @throws DecoderException\\n     *             Thrown if an odd number or illegal of characters is supplied\\n     */\\n    public static byte[] decodeHex(final char[] data) throws DecoderException {\\n\\n        final int len = data.length;\\n\\n        if ((len & 0x01) != 0) {\\n            throw new DecoderException(\\\"Odd number of characters.\\\");\\n        }\\n\\n        final byte[] out = new byte[len >> 1];\\n\\n        // two characters form the hex value.\\n        for (int i = 0, j = 0; j < len; i++) {\\n            int f = toDigit(data[j], j) << 4;\\n            j++;\\n            f = f | toDigit(data[j], j);\\n            j++;\\n            out[i] = (byte) (f & 0xFF);\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\\n     * given byte.\\n     *\\n     * @param data\\n     *            a byte[] to convert to Hex characters\\n     * @return A char[] containing lower-case hexadecimal characters\\n     */\\n    public static char[] encodeHex(final byte[] data) {\\n        return encodeHex(data, true);\\n    }\\n\\n    /**\\n     * Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order.\\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\\n     * given byte.\\n     *\\n     * @param data\\n     *            a byte buffer to convert to Hex characters\\n     * @return A char[] containing lower-case hexadecimal characters\\n     * @since 1.11\\n     */\\n    public static char[] encodeHex(final ByteBuffer data) {\\n        return encodeHex(data, true);\\n    }\\n\\n    /**\\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\\n     * given byte.\\n     *\\n     * @param data\\n     *            a byte[] to convert to Hex characters\\n     * @param toLowerCase\\n     *            <code>true</code> converts to lowercase, <code>false</code> to uppercase\\n     * @return A char[] containing hexadecimal characters in the selected case\\n     * @since 1.4\\n     */\\n    public static char[] encodeHex(final byte[] data, final boolean toLowerCase) {\\n        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\\n    }\\n\\n    /**\\n     * Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order.\\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\\n     * given byte.\\n     *\\n     * @param data\\n     *            a byte buffer to convert to Hex characters\\n     * @param toLowerCase\\n     *            <code>true</code> converts to lowercase, <code>false</code> to uppercase\\n     * @return A char[] containing hexadecimal characters in the selected case\\n     * @since 1.11\\n     */\\n    public static char[] encodeHex(final ByteBuffer data, final boolean toLowerCase) {\\n        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\\n    }\\n\\n    /**\\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\\n     * given byte.\\n     *\\n     * @param data\\n     *            a byte[] to convert to Hex characters\\n     * @param toDigits\\n     *            the output alphabet (must contain at least 16 chars)\\n     * @return A char[] containing the appropriate characters from the alphabet\\n     *         For best results, this should be either upper- or lower-case hex.\\n     * @since 1.4\\n     */\\n    protected static char[] encodeHex(final byte[] data, final char[] toDigits) {\\n        final int l = data.length;\\n        final char[] out = new char[l << 1];\\n        // two characters form the hex value.\\n        for (int i = 0, j = 0; i < l; i++) {\\n            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];\\n            out[j++] = toDigits[0x0F & data[i]];\\n        }\\n        return out;\\n    }\\n\\n    /**\\n     * Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order.\\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\\n     * given byte.\\n     *\\n     * @param data\\n     *            a byte buffer to convert to Hex characters\\n     * @param toDigits\\n     *            the output alphabet (must be at least 16 characters)\\n     * @return A char[] containing the appropriate characters from the alphabet\\n     *         For best results, this should be either upper- or lower-case hex.\\n     * @since 1.11\\n     */\\n    protected static char[] encodeHex(final ByteBuffer data, final char[] toDigits) {\\n        return encodeHex(data.array(), toDigits);\\n    }\\n\\n    /**\\n     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\\n     *\\n     * @param data\\n     *            a byte[] to convert to Hex characters\\n     * @return A String containing lower-case hexadecimal characters\\n     * @since 1.4\\n     */\\n    public static String encodeHexString(final byte[] data) {\\n        return new String(encodeHex(data));\\n    }\\n\\n    /**\\n     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\\n     *\\n     * @param data\\n     *            a byte[] to convert to Hex characters\\n     * @param toLowerCase\\n     *            <code>true</code> converts to lowercase, <code>false</code> to uppercase\\n     * @return A String containing lower-case hexadecimal characters\\n     * @since 1.11\\n     */\\n    public static String encodeHexString(final byte[] data, final boolean toLowerCase) {\\n        return new String(encodeHex(data, toLowerCase));\\n    }\\n\\n    /**\\n     * Converts a byte buffer into a String representing the hexadecimal values of each byte in order. The returned\\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\\n     *\\n     * @param data\\n     *            a byte buffer to convert to Hex characters\\n     * @return A String containing lower-case hexadecimal characters\\n     * @since 1.11\\n     */\\n    public static String encodeHexString(final ByteBuffer data) {\\n        return new String(encodeHex(data));\\n    }\\n\\n    /**\\n     * Converts a byte buffer into a String representing the hexadecimal values of each byte in order. The returned\\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\\n     *\\n     * @param data\\n     *            a byte buffer to convert to Hex characters\\n     * @param toLowerCase\\n     *            <code>true</code> converts to lowercase, <code>false</code> to uppercase\\n     * @return A String containing lower-case hexadecimal characters\\n     * @since 1.11\\n     */\\n    public static String encodeHexString(final ByteBuffer data, final boolean toLowerCase) {\\n        return new String(encodeHex(data, toLowerCase));\\n    }\\n\\n    /**\\n     * Converts a hexadecimal character to an integer.\\n     *\\n     * @param ch\\n     *            A character to convert to an integer digit\\n     * @param index\\n     *            The index of the character in the source\\n     * @return An integer\\n     * @throws DecoderException\\n     *             Thrown if ch is an illegal hex character\\n     */\\n    protected static int toDigit(final char ch, final int index) throws DecoderException {\\n        final int digit = Character.digit(ch, 16);\\n        if (digit == -1) {\\n            throw new DecoderException(\\\"Illegal hexadecimal character \\\" + ch + \\\" at index \\\" + index);\\n        }\\n        return digit;\\n    }\\n\\n    private final Charset charset;\\n\\n    /**\\n     * Creates a new codec with the default charset name {@link #DEFAULT_CHARSET}\\n     */\\n    public Hex() {\\n        // use default encoding\\n        this.charset = DEFAULT_CHARSET;\\n    }\\n\\n    /**\\n     * Creates a new codec with the given Charset.\\n     *\\n     * @param charset\\n     *            the charset.\\n     * @since 1.7\\n     */\\n    public Hex(final Charset charset) {\\n        this.charset = charset;\\n    }\\n\\n    /**\\n     * Creates a new codec with the given charset name.\\n     *\\n     * @param charsetName\\n     *            the charset name.\\n     * @throws java.nio.charset.UnsupportedCharsetException\\n     *             If the named charset is unavailable\\n     * @since 1.4\\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\\n     */\\n    public Hex(final String charsetName) {\\n        this(Charset.forName(charsetName));\\n    }\\n\\n    /**\\n     * Converts an array of character bytes representing hexadecimal values into an array of bytes of those same values.\\n     * The returned array will be half the length of the passed array, as it takes two characters to represent any given\\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\\n     *\\n     * @param array\\n     *            An array of character bytes containing hexadecimal digits\\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\\n     * @throws DecoderException\\n     *             Thrown if an odd number of characters is supplied to this function\\n     * @see #decodeHex(char[])\\n     */\\n    @Override\\n    public byte[] decode(final byte[] array) throws DecoderException {\\n        return decodeHex(new String(array, getCharset()).toCharArray());\\n    }\\n\\n    /**\\n     * Converts a buffer of character bytes representing hexadecimal values into an array of bytes of those same values.\\n     * The returned array will be half the length of the passed array, as it takes two characters to represent any given\\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\\n     *\\n     * @param buffer\\n     *            An array of character bytes containing hexadecimal digits\\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\\n     * @throws DecoderException\\n     *             Thrown if an odd number of characters is supplied to this function\\n     * @see #decodeHex(char[])\\n     * @since 1.11\\n     */\\n    public byte[] decode(final ByteBuffer buffer) throws DecoderException {\\n        return decodeHex(new String(buffer.array(), getCharset()).toCharArray());\\n    }\\n\\n    /**\\n     * Converts a String or an array of character bytes representing hexadecimal values into an array of bytes of those\\n     * same values. The returned array will be half the length of the passed String or array, as it takes two characters\\n     * to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.\\n     *\\n     * @param object\\n     *            A String, ByteBuffer, byte[], or an array of character bytes containing hexadecimal digits\\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\\n     * @throws DecoderException\\n     *             Thrown if an odd number of characters is supplied to this function or the object is not a String or\\n     *             char[]\\n     * @see #decodeHex(char[])\\n     */\\n    @Override\\n    public Object decode(final Object object) throws DecoderException {\\n        if (object instanceof String) {\\n            return decode(((String) object).toCharArray());\\n        } else if (object instanceof byte[]) {\\n            return decode((byte[]) object);\\n        } else if (object instanceof ByteBuffer) {\\n            return decode((ByteBuffer) object);\\n        } else {\\n            try {\\n                return decodeHex((char[]) object);\\n            } catch (final ClassCastException e) {\\n                throw new DecoderException(e.getMessage(), e);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Converts an array of bytes into an array of bytes for the characters representing the hexadecimal values of each\\n     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to\\n     * represent any given byte.\\n     * <p>\\n     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by\\n     * {@link #getCharset()}.\\n     * </p>\\n     *\\n     * @param array\\n     *            a byte[] to convert to Hex characters\\n     * @return A byte[] containing the bytes of the lower-case hexadecimal characters\\n     * @since 1.7 No longer throws IllegalStateException if the charsetName is invalid.\\n     * @see #encodeHex(byte[])\\n     */\\n    @Override\\n    public byte[] encode(final byte[] array) {\\n        return encodeHexString(array).getBytes(this.getCharset());\\n    }\\n\\n    /**\\n     * Converts byte buffer into an array of bytes for the characters representing the hexadecimal values of each\\n     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to\\n     * represent any given byte.\\n     * <p>\\n     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by\\n     * {@link #getCharset()}.\\n     * </p>\\n     *\\n     * @param array\\n     *            a byte buffer to convert to Hex characters\\n     * @return A byte[] containing the bytes of the lower-case hexadecimal characters\\n     * @see #encodeHex(byte[])\\n     * @since 1.11\\n     */\\n    public byte[] encode(final ByteBuffer array) {\\n        return encodeHexString(array).getBytes(this.getCharset());\\n    }\\n\\n    /**\\n     * Converts a String or an array of bytes into an array of characters representing the hexadecimal values of each\\n     * byte in order. The returned array will be double the length of the passed String or array, as it takes two\\n     * characters to represent any given byte.\\n     * <p>\\n     * The conversion from hexadecimal characters to bytes to be encoded to performed with the charset named by\\n     * {@link #getCharset()}.\\n     * </p>\\n     *\\n     * @param object\\n     *            a String, ByteBuffer, or byte[] to convert to Hex characters\\n     * @return A char[] containing lower-case hexadecimal characters\\n     * @throws EncoderException\\n     *             Thrown if the given object is not a String or byte[]\\n     * @see #encodeHex(byte[])\\n     */\\n    @Override\\n    public Object encode(final Object object) throws EncoderException {\\n        byte[] byteArray;\\n        if (object instanceof String) {\\n            byteArray = ((String) object).getBytes(this.getCharset());\\n        } else if (object instanceof ByteBuffer) {\\n            byteArray = ((ByteBuffer) object).array();\\n        } else {\\n            try {\\n                byteArray = (byte[]) object;\\n            } catch (final ClassCastException e) {\\n                throw new EncoderException(e.getMessage(), e);\\n            }\\n        }\\n        return encodeHex(byteArray);\\n    }\\n\\n    /**\\n     * Gets the charset.\\n     *\\n     * @return the charset.\\n     * @since 1.7\\n     */\\n    public Charset getCharset() {\\n        return this.charset;\\n    }\\n\\n    /**\\n     * Gets the charset name.\\n     *\\n     * @return the charset name.\\n     * @since 1.4\\n     */\\n    public String getCharsetName() {\\n        return this.charset.name();\\n    }\\n\\n    /**\\n     * Returns a string representation of the object, which includes the charset name.\\n     *\\n     * @return a string representation of the object.\\n     */\\n    @Override\\n    public String toString() {\\n        return super.toString() + \\\"[charsetName=\\\" + this.charset + \\\"]\\\";\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Hex\", \"position\": {\"start_line\": 39, \"end_line\": 491, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Hex implements BinaryEncoder, BinaryDecoder {\\n\\n    /**\\n     * Default charset is {@link Charsets#UTF_8}\\n     *\\n     * @since 1.7\\n     */\\n    public static final Charset DEFAULT_CHARSET = Charsets.UTF_8;\\n\\n    /**\\n     * Default charset name is {@link CharEncoding#UTF_8}\\n     *\\n     * @since 1.4\\n     */\\n    public static final String DEFAULT_CHARSET_NAME = CharEncoding.UTF_8;\\n\\n    /**\\n     * Used to build output as Hex\\n     */\\n    private static final char[] DIGITS_LOWER =\\n        {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\\n\\n    /**\\n     * Used to build output as Hex\\n     */\\n    private static final char[] DIGITS_UPPER =\\n        {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\\n\\n    /**\\n     * Converts a String representing hexadecimal values into an array of bytes of those same values. The\\n     * returned array will be half the length of the passed String, as it takes two characters to represent any given\\n     * byte. An exception is thrown if the passed String has an odd number of elements.\\n     *\\n     * @param data\\n     *            A String containing hexadecimal digits\\n     * @return A byte array containing binary data decoded from the supplied char array.\\n     * @throws DecoderException\\n     *             Thrown if an odd number or illegal of characters is supplied\\n     * @since 1.11\\n     */\\n    public static byte[] decodeHex(final String data) throws DecoderException {\\n        return decodeHex(data.toCharArray());\\n    }\\n\\n    /**\\n     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The\\n     * returned array will be half the length of the passed array, as it takes two characters to represent any given\\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\\n     *\\n     * @param data\\n     *            An array of characters containing hexadecimal digits\\n     * @return A byte array containing binary data decoded from the supplied char array.\\n     * @throws DecoderException\\n     *             Thrown if an odd number or illegal of characters is supplied\\n     */\\n    public static byte[] decodeHex(final char[] data) throws DecoderException {\\n\\n        final int len = data.length;\\n\\n        if ((len & 0x01) != 0) {\\n            throw new DecoderException(\\\"Odd number of characters.\\\");\\n        }\\n\\n        final byte[] out = new byte[len >> 1];\\n\\n        // two characters form the hex value.\\n        for (int i = 0, j = 0; j < len; i++) {\\n            int f = toDigit(data[j], j) << 4;\\n            j++;\\n            f = f | toDigit(data[j], j);\\n            j++;\\n            out[i] = (byte) (f & 0xFF);\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\\n     * given byte.\\n     *\\n     * @param data\\n     *            a byte[] to convert to Hex characters\\n     * @return A char[] containing lower-case hexadecimal characters\\n     */\\n    public static char[] encodeHex(final byte[] data) {\\n        return encodeHex(data, true);\\n    }\\n\\n    /**\\n     * Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order.\\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\\n     * given byte.\\n     *\\n     * @param data\\n     *            a byte buffer to convert to Hex characters\\n     * @return A char[] containing lower-case hexadecimal characters\\n     * @since 1.11\\n     */\\n    public static char[] encodeHex(final ByteBuffer data) {\\n        return encodeHex(data, true);\\n    }\\n\\n    /**\\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\\n     * given byte.\\n     *\\n     * @param data\\n     *            a byte[] to convert to Hex characters\\n     * @param toLowerCase\\n     *            <code>true</code> converts to lowercase, <code>false</code> to uppercase\\n     * @return A char[] containing hexadecimal characters in the selected case\\n     * @since 1.4\\n     */\\n    public static char[] encodeHex(final byte[] data, final boolean toLowerCase) {\\n        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\\n    }\\n\\n    /**\\n     * Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order.\\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\\n     * given byte.\\n     *\\n     * @param data\\n     *            a byte buffer to convert to Hex characters\\n     * @param toLowerCase\\n     *            <code>true</code> converts to lowercase, <code>false</code> to uppercase\\n     * @return A char[] containing hexadecimal characters in the selected case\\n     * @since 1.11\\n     */\\n    public static char[] encodeHex(final ByteBuffer data, final boolean toLowerCase) {\\n        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\\n    }\\n\\n    /**\\n     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.\\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\\n     * given byte.\\n     *\\n     * @param data\\n     *            a byte[] to convert to Hex characters\\n     * @param toDigits\\n     *            the output alphabet (must contain at least 16 chars)\\n     * @return A char[] containing the appropriate characters from the alphabet\\n     *         For best results, this should be either upper- or lower-case hex.\\n     * @since 1.4\\n     */\\n    protected static char[] encodeHex(final byte[] data, final char[] toDigits) {\\n        final int l = data.length;\\n        final char[] out = new char[l << 1];\\n        // two characters form the hex value.\\n        for (int i = 0, j = 0; i < l; i++) {\\n            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];\\n            out[j++] = toDigits[0x0F & data[i]];\\n        }\\n        return out;\\n    }\\n\\n    /**\\n     * Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order.\\n     * The returned array will be double the length of the passed array, as it takes two characters to represent any\\n     * given byte.\\n     *\\n     * @param data\\n     *            a byte buffer to convert to Hex characters\\n     * @param toDigits\\n     *            the output alphabet (must be at least 16 characters)\\n     * @return A char[] containing the appropriate characters from the alphabet\\n     *         For best results, this should be either upper- or lower-case hex.\\n     * @since 1.11\\n     */\\n    protected static char[] encodeHex(final ByteBuffer data, final char[] toDigits) {\\n        return encodeHex(data.array(), toDigits);\\n    }\\n\\n    /**\\n     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\\n     *\\n     * @param data\\n     *            a byte[] to convert to Hex characters\\n     * @return A String containing lower-case hexadecimal characters\\n     * @since 1.4\\n     */\\n    public static String encodeHexString(final byte[] data) {\\n        return new String(encodeHex(data));\\n    }\\n\\n    /**\\n     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned\\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\\n     *\\n     * @param data\\n     *            a byte[] to convert to Hex characters\\n     * @param toLowerCase\\n     *            <code>true</code> converts to lowercase, <code>false</code> to uppercase\\n     * @return A String containing lower-case hexadecimal characters\\n     * @since 1.11\\n     */\\n    public static String encodeHexString(final byte[] data, final boolean toLowerCase) {\\n        return new String(encodeHex(data, toLowerCase));\\n    }\\n\\n    /**\\n     * Converts a byte buffer into a String representing the hexadecimal values of each byte in order. The returned\\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\\n     *\\n     * @param data\\n     *            a byte buffer to convert to Hex characters\\n     * @return A String containing lower-case hexadecimal characters\\n     * @since 1.11\\n     */\\n    public static String encodeHexString(final ByteBuffer data) {\\n        return new String(encodeHex(data));\\n    }\\n\\n    /**\\n     * Converts a byte buffer into a String representing the hexadecimal values of each byte in order. The returned\\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\\n     *\\n     * @param data\\n     *            a byte buffer to convert to Hex characters\\n     * @param toLowerCase\\n     *            <code>true</code> converts to lowercase, <code>false</code> to uppercase\\n     * @return A String containing lower-case hexadecimal characters\\n     * @since 1.11\\n     */\\n    public static String encodeHexString(final ByteBuffer data, final boolean toLowerCase) {\\n        return new String(encodeHex(data, toLowerCase));\\n    }\\n\\n    /**\\n     * Converts a hexadecimal character to an integer.\\n     *\\n     * @param ch\\n     *            A character to convert to an integer digit\\n     * @param index\\n     *            The index of the character in the source\\n     * @return An integer\\n     * @throws DecoderException\\n     *             Thrown if ch is an illegal hex character\\n     */\\n    protected static int toDigit(final char ch, final int index) throws DecoderException {\\n        final int digit = Character.digit(ch, 16);\\n        if (digit == -1) {\\n            throw new DecoderException(\\\"Illegal hexadecimal character \\\" + ch + \\\" at index \\\" + index);\\n        }\\n        return digit;\\n    }\\n\\n    private final Charset charset;\\n\\n    /**\\n     * Creates a new codec with the default charset name {@link #DEFAULT_CHARSET}\\n     */\\n    public Hex() {\\n        // use default encoding\\n        this.charset = DEFAULT_CHARSET;\\n    }\\n\\n    /**\\n     * Creates a new codec with the given Charset.\\n     *\\n     * @param charset\\n     *            the charset.\\n     * @since 1.7\\n     */\\n    public Hex(final Charset charset) {\\n        this.charset = charset;\\n    }\\n\\n    /**\\n     * Creates a new codec with the given charset name.\\n     *\\n     * @param charsetName\\n     *            the charset name.\\n     * @throws java.nio.charset.UnsupportedCharsetException\\n     *             If the named charset is unavailable\\n     * @since 1.4\\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\\n     */\\n    public Hex(final String charsetName) {\\n        this(Charset.forName(charsetName));\\n    }\\n\\n    /**\\n     * Converts an array of character bytes representing hexadecimal values into an array of bytes of those same values.\\n     * The returned array will be half the length of the passed array, as it takes two characters to represent any given\\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\\n     *\\n     * @param array\\n     *            An array of character bytes containing hexadecimal digits\\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\\n     * @throws DecoderException\\n     *             Thrown if an odd number of characters is supplied to this function\\n     * @see #decodeHex(char[])\\n     */\\n    @Override\\n    public byte[] decode(final byte[] array) throws DecoderException {\\n        return decodeHex(new String(array, getCharset()).toCharArray());\\n    }\\n\\n    /**\\n     * Converts a buffer of character bytes representing hexadecimal values into an array of bytes of those same values.\\n     * The returned array will be half the length of the passed array, as it takes two characters to represent any given\\n     * byte. An exception is thrown if the passed char array has an odd number of elements.\\n     *\\n     * @param buffer\\n     *            An array of character bytes containing hexadecimal digits\\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\\n     * @throws DecoderException\\n     *             Thrown if an odd number of characters is supplied to this function\\n     * @see #decodeHex(char[])\\n     * @since 1.11\\n     */\\n    public byte[] decode(final ByteBuffer buffer) throws DecoderException {\\n        return decodeHex(new String(buffer.array(), getCharset()).toCharArray());\\n    }\\n\\n    /**\\n     * Converts a String or an array of character bytes representing hexadecimal values into an array of bytes of those\\n     * same values. The returned array will be half the length of the passed String or array, as it takes two characters\\n     * to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.\\n     *\\n     * @param object\\n     *            A String, ByteBuffer, byte[], or an array of character bytes containing hexadecimal digits\\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\\n     * @throws DecoderException\\n     *             Thrown if an odd number of characters is supplied to this function or the object is not a String or\\n     *             char[]\\n     * @see #decodeHex(char[])\\n     */\\n    @Override\\n    public Object decode(final Object object) throws DecoderException {\\n        if (object instanceof String) {\\n            return decode(((String) object).toCharArray());\\n        } else if (object instanceof byte[]) {\\n            return decode((byte[]) object);\\n        } else if (object instanceof ByteBuffer) {\\n            return decode((ByteBuffer) object);\\n        } else {\\n            try {\\n                return decodeHex((char[]) object);\\n            } catch (final ClassCastException e) {\\n                throw new DecoderException(e.getMessage(), e);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Converts an array of bytes into an array of bytes for the characters representing the hexadecimal values of each\\n     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to\\n     * represent any given byte.\\n     * <p>\\n     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by\\n     * {@link #getCharset()}.\\n     * </p>\\n     *\\n     * @param array\\n     *            a byte[] to convert to Hex characters\\n     * @return A byte[] containing the bytes of the lower-case hexadecimal characters\\n     * @since 1.7 No longer throws IllegalStateException if the charsetName is invalid.\\n     * @see #encodeHex(byte[])\\n     */\\n    @Override\\n    public byte[] encode(final byte[] array) {\\n        return encodeHexString(array).getBytes(this.getCharset());\\n    }\\n\\n    /**\\n     * Converts byte buffer into an array of bytes for the characters representing the hexadecimal values of each\\n     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to\\n     * represent any given byte.\\n     * <p>\\n     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by\\n     * {@link #getCharset()}.\\n     * </p>\\n     *\\n     * @param array\\n     *            a byte buffer to convert to Hex characters\\n     * @return A byte[] containing the bytes of the lower-case hexadecimal characters\\n     * @see #encodeHex(byte[])\\n     * @since 1.11\\n     */\\n    public byte[] encode(final ByteBuffer array) {\\n        return encodeHexString(array).getBytes(this.getCharset());\\n    }\\n\\n    /**\\n     * Converts a String or an array of bytes into an array of characters representing the hexadecimal values of each\\n     * byte in order. The returned array will be double the length of the passed String or array, as it takes two\\n     * characters to represent any given byte.\\n     * <p>\\n     * The conversion from hexadecimal characters to bytes to be encoded to performed with the charset named by\\n     * {@link #getCharset()}.\\n     * </p>\\n     *\\n     * @param object\\n     *            a String, ByteBuffer, or byte[] to convert to Hex characters\\n     * @return A char[] containing lower-case hexadecimal characters\\n     * @throws EncoderException\\n     *             Thrown if the given object is not a String or byte[]\\n     * @see #encodeHex(byte[])\\n     */\\n    @Override\\n    public Object encode(final Object object) throws EncoderException {\\n        byte[] byteArray;\\n        if (object instanceof String) {\\n            byteArray = ((String) object).getBytes(this.getCharset());\\n        } else if (object instanceof ByteBuffer) {\\n            byteArray = ((ByteBuffer) object).array();\\n        } else {\\n            try {\\n                byteArray = (byte[]) object;\\n            } catch (final ClassCastException e) {\\n                throw new EncoderException(e.getMessage(), e);\\n            }\\n        }\\n        return encodeHex(byteArray);\\n    }\\n\\n    /**\\n     * Gets the charset.\\n     *\\n     * @return the charset.\\n     * @since 1.7\\n     */\\n    public Charset getCharset() {\\n        return this.charset;\\n    }\\n\\n    /**\\n     * Gets the charset name.\\n     *\\n     * @return the charset name.\\n     * @since 1.4\\n     */\\n    public String getCharsetName() {\\n        return this.charset.name();\\n    }\\n\\n    /**\\n     * Returns a string representation of the object, which includes the charset name.\\n     *\\n     * @return a string representation of the object.\\n     */\\n    @Override\\n    public String toString() {\\n        return super.toString() + \\\"[charsetName=\\\" + this.charset + \\\"]\\\";\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"decodeHex\", \"return_type\": \"byte\", \"position\": {\"start_line\": 79, \"end_line\": 81, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] decodeHex(final String data) throws DecoderException {\\n        return decodeHex(data.toCharArray());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"decodeHex\", \"return_type\": \"byte\", \"position\": {\"start_line\": 94, \"end_line\": 114, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] decodeHex(final char[] data) throws DecoderException {\\n\\n        final int len = data.length;\\n\\n        if ((len & 0x01) != 0) {\\n            throw new DecoderException(\\\"Odd number of characters.\\\");\\n        }\\n\\n        final byte[] out = new byte[len >> 1];\\n\\n        // two characters form the hex value.\\n        for (int i = 0, j = 0; j < len; i++) {\\n            int f = toDigit(data[j], j) << 4;\\n            j++;\\n            f = f | toDigit(data[j], j);\\n            j++;\\n            out[i] = (byte) (f & 0xFF);\\n        }\\n\\n        return out;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"char\"}]}, {\"name\": \"encodeHex\", \"return_type\": \"char\", \"position\": {\"start_line\": 125, \"end_line\": 127, \"start_column\": 19, \"end_column\": 5}, \"code\": \"char[] encodeHex(final byte[] data) {\\n        return encodeHex(data, true);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"encodeHex\", \"return_type\": \"char\", \"position\": {\"start_line\": 139, \"end_line\": 141, \"start_column\": 19, \"end_column\": 5}, \"code\": \"char[] encodeHex(final ByteBuffer data) {\\n        return encodeHex(data, true);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"ByteBuffer\"}]}, {\"name\": \"encodeHex\", \"return_type\": \"char\", \"position\": {\"start_line\": 155, \"end_line\": 157, \"start_column\": 19, \"end_column\": 5}, \"code\": \"char[] encodeHex(final byte[] data, final boolean toLowerCase) {\\n        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}, {\"name\": \"toLowerCase\", \"type\": \"boolean\"}]}, {\"name\": \"encodeHex\", \"return_type\": \"char\", \"position\": {\"start_line\": 171, \"end_line\": 173, \"start_column\": 19, \"end_column\": 5}, \"code\": \"char[] encodeHex(final ByteBuffer data, final boolean toLowerCase) {\\n        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"ByteBuffer\"}, {\"name\": \"toLowerCase\", \"type\": \"boolean\"}]}, {\"name\": \"encodeHex\", \"return_type\": \"char\", \"position\": {\"start_line\": 188, \"end_line\": 197, \"start_column\": 22, \"end_column\": 5}, \"code\": \"char[] encodeHex(final byte[] data, final char[] toDigits) {\\n        final int l = data.length;\\n        final char[] out = new char[l << 1];\\n        // two characters form the hex value.\\n        for (int i = 0, j = 0; i < l; i++) {\\n            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];\\n            out[j++] = toDigits[0x0F & data[i]];\\n        }\\n        return out;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}, {\"name\": \"toDigits\", \"type\": \"char\"}]}, {\"name\": \"encodeHex\", \"return_type\": \"char\", \"position\": {\"start_line\": 212, \"end_line\": 214, \"start_column\": 22, \"end_column\": 5}, \"code\": \"char[] encodeHex(final ByteBuffer data, final char[] toDigits) {\\n        return encodeHex(data.array(), toDigits);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"ByteBuffer\"}, {\"name\": \"toDigits\", \"type\": \"char\"}]}, {\"name\": \"encodeHexString\", \"return_type\": \"String\", \"position\": {\"start_line\": 225, \"end_line\": 227, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String encodeHexString(final byte[] data) {\\n        return new String(encodeHex(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"encodeHexString\", \"return_type\": \"String\", \"position\": {\"start_line\": 240, \"end_line\": 242, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String encodeHexString(final byte[] data, final boolean toLowerCase) {\\n        return new String(encodeHex(data, toLowerCase));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}, {\"name\": \"toLowerCase\", \"type\": \"boolean\"}]}, {\"name\": \"encodeHexString\", \"return_type\": \"String\", \"position\": {\"start_line\": 253, \"end_line\": 255, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String encodeHexString(final ByteBuffer data) {\\n        return new String(encodeHex(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"ByteBuffer\"}]}, {\"name\": \"encodeHexString\", \"return_type\": \"String\", \"position\": {\"start_line\": 268, \"end_line\": 270, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String encodeHexString(final ByteBuffer data, final boolean toLowerCase) {\\n        return new String(encodeHex(data, toLowerCase));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"ByteBuffer\"}, {\"name\": \"toLowerCase\", \"type\": \"boolean\"}]}, {\"name\": \"toDigit\", \"return_type\": \"int\", \"position\": {\"start_line\": 283, \"end_line\": 289, \"start_column\": 22, \"end_column\": 5}, \"code\": \"int toDigit(final char ch, final int index) throws DecoderException {\\n        final int digit = Character.digit(ch, 16);\\n        if (digit == -1) {\\n            throw new DecoderException(\\\"Illegal hexadecimal character \\\" + ch + \\\" at index \\\" + index);\\n        }\\n        return digit;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ch\", \"type\": \"char\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"decode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 339, \"end_line\": 341, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] decode(final byte[] array) throws DecoderException {\\n        return decodeHex(new String(array, getCharset()).toCharArray());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"array\", \"type\": \"byte\"}]}, {\"name\": \"decode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 356, \"end_line\": 358, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] decode(final ByteBuffer buffer) throws DecoderException {\\n        return decodeHex(new String(buffer.array(), getCharset()).toCharArray());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"buffer\", \"type\": \"ByteBuffer\"}]}, {\"name\": \"decode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 374, \"end_line\": 388, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object decode(final Object object) throws DecoderException {\\n        if (object instanceof String) {\\n            return decode(((String) object).toCharArray());\\n        } else if (object instanceof byte[]) {\\n            return decode((byte[]) object);\\n        } else if (object instanceof ByteBuffer) {\\n            return decode((ByteBuffer) object);\\n        } else {\\n            try {\\n                return decodeHex((char[]) object);\\n            } catch (final ClassCastException e) {\\n                throw new DecoderException(e.getMessage(), e);\\n            }\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"object\", \"type\": \"Object\"}]}, {\"name\": \"encode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 406, \"end_line\": 408, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] encode(final byte[] array) {\\n        return encodeHexString(array).getBytes(this.getCharset());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"array\", \"type\": \"byte\"}]}, {\"name\": \"encode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 425, \"end_line\": 427, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] encode(final ByteBuffer array) {\\n        return encodeHexString(array).getBytes(this.getCharset());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"array\", \"type\": \"ByteBuffer\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 446, \"end_line\": 460, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object object) throws EncoderException {\\n        byte[] byteArray;\\n        if (object instanceof String) {\\n            byteArray = ((String) object).getBytes(this.getCharset());\\n        } else if (object instanceof ByteBuffer) {\\n            byteArray = ((ByteBuffer) object).array();\\n        } else {\\n            try {\\n                byteArray = (byte[]) object;\\n            } catch (final ClassCastException e) {\\n                throw new EncoderException(e.getMessage(), e);\\n            }\\n        }\\n        return encodeHex(byteArray);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"object\", \"type\": \"Object\"}]}, {\"name\": \"getCharset\", \"return_type\": \"Charset\", \"position\": {\"start_line\": 468, \"end_line\": 470, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Charset getCharset() {\\n        return this.charset;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getCharsetName\", \"return_type\": \"String\", \"position\": {\"start_line\": 478, \"end_line\": 480, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getCharsetName() {\\n        return this.charset.name();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 488, \"end_line\": 490, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String toString() {\\n        return super.toString() + \\\"[charsetName=\\\" + this.charset + \\\"]\\\";\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/binary/StringUtils.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.binary;\\n\\nimport java.io.UnsupportedEncodingException;\\nimport java.nio.ByteBuffer;\\nimport java.nio.charset.Charset;\\n\\nimport org.apache.commons.codec.CharEncoding;\\nimport org.apache.commons.codec.Charsets;\\n\\n/**\\n * Converts String to and from bytes using the encodings required by the Java specification. These encodings are\\n * specified in <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">\\n * Standard charsets</a>.\\n *\\n * <p>This class is immutable and thread-safe.</p>\\n *\\n * @see CharEncoding\\n * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n * @version $Id: StringUtils.java 1789539 2017-03-30 16:36:28Z sebb $\\n * @since 1.4\\n */\\npublic class StringUtils {\\n\\n    /**\\n     * <p>\\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\\n     * </p>\\n     *\\n     * <p>\\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\\n     * The comparison is case sensitive.\\n     * </p>\\n     *\\n     * <pre>\\n     * StringUtils.equals(null, null)   = true\\n     * StringUtils.equals(null, \\\"abc\\\")  = false\\n     * StringUtils.equals(\\\"abc\\\", null)  = false\\n     * StringUtils.equals(\\\"abc\\\", \\\"abc\\\") = true\\n     * StringUtils.equals(\\\"abc\\\", \\\"ABC\\\") = false\\n     * </pre>\\n     *\\n     * <p>\\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\\n     * </p>\\n     *\\n     * @see Object#equals(Object)\\n     * @param cs1\\n     *            the first CharSequence, may be <code>null</code>\\n     * @param cs2\\n     *            the second CharSequence, may be <code>null</code>\\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\\n     * @since 1.10\\n     */\\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\\n        if (cs1 == cs2) {\\n            return true;\\n        }\\n        if (cs1 == null || cs2 == null) {\\n            return false;\\n        }\\n        if (cs1 instanceof String && cs2 instanceof String) {\\n            return cs1.equals(cs2);\\n        }\\n        return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\\n    }\\n\\n    /**\\n     * Calls {@link String#getBytes(Charset)}\\n     *\\n     * @param string\\n     *            The string to encode (if null, return null).\\n     * @param charset\\n     *            The {@link Charset} to encode the <code>String</code>\\n     * @return the encoded bytes\\n     */\\n    private static byte[] getBytes(final String string, final Charset charset) {\\n        if (string == null) {\\n            return null;\\n        }\\n        return string.getBytes(charset);\\n    }\\n\\n    /**\\n     * Calls {@link String#getBytes(Charset)}\\n     *\\n     * @param string\\n     *            The string to encode (if null, return null).\\n     * @param charset\\n     *            The {@link Charset} to encode the <code>String</code>\\n     * @return the encoded bytes\\n     */\\n    private static ByteBuffer getByteBuffer(final String string, final Charset charset) {\\n        if (string == null) {\\n            return null;\\n        }\\n        return ByteBuffer.wrap(string.getBytes(charset));\\n    }\\n\\n    /**\\n     * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte\\n     * array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     * @since 1.11\\n     */\\n    public static ByteBuffer getByteBufferUtf8(final String string) {\\n        return getByteBuffer(string, Charsets.UTF_8);\\n    }\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\\n     * byte array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     */\\n    public static byte[] getBytesIso8859_1(final String string) {\\n        return getBytes(string, Charsets.ISO_8859_1);\\n    }\\n\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\\n     * array.\\n     * <p>\\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\\n     * </p>\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @param charsetName\\n     *            The name of a required {@link java.nio.charset.Charset}\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws IllegalStateException\\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\\n     *             required charset name.\\n     * @see CharEncoding\\n     * @see String#getBytes(String)\\n     */\\n    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\\n        if (string == null) {\\n            return null;\\n        }\\n        try {\\n            return string.getBytes(charsetName);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw StringUtils.newIllegalStateException(charsetName, e);\\n        }\\n    }\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\\n     * array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     */\\n    public static byte[] getBytesUsAscii(final String string) {\\n        return getBytes(string, Charsets.US_ASCII);\\n    }\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\\n     * array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     */\\n    public static byte[] getBytesUtf16(final String string) {\\n        return getBytes(string, Charsets.UTF_16);\\n    }\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\\n     * array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     */\\n    public static byte[] getBytesUtf16Be(final String string) {\\n        return getBytes(string, Charsets.UTF_16BE);\\n    }\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\\n     * array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     */\\n    public static byte[] getBytesUtf16Le(final String string) {\\n        return getBytes(string, Charsets.UTF_16LE);\\n    }\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\\n     * array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     */\\n    public static byte[] getBytesUtf8(final String string) {\\n        return getBytes(string, Charsets.UTF_8);\\n    }\\n\\n    private static IllegalStateException newIllegalStateException(final String charsetName,\\n                                                                  final UnsupportedEncodingException e) {\\n        return new IllegalStateException(charsetName + \\\": \\\" + e);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters\\n     * @param charset\\n     *            The {@link Charset} to encode the <code>String</code>; not {@code null}\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if charset is {@code null}\\n     */\\n    private static String newString(final byte[] bytes, final Charset charset) {\\n        return bytes == null ? null : new String(bytes, charset);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\\n     * <p>\\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\\n     * </p>\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters, may be <code>null</code>\\n     * @param charsetName\\n     *            The name of a required {@link java.nio.charset.Charset}\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws IllegalStateException\\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\\n     *             required charset name.\\n     * @see CharEncoding\\n     * @see String#String(byte[], String)\\n     */\\n    public static String newString(final byte[] bytes, final String charsetName) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        try {\\n            return new String(bytes, charsetName);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw StringUtils.newIllegalStateException(charsetName, e);\\n        }\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters, may be <code>null</code>\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\\n     *         <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     */\\n    public static String newStringIso8859_1(final byte[] bytes) {\\n        return newString(bytes, Charsets.ISO_8859_1);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     */\\n    public static String newStringUsAscii(final byte[] bytes) {\\n        return newString(bytes, Charsets.US_ASCII);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     */\\n    public static String newStringUtf16(final byte[] bytes) {\\n        return newString(bytes, Charsets.UTF_16);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     */\\n    public static String newStringUtf16Be(final byte[] bytes) {\\n        return newString(bytes, Charsets.UTF_16BE);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     */\\n    public static String newStringUtf16Le(final byte[] bytes) {\\n        return newString(bytes, Charsets.UTF_16LE);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     */\\n    public static String newStringUtf8(final byte[] bytes) {\\n        return newString(bytes, Charsets.UTF_8);\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"StringUtils\", \"position\": {\"start_line\": 39, \"end_line\": 420, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class StringUtils {\\n\\n    /**\\n     * <p>\\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\\n     * </p>\\n     *\\n     * <p>\\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\\n     * The comparison is case sensitive.\\n     * </p>\\n     *\\n     * <pre>\\n     * StringUtils.equals(null, null)   = true\\n     * StringUtils.equals(null, \\\"abc\\\")  = false\\n     * StringUtils.equals(\\\"abc\\\", null)  = false\\n     * StringUtils.equals(\\\"abc\\\", \\\"abc\\\") = true\\n     * StringUtils.equals(\\\"abc\\\", \\\"ABC\\\") = false\\n     * </pre>\\n     *\\n     * <p>\\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\\n     * </p>\\n     *\\n     * @see Object#equals(Object)\\n     * @param cs1\\n     *            the first CharSequence, may be <code>null</code>\\n     * @param cs2\\n     *            the second CharSequence, may be <code>null</code>\\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\\n     * @since 1.10\\n     */\\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\\n        if (cs1 == cs2) {\\n            return true;\\n        }\\n        if (cs1 == null || cs2 == null) {\\n            return false;\\n        }\\n        if (cs1 instanceof String && cs2 instanceof String) {\\n            return cs1.equals(cs2);\\n        }\\n        return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\\n    }\\n\\n    /**\\n     * Calls {@link String#getBytes(Charset)}\\n     *\\n     * @param string\\n     *            The string to encode (if null, return null).\\n     * @param charset\\n     *            The {@link Charset} to encode the <code>String</code>\\n     * @return the encoded bytes\\n     */\\n    private static byte[] getBytes(final String string, final Charset charset) {\\n        if (string == null) {\\n            return null;\\n        }\\n        return string.getBytes(charset);\\n    }\\n\\n    /**\\n     * Calls {@link String#getBytes(Charset)}\\n     *\\n     * @param string\\n     *            The string to encode (if null, return null).\\n     * @param charset\\n     *            The {@link Charset} to encode the <code>String</code>\\n     * @return the encoded bytes\\n     */\\n    private static ByteBuffer getByteBuffer(final String string, final Charset charset) {\\n        if (string == null) {\\n            return null;\\n        }\\n        return ByteBuffer.wrap(string.getBytes(charset));\\n    }\\n\\n    /**\\n     * Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte\\n     * array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     * @since 1.11\\n     */\\n    public static ByteBuffer getByteBufferUtf8(final String string) {\\n        return getByteBuffer(string, Charsets.UTF_8);\\n    }\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\\n     * byte array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     */\\n    public static byte[] getBytesIso8859_1(final String string) {\\n        return getBytes(string, Charsets.ISO_8859_1);\\n    }\\n\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\\n     * array.\\n     * <p>\\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\\n     * </p>\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @param charsetName\\n     *            The name of a required {@link java.nio.charset.Charset}\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws IllegalStateException\\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\\n     *             required charset name.\\n     * @see CharEncoding\\n     * @see String#getBytes(String)\\n     */\\n    public static byte[] getBytesUnchecked(final String string, final String charsetName) {\\n        if (string == null) {\\n            return null;\\n        }\\n        try {\\n            return string.getBytes(charsetName);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw StringUtils.newIllegalStateException(charsetName, e);\\n        }\\n    }\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\\n     * array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     */\\n    public static byte[] getBytesUsAscii(final String string) {\\n        return getBytes(string, Charsets.US_ASCII);\\n    }\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\\n     * array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     */\\n    public static byte[] getBytesUtf16(final String string) {\\n        return getBytes(string, Charsets.UTF_16);\\n    }\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\\n     * array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     */\\n    public static byte[] getBytesUtf16Be(final String string) {\\n        return getBytes(string, Charsets.UTF_16BE);\\n    }\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\\n     * array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     */\\n    public static byte[] getBytesUtf16Le(final String string) {\\n        return getBytes(string, Charsets.UTF_16LE);\\n    }\\n\\n    /**\\n     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\\n     * array.\\n     *\\n     * @param string\\n     *            the String to encode, may be <code>null</code>\\n     * @return encoded bytes, or <code>null</code> if the input string was <code>null</code>\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @see #getBytesUnchecked(String, String)\\n     */\\n    public static byte[] getBytesUtf8(final String string) {\\n        return getBytes(string, Charsets.UTF_8);\\n    }\\n\\n    private static IllegalStateException newIllegalStateException(final String charsetName,\\n                                                                  final UnsupportedEncodingException e) {\\n        return new IllegalStateException(charsetName + \\\": \\\" + e);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters\\n     * @param charset\\n     *            The {@link Charset} to encode the <code>String</code>; not {@code null}\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if charset is {@code null}\\n     */\\n    private static String newString(final byte[] bytes, final Charset charset) {\\n        return bytes == null ? null : new String(bytes, charset);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\\n     * <p>\\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\\n     * </p>\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters, may be <code>null</code>\\n     * @param charsetName\\n     *            The name of a required {@link java.nio.charset.Charset}\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset,\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws IllegalStateException\\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\\n     *             required charset name.\\n     * @see CharEncoding\\n     * @see String#String(byte[], String)\\n     */\\n    public static String newString(final byte[] bytes, final String charsetName) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        try {\\n            return new String(bytes, charsetName);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw StringUtils.newIllegalStateException(charsetName, e);\\n        }\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters, may be <code>null</code>\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\\n     *         <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     */\\n    public static String newStringIso8859_1(final byte[] bytes) {\\n        return newString(bytes, Charsets.ISO_8859_1);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     */\\n    public static String newStringUsAscii(final byte[] bytes) {\\n        return newString(bytes, Charsets.US_ASCII);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16 charset\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_16} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     */\\n    public static String newStringUtf16(final byte[] bytes) {\\n        return newString(bytes, Charsets.UTF_16);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16BE charset,\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_16BE} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     */\\n    public static String newStringUtf16Be(final byte[] bytes) {\\n        return newString(bytes, Charsets.UTF_16BE);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-16LE charset,\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_16LE} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     */\\n    public static String newStringUtf16Le(final byte[] bytes) {\\n        return newString(bytes, Charsets.UTF_16LE);\\n    }\\n\\n    /**\\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\\n     *\\n     * @param bytes\\n     *            The bytes to be decoded into characters\\n     * @return A new <code>String</code> decoded from the specified array of bytes using the UTF-8 charset,\\n     *         or <code>null</code> if the input byte array was <code>null</code>.\\n     * @throws NullPointerException\\n     *             Thrown if {@link Charsets#UTF_8} is not initialized, which should never happen since it is\\n     *             required by the Java platform specification.\\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\\n     */\\n    public static String newStringUtf8(final byte[] bytes) {\\n        return newString(bytes, Charsets.UTF_8);\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"equals\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 71, \"end_line\": 82, \"start_column\": 19, \"end_column\": 5}, \"code\": \"boolean equals(final CharSequence cs1, final CharSequence cs2) {\\n        if (cs1 == cs2) {\\n            return true;\\n        }\\n        if (cs1 == null || cs2 == null) {\\n            return false;\\n        }\\n        if (cs1 instanceof String && cs2 instanceof String) {\\n            return cs1.equals(cs2);\\n        }\\n        return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"cs1\", \"type\": \"CharSequence\"}, {\"name\": \"cs2\", \"type\": \"CharSequence\"}]}, {\"name\": \"getBytes\", \"return_type\": \"byte\", \"position\": {\"start_line\": 93, \"end_line\": 98, \"start_column\": 20, \"end_column\": 5}, \"code\": \"byte[] getBytes(final String string, final Charset charset) {\\n        if (string == null) {\\n            return null;\\n        }\\n        return string.getBytes(charset);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"Charset\"}]}, {\"name\": \"getByteBuffer\", \"return_type\": \"ByteBuffer\", \"position\": {\"start_line\": 109, \"end_line\": 114, \"start_column\": 20, \"end_column\": 5}, \"code\": \"ByteBuffer getByteBuffer(final String string, final Charset charset) {\\n        if (string == null) {\\n            return null;\\n        }\\n        return ByteBuffer.wrap(string.getBytes(charset));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"Charset\"}]}, {\"name\": \"getByteBufferUtf8\", \"return_type\": \"ByteBuffer\", \"position\": {\"start_line\": 130, \"end_line\": 132, \"start_column\": 19, \"end_column\": 5}, \"code\": \"ByteBuffer getByteBufferUtf8(final String string) {\\n        return getByteBuffer(string, Charsets.UTF_8);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"String\"}]}, {\"name\": \"getBytesIso8859_1\", \"return_type\": \"byte\", \"position\": {\"start_line\": 148, \"end_line\": 150, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] getBytesIso8859_1(final String string) {\\n        return getBytes(string, Charsets.ISO_8859_1);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"String\"}]}, {\"name\": \"getBytesUnchecked\", \"return_type\": \"byte\", \"position\": {\"start_line\": 172, \"end_line\": 181, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] getBytesUnchecked(final String string, final String charsetName) {\\n        if (string == null) {\\n            return null;\\n        }\\n        try {\\n            return string.getBytes(charsetName);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw StringUtils.newIllegalStateException(charsetName, e);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"String\"}, {\"name\": \"charsetName\", \"type\": \"String\"}]}, {\"name\": \"getBytesUsAscii\", \"return_type\": \"byte\", \"position\": {\"start_line\": 197, \"end_line\": 199, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] getBytesUsAscii(final String string) {\\n        return getBytes(string, Charsets.US_ASCII);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"String\"}]}, {\"name\": \"getBytesUtf16\", \"return_type\": \"byte\", \"position\": {\"start_line\": 215, \"end_line\": 217, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] getBytesUtf16(final String string) {\\n        return getBytes(string, Charsets.UTF_16);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"String\"}]}, {\"name\": \"getBytesUtf16Be\", \"return_type\": \"byte\", \"position\": {\"start_line\": 233, \"end_line\": 235, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] getBytesUtf16Be(final String string) {\\n        return getBytes(string, Charsets.UTF_16BE);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"String\"}]}, {\"name\": \"getBytesUtf16Le\", \"return_type\": \"byte\", \"position\": {\"start_line\": 251, \"end_line\": 253, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] getBytesUtf16Le(final String string) {\\n        return getBytes(string, Charsets.UTF_16LE);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"String\"}]}, {\"name\": \"getBytesUtf8\", \"return_type\": \"byte\", \"position\": {\"start_line\": 269, \"end_line\": 271, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] getBytesUtf8(final String string) {\\n        return getBytes(string, Charsets.UTF_8);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"String\"}]}, {\"name\": \"newIllegalStateException\", \"return_type\": \"IllegalStateException\", \"position\": {\"start_line\": 273, \"end_line\": 276, \"start_column\": 20, \"end_column\": 5}, \"code\": \"IllegalStateException newIllegalStateException(final String charsetName,\\n                                                                  final UnsupportedEncodingException e) {\\n        return new IllegalStateException(charsetName + \\\": \\\" + e);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"charsetName\", \"type\": \"String\"}, {\"name\": \"e\", \"type\": \"UnsupportedEncodingException\"}]}, {\"name\": \"newString\", \"return_type\": \"String\", \"position\": {\"start_line\": 290, \"end_line\": 292, \"start_column\": 20, \"end_column\": 5}, \"code\": \"String newString(final byte[] bytes, final Charset charset) {\\n        return bytes == null ? null : new String(bytes, charset);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}, {\"name\": \"charset\", \"type\": \"Charset\"}]}, {\"name\": \"newString\", \"return_type\": \"String\", \"position\": {\"start_line\": 313, \"end_line\": 322, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String newString(final byte[] bytes, final String charsetName) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        try {\\n            return new String(bytes, charsetName);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw StringUtils.newIllegalStateException(charsetName, e);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}, {\"name\": \"charsetName\", \"type\": \"String\"}]}, {\"name\": \"newStringIso8859_1\", \"return_type\": \"String\", \"position\": {\"start_line\": 336, \"end_line\": 338, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String newStringIso8859_1(final byte[] bytes) {\\n        return newString(bytes, Charsets.ISO_8859_1);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"newStringUsAscii\", \"return_type\": \"String\", \"position\": {\"start_line\": 352, \"end_line\": 354, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String newStringUsAscii(final byte[] bytes) {\\n        return newString(bytes, Charsets.US_ASCII);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"newStringUtf16\", \"return_type\": \"String\", \"position\": {\"start_line\": 368, \"end_line\": 370, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String newStringUtf16(final byte[] bytes) {\\n        return newString(bytes, Charsets.UTF_16);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"newStringUtf16Be\", \"return_type\": \"String\", \"position\": {\"start_line\": 384, \"end_line\": 386, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String newStringUtf16Be(final byte[] bytes) {\\n        return newString(bytes, Charsets.UTF_16BE);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"newStringUtf16Le\", \"return_type\": \"String\", \"position\": {\"start_line\": 400, \"end_line\": 402, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String newStringUtf16Le(final byte[] bytes) {\\n        return newString(bytes, Charsets.UTF_16LE);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"newStringUtf8\", \"return_type\": \"String\", \"position\": {\"start_line\": 416, \"end_line\": 418, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String newStringUtf8(final byte[] bytes) {\\n        return newString(bytes, Charsets.UTF_8);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/cli/Digest.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npackage org.apache.commons.codec.cli;\\n\\nimport java.io.File;\\nimport java.io.IOException;\\nimport java.nio.charset.Charset;\\nimport java.security.MessageDigest;\\nimport java.util.Arrays;\\nimport java.util.Locale;\\n\\nimport org.apache.commons.codec.binary.Hex;\\nimport org.apache.commons.codec.digest.DigestUtils;\\nimport org.apache.commons.codec.digest.MessageDigestAlgorithms;\\n\\n/**\\n * A minimal command line to run digest over files, directories or a string\\n *\\n * @see #main(String[])\\n * @since 1.11\\n */\\npublic class Digest {\\n\\n    /**\\n     * Runs the digest algorithm in {@code args[0]} on the file in {@code args[1]}. If there is no {@code args[1]}, use\\n     * standard input.\\n     *\\n     * <p>\\n     * The algorithm can also be {@code ALL} or {@code *} to output one line for each known algorithm.\\n     * </p>\\n     *\\n     * @param args\\n     *            {@code args[0]} is one of {@link MessageDigestAlgorithms} name,\\n     *            {@link MessageDigest} name, {@code ALL}, or {@code *}.\\n     *            {@code args[1+]} is a FILE/DIRECTORY/String.\\n     * @throws IOException if an error occurs\\n     */\\n    public static void main(final String[] args) throws IOException {\\n        new Digest(args).run();\\n    }\\n\\n    private final String algorithm;\\n    private final String[] args;\\n    private final String[] inputs;\\n\\n    private Digest(final String[] args) {\\n        if (args == null) {\\n            throw new IllegalArgumentException(\\\"args\\\");\\n        }\\n        if (args.length == 0) {\\n            throw new IllegalArgumentException(\\n                    String.format(\\\"Usage: java %s [algorithm] [FILE|DIRECTORY|string] ...\\\", Digest.class.getName()));\\n        }\\n        this.args = args;\\n        algorithm = args[0];\\n        if (args.length <= 1) {\\n            inputs = null;\\n        } else {\\n            inputs = new String[args.length -1];\\n            System.arraycopy(args, 1, inputs, 0, inputs.length);\\n        }\\n    }\\n\\n    private void println(final String prefix, final byte[] digest) {\\n        println(prefix, digest, null);\\n    }\\n\\n    private void println(final String prefix, final byte[] digest, final String fileName) {\\n        // The standard appears to be to print\\n        // hex, space, then either space or '*' followed by filename\\n        // where '*' is used for binary files\\n        // shasum(1) has a -b option which generates \\\" *\\\" separator\\n        // we don't distinguish binary files at present\\n        System.out.println(prefix + Hex.encodeHexString(digest) + (fileName != null ? \\\"  \\\" + fileName : \\\"\\\"));\\n    }\\n\\n    private void run() throws IOException {\\n        if (algorithm.equalsIgnoreCase(\\\"ALL\\\") || algorithm.equals(\\\"*\\\")) {\\n            run(MessageDigestAlgorithms.values());\\n            return;\\n        }\\n        final MessageDigest messageDigest = DigestUtils.getDigest(algorithm, null);\\n        if (messageDigest != null) {\\n            run(\\\"\\\", messageDigest);\\n        } else {\\n            run(\\\"\\\", DigestUtils.getDigest(algorithm.toUpperCase(Locale.ROOT)));\\n        }\\n    }\\n\\n    private void run(final String[] digestAlgorithms) throws IOException {\\n        for (final String messageDigestAlgorithm : digestAlgorithms) {\\n            if (DigestUtils.isAvailable(messageDigestAlgorithm)) {\\n                run(messageDigestAlgorithm + \\\" \\\", messageDigestAlgorithm);\\n            }\\n        }\\n    }\\n\\n    private void run(final String prefix, final MessageDigest messageDigest) throws IOException {\\n        if (inputs == null) {\\n            println(prefix, DigestUtils.digest(messageDigest, System.in));\\n            return;\\n        }\\n        for(final String source : inputs) {\\n            final File file = new File(source);\\n            if (file.isFile()) {\\n                println(prefix, DigestUtils.digest(messageDigest, file), source);\\n            } else if (file.isDirectory()) {\\n                final File[] listFiles = file.listFiles();\\n                if (listFiles != null) {\\n                    run(prefix, messageDigest, listFiles);\\n                }\\n            } else {\\n                // use the default charset for the command-line parameter\\n                final byte[] bytes = source.getBytes(Charset.defaultCharset());\\n                println(prefix, DigestUtils.digest(messageDigest, bytes));\\n            }\\n        }\\n    }\\n\\n    private void run(final String prefix, final MessageDigest messageDigest, final File[] files) throws IOException {\\n        for (final File file : files) {\\n            if (file.isFile()) {\\n                println(prefix, DigestUtils.digest(messageDigest, file), file.getName());\\n            }\\n        }\\n    }\\n\\n    private void run(final String prefix, final String messageDigestAlgorithm) throws IOException {\\n        run(prefix, DigestUtils.getDigest(messageDigestAlgorithm));\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return String.format(\\\"%s %s\\\", super.toString(), Arrays.toString(args));\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Digest\", \"position\": {\"start_line\": 36, \"end_line\": 150, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Digest {\\n\\n    /**\\n     * Runs the digest algorithm in {@code args[0]} on the file in {@code args[1]}. If there is no {@code args[1]}, use\\n     * standard input.\\n     *\\n     * <p>\\n     * The algorithm can also be {@code ALL} or {@code *} to output one line for each known algorithm.\\n     * </p>\\n     *\\n     * @param args\\n     *            {@code args[0]} is one of {@link MessageDigestAlgorithms} name,\\n     *            {@link MessageDigest} name, {@code ALL}, or {@code *}.\\n     *            {@code args[1+]} is a FILE/DIRECTORY/String.\\n     * @throws IOException if an error occurs\\n     */\\n    public static void main(final String[] args) throws IOException {\\n        new Digest(args).run();\\n    }\\n\\n    private final String algorithm;\\n    private final String[] args;\\n    private final String[] inputs;\\n\\n    private Digest(final String[] args) {\\n        if (args == null) {\\n            throw new IllegalArgumentException(\\\"args\\\");\\n        }\\n        if (args.length == 0) {\\n            throw new IllegalArgumentException(\\n                    String.format(\\\"Usage: java %s [algorithm] [FILE|DIRECTORY|string] ...\\\", Digest.class.getName()));\\n        }\\n        this.args = args;\\n        algorithm = args[0];\\n        if (args.length <= 1) {\\n            inputs = null;\\n        } else {\\n            inputs = new String[args.length -1];\\n            System.arraycopy(args, 1, inputs, 0, inputs.length);\\n        }\\n    }\\n\\n    private void println(final String prefix, final byte[] digest) {\\n        println(prefix, digest, null);\\n    }\\n\\n    private void println(final String prefix, final byte[] digest, final String fileName) {\\n        // The standard appears to be to print\\n        // hex, space, then either space or '*' followed by filename\\n        // where '*' is used for binary files\\n        // shasum(1) has a -b option which generates \\\" *\\\" separator\\n        // we don't distinguish binary files at present\\n        System.out.println(prefix + Hex.encodeHexString(digest) + (fileName != null ? \\\"  \\\" + fileName : \\\"\\\"));\\n    }\\n\\n    private void run() throws IOException {\\n        if (algorithm.equalsIgnoreCase(\\\"ALL\\\") || algorithm.equals(\\\"*\\\")) {\\n            run(MessageDigestAlgorithms.values());\\n            return;\\n        }\\n        final MessageDigest messageDigest = DigestUtils.getDigest(algorithm, null);\\n        if (messageDigest != null) {\\n            run(\\\"\\\", messageDigest);\\n        } else {\\n            run(\\\"\\\", DigestUtils.getDigest(algorithm.toUpperCase(Locale.ROOT)));\\n        }\\n    }\\n\\n    private void run(final String[] digestAlgorithms) throws IOException {\\n        for (final String messageDigestAlgorithm : digestAlgorithms) {\\n            if (DigestUtils.isAvailable(messageDigestAlgorithm)) {\\n                run(messageDigestAlgorithm + \\\" \\\", messageDigestAlgorithm);\\n            }\\n        }\\n    }\\n\\n    private void run(final String prefix, final MessageDigest messageDigest) throws IOException {\\n        if (inputs == null) {\\n            println(prefix, DigestUtils.digest(messageDigest, System.in));\\n            return;\\n        }\\n        for(final String source : inputs) {\\n            final File file = new File(source);\\n            if (file.isFile()) {\\n                println(prefix, DigestUtils.digest(messageDigest, file), source);\\n            } else if (file.isDirectory()) {\\n                final File[] listFiles = file.listFiles();\\n                if (listFiles != null) {\\n                    run(prefix, messageDigest, listFiles);\\n                }\\n            } else {\\n                // use the default charset for the command-line parameter\\n                final byte[] bytes = source.getBytes(Charset.defaultCharset());\\n                println(prefix, DigestUtils.digest(messageDigest, bytes));\\n            }\\n        }\\n    }\\n\\n    private void run(final String prefix, final MessageDigest messageDigest, final File[] files) throws IOException {\\n        for (final File file : files) {\\n            if (file.isFile()) {\\n                println(prefix, DigestUtils.digest(messageDigest, file), file.getName());\\n            }\\n        }\\n    }\\n\\n    private void run(final String prefix, final String messageDigestAlgorithm) throws IOException {\\n        run(prefix, DigestUtils.getDigest(messageDigestAlgorithm));\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return String.format(\\\"%s %s\\\", super.toString(), Arrays.toString(args));\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"main\", \"return_type\": \"void\", \"position\": {\"start_line\": 52, \"end_line\": 54, \"start_column\": 19, \"end_column\": 5}, \"code\": \"void main(final String[] args) throws IOException {\\n        new Digest(args).run();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"args\", \"type\": \"String\"}]}, {\"name\": \"println\", \"return_type\": \"void\", \"position\": {\"start_line\": 78, \"end_line\": 80, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void println(final String prefix, final byte[] digest) {\\n        println(prefix, digest, null);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"prefix\", \"type\": \"String\"}, {\"name\": \"digest\", \"type\": \"byte\"}]}, {\"name\": \"println\", \"return_type\": \"void\", \"position\": {\"start_line\": 82, \"end_line\": 89, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void println(final String prefix, final byte[] digest, final String fileName) {\\n        // The standard appears to be to print\\n        // hex, space, then either space or '*' followed by filename\\n        // where '*' is used for binary files\\n        // shasum(1) has a -b option which generates \\\" *\\\" separator\\n        // we don't distinguish binary files at present\\n        System.out.println(prefix + Hex.encodeHexString(digest) + (fileName != null ? \\\"  \\\" + fileName : \\\"\\\"));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"prefix\", \"type\": \"String\"}, {\"name\": \"digest\", \"type\": \"byte\"}, {\"name\": \"fileName\", \"type\": \"String\"}]}, {\"name\": \"run\", \"return_type\": \"void\", \"position\": {\"start_line\": 91, \"end_line\": 102, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void run() throws IOException {\\n        if (algorithm.equalsIgnoreCase(\\\"ALL\\\") || algorithm.equals(\\\"*\\\")) {\\n            run(MessageDigestAlgorithms.values());\\n            return;\\n        }\\n        final MessageDigest messageDigest = DigestUtils.getDigest(algorithm, null);\\n        if (messageDigest != null) {\\n            run(\\\"\\\", messageDigest);\\n        } else {\\n            run(\\\"\\\", DigestUtils.getDigest(algorithm.toUpperCase(Locale.ROOT)));\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"run\", \"return_type\": \"void\", \"position\": {\"start_line\": 104, \"end_line\": 110, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void run(final String[] digestAlgorithms) throws IOException {\\n        for (final String messageDigestAlgorithm : digestAlgorithms) {\\n            if (DigestUtils.isAvailable(messageDigestAlgorithm)) {\\n                run(messageDigestAlgorithm + \\\" \\\", messageDigestAlgorithm);\\n            }\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"digestAlgorithms\", \"type\": \"String\"}]}, {\"name\": \"run\", \"return_type\": \"void\", \"position\": {\"start_line\": 112, \"end_line\": 132, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void run(final String prefix, final MessageDigest messageDigest) throws IOException {\\n        if (inputs == null) {\\n            println(prefix, DigestUtils.digest(messageDigest, System.in));\\n            return;\\n        }\\n        for(final String source : inputs) {\\n            final File file = new File(source);\\n            if (file.isFile()) {\\n                println(prefix, DigestUtils.digest(messageDigest, file), source);\\n            } else if (file.isDirectory()) {\\n                final File[] listFiles = file.listFiles();\\n                if (listFiles != null) {\\n                    run(prefix, messageDigest, listFiles);\\n                }\\n            } else {\\n                // use the default charset for the command-line parameter\\n                final byte[] bytes = source.getBytes(Charset.defaultCharset());\\n                println(prefix, DigestUtils.digest(messageDigest, bytes));\\n            }\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"prefix\", \"type\": \"String\"}, {\"name\": \"messageDigest\", \"type\": \"MessageDigest\"}]}, {\"name\": \"run\", \"return_type\": \"void\", \"position\": {\"start_line\": 134, \"end_line\": 140, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void run(final String prefix, final MessageDigest messageDigest, final File[] files) throws IOException {\\n        for (final File file : files) {\\n            if (file.isFile()) {\\n                println(prefix, DigestUtils.digest(messageDigest, file), file.getName());\\n            }\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"prefix\", \"type\": \"String\"}, {\"name\": \"messageDigest\", \"type\": \"MessageDigest\"}, {\"name\": \"files\", \"type\": \"File\"}]}, {\"name\": \"run\", \"return_type\": \"void\", \"position\": {\"start_line\": 142, \"end_line\": 144, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void run(final String prefix, final String messageDigestAlgorithm) throws IOException {\\n        run(prefix, DigestUtils.getDigest(messageDigestAlgorithm));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"prefix\", \"type\": \"String\"}, {\"name\": \"messageDigestAlgorithm\", \"type\": \"String\"}]}, {\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 147, \"end_line\": 149, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String toString() {\\n        return String.format(\\\"%s %s\\\", super.toString(), Arrays.toString(args));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/digest/B64.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npackage org.apache.commons.codec.digest;\\n\\nimport java.util.Random;\\n\\n/**\\n * Base64 like method to convert binary bytes into ASCII chars.\\n *\\n * TODO: Can Base64 be reused?\\n *\\n * <p>\\n * This class is immutable and thread-safe.\\n * </p>\\n *\\n * @version $Id: B64.java 1435550 2013-01-19 14:09:52Z tn $\\n * @since 1.7\\n */\\nclass B64 {\\n\\n    /**\\n     * Table with characters for Base64 transformation.\\n     */\\n    static final String B64T = \\\"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\";\\n\\n    /**\\n     * Base64 like conversion of bytes to ASCII chars.\\n     *\\n     * @param b2\\n     *            A byte from the result.\\n     * @param b1\\n     *            A byte from the result.\\n     * @param b0\\n     *            A byte from the result.\\n     * @param outLen\\n     *            The number of expected output chars.\\n     * @param buffer\\n     *            Where the output chars is appended to.\\n     */\\n    static void b64from24bit(final byte b2, final byte b1, final byte b0, final int outLen,\\n                             final StringBuilder buffer) {\\n        // The bit masking is necessary because the JVM byte type is signed!\\n        int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff);\\n        // It's effectively a \\\"for\\\" loop but kept to resemble the original C code.\\n        int n = outLen;\\n        while (n-- > 0) {\\n            buffer.append(B64T.charAt(w & 0x3f));\\n            w >>= 6;\\n        }\\n    }\\n\\n    /**\\n     * Generates a string of random chars from the B64T set.\\n     *\\n     * @param num\\n     *            Number of chars to generate.\\n     */\\n    static String getRandomSalt(final int num) {\\n        final StringBuilder saltString = new StringBuilder();\\n        for (int i = 1; i <= num; i++) {\\n            saltString.append(B64T.charAt(new Random().nextInt(B64T.length())));\\n        }\\n        return saltString.toString();\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"B64\", \"position\": {\"start_line\": 33, \"end_line\": 79, \"start_column\": 1, \"end_column\": 1}, \"code\": \"class B64 {\\n\\n    /**\\n     * Table with characters for Base64 transformation.\\n     */\\n    static final String B64T = \\\"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\";\\n\\n    /**\\n     * Base64 like conversion of bytes to ASCII chars.\\n     *\\n     * @param b2\\n     *            A byte from the result.\\n     * @param b1\\n     *            A byte from the result.\\n     * @param b0\\n     *            A byte from the result.\\n     * @param outLen\\n     *            The number of expected output chars.\\n     * @param buffer\\n     *            Where the output chars is appended to.\\n     */\\n    static void b64from24bit(final byte b2, final byte b1, final byte b0, final int outLen,\\n                             final StringBuilder buffer) {\\n        // The bit masking is necessary because the JVM byte type is signed!\\n        int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff);\\n        // It's effectively a \\\"for\\\" loop but kept to resemble the original C code.\\n        int n = outLen;\\n        while (n-- > 0) {\\n            buffer.append(B64T.charAt(w & 0x3f));\\n            w >>= 6;\\n        }\\n    }\\n\\n    /**\\n     * Generates a string of random chars from the B64T set.\\n     *\\n     * @param num\\n     *            Number of chars to generate.\\n     */\\n    static String getRandomSalt(final int num) {\\n        final StringBuilder saltString = new StringBuilder();\\n        for (int i = 1; i <= num; i++) {\\n            saltString.append(B64T.charAt(new Random().nextInt(B64T.length())));\\n        }\\n        return saltString.toString();\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"b64from24bit\", \"return_type\": \"void\", \"position\": {\"start_line\": 54, \"end_line\": 64, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void b64from24bit(final byte b2, final byte b1, final byte b0, final int outLen,\\n                             final StringBuilder buffer) {\\n        // The bit masking is necessary because the JVM byte type is signed!\\n        int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff);\\n        // It's effectively a \\\"for\\\" loop but kept to resemble the original C code.\\n        int n = outLen;\\n        while (n-- > 0) {\\n            buffer.append(B64T.charAt(w & 0x3f));\\n            w >>= 6;\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b2\", \"type\": \"byte\"}, {\"name\": \"b1\", \"type\": \"byte\"}, {\"name\": \"b0\", \"type\": \"byte\"}, {\"name\": \"outLen\", \"type\": \"int\"}, {\"name\": \"buffer\", \"type\": \"StringBuilder\"}]}, {\"name\": \"getRandomSalt\", \"return_type\": \"String\", \"position\": {\"start_line\": 72, \"end_line\": 78, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getRandomSalt(final int num) {\\n        final StringBuilder saltString = new StringBuilder();\\n        for (int i = 1; i <= num; i++) {\\n            saltString.append(B64T.charAt(new Random().nextInt(B64T.length())));\\n        }\\n        return saltString.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"num\", \"type\": \"int\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/digest/Crypt.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npackage org.apache.commons.codec.digest;\\n\\nimport org.apache.commons.codec.Charsets;\\n\\n/**\\n * GNU libc crypt(3) compatible hash method.\\n * <p>\\n * See {@link #crypt(String, String)} for further details.\\n * <p>\\n * This class is immutable and thread-safe.\\n *\\n * @version $Id: Crypt.java 1744646 2016-05-20 00:11:45Z sebb $\\n * @since 1.7\\n */\\npublic class Crypt {\\n\\n    /**\\n     * Encrypts a password in a crypt(3) compatible way.\\n     * <p>\\n     * A random salt and the default algorithm (currently SHA-512) are used. See {@link #crypt(String, String)} for\\n     * details.\\n     *\\n     * @param keyBytes\\n     *            plaintext password\\n     * @return hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String crypt(final byte[] keyBytes) {\\n        return crypt(keyBytes, null);\\n    }\\n\\n    /**\\n     * Encrypts a password in a crypt(3) compatible way.\\n     * <p>\\n     * If no salt is provided, a random salt and the default algorithm (currently SHA-512) will be used. See\\n     * {@link #crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext password\\n     * @param salt\\n     *            salt value\\n     * @return hash value\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String crypt(final byte[] keyBytes, final String salt) {\\n        if (salt == null) {\\n            return Sha2Crypt.sha512Crypt(keyBytes);\\n        } else if (salt.startsWith(Sha2Crypt.SHA512_PREFIX)) {\\n            return Sha2Crypt.sha512Crypt(keyBytes, salt);\\n        } else if (salt.startsWith(Sha2Crypt.SHA256_PREFIX)) {\\n            return Sha2Crypt.sha256Crypt(keyBytes, salt);\\n        } else if (salt.startsWith(Md5Crypt.MD5_PREFIX)) {\\n            return Md5Crypt.md5Crypt(keyBytes, salt);\\n        } else {\\n            return UnixCrypt.crypt(keyBytes, salt);\\n        }\\n    }\\n\\n    /**\\n     * Calculates the digest using the strongest crypt(3) algorithm.\\n     * <p>\\n     * A random salt and the default algorithm (currently SHA-512) are used.\\n     *\\n     * @see #crypt(String, String)\\n     * @param key\\n     *            plaintext password\\n     * @return hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String crypt(final String key) {\\n        return crypt(key, null);\\n    }\\n\\n    /**\\n     * Encrypts a password in a crypt(3) compatible way.\\n     * <p>\\n     * The exact algorithm depends on the format of the salt string:\\n     * <ul>\\n     * <li>SHA-512 salts start with {@code $6$} and are up to 16 chars long.\\n     * <li>SHA-256 salts start with {@code $5$} and are up to 16 chars long\\n     * <li>MD5 salts start with {@code $1$} and are up to 8 chars long\\n     * <li>DES, the traditional UnixCrypt algorithm is used with only 2 chars\\n     * <li>Only the first 8 chars of the passwords are used in the DES algorithm!\\n     * </ul>\\n     * The magic strings {@code \\\"$apr1$\\\"} and {@code \\\"$2a$\\\"} are not recognized by this method as its output should be\\n     * identical with that of the libc implementation.\\n     * <p>\\n     * The rest of the salt string is drawn from the set {@code [a-zA-Z0-9./]} and is cut at the maximum length of if a\\n     * {@code \\\"$\\\"} sign is encountered. It is therefore valid to enter a complete hash value as salt to e.g. verify a\\n     * password with:\\n     *\\n     * <pre>\\n     * storedPwd.equals(crypt(enteredPwd, storedPwd))\\n     * </pre>\\n     * <p>\\n     * The resulting string starts with the marker string ({@code $n$}), where n is the same as the input salt.\\n     * The salt is then appended, followed by a {@code \\\"$\\\"} sign.\\n     * This is followed by the actual hash value.\\n     * For DES the string only contains the salt and actual hash.\\n     * The total length is dependent on the algorithm used:\\n     * <ul>\\n     * <li>SHA-512: 106 chars\\n     * <li>SHA-256: 63 chars\\n     * <li>MD5: 34 chars\\n     * <li>DES: 13 chars\\n     * </ul>\\n     * <p>\\n     * Example:\\n     *\\n     * <pre>\\n     *      crypt(\\\"secret\\\", \\\"$1$xxxx\\\") =&gt; \\\"$1$xxxx$aMkevjfEIpa35Bh3G4bAc.\\\"\\n     *      crypt(\\\"secret\\\", \\\"xx\\\") =&gt; \\\"xxWAum7tHdIUw\\\"\\n     * </pre>\\n     * <p>\\n     * This method comes in a variation that accepts a byte[] array to support input strings that are not encoded in\\n     * UTF-8 but e.g. in ISO-8859-1 where equal characters result in different byte values.\\n     *\\n     * @see \\\"The man page of the libc crypt (3) function.\\\"\\n     * @param key\\n     *            plaintext password as entered by the used\\n     * @param salt\\n     *            salt value\\n     * @return hash value, i.e. encrypted password including the salt string\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught. *\\n     */\\n    public static String crypt(final String key, final String salt) {\\n        return crypt(key.getBytes(Charsets.UTF_8), salt);\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Crypt\", \"position\": {\"start_line\": 31, \"end_line\": 153, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Crypt {\\n\\n    /**\\n     * Encrypts a password in a crypt(3) compatible way.\\n     * <p>\\n     * A random salt and the default algorithm (currently SHA-512) are used. See {@link #crypt(String, String)} for\\n     * details.\\n     *\\n     * @param keyBytes\\n     *            plaintext password\\n     * @return hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String crypt(final byte[] keyBytes) {\\n        return crypt(keyBytes, null);\\n    }\\n\\n    /**\\n     * Encrypts a password in a crypt(3) compatible way.\\n     * <p>\\n     * If no salt is provided, a random salt and the default algorithm (currently SHA-512) will be used. See\\n     * {@link #crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext password\\n     * @param salt\\n     *            salt value\\n     * @return hash value\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String crypt(final byte[] keyBytes, final String salt) {\\n        if (salt == null) {\\n            return Sha2Crypt.sha512Crypt(keyBytes);\\n        } else if (salt.startsWith(Sha2Crypt.SHA512_PREFIX)) {\\n            return Sha2Crypt.sha512Crypt(keyBytes, salt);\\n        } else if (salt.startsWith(Sha2Crypt.SHA256_PREFIX)) {\\n            return Sha2Crypt.sha256Crypt(keyBytes, salt);\\n        } else if (salt.startsWith(Md5Crypt.MD5_PREFIX)) {\\n            return Md5Crypt.md5Crypt(keyBytes, salt);\\n        } else {\\n            return UnixCrypt.crypt(keyBytes, salt);\\n        }\\n    }\\n\\n    /**\\n     * Calculates the digest using the strongest crypt(3) algorithm.\\n     * <p>\\n     * A random salt and the default algorithm (currently SHA-512) are used.\\n     *\\n     * @see #crypt(String, String)\\n     * @param key\\n     *            plaintext password\\n     * @return hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String crypt(final String key) {\\n        return crypt(key, null);\\n    }\\n\\n    /**\\n     * Encrypts a password in a crypt(3) compatible way.\\n     * <p>\\n     * The exact algorithm depends on the format of the salt string:\\n     * <ul>\\n     * <li>SHA-512 salts start with {@code $6$} and are up to 16 chars long.\\n     * <li>SHA-256 salts start with {@code $5$} and are up to 16 chars long\\n     * <li>MD5 salts start with {@code $1$} and are up to 8 chars long\\n     * <li>DES, the traditional UnixCrypt algorithm is used with only 2 chars\\n     * <li>Only the first 8 chars of the passwords are used in the DES algorithm!\\n     * </ul>\\n     * The magic strings {@code \\\"$apr1$\\\"} and {@code \\\"$2a$\\\"} are not recognized by this method as its output should be\\n     * identical with that of the libc implementation.\\n     * <p>\\n     * The rest of the salt string is drawn from the set {@code [a-zA-Z0-9./]} and is cut at the maximum length of if a\\n     * {@code \\\"$\\\"} sign is encountered. It is therefore valid to enter a complete hash value as salt to e.g. verify a\\n     * password with:\\n     *\\n     * <pre>\\n     * storedPwd.equals(crypt(enteredPwd, storedPwd))\\n     * </pre>\\n     * <p>\\n     * The resulting string starts with the marker string ({@code $n$}), where n is the same as the input salt.\\n     * The salt is then appended, followed by a {@code \\\"$\\\"} sign.\\n     * This is followed by the actual hash value.\\n     * For DES the string only contains the salt and actual hash.\\n     * The total length is dependent on the algorithm used:\\n     * <ul>\\n     * <li>SHA-512: 106 chars\\n     * <li>SHA-256: 63 chars\\n     * <li>MD5: 34 chars\\n     * <li>DES: 13 chars\\n     * </ul>\\n     * <p>\\n     * Example:\\n     *\\n     * <pre>\\n     *      crypt(\\\"secret\\\", \\\"$1$xxxx\\\") =&gt; \\\"$1$xxxx$aMkevjfEIpa35Bh3G4bAc.\\\"\\n     *      crypt(\\\"secret\\\", \\\"xx\\\") =&gt; \\\"xxWAum7tHdIUw\\\"\\n     * </pre>\\n     * <p>\\n     * This method comes in a variation that accepts a byte[] array to support input strings that are not encoded in\\n     * UTF-8 but e.g. in ISO-8859-1 where equal characters result in different byte values.\\n     *\\n     * @see \\\"The man page of the libc crypt (3) function.\\\"\\n     * @param key\\n     *            plaintext password as entered by the used\\n     * @param salt\\n     *            salt value\\n     * @return hash value, i.e. encrypted password including the salt string\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught. *\\n     */\\n    public static String crypt(final String key, final String salt) {\\n        return crypt(key.getBytes(Charsets.UTF_8), salt);\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 45, \"end_line\": 47, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String crypt(final byte[] keyBytes) {\\n        return crypt(keyBytes, null);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"byte\"}]}, {\"name\": \"crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 65, \"end_line\": 77, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String crypt(final byte[] keyBytes, final String salt) {\\n        if (salt == null) {\\n            return Sha2Crypt.sha512Crypt(keyBytes);\\n        } else if (salt.startsWith(Sha2Crypt.SHA512_PREFIX)) {\\n            return Sha2Crypt.sha512Crypt(keyBytes, salt);\\n        } else if (salt.startsWith(Sha2Crypt.SHA256_PREFIX)) {\\n            return Sha2Crypt.sha256Crypt(keyBytes, salt);\\n        } else if (salt.startsWith(Md5Crypt.MD5_PREFIX)) {\\n            return Md5Crypt.md5Crypt(keyBytes, salt);\\n        } else {\\n            return UnixCrypt.crypt(keyBytes, salt);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"byte\"}, {\"name\": \"salt\", \"type\": \"String\"}]}, {\"name\": \"crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 91, \"end_line\": 93, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String crypt(final String key) {\\n        return crypt(key, null);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"String\"}]}, {\"name\": \"crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 150, \"end_line\": 152, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String crypt(final String key, final String salt) {\\n        return crypt(key.getBytes(Charsets.UTF_8), salt);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"String\"}, {\"name\": \"salt\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/digest/DigestUtils.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.digest;\\n\\nimport java.io.BufferedInputStream;\\nimport java.io.File;\\nimport java.io.FileInputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.nio.ByteBuffer;\\nimport java.security.MessageDigest;\\nimport java.security.NoSuchAlgorithmException;\\n\\nimport org.apache.commons.codec.binary.Hex;\\nimport org.apache.commons.codec.binary.StringUtils;\\n\\n/**\\n * Operations to simplify common {@link java.security.MessageDigest} tasks.\\n * This class is immutable and thread-safe.\\n * However the MessageDigest instances it creates generally won't be.\\n * <p>\\n * The {@link MessageDigestAlgorithms} class provides constants for standard\\n * digest algorithms that can be used with the {@link #getDigest(String)} method\\n * and other methods that require the Digest algorithm name.\\n * <p>\\n * Note: the class has short-hand methods for all the algorithms present as standard in Java 6.\\n * This approach requires lots of methods for each algorithm, and quickly becomes unwieldy.\\n * The following code works with all algorithms:\\n * <pre>\\n * import static org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224;\\n * ...\\n * byte [] digest = new DigestUtils(SHA_224).digest(dataToDigest);\\n * String hdigest = new DigestUtils(SHA_224).digestAsHex(new File(\\\"pom.xml\\\"));\\n * </pre>\\n * @see MessageDigestAlgorithms\\n * @version $Id: DigestUtils.java 1811344 2017-10-06 15:19:57Z ggregory $\\n */\\npublic class DigestUtils {\\n\\n    private static final int STREAM_BUFFER_LENGTH = 1024;\\n\\n    /**\\n     * Reads through a byte array and returns the digest for the data. Provided for symmetry with other methods.\\n     *\\n     * @param messageDigest\\n     *            The MessageDigest to use (e.g. MD5)\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @since 1.11\\n     */\\n    public static byte[] digest(final MessageDigest messageDigest, final byte[] data) {\\n        return messageDigest.digest(data);\\n    }\\n\\n    /**\\n     * Reads through a ByteBuffer and returns the digest for the data\\n     *\\n     * @param messageDigest\\n     *            The MessageDigest to use (e.g. MD5)\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     *\\n     * @since 1.11\\n     */\\n    public static byte[] digest(final MessageDigest messageDigest, final ByteBuffer data) {\\n        messageDigest.update(data);\\n        return messageDigest.digest();\\n    }\\n\\n    /**\\n     * Reads through a File and returns the digest for the data\\n     *\\n     * @param messageDigest\\n     *            The MessageDigest to use (e.g. MD5)\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11\\n     */\\n    public static byte[] digest(final MessageDigest messageDigest, final File data) throws IOException {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Reads through an InputStream and returns the digest for the data\\n     *\\n     * @param messageDigest\\n     *            The MessageDigest to use (e.g. MD5)\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11 (was private)\\n     */\\n    public static byte[] digest(final MessageDigest messageDigest, final InputStream data) throws IOException {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Returns a <code>MessageDigest</code> for the given <code>algorithm</code>.\\n     *\\n     * @param algorithm\\n     *            the name of the algorithm requested. See <a\\n     *            href=\\\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\\\"\\n     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\\n     *            algorithm names.\\n     * @return A digest instance.\\n     * @see MessageDigest#getInstance(String)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught.\\n     */\\n    public static MessageDigest getDigest(final String algorithm) {\\n        try {\\n            return MessageDigest.getInstance(algorithm);\\n        } catch (final NoSuchAlgorithmException e) {\\n            throw new IllegalArgumentException(e);\\n        }\\n    }\\n\\n    /**\\n     * Returns a <code>MessageDigest</code> for the given <code>algorithm</code> or a default if there is a problem\\n     * getting the algorithm.\\n     *\\n     * @param algorithm\\n     *            the name of the algorithm requested. See\\n     *            <a href=\\\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\\\" >\\n     *            Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\\n     *            algorithm names.\\n     * @param defaultMessageDigest\\n     *            The default MessageDigest.\\n     * @return A digest instance.\\n     * @see MessageDigest#getInstance(String)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught.\\n     * @since 1.11\\n     */\\n    public static MessageDigest getDigest(final String algorithm, final MessageDigest defaultMessageDigest) {\\n        try {\\n            return MessageDigest.getInstance(algorithm);\\n        } catch (final Exception e) {\\n            return defaultMessageDigest;\\n        }\\n    }\\n\\n    /**\\n     * Returns an MD2 MessageDigest.\\n     *\\n     * @return An MD2 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD2 is a\\n     *             built-in algorithm\\n     * @see MessageDigestAlgorithms#MD2\\n     * @since 1.7\\n     */\\n    public static MessageDigest getMd2Digest() {\\n        return getDigest(MessageDigestAlgorithms.MD2);\\n    }\\n\\n    /**\\n     * Returns an MD5 MessageDigest.\\n     *\\n     * @return An MD5 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD5 is a\\n     *             built-in algorithm\\n     * @see MessageDigestAlgorithms#MD5\\n     */\\n    public static MessageDigest getMd5Digest() {\\n        return getDigest(MessageDigestAlgorithms.MD5);\\n    }\\n\\n    /**\\n     * Returns an SHA-1 digest.\\n     *\\n     * @return An SHA-1 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-1 is a\\n     *             built-in algorithm\\n     * @see MessageDigestAlgorithms#SHA_1\\n     * @since 1.7\\n     */\\n    public static MessageDigest getSha1Digest() {\\n        return getDigest(MessageDigestAlgorithms.SHA_1);\\n    }\\n\\n    /**\\n     * Returns an SHA-256 digest.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @return An SHA-256 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-256 is a\\n     *             built-in algorithm\\n     * @see MessageDigestAlgorithms#SHA_256\\n     */\\n    public static MessageDigest getSha256Digest() {\\n        return getDigest(MessageDigestAlgorithms.SHA_256);\\n    }\\n\\n    /**\\n     * Returns an SHA-384 digest.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @return An SHA-384 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-384 is a\\n     *             built-in algorithm\\n     * @see MessageDigestAlgorithms#SHA_384\\n     */\\n    public static MessageDigest getSha384Digest() {\\n        return getDigest(MessageDigestAlgorithms.SHA_384);\\n    }\\n\\n    /**\\n     * Returns an SHA-512 digest.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @return An SHA-512 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-512 is a\\n     *             built-in algorithm\\n     * @see MessageDigestAlgorithms#SHA_512\\n     */\\n    public static MessageDigest getSha512Digest() {\\n        return getDigest(MessageDigestAlgorithms.SHA_512);\\n    }\\n\\n    /**\\n     * Returns an SHA-1 digest.\\n     *\\n     * @return An SHA-1 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught\\n     * @deprecated (1.11) Use {@link #getSha1Digest()}\\n     */\\n    @Deprecated\\n    public static MessageDigest getShaDigest() {\\n        return getSha1Digest();\\n    }\\n\\n    /**\\n     * Calculates the MD2 digest and returns the value as a 16 element <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD2 digest\\n     * @since 1.7\\n     */\\n    public static byte[] md2(final byte[] data) {\\n        return getMd2Digest().digest(data);\\n    }\\n\\n    /**\\n     * Calculates the MD2 digest and returns the value as a 16 element <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD2 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.7\\n     */\\n    public static byte[] md2(final InputStream data) throws IOException {\\n        return digest(getMd2Digest(), data);\\n    }\\n\\n    /**\\n     * Calculates the MD2 digest and returns the value as a 16 element <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return MD2 digest\\n     * @since 1.7\\n     */\\n    public static byte[] md2(final String data) {\\n        return md2(StringUtils.getBytesUtf8(data));\\n    }\\n\\n    /**\\n     * Calculates the MD2 digest and returns the value as a 32 character hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD2 digest as a hex string\\n     * @since 1.7\\n     */\\n    public static String md2Hex(final byte[] data) {\\n        return Hex.encodeHexString(md2(data));\\n    }\\n\\n    /**\\n     * Calculates the MD2 digest and returns the value as a 32 character hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD2 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.7\\n     */\\n    public static String md2Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(md2(data));\\n    }\\n\\n    /**\\n     * Calculates the MD2 digest and returns the value as a 32 character hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD2 digest as a hex string\\n     * @since 1.7\\n     */\\n    public static String md2Hex(final String data) {\\n        return Hex.encodeHexString(md2(data));\\n    }\\n\\n    /**\\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD5 digest\\n     */\\n    public static byte[] md5(final byte[] data) {\\n        return getMd5Digest().digest(data);\\n    }\\n\\n    /**\\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD5 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static byte[] md5(final InputStream data) throws IOException {\\n        return digest(getMd5Digest(), data);\\n    }\\n\\n    /**\\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return MD5 digest\\n     */\\n    public static byte[] md5(final String data) {\\n        return md5(StringUtils.getBytesUtf8(data));\\n    }\\n\\n    /**\\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD5 digest as a hex string\\n     */\\n    public static String md5Hex(final byte[] data) {\\n        return Hex.encodeHexString(md5(data));\\n    }\\n\\n    /**\\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD5 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static String md5Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(md5(data));\\n    }\\n\\n    /**\\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD5 digest as a hex string\\n     */\\n    public static String md5Hex(final String data) {\\n        return Hex.encodeHexString(md5(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest\\n     * @deprecated (1.11) Use {@link #sha1(byte[])}\\n     */\\n    @Deprecated\\n    public static byte[] sha(final byte[] data) {\\n        return sha1(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     * @deprecated (1.11) Use {@link #sha1(InputStream)}\\n     */\\n    @Deprecated\\n    public static byte[] sha(final InputStream data) throws IOException {\\n        return sha1(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest\\n     * @deprecated (1.11) Use {@link #sha1(String)}\\n     */\\n    @Deprecated\\n    public static byte[] sha(final String data) {\\n        return sha1(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest\\n     * @since 1.7\\n     */\\n    public static byte[] sha1(final byte[] data) {\\n        return getSha1Digest().digest(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.7\\n     */\\n    public static byte[] sha1(final InputStream data) throws IOException {\\n        return digest(getSha1Digest(), data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return SHA-1 digest\\n     */\\n    public static byte[] sha1(final String data) {\\n        return sha1(StringUtils.getBytesUtf8(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest as a hex string\\n     * @since 1.7\\n     */\\n    public static String sha1Hex(final byte[] data) {\\n        return Hex.encodeHexString(sha1(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.7\\n     */\\n    public static String sha1Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(sha1(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest as a hex string\\n     * @since 1.7\\n     */\\n    public static String sha1Hex(final String data) {\\n        return Hex.encodeHexString(sha1(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-256 digest\\n     * @since 1.4\\n     */\\n    public static byte[] sha256(final byte[] data) {\\n        return getSha256Digest().digest(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-256 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static byte[] sha256(final InputStream data) throws IOException {\\n        return digest(getSha256Digest(), data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return SHA-256 digest\\n     * @since 1.4\\n     */\\n    public static byte[] sha256(final String data) {\\n        return sha256(StringUtils.getBytesUtf8(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-256 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-256 digest as a hex string\\n     * @since 1.4\\n     */\\n    public static String sha256Hex(final byte[] data) {\\n        return Hex.encodeHexString(sha256(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-256 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-256 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static String sha256Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(sha256(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-256 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-256 digest as a hex string\\n     * @since 1.4\\n     */\\n    public static String sha256Hex(final String data) {\\n        return Hex.encodeHexString(sha256(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-384 digest\\n     * @since 1.4\\n     */\\n    public static byte[] sha384(final byte[] data) {\\n        return getSha384Digest().digest(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-384 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static byte[] sha384(final InputStream data) throws IOException {\\n        return digest(getSha384Digest(), data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return SHA-384 digest\\n     * @since 1.4\\n     */\\n    public static byte[] sha384(final String data) {\\n        return sha384(StringUtils.getBytesUtf8(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-384 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-384 digest as a hex string\\n     * @since 1.4\\n     */\\n    public static String sha384Hex(final byte[] data) {\\n        return Hex.encodeHexString(sha384(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-384 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-384 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static String sha384Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(sha384(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-384 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-384 digest as a hex string\\n     * @since 1.4\\n     */\\n    public static String sha384Hex(final String data) {\\n        return Hex.encodeHexString(sha384(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-512 digest\\n     * @since 1.4\\n     */\\n    public static byte[] sha512(final byte[] data) {\\n        return getSha512Digest().digest(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-512 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static byte[] sha512(final InputStream data) throws IOException {\\n        return digest(getSha512Digest(), data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return SHA-512 digest\\n     * @since 1.4\\n     */\\n    public static byte[] sha512(final String data) {\\n        return sha512(StringUtils.getBytesUtf8(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-512 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-512 digest as a hex string\\n     * @since 1.4\\n     */\\n    public static String sha512Hex(final byte[] data) {\\n        return Hex.encodeHexString(sha512(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-512 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-512 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static String sha512Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(sha512(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-512 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-512 digest as a hex string\\n     * @since 1.4\\n     */\\n    public static String sha512Hex(final String data) {\\n        return Hex.encodeHexString(sha512(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest as a hex string\\n     * @deprecated (1.11) Use {@link #sha1Hex(byte[])}\\n     */\\n    @Deprecated\\n    public static String shaHex(final byte[] data) {\\n        return sha1Hex(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     * @deprecated (1.11) Use {@link #sha1Hex(InputStream)}\\n     */\\n    @Deprecated\\n    public static String shaHex(final InputStream data) throws IOException {\\n        return sha1Hex(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest as a hex string\\n     * @deprecated (1.11) Use {@link #sha1Hex(String)}\\n     */\\n    @Deprecated\\n    public static String shaHex(final String data) {\\n        return sha1Hex(data);\\n    }\\n\\n    /**\\n     * Updates the given {@link MessageDigest}.\\n     *\\n     * @param messageDigest\\n     *            the {@link MessageDigest} to update\\n     * @param valueToDigest\\n     *            the value to update the {@link MessageDigest} with\\n     * @return the updated {@link MessageDigest}\\n     * @since 1.7\\n     */\\n    public static MessageDigest updateDigest(final MessageDigest messageDigest, final byte[] valueToDigest) {\\n        messageDigest.update(valueToDigest);\\n        return messageDigest;\\n    }\\n\\n    /**\\n     * Updates the given {@link MessageDigest}.\\n     *\\n     * @param messageDigest\\n     *            the {@link MessageDigest} to update\\n     * @param valueToDigest\\n     *            the value to update the {@link MessageDigest} with\\n     * @return the updated {@link MessageDigest}\\n     * @since 1.11\\n     */\\n    public static MessageDigest updateDigest(final MessageDigest messageDigest, final ByteBuffer valueToDigest) {\\n        messageDigest.update(valueToDigest);\\n        return messageDigest;\\n    }\\n\\n    /**\\n     * Reads through a File and updates the digest for the data\\n     *\\n     * @param digest\\n     *            The MessageDigest to use (e.g. MD5)\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11\\n     */\\n    public static MessageDigest updateDigest(final MessageDigest digest, final File data) throws IOException {\\n        final BufferedInputStream stream = new BufferedInputStream(new FileInputStream(data));\\n        try {\\n            return updateDigest(digest, stream);\\n        } finally {\\n            stream.close();\\n        }\\n    }\\n\\n    /**\\n     * Reads through an InputStream and updates the digest for the data\\n     *\\n     * @param digest\\n     *            The MessageDigest to use (e.g. MD5)\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.8\\n     */\\n    public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException {\\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\\n        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\\n\\n        while (read > -1) {\\n            digest.update(buffer, 0, read);\\n            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\\n        }\\n\\n        return digest;\\n    }\\n\\n    /**\\n     * Updates the given {@link MessageDigest} from a String (converted to bytes using UTF-8).\\n     * <p>\\n     * To update the digest using a different charset for the conversion,\\n     * convert the String to a byte array using\\n     * {@link String#getBytes(java.nio.charset.Charset)} and pass that\\n     * to the {@link DigestUtils#updateDigest(MessageDigest, byte[])} method\\n     *\\n     * @param messageDigest\\n     *            the {@link MessageDigest} to update\\n     * @param valueToDigest\\n     *            the value to update the {@link MessageDigest} with;\\n     *            converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return the updated {@link MessageDigest}\\n     * @since 1.7\\n     */\\n    public static MessageDigest updateDigest(final MessageDigest messageDigest, final String valueToDigest) {\\n        messageDigest.update(StringUtils.getBytesUtf8(valueToDigest));\\n        return messageDigest;\\n    }\\n\\n    /**\\n     * Test whether the algorithm is supported.\\n     * @param messageDigestAlgorithm the algorithm name\\n     * @return {@code true} if the algorithm can be found\\n     * @since 1.11\\n     */\\n    public static boolean isAvailable(final String messageDigestAlgorithm) {\\n        return getDigest(messageDigestAlgorithm, null) != null;\\n    }\\n\\n    private final MessageDigest messageDigest;\\n\\n   /**\\n    * Preserves binary compatibity only.\\n    * As for previous versions does not provide useful behaviour\\n    * @deprecated since 1.11; only useful to preserve binary compatibility\\n    */\\n   @Deprecated\\n    public DigestUtils() {\\n        this.messageDigest = null;\\n    }\\n\\n    /**\\n     * Creates an instance using the provided {@link MessageDigest} parameter.\\n     *\\n     * This can then be used to create digests using methods such as\\n     * {@link #digest(byte[])} and {@link #digestAsHex(File)}.\\n     *\\n     * @param digest the {@link MessageDigest} to use\\n     * @since 1.11\\n     */\\n    public DigestUtils(final MessageDigest digest) {\\n        this.messageDigest = digest;\\n    }\\n\\n    /**\\n     * Creates an instance using the provided {@link MessageDigest} parameter.\\n     *\\n     * This can then be used to create digests using methods such as\\n     * {@link #digest(byte[])} and {@link #digestAsHex(File)}.\\n     *\\n     * @param name the name of the {@link MessageDigest} to use\\n     * @see #getDigest(String)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught.\\n     * @since 1.11\\n     */\\n    public DigestUtils(final String name) {\\n        this(getDigest(name));\\n    }\\n\\n    /**\\n     * Returns the message digest instance.\\n     * @return the message digest instance\\n     * @since 1.11\\n     */\\n    public MessageDigest getMessageDigest() {\\n        return messageDigest;\\n    }\\n\\n    /**\\n     * Reads through a byte array and returns the digest for the data.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @since 1.11\\n     */\\n    public byte[] digest(final byte[] data) {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Reads through a byte array and returns the digest for the data.\\n     *\\n     * @param data\\n     *            Data to digest treated as UTF-8 string\\n     * @return the digest\\n     * @since 1.11\\n     */\\n    public byte[] digest(final String data) {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Reads through a ByteBuffer and returns the digest for the data\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     *\\n     * @since 1.11\\n     */\\n    public byte[] digest(final ByteBuffer data) {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Reads through a File and returns the digest for the data\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11\\n     */\\n    public byte[] digest(final File data) throws IOException {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Reads through an InputStream and returns the digest for the data\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11\\n     */\\n    public byte[] digest(final InputStream data) throws IOException {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Reads through a byte array and returns the digest for the data.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest as a hex string\\n     * @since 1.11\\n     */\\n    public String digestAsHex(final byte[] data) {\\n        return Hex.encodeHexString(digest(data));\\n    }\\n\\n    /**\\n     * Reads through a byte array and returns the digest for the data.\\n     *\\n     * @param data\\n     *            Data to digest treated as UTF-8 string\\n     * @return the digest as a hex string\\n     * @since 1.11\\n     */\\n    public String digestAsHex(final String data) {\\n        return Hex.encodeHexString(digest(data));\\n    }\\n\\n    /**\\n     * Reads through a ByteBuffer and returns the digest for the data\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest as a hex string\\n     *\\n     * @since 1.11\\n     */\\n    public String digestAsHex(final ByteBuffer data) {\\n        return Hex.encodeHexString(digest(data));\\n    }\\n\\n    /**\\n     * Reads through a File and returns the digest for the data\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11\\n     */\\n    public String digestAsHex(final File data) throws IOException {\\n        return Hex.encodeHexString(digest(data));\\n    }\\n\\n    /**\\n     * Reads through an InputStream and returns the digest for the data\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11\\n     */\\n    public String digestAsHex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(digest(data));\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"DigestUtils\", \"position\": {\"start_line\": 53, \"end_line\": 1142, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class DigestUtils {\\n\\n    private static final int STREAM_BUFFER_LENGTH = 1024;\\n\\n    /**\\n     * Reads through a byte array and returns the digest for the data. Provided for symmetry with other methods.\\n     *\\n     * @param messageDigest\\n     *            The MessageDigest to use (e.g. MD5)\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @since 1.11\\n     */\\n    public static byte[] digest(final MessageDigest messageDigest, final byte[] data) {\\n        return messageDigest.digest(data);\\n    }\\n\\n    /**\\n     * Reads through a ByteBuffer and returns the digest for the data\\n     *\\n     * @param messageDigest\\n     *            The MessageDigest to use (e.g. MD5)\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     *\\n     * @since 1.11\\n     */\\n    public static byte[] digest(final MessageDigest messageDigest, final ByteBuffer data) {\\n        messageDigest.update(data);\\n        return messageDigest.digest();\\n    }\\n\\n    /**\\n     * Reads through a File and returns the digest for the data\\n     *\\n     * @param messageDigest\\n     *            The MessageDigest to use (e.g. MD5)\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11\\n     */\\n    public static byte[] digest(final MessageDigest messageDigest, final File data) throws IOException {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Reads through an InputStream and returns the digest for the data\\n     *\\n     * @param messageDigest\\n     *            The MessageDigest to use (e.g. MD5)\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11 (was private)\\n     */\\n    public static byte[] digest(final MessageDigest messageDigest, final InputStream data) throws IOException {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Returns a <code>MessageDigest</code> for the given <code>algorithm</code>.\\n     *\\n     * @param algorithm\\n     *            the name of the algorithm requested. See <a\\n     *            href=\\\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\\\"\\n     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\\n     *            algorithm names.\\n     * @return A digest instance.\\n     * @see MessageDigest#getInstance(String)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught.\\n     */\\n    public static MessageDigest getDigest(final String algorithm) {\\n        try {\\n            return MessageDigest.getInstance(algorithm);\\n        } catch (final NoSuchAlgorithmException e) {\\n            throw new IllegalArgumentException(e);\\n        }\\n    }\\n\\n    /**\\n     * Returns a <code>MessageDigest</code> for the given <code>algorithm</code> or a default if there is a problem\\n     * getting the algorithm.\\n     *\\n     * @param algorithm\\n     *            the name of the algorithm requested. See\\n     *            <a href=\\\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\\\" >\\n     *            Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\\n     *            algorithm names.\\n     * @param defaultMessageDigest\\n     *            The default MessageDigest.\\n     * @return A digest instance.\\n     * @see MessageDigest#getInstance(String)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught.\\n     * @since 1.11\\n     */\\n    public static MessageDigest getDigest(final String algorithm, final MessageDigest defaultMessageDigest) {\\n        try {\\n            return MessageDigest.getInstance(algorithm);\\n        } catch (final Exception e) {\\n            return defaultMessageDigest;\\n        }\\n    }\\n\\n    /**\\n     * Returns an MD2 MessageDigest.\\n     *\\n     * @return An MD2 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD2 is a\\n     *             built-in algorithm\\n     * @see MessageDigestAlgorithms#MD2\\n     * @since 1.7\\n     */\\n    public static MessageDigest getMd2Digest() {\\n        return getDigest(MessageDigestAlgorithms.MD2);\\n    }\\n\\n    /**\\n     * Returns an MD5 MessageDigest.\\n     *\\n     * @return An MD5 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD5 is a\\n     *             built-in algorithm\\n     * @see MessageDigestAlgorithms#MD5\\n     */\\n    public static MessageDigest getMd5Digest() {\\n        return getDigest(MessageDigestAlgorithms.MD5);\\n    }\\n\\n    /**\\n     * Returns an SHA-1 digest.\\n     *\\n     * @return An SHA-1 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-1 is a\\n     *             built-in algorithm\\n     * @see MessageDigestAlgorithms#SHA_1\\n     * @since 1.7\\n     */\\n    public static MessageDigest getSha1Digest() {\\n        return getDigest(MessageDigestAlgorithms.SHA_1);\\n    }\\n\\n    /**\\n     * Returns an SHA-256 digest.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @return An SHA-256 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-256 is a\\n     *             built-in algorithm\\n     * @see MessageDigestAlgorithms#SHA_256\\n     */\\n    public static MessageDigest getSha256Digest() {\\n        return getDigest(MessageDigestAlgorithms.SHA_256);\\n    }\\n\\n    /**\\n     * Returns an SHA-384 digest.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @return An SHA-384 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-384 is a\\n     *             built-in algorithm\\n     * @see MessageDigestAlgorithms#SHA_384\\n     */\\n    public static MessageDigest getSha384Digest() {\\n        return getDigest(MessageDigestAlgorithms.SHA_384);\\n    }\\n\\n    /**\\n     * Returns an SHA-512 digest.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @return An SHA-512 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-512 is a\\n     *             built-in algorithm\\n     * @see MessageDigestAlgorithms#SHA_512\\n     */\\n    public static MessageDigest getSha512Digest() {\\n        return getDigest(MessageDigestAlgorithms.SHA_512);\\n    }\\n\\n    /**\\n     * Returns an SHA-1 digest.\\n     *\\n     * @return An SHA-1 digest instance.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught\\n     * @deprecated (1.11) Use {@link #getSha1Digest()}\\n     */\\n    @Deprecated\\n    public static MessageDigest getShaDigest() {\\n        return getSha1Digest();\\n    }\\n\\n    /**\\n     * Calculates the MD2 digest and returns the value as a 16 element <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD2 digest\\n     * @since 1.7\\n     */\\n    public static byte[] md2(final byte[] data) {\\n        return getMd2Digest().digest(data);\\n    }\\n\\n    /**\\n     * Calculates the MD2 digest and returns the value as a 16 element <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD2 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.7\\n     */\\n    public static byte[] md2(final InputStream data) throws IOException {\\n        return digest(getMd2Digest(), data);\\n    }\\n\\n    /**\\n     * Calculates the MD2 digest and returns the value as a 16 element <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return MD2 digest\\n     * @since 1.7\\n     */\\n    public static byte[] md2(final String data) {\\n        return md2(StringUtils.getBytesUtf8(data));\\n    }\\n\\n    /**\\n     * Calculates the MD2 digest and returns the value as a 32 character hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD2 digest as a hex string\\n     * @since 1.7\\n     */\\n    public static String md2Hex(final byte[] data) {\\n        return Hex.encodeHexString(md2(data));\\n    }\\n\\n    /**\\n     * Calculates the MD2 digest and returns the value as a 32 character hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD2 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.7\\n     */\\n    public static String md2Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(md2(data));\\n    }\\n\\n    /**\\n     * Calculates the MD2 digest and returns the value as a 32 character hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD2 digest as a hex string\\n     * @since 1.7\\n     */\\n    public static String md2Hex(final String data) {\\n        return Hex.encodeHexString(md2(data));\\n    }\\n\\n    /**\\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD5 digest\\n     */\\n    public static byte[] md5(final byte[] data) {\\n        return getMd5Digest().digest(data);\\n    }\\n\\n    /**\\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD5 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static byte[] md5(final InputStream data) throws IOException {\\n        return digest(getMd5Digest(), data);\\n    }\\n\\n    /**\\n     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return MD5 digest\\n     */\\n    public static byte[] md5(final String data) {\\n        return md5(StringUtils.getBytesUtf8(data));\\n    }\\n\\n    /**\\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD5 digest as a hex string\\n     */\\n    public static String md5Hex(final byte[] data) {\\n        return Hex.encodeHexString(md5(data));\\n    }\\n\\n    /**\\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD5 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static String md5Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(md5(data));\\n    }\\n\\n    /**\\n     * Calculates the MD5 digest and returns the value as a 32 character hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return MD5 digest as a hex string\\n     */\\n    public static String md5Hex(final String data) {\\n        return Hex.encodeHexString(md5(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest\\n     * @deprecated (1.11) Use {@link #sha1(byte[])}\\n     */\\n    @Deprecated\\n    public static byte[] sha(final byte[] data) {\\n        return sha1(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     * @deprecated (1.11) Use {@link #sha1(InputStream)}\\n     */\\n    @Deprecated\\n    public static byte[] sha(final InputStream data) throws IOException {\\n        return sha1(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest\\n     * @deprecated (1.11) Use {@link #sha1(String)}\\n     */\\n    @Deprecated\\n    public static byte[] sha(final String data) {\\n        return sha1(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest\\n     * @since 1.7\\n     */\\n    public static byte[] sha1(final byte[] data) {\\n        return getSha1Digest().digest(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.7\\n     */\\n    public static byte[] sha1(final InputStream data) throws IOException {\\n        return digest(getSha1Digest(), data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.\\n     *\\n     * @param data\\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return SHA-1 digest\\n     */\\n    public static byte[] sha1(final String data) {\\n        return sha1(StringUtils.getBytesUtf8(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest as a hex string\\n     * @since 1.7\\n     */\\n    public static String sha1Hex(final byte[] data) {\\n        return Hex.encodeHexString(sha1(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.7\\n     */\\n    public static String sha1Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(sha1(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest as a hex string\\n     * @since 1.7\\n     */\\n    public static String sha1Hex(final String data) {\\n        return Hex.encodeHexString(sha1(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-256 digest\\n     * @since 1.4\\n     */\\n    public static byte[] sha256(final byte[] data) {\\n        return getSha256Digest().digest(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-256 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static byte[] sha256(final InputStream data) throws IOException {\\n        return digest(getSha256Digest(), data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return SHA-256 digest\\n     * @since 1.4\\n     */\\n    public static byte[] sha256(final String data) {\\n        return sha256(StringUtils.getBytesUtf8(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-256 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-256 digest as a hex string\\n     * @since 1.4\\n     */\\n    public static String sha256Hex(final byte[] data) {\\n        return Hex.encodeHexString(sha256(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-256 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-256 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static String sha256Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(sha256(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-256 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-256 digest as a hex string\\n     * @since 1.4\\n     */\\n    public static String sha256Hex(final String data) {\\n        return Hex.encodeHexString(sha256(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-384 digest\\n     * @since 1.4\\n     */\\n    public static byte[] sha384(final byte[] data) {\\n        return getSha384Digest().digest(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-384 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static byte[] sha384(final InputStream data) throws IOException {\\n        return digest(getSha384Digest(), data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return SHA-384 digest\\n     * @since 1.4\\n     */\\n    public static byte[] sha384(final String data) {\\n        return sha384(StringUtils.getBytesUtf8(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-384 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-384 digest as a hex string\\n     * @since 1.4\\n     */\\n    public static String sha384Hex(final byte[] data) {\\n        return Hex.encodeHexString(sha384(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-384 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-384 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static String sha384Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(sha384(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-384 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-384 digest as a hex string\\n     * @since 1.4\\n     */\\n    public static String sha384Hex(final String data) {\\n        return Hex.encodeHexString(sha384(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-512 digest\\n     * @since 1.4\\n     */\\n    public static byte[] sha512(final byte[] data) {\\n        return getSha512Digest().digest(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-512 digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static byte[] sha512(final InputStream data) throws IOException {\\n        return digest(getSha512Digest(), data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return SHA-512 digest\\n     * @since 1.4\\n     */\\n    public static byte[] sha512(final String data) {\\n        return sha512(StringUtils.getBytesUtf8(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-512 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-512 digest as a hex string\\n     * @since 1.4\\n     */\\n    public static String sha512Hex(final byte[] data) {\\n        return Hex.encodeHexString(sha512(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-512 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-512 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     */\\n    public static String sha512Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(sha512(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-512 digest and returns the value as a hex string.\\n     * <p>\\n     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.\\n     * </p>\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-512 digest as a hex string\\n     * @since 1.4\\n     */\\n    public static String sha512Hex(final String data) {\\n        return Hex.encodeHexString(sha512(data));\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest as a hex string\\n     * @deprecated (1.11) Use {@link #sha1Hex(byte[])}\\n     */\\n    @Deprecated\\n    public static String shaHex(final byte[] data) {\\n        return sha1Hex(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.4\\n     * @deprecated (1.11) Use {@link #sha1Hex(InputStream)}\\n     */\\n    @Deprecated\\n    public static String shaHex(final InputStream data) throws IOException {\\n        return sha1Hex(data);\\n    }\\n\\n    /**\\n     * Calculates the SHA-1 digest and returns the value as a hex string.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return SHA-1 digest as a hex string\\n     * @deprecated (1.11) Use {@link #sha1Hex(String)}\\n     */\\n    @Deprecated\\n    public static String shaHex(final String data) {\\n        return sha1Hex(data);\\n    }\\n\\n    /**\\n     * Updates the given {@link MessageDigest}.\\n     *\\n     * @param messageDigest\\n     *            the {@link MessageDigest} to update\\n     * @param valueToDigest\\n     *            the value to update the {@link MessageDigest} with\\n     * @return the updated {@link MessageDigest}\\n     * @since 1.7\\n     */\\n    public static MessageDigest updateDigest(final MessageDigest messageDigest, final byte[] valueToDigest) {\\n        messageDigest.update(valueToDigest);\\n        return messageDigest;\\n    }\\n\\n    /**\\n     * Updates the given {@link MessageDigest}.\\n     *\\n     * @param messageDigest\\n     *            the {@link MessageDigest} to update\\n     * @param valueToDigest\\n     *            the value to update the {@link MessageDigest} with\\n     * @return the updated {@link MessageDigest}\\n     * @since 1.11\\n     */\\n    public static MessageDigest updateDigest(final MessageDigest messageDigest, final ByteBuffer valueToDigest) {\\n        messageDigest.update(valueToDigest);\\n        return messageDigest;\\n    }\\n\\n    /**\\n     * Reads through a File and updates the digest for the data\\n     *\\n     * @param digest\\n     *            The MessageDigest to use (e.g. MD5)\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11\\n     */\\n    public static MessageDigest updateDigest(final MessageDigest digest, final File data) throws IOException {\\n        final BufferedInputStream stream = new BufferedInputStream(new FileInputStream(data));\\n        try {\\n            return updateDigest(digest, stream);\\n        } finally {\\n            stream.close();\\n        }\\n    }\\n\\n    /**\\n     * Reads through an InputStream and updates the digest for the data\\n     *\\n     * @param digest\\n     *            The MessageDigest to use (e.g. MD5)\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.8\\n     */\\n    public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException {\\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\\n        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\\n\\n        while (read > -1) {\\n            digest.update(buffer, 0, read);\\n            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\\n        }\\n\\n        return digest;\\n    }\\n\\n    /**\\n     * Updates the given {@link MessageDigest} from a String (converted to bytes using UTF-8).\\n     * <p>\\n     * To update the digest using a different charset for the conversion,\\n     * convert the String to a byte array using\\n     * {@link String#getBytes(java.nio.charset.Charset)} and pass that\\n     * to the {@link DigestUtils#updateDigest(MessageDigest, byte[])} method\\n     *\\n     * @param messageDigest\\n     *            the {@link MessageDigest} to update\\n     * @param valueToDigest\\n     *            the value to update the {@link MessageDigest} with;\\n     *            converted to bytes using {@link StringUtils#getBytesUtf8(String)}\\n     * @return the updated {@link MessageDigest}\\n     * @since 1.7\\n     */\\n    public static MessageDigest updateDigest(final MessageDigest messageDigest, final String valueToDigest) {\\n        messageDigest.update(StringUtils.getBytesUtf8(valueToDigest));\\n        return messageDigest;\\n    }\\n\\n    /**\\n     * Test whether the algorithm is supported.\\n     * @param messageDigestAlgorithm the algorithm name\\n     * @return {@code true} if the algorithm can be found\\n     * @since 1.11\\n     */\\n    public static boolean isAvailable(final String messageDigestAlgorithm) {\\n        return getDigest(messageDigestAlgorithm, null) != null;\\n    }\\n\\n    private final MessageDigest messageDigest;\\n\\n   /**\\n    * Preserves binary compatibity only.\\n    * As for previous versions does not provide useful behaviour\\n    * @deprecated since 1.11; only useful to preserve binary compatibility\\n    */\\n   @Deprecated\\n    public DigestUtils() {\\n        this.messageDigest = null;\\n    }\\n\\n    /**\\n     * Creates an instance using the provided {@link MessageDigest} parameter.\\n     *\\n     * This can then be used to create digests using methods such as\\n     * {@link #digest(byte[])} and {@link #digestAsHex(File)}.\\n     *\\n     * @param digest the {@link MessageDigest} to use\\n     * @since 1.11\\n     */\\n    public DigestUtils(final MessageDigest digest) {\\n        this.messageDigest = digest;\\n    }\\n\\n    /**\\n     * Creates an instance using the provided {@link MessageDigest} parameter.\\n     *\\n     * This can then be used to create digests using methods such as\\n     * {@link #digest(byte[])} and {@link #digestAsHex(File)}.\\n     *\\n     * @param name the name of the {@link MessageDigest} to use\\n     * @see #getDigest(String)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught.\\n     * @since 1.11\\n     */\\n    public DigestUtils(final String name) {\\n        this(getDigest(name));\\n    }\\n\\n    /**\\n     * Returns the message digest instance.\\n     * @return the message digest instance\\n     * @since 1.11\\n     */\\n    public MessageDigest getMessageDigest() {\\n        return messageDigest;\\n    }\\n\\n    /**\\n     * Reads through a byte array and returns the digest for the data.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @since 1.11\\n     */\\n    public byte[] digest(final byte[] data) {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Reads through a byte array and returns the digest for the data.\\n     *\\n     * @param data\\n     *            Data to digest treated as UTF-8 string\\n     * @return the digest\\n     * @since 1.11\\n     */\\n    public byte[] digest(final String data) {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Reads through a ByteBuffer and returns the digest for the data\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     *\\n     * @since 1.11\\n     */\\n    public byte[] digest(final ByteBuffer data) {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Reads through a File and returns the digest for the data\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11\\n     */\\n    public byte[] digest(final File data) throws IOException {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Reads through an InputStream and returns the digest for the data\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11\\n     */\\n    public byte[] digest(final InputStream data) throws IOException {\\n        return updateDigest(messageDigest, data).digest();\\n    }\\n\\n    /**\\n     * Reads through a byte array and returns the digest for the data.\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest as a hex string\\n     * @since 1.11\\n     */\\n    public String digestAsHex(final byte[] data) {\\n        return Hex.encodeHexString(digest(data));\\n    }\\n\\n    /**\\n     * Reads through a byte array and returns the digest for the data.\\n     *\\n     * @param data\\n     *            Data to digest treated as UTF-8 string\\n     * @return the digest as a hex string\\n     * @since 1.11\\n     */\\n    public String digestAsHex(final String data) {\\n        return Hex.encodeHexString(digest(data));\\n    }\\n\\n    /**\\n     * Reads through a ByteBuffer and returns the digest for the data\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest as a hex string\\n     *\\n     * @since 1.11\\n     */\\n    public String digestAsHex(final ByteBuffer data) {\\n        return Hex.encodeHexString(digest(data));\\n    }\\n\\n    /**\\n     * Reads through a File and returns the digest for the data\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11\\n     */\\n    public String digestAsHex(final File data) throws IOException {\\n        return Hex.encodeHexString(digest(data));\\n    }\\n\\n    /**\\n     * Reads through an InputStream and returns the digest for the data\\n     *\\n     * @param data\\n     *            Data to digest\\n     * @return the digest as a hex string\\n     * @throws IOException\\n     *             On error reading from the stream\\n     * @since 1.11\\n     */\\n    public String digestAsHex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(digest(data));\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"digest\", \"return_type\": \"byte\", \"position\": {\"start_line\": 67, \"end_line\": 69, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] digest(final MessageDigest messageDigest, final byte[] data) {\\n        return messageDigest.digest(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"messageDigest\", \"type\": \"MessageDigest\"}, {\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"digest\", \"return_type\": \"byte\", \"position\": {\"start_line\": 82, \"end_line\": 85, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] digest(final MessageDigest messageDigest, final ByteBuffer data) {\\n        messageDigest.update(data);\\n        return messageDigest.digest();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"messageDigest\", \"type\": \"MessageDigest\"}, {\"name\": \"data\", \"type\": \"ByteBuffer\"}]}, {\"name\": \"digest\", \"return_type\": \"byte\", \"position\": {\"start_line\": 99, \"end_line\": 101, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] digest(final MessageDigest messageDigest, final File data) throws IOException {\\n        return updateDigest(messageDigest, data).digest();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"messageDigest\", \"type\": \"MessageDigest\"}, {\"name\": \"data\", \"type\": \"File\"}]}, {\"name\": \"digest\", \"return_type\": \"byte\", \"position\": {\"start_line\": 115, \"end_line\": 117, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] digest(final MessageDigest messageDigest, final InputStream data) throws IOException {\\n        return updateDigest(messageDigest, data).digest();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"messageDigest\", \"type\": \"MessageDigest\"}, {\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"getDigest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 132, \"end_line\": 138, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest getDigest(final String algorithm) {\\n        try {\\n            return MessageDigest.getInstance(algorithm);\\n        } catch (final NoSuchAlgorithmException e) {\\n            throw new IllegalArgumentException(e);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"algorithm\", \"type\": \"String\"}]}, {\"name\": \"getDigest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 157, \"end_line\": 163, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest getDigest(final String algorithm, final MessageDigest defaultMessageDigest) {\\n        try {\\n            return MessageDigest.getInstance(algorithm);\\n        } catch (final Exception e) {\\n            return defaultMessageDigest;\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"algorithm\", \"type\": \"String\"}, {\"name\": \"defaultMessageDigest\", \"type\": \"MessageDigest\"}]}, {\"name\": \"getMd2Digest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 175, \"end_line\": 177, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest getMd2Digest() {\\n        return getDigest(MessageDigestAlgorithms.MD2);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getMd5Digest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 188, \"end_line\": 190, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest getMd5Digest() {\\n        return getDigest(MessageDigestAlgorithms.MD5);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getSha1Digest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 202, \"end_line\": 204, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest getSha1Digest() {\\n        return getDigest(MessageDigestAlgorithms.SHA_1);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getSha256Digest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 218, \"end_line\": 220, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest getSha256Digest() {\\n        return getDigest(MessageDigestAlgorithms.SHA_256);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getSha384Digest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 234, \"end_line\": 236, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest getSha384Digest() {\\n        return getDigest(MessageDigestAlgorithms.SHA_384);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getSha512Digest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 250, \"end_line\": 252, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest getSha512Digest() {\\n        return getDigest(MessageDigestAlgorithms.SHA_512);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getShaDigest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 263, \"end_line\": 265, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest getShaDigest() {\\n        return getSha1Digest();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"md2\", \"return_type\": \"byte\", \"position\": {\"start_line\": 275, \"end_line\": 277, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] md2(final byte[] data) {\\n        return getMd2Digest().digest(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"md2\", \"return_type\": \"byte\", \"position\": {\"start_line\": 289, \"end_line\": 291, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] md2(final InputStream data) throws IOException {\\n        return digest(getMd2Digest(), data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"md2\", \"return_type\": \"byte\", \"position\": {\"start_line\": 301, \"end_line\": 303, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] md2(final String data) {\\n        return md2(StringUtils.getBytesUtf8(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"md2Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 313, \"end_line\": 315, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String md2Hex(final byte[] data) {\\n        return Hex.encodeHexString(md2(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"md2Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 327, \"end_line\": 329, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String md2Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(md2(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"md2Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 339, \"end_line\": 341, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String md2Hex(final String data) {\\n        return Hex.encodeHexString(md2(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"md5\", \"return_type\": \"byte\", \"position\": {\"start_line\": 350, \"end_line\": 352, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] md5(final byte[] data) {\\n        return getMd5Digest().digest(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"md5\", \"return_type\": \"byte\", \"position\": {\"start_line\": 364, \"end_line\": 366, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] md5(final InputStream data) throws IOException {\\n        return digest(getMd5Digest(), data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"md5\", \"return_type\": \"byte\", \"position\": {\"start_line\": 375, \"end_line\": 377, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] md5(final String data) {\\n        return md5(StringUtils.getBytesUtf8(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"md5Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 386, \"end_line\": 388, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String md5Hex(final byte[] data) {\\n        return Hex.encodeHexString(md5(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"md5Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 400, \"end_line\": 402, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String md5Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(md5(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"md5Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 411, \"end_line\": 413, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String md5Hex(final String data) {\\n        return Hex.encodeHexString(md5(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"sha\", \"return_type\": \"byte\", \"position\": {\"start_line\": 424, \"end_line\": 426, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha(final byte[] data) {\\n        return sha1(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"sha\", \"return_type\": \"byte\", \"position\": {\"start_line\": 440, \"end_line\": 442, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha(final InputStream data) throws IOException {\\n        return sha1(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"sha\", \"return_type\": \"byte\", \"position\": {\"start_line\": 453, \"end_line\": 455, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha(final String data) {\\n        return sha1(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"sha1\", \"return_type\": \"byte\", \"position\": {\"start_line\": 465, \"end_line\": 467, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha1(final byte[] data) {\\n        return getSha1Digest().digest(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"sha1\", \"return_type\": \"byte\", \"position\": {\"start_line\": 479, \"end_line\": 481, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha1(final InputStream data) throws IOException {\\n        return digest(getSha1Digest(), data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"sha1\", \"return_type\": \"byte\", \"position\": {\"start_line\": 490, \"end_line\": 492, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha1(final String data) {\\n        return sha1(StringUtils.getBytesUtf8(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"sha1Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 502, \"end_line\": 504, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha1Hex(final byte[] data) {\\n        return Hex.encodeHexString(sha1(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"sha1Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 516, \"end_line\": 518, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha1Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(sha1(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"sha1Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 528, \"end_line\": 530, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha1Hex(final String data) {\\n        return Hex.encodeHexString(sha1(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"sha256\", \"return_type\": \"byte\", \"position\": {\"start_line\": 543, \"end_line\": 545, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha256(final byte[] data) {\\n        return getSha256Digest().digest(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"sha256\", \"return_type\": \"byte\", \"position\": {\"start_line\": 560, \"end_line\": 562, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha256(final InputStream data) throws IOException {\\n        return digest(getSha256Digest(), data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"sha256\", \"return_type\": \"byte\", \"position\": {\"start_line\": 575, \"end_line\": 577, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha256(final String data) {\\n        return sha256(StringUtils.getBytesUtf8(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"sha256Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 590, \"end_line\": 592, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha256Hex(final byte[] data) {\\n        return Hex.encodeHexString(sha256(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"sha256Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 607, \"end_line\": 609, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha256Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(sha256(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"sha256Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 622, \"end_line\": 624, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha256Hex(final String data) {\\n        return Hex.encodeHexString(sha256(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"sha384\", \"return_type\": \"byte\", \"position\": {\"start_line\": 637, \"end_line\": 639, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha384(final byte[] data) {\\n        return getSha384Digest().digest(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"sha384\", \"return_type\": \"byte\", \"position\": {\"start_line\": 654, \"end_line\": 656, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha384(final InputStream data) throws IOException {\\n        return digest(getSha384Digest(), data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"sha384\", \"return_type\": \"byte\", \"position\": {\"start_line\": 669, \"end_line\": 671, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha384(final String data) {\\n        return sha384(StringUtils.getBytesUtf8(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"sha384Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 684, \"end_line\": 686, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha384Hex(final byte[] data) {\\n        return Hex.encodeHexString(sha384(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"sha384Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 701, \"end_line\": 703, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha384Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(sha384(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"sha384Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 716, \"end_line\": 718, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha384Hex(final String data) {\\n        return Hex.encodeHexString(sha384(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"sha512\", \"return_type\": \"byte\", \"position\": {\"start_line\": 731, \"end_line\": 733, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha512(final byte[] data) {\\n        return getSha512Digest().digest(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"sha512\", \"return_type\": \"byte\", \"position\": {\"start_line\": 748, \"end_line\": 750, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha512(final InputStream data) throws IOException {\\n        return digest(getSha512Digest(), data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"sha512\", \"return_type\": \"byte\", \"position\": {\"start_line\": 763, \"end_line\": 765, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] sha512(final String data) {\\n        return sha512(StringUtils.getBytesUtf8(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"sha512Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 778, \"end_line\": 780, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha512Hex(final byte[] data) {\\n        return Hex.encodeHexString(sha512(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"sha512Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 795, \"end_line\": 797, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha512Hex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(sha512(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"sha512Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 810, \"end_line\": 812, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha512Hex(final String data) {\\n        return Hex.encodeHexString(sha512(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"shaHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 823, \"end_line\": 825, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String shaHex(final byte[] data) {\\n        return sha1Hex(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"shaHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 839, \"end_line\": 841, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String shaHex(final InputStream data) throws IOException {\\n        return sha1Hex(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"shaHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 852, \"end_line\": 854, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String shaHex(final String data) {\\n        return sha1Hex(data);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"updateDigest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 866, \"end_line\": 869, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest updateDigest(final MessageDigest messageDigest, final byte[] valueToDigest) {\\n        messageDigest.update(valueToDigest);\\n        return messageDigest;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"messageDigest\", \"type\": \"MessageDigest\"}, {\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"updateDigest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 881, \"end_line\": 884, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest updateDigest(final MessageDigest messageDigest, final ByteBuffer valueToDigest) {\\n        messageDigest.update(valueToDigest);\\n        return messageDigest;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"messageDigest\", \"type\": \"MessageDigest\"}, {\"name\": \"valueToDigest\", \"type\": \"ByteBuffer\"}]}, {\"name\": \"updateDigest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 898, \"end_line\": 905, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest updateDigest(final MessageDigest digest, final File data) throws IOException {\\n        final BufferedInputStream stream = new BufferedInputStream(new FileInputStream(data));\\n        try {\\n            return updateDigest(digest, stream);\\n        } finally {\\n            stream.close();\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"digest\", \"type\": \"MessageDigest\"}, {\"name\": \"data\", \"type\": \"File\"}]}, {\"name\": \"updateDigest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 919, \"end_line\": 929, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException {\\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\\n        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\\n\\n        while (read > -1) {\\n            digest.update(buffer, 0, read);\\n            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\\n        }\\n\\n        return digest;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"digest\", \"type\": \"MessageDigest\"}, {\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"updateDigest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 947, \"end_line\": 950, \"start_column\": 19, \"end_column\": 5}, \"code\": \"MessageDigest updateDigest(final MessageDigest messageDigest, final String valueToDigest) {\\n        messageDigest.update(StringUtils.getBytesUtf8(valueToDigest));\\n        return messageDigest;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"messageDigest\", \"type\": \"MessageDigest\"}, {\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"isAvailable\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 958, \"end_line\": 960, \"start_column\": 19, \"end_column\": 5}, \"code\": \"boolean isAvailable(final String messageDigestAlgorithm) {\\n        return getDigest(messageDigestAlgorithm, null) != null;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"messageDigestAlgorithm\", \"type\": \"String\"}]}, {\"name\": \"getMessageDigest\", \"return_type\": \"MessageDigest\", \"position\": {\"start_line\": 1008, \"end_line\": 1010, \"start_column\": 12, \"end_column\": 5}, \"code\": \"MessageDigest getMessageDigest() {\\n        return messageDigest;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"digest\", \"return_type\": \"byte\", \"position\": {\"start_line\": 1020, \"end_line\": 1022, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] digest(final byte[] data) {\\n        return updateDigest(messageDigest, data).digest();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"digest\", \"return_type\": \"byte\", \"position\": {\"start_line\": 1032, \"end_line\": 1034, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] digest(final String data) {\\n        return updateDigest(messageDigest, data).digest();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"digest\", \"return_type\": \"byte\", \"position\": {\"start_line\": 1045, \"end_line\": 1047, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] digest(final ByteBuffer data) {\\n        return updateDigest(messageDigest, data).digest();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"ByteBuffer\"}]}, {\"name\": \"digest\", \"return_type\": \"byte\", \"position\": {\"start_line\": 1059, \"end_line\": 1061, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] digest(final File data) throws IOException {\\n        return updateDigest(messageDigest, data).digest();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"File\"}]}, {\"name\": \"digest\", \"return_type\": \"byte\", \"position\": {\"start_line\": 1073, \"end_line\": 1075, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] digest(final InputStream data) throws IOException {\\n        return updateDigest(messageDigest, data).digest();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}, {\"name\": \"digestAsHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 1085, \"end_line\": 1087, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String digestAsHex(final byte[] data) {\\n        return Hex.encodeHexString(digest(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"byte\"}]}, {\"name\": \"digestAsHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 1097, \"end_line\": 1099, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String digestAsHex(final String data) {\\n        return Hex.encodeHexString(digest(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"String\"}]}, {\"name\": \"digestAsHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 1110, \"end_line\": 1112, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String digestAsHex(final ByteBuffer data) {\\n        return Hex.encodeHexString(digest(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"ByteBuffer\"}]}, {\"name\": \"digestAsHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 1124, \"end_line\": 1126, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String digestAsHex(final File data) throws IOException {\\n        return Hex.encodeHexString(digest(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"File\"}]}, {\"name\": \"digestAsHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 1138, \"end_line\": 1140, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String digestAsHex(final InputStream data) throws IOException {\\n        return Hex.encodeHexString(digest(data));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"data\", \"type\": \"InputStream\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/digest/HmacAlgorithms.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.digest;\\n\\n/**\\n * Standard {@link HmacUtils} algorithm names from the <cite>Java Cryptography Architecture Standard Algorithm Name\\n * Documentation</cite>.\\n *\\n * <p>\\n * <strong>Note: Not all JCE implementations support all the algorithms in this enum.</strong>\\n * </p>\\n *\\n * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunJCEProvider\\\"> Java\\n *      6 Cryptography Architecture Sun Providers Documentation</a>\\n * @see <a href=\\\"http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJCEProvider\\\"> Java\\n *      7 Cryptography Architecture Sun Providers Documentation</a>\\n * @see <a href=\\\"http://docs.oracle.com/javase/8/docs/technotes/guides/security/SunProviders.html#SunJCEProvider\\\"> Java\\n *      8 Cryptography Architecture Sun Providers Documentation</a>\\n * @see <a href=\\n *      \\\"http://docs.oracle.com/javase/9/security/oracleproviders.htm#JSSEC-GUID-A47B1249-593C-4C38-A0D0-68FA7681E0A7\\\">\\n *      Java 9 Cryptography Architecture Sun Providers Documentation</a>\\n * @since 1.10\\n * @version $Id: HmacAlgorithms.java 1811624 2017-10-09 23:07:49Z ggregory $\\n */\\npublic enum HmacAlgorithms {\\n\\n    /**\\n     * The HmacMD5 Message Authentication Code (MAC) algorithm specified in RFC 2104 and RFC 1321.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this standard MAC algorithm.\\n     * </p>\\n     */\\n    HMAC_MD5(\\\"HmacMD5\\\"),\\n\\n    /**\\n     * The HmacSHA1 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this standard MAC algorithm.\\n     * </p>\\n     */\\n    HMAC_SHA_1(\\\"HmacSHA1\\\"),\\n\\n    /**\\n     * The HmacSHA224 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.\\n     * <p>\\n     * Every implementation of the Java 8+ platform is required to support this standard MAC algorithm.\\n     * </p>\\n     * @since 1.11\\n     */\\n    HMAC_SHA_224(\\\"HmacSHA224\\\"),\\n\\n    /**\\n     * The HmacSHA256 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this standard MAC algorithm.\\n     * </p>\\n     */\\n    HMAC_SHA_256(\\\"HmacSHA256\\\"),\\n\\n    /**\\n     * The HmacSHA384 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.\\n     * <p>\\n     * This MAC algorithm is <em>optional</em>; not all implementations support it.\\n     * </p>\\n     */\\n    HMAC_SHA_384(\\\"HmacSHA384\\\"),\\n\\n    /**\\n     * The HmacSHA512 Message Authentication Code (MAC) algorithm specified in RFC 2104 and FIPS PUB 180-2.\\n     * <p>\\n     * This MAC algorithm is <em>optional</em>; not all implementations support it.\\n     * </p>\\n     */\\n    HMAC_SHA_512(\\\"HmacSHA512\\\");\\n\\n    private final String name;\\n\\n    private HmacAlgorithms(final String algorithm) {\\n        this.name = algorithm;\\n    }\\n\\n    /**\\n     * Gets the algorithm name.\\n     *\\n     * @return the algorithm name.\\n     * @since 1.11\\n     */\\n    public String getName() {\\n        return name;\\n    }\\n\\n    /**\\n     * The algorithm name\\n     *\\n     * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunJCEProvider\\\">\\n     *      Java 6 Cryptography Architecture Sun Providers Documentation</a>\\n     * @see <a href=\\\"http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJCEProvider\\\">\\n     *      Java 7 Cryptography Architecture Sun Providers Documentation</a>\\n     * @see <a href=\\\"http://docs.oracle.com/javase/8/docs/technotes/guides/security/SunProviders.html#SunJCEProvider\\\">\\n     *      Java 8 Cryptography Architecture Sun Providers Documentation</a>\\n     * @see <a href=\\n     *      \\\"http://docs.oracle.com/javase/9/security/oracleproviders.htm#JSSEC-GUID-A47B1249-593C-4C38-A0D0-68FA7681E0A7\\\">\\n     *      Java 9 Cryptography Architecture Sun Providers Documentation</a>\\n     * @return The algorithm name (\\\"HmacSHA512\\\" for example)\\n     */\\n    @Override\\n    public String toString() {\\n        return name;\\n    }\\n\\n}\\n\", \"classes\": []}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/digest/HmacUtils.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.digest;\\n\\nimport java.io.BufferedInputStream;\\nimport java.io.File;\\nimport java.io.FileInputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.nio.ByteBuffer;\\nimport java.security.InvalidKeyException;\\nimport java.security.Key;\\nimport java.security.NoSuchAlgorithmException;\\n\\nimport javax.crypto.Mac;\\nimport javax.crypto.spec.SecretKeySpec;\\n\\nimport org.apache.commons.codec.binary.Hex;\\nimport org.apache.commons.codec.binary.StringUtils;\\n\\n/**\\n * Simplifies common {@link javax.crypto.Mac} tasks. This class is immutable and thread-safe.\\n * However the Mac may not be.\\n * <p>\\n * <strong>Note: Not all JCE implementations support all algorithms. If not supported, an IllegalArgumentException is\\n * thrown.</strong>\\n * <p>\\n * Sample usage:\\n * <pre>\\n * import static HmacAlgorithms.*;\\n * byte[] key = {1,2,3,4}; // don't use this actual key!\\n * String valueToDigest = \\\"The quick brown fox jumps over the lazy dog\\\";\\n * byte[] hmac = new HmacUtils(HMAC_SHA_224, key).hmac(valueToDigest);\\n * // Mac re-use\\n * HmacUtils hm1 = new HmacUtils(\\\"HmacAlgoName\\\", key); // use a valid name here!\\n * String hexPom = hm1.hmacHex(new File(\\\"pom.xml\\\"));\\n * String hexNot = hm1.hmacHex(new File(\\\"NOTICE.txt\\\"));\\n * </pre>\\n * @since 1.10\\n * @version $Id: HmacUtils.java 1811344 2017-10-06 15:19:57Z ggregory $\\n */\\npublic final class HmacUtils {\\n\\n    private static final int STREAM_BUFFER_LENGTH = 1024;\\n\\n    /**\\n    * Returns whether this algorithm is available\\n    *\\n    *@param name the name to check\\n    * @return whether this algorithm is available\\n    * @since 1.11\\n    */\\n    public static boolean isAvailable(final String name) {\\n        try {\\n            Mac.getInstance(name);\\n            return true;\\n        } catch (final NoSuchAlgorithmException e) {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n    * Returns whether this algorithm is available\\n    *\\n    *@param name the name to check\\n    * @return whether this algorithm is available\\n    * @since 1.11\\n    */\\n    public static boolean isAvailable(final HmacAlgorithms name) {\\n        try {\\n            Mac.getInstance(name.getName());\\n            return true;\\n        } catch (final NoSuchAlgorithmException e) {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the HmacMD5 algorithm.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\\n     * </p>\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_MD5, byte[])}\\n     */\\n    @Deprecated\\n    public static Mac getHmacMd5(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_MD5, key);\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the HmacSHA1 algorithm.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\\n     * </p>\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_1, byte[])}\\n     */\\n    @Deprecated\\n    public static Mac getHmacSha1(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_1, key);\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the HmacSHA256 algorithm.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\\n     * </p>\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_256, byte[])}\\n     */\\n    @Deprecated\\n    public static Mac getHmacSha256(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_256, key);\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the HmacSHA384 algorithm.\\n     * <p>\\n     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\\n     * </p>\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_384, byte[])}\\n     */\\n    @Deprecated\\n    public static Mac getHmacSha384(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_384, key);\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the HmacSHA512 algorithm.\\n     * <p>\\n     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\\n     * </p>\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_512, byte[])}\\n     */\\n    @Deprecated\\n    public static Mac getHmacSha512(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_512, key);\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the given <code>algorithm</code>.\\n     *\\n     * @param algorithm\\n     *            the name of the algorithm requested. See\\n     *            <a href= \\\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\\\"\\n     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\\n     *            algorithm names.\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     */\\n    public static Mac getInitializedMac(final HmacAlgorithms algorithm, final byte[] key) {\\n        return getInitializedMac(algorithm.getName(), key);\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the given <code>algorithm</code>.\\n     *\\n     * @param algorithm\\n     *            the name of the algorithm requested. See\\n     *            <a href= \\\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\\\"\\n     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\\n     *            algorithm names.\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     */\\n    public static Mac getInitializedMac(final String algorithm, final byte[] key) {\\n\\n        if (key == null) {\\n            throw new IllegalArgumentException(\\\"Null key\\\");\\n        }\\n\\n        try {\\n            final SecretKeySpec keySpec = new SecretKeySpec(key, algorithm);\\n            final Mac mac = Mac.getInstance(algorithm);\\n            mac.init(keySpec);\\n            return mac;\\n        } catch (final NoSuchAlgorithmException e) {\\n            throw new IllegalArgumentException(e);\\n        } catch (final InvalidKeyException e) {\\n            throw new IllegalArgumentException(e);\\n        }\\n    }\\n\\n    // hmacMd5\\n\\n    /**\\n     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacMD5 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmac(byte[])}\\n     */\\n    @Deprecated\\n    public static byte[] hmacMd5(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacMD5 MAC for the given key and value\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmac(InputStream)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacMd5(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacMD5 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, String).hmac(String)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacMd5(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacMD5 MAC for the given key and value as a hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmacHex(byte[])}\\n     */\\n    @Deprecated\\n    public static String hmacMd5Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacMD5 MAC for the given key and value as a hex string (lowercase)\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmacHex(InputStream)}\\n     */\\n    @Deprecated\\n    public static String hmacMd5Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacMD5 MAC for the given key and value as a hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, String).hmacHex(String)}\\n     */\\n    @Deprecated\\n    public static String hmacMd5Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);\\n    }\\n\\n    // hmacSha1\\n\\n    /**\\n     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA1 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmac(byte[])}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha1(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA1 MAC for the given key and value\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmac(InputStream)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha1(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA1 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, String).hmac(String)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha1(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA1 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmacHex(byte[])}\\n     */\\n    @Deprecated\\n    public static String hmacSha1Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA1 MAC for the given key and value as hex string (lowercase)\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmacHex(InputStream)}\\n     */\\n    @Deprecated\\n    public static String hmacSha1Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA1 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, String).hmacHex(String)}\\n     */\\n    @Deprecated\\n    public static String hmacSha1Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmacHex(valueToDigest);\\n    }\\n\\n    // hmacSha256\\n\\n    /**\\n     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA256 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmac(byte[])}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha256(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA256 MAC for the given key and value\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmac(InputStream)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha256(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA256 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, String).hmac(String)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha256(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA256 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmacHex(byte[])}\\n     */\\n    @Deprecated\\n    public static String hmacSha256Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA256 MAC for the given key and value as hex string (lowercase)\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmacHex(InputStream)}\\n     */\\n    @Deprecated\\n    public static String hmacSha256Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA256 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, String).hmacHex(String)}\\n     */\\n    @Deprecated\\n    public static String hmacSha256Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);\\n    }\\n\\n    // hmacSha384\\n\\n    /**\\n     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA384 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmac(byte[])}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha384(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA384 MAC for the given key and value\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmac(InputStream)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha384(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA384 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, String).hmac(String)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha384(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA384 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmacHex(byte[])}\\n     */\\n    @Deprecated\\n    public static String hmacSha384Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA384 MAC for the given key and value as hex string (lowercase)\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmacHex(InputStream)}\\n     */\\n    @Deprecated\\n    public static String hmacSha384Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA384 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, String).hmacHex(String)}\\n     */\\n    @Deprecated\\n    public static String hmacSha384Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);\\n    }\\n\\n    // hmacSha512\\n\\n    /**\\n     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA512 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmac(byte[])}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha512(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA512 MAC for the given key and value\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmac(InputStream)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha512(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA512 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, String).hmac(String)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha512(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA512 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmacHex(byte[])}\\n     */\\n    @Deprecated\\n    public static String hmacSha512Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA512 MAC for the given key and value as hex string (lowercase)\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmacHex(InputStream)}\\n     */\\n    @Deprecated\\n    public static String hmacSha512Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA512 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, String).hmacHex(String)}\\n     */\\n    @Deprecated\\n    public static String hmacSha512Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);\\n    }\\n\\n    // update\\n\\n    /**\\n     * Resets and then updates the given {@link Mac} with the value.\\n     *\\n     * @param mac\\n     *            the initialized {@link Mac} to update\\n     * @param valueToDigest\\n     *            the value to update the {@link Mac} with (maybe null or empty)\\n     * @return the updated {@link Mac}\\n     * @throws IllegalStateException\\n     *             if the Mac was not initialized\\n     */\\n    public static Mac updateHmac(final Mac mac, final byte[] valueToDigest) {\\n        mac.reset();\\n        mac.update(valueToDigest);\\n        return mac;\\n    }\\n\\n    /**\\n     * Resets and then updates the given {@link Mac} with the value.\\n     *\\n     * @param mac\\n     *            the initialized {@link Mac} to update\\n     * @param valueToDigest\\n     *            the value to update the {@link Mac} with\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return the updated {@link Mac}\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalStateException\\n     *             If the Mac was not initialized\\n     */\\n    public static Mac updateHmac(final Mac mac, final InputStream valueToDigest) throws IOException {\\n        mac.reset();\\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\\n        int read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH);\\n\\n        while (read > -1) {\\n            mac.update(buffer, 0, read);\\n            read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH);\\n        }\\n\\n        return mac;\\n    }\\n\\n    /**\\n     * Resets and then updates the given {@link Mac} with the value.\\n     *\\n     * @param mac\\n     *            the initialized {@link Mac} to update\\n     * @param valueToDigest\\n     *            the value to update the {@link Mac} with (maybe null or empty)\\n     * @return the updated {@link Mac}\\n     * @throws IllegalStateException\\n     *             if the Mac was not initialized\\n     */\\n    public static Mac updateHmac(final Mac mac, final String valueToDigest) {\\n        mac.reset();\\n        mac.update(StringUtils.getBytesUtf8(valueToDigest));\\n        return mac;\\n    }\\n\\n    /**\\n     * Preserves binary compatibity only.\\n     * As for previous versions does not provide useful behaviour\\n     * @deprecated since 1.11; only useful to preserve binary compatibility\\n     */\\n    @Deprecated\\n    public HmacUtils() {\\n        this(null);\\n    }\\n\\n    private final Mac mac;\\n\\n    private HmacUtils(final Mac mac) {\\n        this.mac = mac;\\n    }\\n\\n    /**\\n     * Creates an instance using the provided algorithm type.\\n     *\\n     * @param algorithm to use\\n     * @param  key the key to use\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @since 1.11\\n     */\\n    public HmacUtils(final String algorithm, final byte[] key) {\\n        this(getInitializedMac(algorithm, key));\\n    }\\n\\n    /**\\n     * Creates an instance using the provided algorithm type.\\n     *\\n     * @param algorithm to use\\n     * @param  key the key to use\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @since 1.11\\n     */\\n    public HmacUtils(final String algorithm, final String key) {\\n        this(algorithm, StringUtils.getBytesUtf8(key));\\n    }\\n\\n    /**\\n     * Creates an instance using the provided algorithm type.\\n     *\\n     * @param algorithm to use\\n     * @param  key the key to use\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @since 1.11\\n     */\\n    public HmacUtils(final HmacAlgorithms algorithm, final String key) {\\n        this(algorithm.getName(), StringUtils.getBytesUtf8(key));\\n    }\\n\\n    /**\\n     * Creates an instance using the provided algorithm type.\\n     *\\n     * @param algorithm to use.\\n     * @param key the key to use\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @since 1.11\\n     */\\n    public HmacUtils(final HmacAlgorithms algorithm, final byte[] key) {\\n        this(algorithm.getName(), key);\\n    }\\n\\n    /**\\n     * Returns the digest for the input data.\\n     *\\n     * @param valueToDigest the input to use\\n     * @return the digest as a byte[]\\n     * @since 1.11\\n     */\\n    public byte[] hmac(final byte[] valueToDigest) {\\n        return mac.doFinal(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns the digest for the input data.\\n     *\\n     * @param valueToDigest the input to use\\n     * @return the digest as a hex String\\n     * @since 1.11\\n     */\\n    public String hmacHex(final byte[] valueToDigest) {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\\n\\n    /**\\n     * Returns the digest for the input data.\\n     *\\n     * @param valueToDigest the input to use, treated as UTF-8\\n     * @return the digest as a byte[]\\n     * @since 1.11\\n     */\\n    public byte[] hmac(final String valueToDigest) {\\n        return mac.doFinal(StringUtils.getBytesUtf8(valueToDigest));\\n    }\\n\\n    /**\\n     * Returns the digest for the input data.\\n     *\\n     * @param valueToDigest the input to use, treated as UTF-8\\n     * @return the digest as a hex String\\n     * @since 1.11\\n     */\\n    public String hmacHex(final String valueToDigest) {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\\n\\n    /**\\n     * Returns the digest for the input data.\\n     *\\n     * @param valueToDigest the input to use\\n     * @return the digest as a byte[]\\n     * @since 1.11\\n     */\\n    public byte[] hmac(final ByteBuffer valueToDigest) {\\n        mac.update(valueToDigest);\\n        return mac.doFinal();\\n    }\\n\\n    /**\\n     * Returns the digest for the input data.\\n     *\\n     * @param valueToDigest the input to use\\n     * @return the digest as a hex String\\n     * @since 1.11\\n     */\\n    public String hmacHex(final ByteBuffer valueToDigest) {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\\n\\n    /**\\n     * Returns the digest for the stream.\\n     *\\n     * @param valueToDigest\\n     *            the data to use\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return the digest\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @since 1.11\\n     */\\n    public byte[] hmac(final InputStream valueToDigest) throws IOException {\\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\\n        int read;\\n\\n        while ((read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH) ) > -1) {\\n            mac.update(buffer, 0, read);\\n        }\\n        return mac.doFinal();\\n    }\\n\\n    /**\\n     * Returns the digest for the stream.\\n     *\\n     * @param valueToDigest\\n     *            the data to use\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return the digest as a hex String\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @since 1.11\\n     */\\n    public String hmacHex(final InputStream valueToDigest) throws IOException {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\\n\\n    /**\\n     * Returns the digest for the file.\\n     *\\n     * @param valueToDigest the file to use\\n     * @return the digest\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @since 1.11\\n     */\\n    public byte[] hmac(final File valueToDigest) throws IOException {\\n        final BufferedInputStream stream = new BufferedInputStream(new FileInputStream(valueToDigest));\\n        try {\\n            return hmac(stream);\\n        } finally {\\n            stream.close();\\n        }\\n    }\\n\\n    /**\\n     * Returns the digest for the file.\\n     *\\n     * @param valueToDigest the file to use\\n     * @return the digest as a hex String\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @since 1.11\\n     */\\n    public String hmacHex(final File valueToDigest) throws IOException {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"HmacUtils\", \"position\": {\"start_line\": 57, \"end_line\": 1088, \"start_column\": 14, \"end_column\": 1}, \"code\": \"class HmacUtils {\\n\\n    private static final int STREAM_BUFFER_LENGTH = 1024;\\n\\n    /**\\n    * Returns whether this algorithm is available\\n    *\\n    *@param name the name to check\\n    * @return whether this algorithm is available\\n    * @since 1.11\\n    */\\n    public static boolean isAvailable(final String name) {\\n        try {\\n            Mac.getInstance(name);\\n            return true;\\n        } catch (final NoSuchAlgorithmException e) {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n    * Returns whether this algorithm is available\\n    *\\n    *@param name the name to check\\n    * @return whether this algorithm is available\\n    * @since 1.11\\n    */\\n    public static boolean isAvailable(final HmacAlgorithms name) {\\n        try {\\n            Mac.getInstance(name.getName());\\n            return true;\\n        } catch (final NoSuchAlgorithmException e) {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the HmacMD5 algorithm.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\\n     * </p>\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_MD5, byte[])}\\n     */\\n    @Deprecated\\n    public static Mac getHmacMd5(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_MD5, key);\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the HmacSHA1 algorithm.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\\n     * </p>\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_1, byte[])}\\n     */\\n    @Deprecated\\n    public static Mac getHmacSha1(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_1, key);\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the HmacSHA256 algorithm.\\n     * <p>\\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\\n     * </p>\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_256, byte[])}\\n     */\\n    @Deprecated\\n    public static Mac getHmacSha256(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_256, key);\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the HmacSHA384 algorithm.\\n     * <p>\\n     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\\n     * </p>\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_384, byte[])}\\n     */\\n    @Deprecated\\n    public static Mac getHmacSha384(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_384, key);\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the HmacSHA512 algorithm.\\n     * <p>\\n     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\\n     * </p>\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_512, byte[])}\\n     */\\n    @Deprecated\\n    public static Mac getHmacSha512(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_512, key);\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the given <code>algorithm</code>.\\n     *\\n     * @param algorithm\\n     *            the name of the algorithm requested. See\\n     *            <a href= \\\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\\\"\\n     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\\n     *            algorithm names.\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     */\\n    public static Mac getInitializedMac(final HmacAlgorithms algorithm, final byte[] key) {\\n        return getInitializedMac(algorithm.getName(), key);\\n    }\\n\\n    /**\\n     * Returns an initialized <code>Mac</code> for the given <code>algorithm</code>.\\n     *\\n     * @param algorithm\\n     *            the name of the algorithm requested. See\\n     *            <a href= \\\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\\\"\\n     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\\n     *            algorithm names.\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @return A Mac instance initialized with the given key.\\n     * @see Mac#getInstance(String)\\n     * @see Mac#init(Key)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     */\\n    public static Mac getInitializedMac(final String algorithm, final byte[] key) {\\n\\n        if (key == null) {\\n            throw new IllegalArgumentException(\\\"Null key\\\");\\n        }\\n\\n        try {\\n            final SecretKeySpec keySpec = new SecretKeySpec(key, algorithm);\\n            final Mac mac = Mac.getInstance(algorithm);\\n            mac.init(keySpec);\\n            return mac;\\n        } catch (final NoSuchAlgorithmException e) {\\n            throw new IllegalArgumentException(e);\\n        } catch (final InvalidKeyException e) {\\n            throw new IllegalArgumentException(e);\\n        }\\n    }\\n\\n    // hmacMd5\\n\\n    /**\\n     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacMD5 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmac(byte[])}\\n     */\\n    @Deprecated\\n    public static byte[] hmacMd5(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacMD5 MAC for the given key and value\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmac(InputStream)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacMd5(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacMD5 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, String).hmac(String)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacMd5(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacMD5 MAC for the given key and value as a hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmacHex(byte[])}\\n     */\\n    @Deprecated\\n    public static String hmacMd5Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacMD5 MAC for the given key and value as a hex string (lowercase)\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, byte[]).hmacHex(InputStream)}\\n     */\\n    @Deprecated\\n    public static String hmacMd5Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacMD5 Message Authentication Code (MAC) as a hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacMD5 MAC for the given key and value as a hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, String).hmacHex(String)}\\n     */\\n    @Deprecated\\n    public static String hmacMd5Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);\\n    }\\n\\n    // hmacSha1\\n\\n    /**\\n     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA1 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmac(byte[])}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha1(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA1 MAC for the given key and value\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmac(InputStream)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha1(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA1 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, String).hmac(String)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha1(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA1 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmacHex(byte[])}\\n     */\\n    @Deprecated\\n    public static String hmacSha1Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA1 MAC for the given key and value as hex string (lowercase)\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, byte[]).hmacHex(InputStream)}\\n     */\\n    @Deprecated\\n    public static String hmacSha1Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA1 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA1 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, String).hmacHex(String)}\\n     */\\n    @Deprecated\\n    public static String hmacSha1Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmacHex(valueToDigest);\\n    }\\n\\n    // hmacSha256\\n\\n    /**\\n     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA256 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmac(byte[])}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha256(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA256 MAC for the given key and value\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmac(InputStream)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha256(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA256 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, String).hmac(String)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha256(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA256 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmacHex(byte[])}\\n     */\\n    @Deprecated\\n    public static String hmacSha256Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA256 MAC for the given key and value as hex string (lowercase)\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, byte[]).hmacHex(InputStream)}\\n     */\\n    @Deprecated\\n    public static String hmacSha256Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA256 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA256 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, String).hmacHex(String)}\\n     */\\n    @Deprecated\\n    public static String hmacSha256Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);\\n    }\\n\\n    // hmacSha384\\n\\n    /**\\n     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA384 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmac(byte[])}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha384(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA384 MAC for the given key and value\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmac(InputStream)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha384(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA384 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, String).hmac(String)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha384(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA384 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmacHex(byte[])}\\n     */\\n    @Deprecated\\n    public static String hmacSha384Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA384 MAC for the given key and value as hex string (lowercase)\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, byte[]).hmacHex(InputStream)}\\n     */\\n    @Deprecated\\n    public static String hmacSha384Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA384 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA384 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, String).hmacHex(String)}\\n     */\\n    @Deprecated\\n    public static String hmacSha384Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);\\n    }\\n\\n    // hmacSha512\\n\\n    /**\\n     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA512 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmac(byte[])}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha512(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA512 MAC for the given key and value\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmac(InputStream)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha512(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA512 MAC for the given key and value\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, String).hmac(String)}\\n     */\\n    @Deprecated\\n    public static byte[] hmacSha512(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmac(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA512 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmacHex(byte[])}\\n     */\\n    @Deprecated\\n    public static String hmacSha512Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return HmacSHA512 MAC for the given key and value as hex string (lowercase)\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, byte[]).hmacHex(InputStream)}\\n     */\\n    @Deprecated\\n    public static String hmacSha512Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns a HmacSHA512 Message Authentication Code (MAC) as hex string (lowercase) for the given key and value.\\n     *\\n     * @param key\\n     *            They key for the keyed digest (must not be null)\\n     * @param valueToDigest\\n     *            The value (data) which should to digest (maybe empty or null)\\n     * @return HmacSHA512 MAC for the given key and value as hex string (lowercase)\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, String).hmacHex(String)}\\n     */\\n    @Deprecated\\n    public static String hmacSha512Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);\\n    }\\n\\n    // update\\n\\n    /**\\n     * Resets and then updates the given {@link Mac} with the value.\\n     *\\n     * @param mac\\n     *            the initialized {@link Mac} to update\\n     * @param valueToDigest\\n     *            the value to update the {@link Mac} with (maybe null or empty)\\n     * @return the updated {@link Mac}\\n     * @throws IllegalStateException\\n     *             if the Mac was not initialized\\n     */\\n    public static Mac updateHmac(final Mac mac, final byte[] valueToDigest) {\\n        mac.reset();\\n        mac.update(valueToDigest);\\n        return mac;\\n    }\\n\\n    /**\\n     * Resets and then updates the given {@link Mac} with the value.\\n     *\\n     * @param mac\\n     *            the initialized {@link Mac} to update\\n     * @param valueToDigest\\n     *            the value to update the {@link Mac} with\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return the updated {@link Mac}\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @throws IllegalStateException\\n     *             If the Mac was not initialized\\n     */\\n    public static Mac updateHmac(final Mac mac, final InputStream valueToDigest) throws IOException {\\n        mac.reset();\\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\\n        int read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH);\\n\\n        while (read > -1) {\\n            mac.update(buffer, 0, read);\\n            read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH);\\n        }\\n\\n        return mac;\\n    }\\n\\n    /**\\n     * Resets and then updates the given {@link Mac} with the value.\\n     *\\n     * @param mac\\n     *            the initialized {@link Mac} to update\\n     * @param valueToDigest\\n     *            the value to update the {@link Mac} with (maybe null or empty)\\n     * @return the updated {@link Mac}\\n     * @throws IllegalStateException\\n     *             if the Mac was not initialized\\n     */\\n    public static Mac updateHmac(final Mac mac, final String valueToDigest) {\\n        mac.reset();\\n        mac.update(StringUtils.getBytesUtf8(valueToDigest));\\n        return mac;\\n    }\\n\\n    /**\\n     * Preserves binary compatibity only.\\n     * As for previous versions does not provide useful behaviour\\n     * @deprecated since 1.11; only useful to preserve binary compatibility\\n     */\\n    @Deprecated\\n    public HmacUtils() {\\n        this(null);\\n    }\\n\\n    private final Mac mac;\\n\\n    private HmacUtils(final Mac mac) {\\n        this.mac = mac;\\n    }\\n\\n    /**\\n     * Creates an instance using the provided algorithm type.\\n     *\\n     * @param algorithm to use\\n     * @param  key the key to use\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @since 1.11\\n     */\\n    public HmacUtils(final String algorithm, final byte[] key) {\\n        this(getInitializedMac(algorithm, key));\\n    }\\n\\n    /**\\n     * Creates an instance using the provided algorithm type.\\n     *\\n     * @param algorithm to use\\n     * @param  key the key to use\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @since 1.11\\n     */\\n    public HmacUtils(final String algorithm, final String key) {\\n        this(algorithm, StringUtils.getBytesUtf8(key));\\n    }\\n\\n    /**\\n     * Creates an instance using the provided algorithm type.\\n     *\\n     * @param algorithm to use\\n     * @param  key the key to use\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @since 1.11\\n     */\\n    public HmacUtils(final HmacAlgorithms algorithm, final String key) {\\n        this(algorithm.getName(), StringUtils.getBytesUtf8(key));\\n    }\\n\\n    /**\\n     * Creates an instance using the provided algorithm type.\\n     *\\n     * @param algorithm to use.\\n     * @param key the key to use\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\\n     * @since 1.11\\n     */\\n    public HmacUtils(final HmacAlgorithms algorithm, final byte[] key) {\\n        this(algorithm.getName(), key);\\n    }\\n\\n    /**\\n     * Returns the digest for the input data.\\n     *\\n     * @param valueToDigest the input to use\\n     * @return the digest as a byte[]\\n     * @since 1.11\\n     */\\n    public byte[] hmac(final byte[] valueToDigest) {\\n        return mac.doFinal(valueToDigest);\\n    }\\n\\n    /**\\n     * Returns the digest for the input data.\\n     *\\n     * @param valueToDigest the input to use\\n     * @return the digest as a hex String\\n     * @since 1.11\\n     */\\n    public String hmacHex(final byte[] valueToDigest) {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\\n\\n    /**\\n     * Returns the digest for the input data.\\n     *\\n     * @param valueToDigest the input to use, treated as UTF-8\\n     * @return the digest as a byte[]\\n     * @since 1.11\\n     */\\n    public byte[] hmac(final String valueToDigest) {\\n        return mac.doFinal(StringUtils.getBytesUtf8(valueToDigest));\\n    }\\n\\n    /**\\n     * Returns the digest for the input data.\\n     *\\n     * @param valueToDigest the input to use, treated as UTF-8\\n     * @return the digest as a hex String\\n     * @since 1.11\\n     */\\n    public String hmacHex(final String valueToDigest) {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\\n\\n    /**\\n     * Returns the digest for the input data.\\n     *\\n     * @param valueToDigest the input to use\\n     * @return the digest as a byte[]\\n     * @since 1.11\\n     */\\n    public byte[] hmac(final ByteBuffer valueToDigest) {\\n        mac.update(valueToDigest);\\n        return mac.doFinal();\\n    }\\n\\n    /**\\n     * Returns the digest for the input data.\\n     *\\n     * @param valueToDigest the input to use\\n     * @return the digest as a hex String\\n     * @since 1.11\\n     */\\n    public String hmacHex(final ByteBuffer valueToDigest) {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\\n\\n    /**\\n     * Returns the digest for the stream.\\n     *\\n     * @param valueToDigest\\n     *            the data to use\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return the digest\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @since 1.11\\n     */\\n    public byte[] hmac(final InputStream valueToDigest) throws IOException {\\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\\n        int read;\\n\\n        while ((read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH) ) > -1) {\\n            mac.update(buffer, 0, read);\\n        }\\n        return mac.doFinal();\\n    }\\n\\n    /**\\n     * Returns the digest for the stream.\\n     *\\n     * @param valueToDigest\\n     *            the data to use\\n     *            <p>\\n     *            The InputStream must not be null and will not be closed\\n     *            </p>\\n     * @return the digest as a hex String\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @since 1.11\\n     */\\n    public String hmacHex(final InputStream valueToDigest) throws IOException {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\\n\\n    /**\\n     * Returns the digest for the file.\\n     *\\n     * @param valueToDigest the file to use\\n     * @return the digest\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @since 1.11\\n     */\\n    public byte[] hmac(final File valueToDigest) throws IOException {\\n        final BufferedInputStream stream = new BufferedInputStream(new FileInputStream(valueToDigest));\\n        try {\\n            return hmac(stream);\\n        } finally {\\n            stream.close();\\n        }\\n    }\\n\\n    /**\\n     * Returns the digest for the file.\\n     *\\n     * @param valueToDigest the file to use\\n     * @return the digest as a hex String\\n     * @throws IOException\\n     *             If an I/O error occurs.\\n     * @since 1.11\\n     */\\n    public String hmacHex(final File valueToDigest) throws IOException {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"isAvailable\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 68, \"end_line\": 75, \"start_column\": 19, \"end_column\": 5}, \"code\": \"boolean isAvailable(final String name) {\\n        try {\\n            Mac.getInstance(name);\\n            return true;\\n        } catch (final NoSuchAlgorithmException e) {\\n            return false;\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"name\", \"type\": \"String\"}]}, {\"name\": \"isAvailable\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 84, \"end_line\": 91, \"start_column\": 19, \"end_column\": 5}, \"code\": \"boolean isAvailable(final HmacAlgorithms name) {\\n        try {\\n            Mac.getInstance(name.getName());\\n            return true;\\n        } catch (final NoSuchAlgorithmException e) {\\n            return false;\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"name\", \"type\": \"HmacAlgorithms\"}]}, {\"name\": \"getHmacMd5\", \"return_type\": \"Mac\", \"position\": {\"start_line\": 109, \"end_line\": 111, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Mac getHmacMd5(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_MD5, key);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}]}, {\"name\": \"getHmacSha1\", \"return_type\": \"Mac\", \"position\": {\"start_line\": 129, \"end_line\": 131, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Mac getHmacSha1(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_1, key);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}]}, {\"name\": \"getHmacSha256\", \"return_type\": \"Mac\", \"position\": {\"start_line\": 149, \"end_line\": 151, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Mac getHmacSha256(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_256, key);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}]}, {\"name\": \"getHmacSha384\", \"return_type\": \"Mac\", \"position\": {\"start_line\": 169, \"end_line\": 171, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Mac getHmacSha384(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_384, key);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}]}, {\"name\": \"getHmacSha512\", \"return_type\": \"Mac\", \"position\": {\"start_line\": 189, \"end_line\": 191, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Mac getHmacSha512(final byte[] key) {\\n        return getInitializedMac(HmacAlgorithms.HMAC_SHA_512, key);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}]}, {\"name\": \"getInitializedMac\", \"return_type\": \"Mac\", \"position\": {\"start_line\": 209, \"end_line\": 211, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Mac getInitializedMac(final HmacAlgorithms algorithm, final byte[] key) {\\n        return getInitializedMac(algorithm.getName(), key);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"algorithm\", \"type\": \"HmacAlgorithms\"}, {\"name\": \"key\", \"type\": \"byte\"}]}, {\"name\": \"getInitializedMac\", \"return_type\": \"Mac\", \"position\": {\"start_line\": 229, \"end_line\": 245, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Mac getInitializedMac(final String algorithm, final byte[] key) {\\n\\n        if (key == null) {\\n            throw new IllegalArgumentException(\\\"Null key\\\");\\n        }\\n\\n        try {\\n            final SecretKeySpec keySpec = new SecretKeySpec(key, algorithm);\\n            final Mac mac = Mac.getInstance(algorithm);\\n            mac.init(keySpec);\\n            return mac;\\n        } catch (final NoSuchAlgorithmException e) {\\n            throw new IllegalArgumentException(e);\\n        } catch (final InvalidKeyException e) {\\n            throw new IllegalArgumentException(e);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"algorithm\", \"type\": \"String\"}, {\"name\": \"key\", \"type\": \"byte\"}]}, {\"name\": \"hmacMd5\", \"return_type\": \"byte\", \"position\": {\"start_line\": 262, \"end_line\": 264, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacMd5(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"hmacMd5\", \"return_type\": \"byte\", \"position\": {\"start_line\": 284, \"end_line\": 286, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacMd5(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"hmacMd5\", \"return_type\": \"byte\", \"position\": {\"start_line\": 301, \"end_line\": 303, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacMd5(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"String\"}, {\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"hmacMd5Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 318, \"end_line\": 320, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacMd5Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"hmacMd5Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 340, \"end_line\": 342, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacMd5Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"hmacMd5Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 357, \"end_line\": 359, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacMd5Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_MD5, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"String\"}, {\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"hmacSha1\", \"return_type\": \"byte\", \"position\": {\"start_line\": 376, \"end_line\": 378, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacSha1(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"hmacSha1\", \"return_type\": \"byte\", \"position\": {\"start_line\": 398, \"end_line\": 400, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacSha1(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"hmacSha1\", \"return_type\": \"byte\", \"position\": {\"start_line\": 415, \"end_line\": 417, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacSha1(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"String\"}, {\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"hmacSha1Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 432, \"end_line\": 434, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacSha1Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"hmacSha1Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 454, \"end_line\": 456, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacSha1Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"hmacSha1Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 471, \"end_line\": 473, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacSha1Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_1, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"String\"}, {\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"hmacSha256\", \"return_type\": \"byte\", \"position\": {\"start_line\": 490, \"end_line\": 492, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacSha256(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"hmacSha256\", \"return_type\": \"byte\", \"position\": {\"start_line\": 512, \"end_line\": 514, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacSha256(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"hmacSha256\", \"return_type\": \"byte\", \"position\": {\"start_line\": 529, \"end_line\": 531, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacSha256(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"String\"}, {\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"hmacSha256Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 546, \"end_line\": 548, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacSha256Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"hmacSha256Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 568, \"end_line\": 570, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacSha256Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"hmacSha256Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 585, \"end_line\": 587, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacSha256Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"String\"}, {\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"hmacSha384\", \"return_type\": \"byte\", \"position\": {\"start_line\": 604, \"end_line\": 606, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacSha384(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"hmacSha384\", \"return_type\": \"byte\", \"position\": {\"start_line\": 626, \"end_line\": 628, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacSha384(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"hmacSha384\", \"return_type\": \"byte\", \"position\": {\"start_line\": 643, \"end_line\": 645, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacSha384(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"String\"}, {\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"hmacSha384Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 660, \"end_line\": 662, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacSha384Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"hmacSha384Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 682, \"end_line\": 684, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacSha384Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"hmacSha384Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 699, \"end_line\": 701, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacSha384Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_384, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"String\"}, {\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"hmacSha512\", \"return_type\": \"byte\", \"position\": {\"start_line\": 718, \"end_line\": 720, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacSha512(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"hmacSha512\", \"return_type\": \"byte\", \"position\": {\"start_line\": 740, \"end_line\": 742, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacSha512(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"hmacSha512\", \"return_type\": \"byte\", \"position\": {\"start_line\": 757, \"end_line\": 759, \"start_column\": 19, \"end_column\": 5}, \"code\": \"byte[] hmacSha512(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmac(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"String\"}, {\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"hmacSha512Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 774, \"end_line\": 776, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacSha512Hex(final byte[] key, final byte[] valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"hmacSha512Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 796, \"end_line\": 798, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacSha512Hex(final byte[] key, final InputStream valueToDigest) throws IOException {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}, {\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"hmacSha512Hex\", \"return_type\": \"String\", \"position\": {\"start_line\": 813, \"end_line\": 815, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String hmacSha512Hex(final String key, final String valueToDigest) {\\n        return new HmacUtils(HmacAlgorithms.HMAC_SHA_512, key).hmacHex(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"String\"}, {\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"updateHmac\", \"return_type\": \"Mac\", \"position\": {\"start_line\": 830, \"end_line\": 834, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Mac updateHmac(final Mac mac, final byte[] valueToDigest) {\\n        mac.reset();\\n        mac.update(valueToDigest);\\n        return mac;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"mac\", \"type\": \"Mac\"}, {\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"updateHmac\", \"return_type\": \"Mac\", \"position\": {\"start_line\": 852, \"end_line\": 863, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Mac updateHmac(final Mac mac, final InputStream valueToDigest) throws IOException {\\n        mac.reset();\\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\\n        int read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH);\\n\\n        while (read > -1) {\\n            mac.update(buffer, 0, read);\\n            read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH);\\n        }\\n\\n        return mac;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"mac\", \"type\": \"Mac\"}, {\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"updateHmac\", \"return_type\": \"Mac\", \"position\": {\"start_line\": 876, \"end_line\": 880, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Mac updateHmac(final Mac mac, final String valueToDigest) {\\n        mac.reset();\\n        mac.update(StringUtils.getBytesUtf8(valueToDigest));\\n        return mac;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"mac\", \"type\": \"Mac\"}, {\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"hmac\", \"return_type\": \"byte\", \"position\": {\"start_line\": 957, \"end_line\": 959, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] hmac(final byte[] valueToDigest) {\\n        return mac.doFinal(valueToDigest);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"hmacHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 968, \"end_line\": 970, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String hmacHex(final byte[] valueToDigest) {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"valueToDigest\", \"type\": \"byte\"}]}, {\"name\": \"hmac\", \"return_type\": \"byte\", \"position\": {\"start_line\": 979, \"end_line\": 981, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] hmac(final String valueToDigest) {\\n        return mac.doFinal(StringUtils.getBytesUtf8(valueToDigest));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"hmacHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 990, \"end_line\": 992, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String hmacHex(final String valueToDigest) {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"valueToDigest\", \"type\": \"String\"}]}, {\"name\": \"hmac\", \"return_type\": \"byte\", \"position\": {\"start_line\": 1001, \"end_line\": 1004, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] hmac(final ByteBuffer valueToDigest) {\\n        mac.update(valueToDigest);\\n        return mac.doFinal();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"valueToDigest\", \"type\": \"ByteBuffer\"}]}, {\"name\": \"hmacHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 1013, \"end_line\": 1015, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String hmacHex(final ByteBuffer valueToDigest) {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"valueToDigest\", \"type\": \"ByteBuffer\"}]}, {\"name\": \"hmac\", \"return_type\": \"byte\", \"position\": {\"start_line\": 1030, \"end_line\": 1038, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] hmac(final InputStream valueToDigest) throws IOException {\\n        final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\\n        int read;\\n\\n        while ((read = valueToDigest.read(buffer, 0, STREAM_BUFFER_LENGTH) ) > -1) {\\n            mac.update(buffer, 0, read);\\n        }\\n        return mac.doFinal();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"hmacHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 1053, \"end_line\": 1055, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String hmacHex(final InputStream valueToDigest) throws IOException {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"valueToDigest\", \"type\": \"InputStream\"}]}, {\"name\": \"hmac\", \"return_type\": \"byte\", \"position\": {\"start_line\": 1066, \"end_line\": 1073, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] hmac(final File valueToDigest) throws IOException {\\n        final BufferedInputStream stream = new BufferedInputStream(new FileInputStream(valueToDigest));\\n        try {\\n            return hmac(stream);\\n        } finally {\\n            stream.close();\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"valueToDigest\", \"type\": \"File\"}]}, {\"name\": \"hmacHex\", \"return_type\": \"String\", \"position\": {\"start_line\": 1084, \"end_line\": 1086, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String hmacHex(final File valueToDigest) throws IOException {\\n        return Hex.encodeHexString(hmac(valueToDigest));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"valueToDigest\", \"type\": \"File\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/digest/Md5Crypt.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npackage org.apache.commons.codec.digest;\\n\\nimport java.security.MessageDigest;\\nimport java.util.Arrays;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\nimport org.apache.commons.codec.Charsets;\\n\\n/**\\n * The libc crypt() \\\"$1$\\\" and Apache \\\"$apr1$\\\" MD5-based hash algorithm.\\n * <p>\\n * Based on the public domain (\\\"beer-ware\\\") C implementation from Poul-Henning Kamp which was found at: <a\\n * href=\\\"http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/libcrypt/crypt-md5.c?rev=1.1;content-type=text%2Fplain\\\">\\n * crypt-md5.c @ freebsd.org</a><br>\\n * <p>\\n * Source:\\n *\\n * <pre>\\n * $FreeBSD: src/lib/libcrypt/crypt-md5.c,v 1.1 1999/01/21 13:50:09 brandon Exp $\\n * </pre>\\n * <p>\\n * Conversion to Kotlin and from there to Java in 2012.\\n * <p>\\n * The C style comments are from the original C code, the ones with \\\"//\\\" from the port.\\n * <p>\\n * This class is immutable and thread-safe.\\n *\\n * @version $Id: Md5Crypt.java 1744746 2016-05-20 14:19:43Z sebb $\\n * @since 1.7\\n */\\npublic class Md5Crypt {\\n\\n    /** The Identifier of the Apache variant. */\\n    static final String APR1_PREFIX = \\\"$apr1$\\\";\\n\\n    /** The number of bytes of the final hash. */\\n    private static final int BLOCKSIZE = 16;\\n\\n    /** The Identifier of this crypt() variant. */\\n    static final String MD5_PREFIX = \\\"$1$\\\";\\n\\n    /** The number of rounds of the big loop. */\\n    private static final int ROUNDS = 1000;\\n\\n    /**\\n     * See {@link #apr1Crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @return the hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught. *\\n     */\\n    public static String apr1Crypt(final byte[] keyBytes) {\\n        return apr1Crypt(keyBytes, APR1_PREFIX + B64.getRandomSalt(8));\\n    }\\n\\n    /**\\n     * See {@link #apr1Crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @param salt An APR1 salt.\\n     * @return the hash value\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String apr1Crypt(final byte[] keyBytes, String salt) {\\n        // to make the md5Crypt regex happy\\n        if (salt != null && !salt.startsWith(APR1_PREFIX)) {\\n            salt = APR1_PREFIX + salt;\\n        }\\n        return Md5Crypt.md5Crypt(keyBytes, salt, APR1_PREFIX);\\n    }\\n\\n    /**\\n     * See {@link #apr1Crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @return the hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String apr1Crypt(final String keyBytes) {\\n        return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8));\\n    }\\n\\n    /**\\n     * Generates an Apache htpasswd compatible \\\"$apr1$\\\" MD5 based hash value.\\n     * <p>\\n     * The algorithm is identical to the crypt(3) \\\"$1$\\\" one but produces different outputs due to the different salt\\n     * prefix.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @param salt\\n     *            salt string including the prefix and optionally garbage at the end. Will be generated randomly if\\n     *            null.\\n     * @return the hash value\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String apr1Crypt(final String keyBytes, final String salt) {\\n        return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8), salt);\\n    }\\n\\n    /**\\n     * Generates a libc6 crypt() compatible \\\"$1$\\\" hash value.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @return the hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String md5Crypt(final byte[] keyBytes) {\\n        return md5Crypt(keyBytes, MD5_PREFIX + B64.getRandomSalt(8));\\n    }\\n\\n    /**\\n     * Generates a libc crypt() compatible \\\"$1$\\\" MD5 based hash value.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @param salt\\n     *            salt string including the prefix and optionally garbage at the end. Will be generated randomly if\\n     *            null.\\n     * @return the hash value\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String md5Crypt(final byte[] keyBytes, final String salt) {\\n        return md5Crypt(keyBytes, salt, MD5_PREFIX);\\n    }\\n\\n    /**\\n     * Generates a libc6 crypt() \\\"$1$\\\" or Apache htpasswd \\\"$apr1$\\\" hash value.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @param salt May be null.\\n     * @param prefix salt prefix\\n     * @return the hash value\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {\\n        final int keyLen = keyBytes.length;\\n\\n        // Extract the real salt from the given string which can be a complete hash string.\\n        String saltString;\\n        if (salt == null) {\\n            saltString = B64.getRandomSalt(8);\\n        } else {\\n            final Pattern p = Pattern.compile(\\\"^\\\" + prefix.replace(\\\"$\\\", \\\"\\\\\\\\$\\\") + \\\"([\\\\\\\\.\\\\\\\\/a-zA-Z0-9]{1,8}).*\\\");\\n            final Matcher m = p.matcher(salt);\\n            if (!m.find()) {\\n                throw new IllegalArgumentException(\\\"Invalid salt value: \\\" + salt);\\n            }\\n            saltString = m.group(1);\\n        }\\n        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\\n\\n        final MessageDigest ctx = DigestUtils.getMd5Digest();\\n\\n        /*\\n         * The password first, since that is what is most unknown\\n         */\\n        ctx.update(keyBytes);\\n\\n        /*\\n         * Then our magic string\\n         */\\n        ctx.update(prefix.getBytes(Charsets.UTF_8));\\n\\n        /*\\n         * Then the raw salt\\n         */\\n        ctx.update(saltBytes);\\n\\n        /*\\n         * Then just as many characters of the MD5(pw,salt,pw)\\n         */\\n        MessageDigest ctx1 = DigestUtils.getMd5Digest();\\n        ctx1.update(keyBytes);\\n        ctx1.update(saltBytes);\\n        ctx1.update(keyBytes);\\n        byte[] finalb = ctx1.digest();\\n        int ii = keyLen;\\n        while (ii > 0) {\\n            ctx.update(finalb, 0, ii > 16 ? 16 : ii);\\n            ii -= 16;\\n        }\\n\\n        /*\\n         * Don't leave anything around in vm they could use.\\n         */\\n        Arrays.fill(finalb, (byte) 0);\\n\\n        /*\\n         * Then something really weird...\\n         */\\n        ii = keyLen;\\n        final int j = 0;\\n        while (ii > 0) {\\n            if ((ii & 1) == 1) {\\n                ctx.update(finalb[j]);\\n            } else {\\n                ctx.update(keyBytes[j]);\\n            }\\n            ii >>= 1;\\n        }\\n\\n        /*\\n         * Now make the output string\\n         */\\n        final StringBuilder passwd = new StringBuilder(prefix + saltString + \\\"$\\\");\\n        finalb = ctx.digest();\\n\\n        /*\\n         * and now, just to make sure things don't run too fast On a 60 Mhz Pentium this takes 34 msec, so you would\\n         * need 30 seconds to build a 1000 entry dictionary...\\n         */\\n        for (int i = 0; i < ROUNDS; i++) {\\n            ctx1 = DigestUtils.getMd5Digest();\\n            if ((i & 1) != 0) {\\n                ctx1.update(keyBytes);\\n            } else {\\n                ctx1.update(finalb, 0, BLOCKSIZE);\\n            }\\n\\n            if (i % 3 != 0) {\\n                ctx1.update(saltBytes);\\n            }\\n\\n            if (i % 7 != 0) {\\n                ctx1.update(keyBytes);\\n            }\\n\\n            if ((i & 1) != 0) {\\n                ctx1.update(finalb, 0, BLOCKSIZE);\\n            } else {\\n                ctx1.update(keyBytes);\\n            }\\n            finalb = ctx1.digest();\\n        }\\n\\n        // The following was nearly identical to the Sha2Crypt code.\\n        // Again, the buflen is not really needed.\\n        // int buflen = MD5_PREFIX.length() - 1 + salt_string.length() + 1 + BLOCKSIZE + 1;\\n        B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);\\n        B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);\\n        B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);\\n        B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);\\n        B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);\\n        B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);\\n\\n        /*\\n         * Don't leave anything around in vm they could use.\\n         */\\n        // Is there a better way to do this with the JVM?\\n        ctx.reset();\\n        ctx1.reset();\\n        Arrays.fill(keyBytes, (byte) 0);\\n        Arrays.fill(saltBytes, (byte) 0);\\n        Arrays.fill(finalb, (byte) 0);\\n\\n        return passwd.toString();\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Md5Crypt\", \"position\": {\"start_line\": 48, \"end_line\": 302, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Md5Crypt {\\n\\n    /** The Identifier of the Apache variant. */\\n    static final String APR1_PREFIX = \\\"$apr1$\\\";\\n\\n    /** The number of bytes of the final hash. */\\n    private static final int BLOCKSIZE = 16;\\n\\n    /** The Identifier of this crypt() variant. */\\n    static final String MD5_PREFIX = \\\"$1$\\\";\\n\\n    /** The number of rounds of the big loop. */\\n    private static final int ROUNDS = 1000;\\n\\n    /**\\n     * See {@link #apr1Crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @return the hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught. *\\n     */\\n    public static String apr1Crypt(final byte[] keyBytes) {\\n        return apr1Crypt(keyBytes, APR1_PREFIX + B64.getRandomSalt(8));\\n    }\\n\\n    /**\\n     * See {@link #apr1Crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @param salt An APR1 salt.\\n     * @return the hash value\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String apr1Crypt(final byte[] keyBytes, String salt) {\\n        // to make the md5Crypt regex happy\\n        if (salt != null && !salt.startsWith(APR1_PREFIX)) {\\n            salt = APR1_PREFIX + salt;\\n        }\\n        return Md5Crypt.md5Crypt(keyBytes, salt, APR1_PREFIX);\\n    }\\n\\n    /**\\n     * See {@link #apr1Crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @return the hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String apr1Crypt(final String keyBytes) {\\n        return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8));\\n    }\\n\\n    /**\\n     * Generates an Apache htpasswd compatible \\\"$apr1$\\\" MD5 based hash value.\\n     * <p>\\n     * The algorithm is identical to the crypt(3) \\\"$1$\\\" one but produces different outputs due to the different salt\\n     * prefix.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @param salt\\n     *            salt string including the prefix and optionally garbage at the end. Will be generated randomly if\\n     *            null.\\n     * @return the hash value\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String apr1Crypt(final String keyBytes, final String salt) {\\n        return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8), salt);\\n    }\\n\\n    /**\\n     * Generates a libc6 crypt() compatible \\\"$1$\\\" hash value.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @return the hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String md5Crypt(final byte[] keyBytes) {\\n        return md5Crypt(keyBytes, MD5_PREFIX + B64.getRandomSalt(8));\\n    }\\n\\n    /**\\n     * Generates a libc crypt() compatible \\\"$1$\\\" MD5 based hash value.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @param salt\\n     *            salt string including the prefix and optionally garbage at the end. Will be generated randomly if\\n     *            null.\\n     * @return the hash value\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String md5Crypt(final byte[] keyBytes, final String salt) {\\n        return md5Crypt(keyBytes, salt, MD5_PREFIX);\\n    }\\n\\n    /**\\n     * Generates a libc6 crypt() \\\"$1$\\\" or Apache htpasswd \\\"$apr1$\\\" hash value.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext string to hash.\\n     * @param salt May be null.\\n     * @param prefix salt prefix\\n     * @return the hash value\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {\\n        final int keyLen = keyBytes.length;\\n\\n        // Extract the real salt from the given string which can be a complete hash string.\\n        String saltString;\\n        if (salt == null) {\\n            saltString = B64.getRandomSalt(8);\\n        } else {\\n            final Pattern p = Pattern.compile(\\\"^\\\" + prefix.replace(\\\"$\\\", \\\"\\\\\\\\$\\\") + \\\"([\\\\\\\\.\\\\\\\\/a-zA-Z0-9]{1,8}).*\\\");\\n            final Matcher m = p.matcher(salt);\\n            if (!m.find()) {\\n                throw new IllegalArgumentException(\\\"Invalid salt value: \\\" + salt);\\n            }\\n            saltString = m.group(1);\\n        }\\n        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\\n\\n        final MessageDigest ctx = DigestUtils.getMd5Digest();\\n\\n        /*\\n         * The password first, since that is what is most unknown\\n         */\\n        ctx.update(keyBytes);\\n\\n        /*\\n         * Then our magic string\\n         */\\n        ctx.update(prefix.getBytes(Charsets.UTF_8));\\n\\n        /*\\n         * Then the raw salt\\n         */\\n        ctx.update(saltBytes);\\n\\n        /*\\n         * Then just as many characters of the MD5(pw,salt,pw)\\n         */\\n        MessageDigest ctx1 = DigestUtils.getMd5Digest();\\n        ctx1.update(keyBytes);\\n        ctx1.update(saltBytes);\\n        ctx1.update(keyBytes);\\n        byte[] finalb = ctx1.digest();\\n        int ii = keyLen;\\n        while (ii > 0) {\\n            ctx.update(finalb, 0, ii > 16 ? 16 : ii);\\n            ii -= 16;\\n        }\\n\\n        /*\\n         * Don't leave anything around in vm they could use.\\n         */\\n        Arrays.fill(finalb, (byte) 0);\\n\\n        /*\\n         * Then something really weird...\\n         */\\n        ii = keyLen;\\n        final int j = 0;\\n        while (ii > 0) {\\n            if ((ii & 1) == 1) {\\n                ctx.update(finalb[j]);\\n            } else {\\n                ctx.update(keyBytes[j]);\\n            }\\n            ii >>= 1;\\n        }\\n\\n        /*\\n         * Now make the output string\\n         */\\n        final StringBuilder passwd = new StringBuilder(prefix + saltString + \\\"$\\\");\\n        finalb = ctx.digest();\\n\\n        /*\\n         * and now, just to make sure things don't run too fast On a 60 Mhz Pentium this takes 34 msec, so you would\\n         * need 30 seconds to build a 1000 entry dictionary...\\n         */\\n        for (int i = 0; i < ROUNDS; i++) {\\n            ctx1 = DigestUtils.getMd5Digest();\\n            if ((i & 1) != 0) {\\n                ctx1.update(keyBytes);\\n            } else {\\n                ctx1.update(finalb, 0, BLOCKSIZE);\\n            }\\n\\n            if (i % 3 != 0) {\\n                ctx1.update(saltBytes);\\n            }\\n\\n            if (i % 7 != 0) {\\n                ctx1.update(keyBytes);\\n            }\\n\\n            if ((i & 1) != 0) {\\n                ctx1.update(finalb, 0, BLOCKSIZE);\\n            } else {\\n                ctx1.update(keyBytes);\\n            }\\n            finalb = ctx1.digest();\\n        }\\n\\n        // The following was nearly identical to the Sha2Crypt code.\\n        // Again, the buflen is not really needed.\\n        // int buflen = MD5_PREFIX.length() - 1 + salt_string.length() + 1 + BLOCKSIZE + 1;\\n        B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);\\n        B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);\\n        B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);\\n        B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);\\n        B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);\\n        B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);\\n\\n        /*\\n         * Don't leave anything around in vm they could use.\\n         */\\n        // Is there a better way to do this with the JVM?\\n        ctx.reset();\\n        ctx1.reset();\\n        Arrays.fill(keyBytes, (byte) 0);\\n        Arrays.fill(saltBytes, (byte) 0);\\n        Arrays.fill(finalb, (byte) 0);\\n\\n        return passwd.toString();\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"apr1Crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 71, \"end_line\": 73, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String apr1Crypt(final byte[] keyBytes) {\\n        return apr1Crypt(keyBytes, APR1_PREFIX + B64.getRandomSalt(8));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"byte\"}]}, {\"name\": \"apr1Crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 87, \"end_line\": 93, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String apr1Crypt(final byte[] keyBytes, String salt) {\\n        // to make the md5Crypt regex happy\\n        if (salt != null && !salt.startsWith(APR1_PREFIX)) {\\n            salt = APR1_PREFIX + salt;\\n        }\\n        return Md5Crypt.md5Crypt(keyBytes, salt, APR1_PREFIX);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"byte\"}, {\"name\": \"salt\", \"type\": \"String\"}]}, {\"name\": \"apr1Crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 104, \"end_line\": 106, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String apr1Crypt(final String keyBytes) {\\n        return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"String\"}]}, {\"name\": \"apr1Crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 125, \"end_line\": 127, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String apr1Crypt(final String keyBytes, final String salt) {\\n        return apr1Crypt(keyBytes.getBytes(Charsets.UTF_8), salt);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"String\"}, {\"name\": \"salt\", \"type\": \"String\"}]}, {\"name\": \"md5Crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 140, \"end_line\": 142, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String md5Crypt(final byte[] keyBytes) {\\n        return md5Crypt(keyBytes, MD5_PREFIX + B64.getRandomSalt(8));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"byte\"}]}, {\"name\": \"md5Crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 160, \"end_line\": 162, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String md5Crypt(final byte[] keyBytes, final String salt) {\\n        return md5Crypt(keyBytes, salt, MD5_PREFIX);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"byte\"}, {\"name\": \"salt\", \"type\": \"String\"}]}, {\"name\": \"md5Crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 179, \"end_line\": 301, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String md5Crypt(final byte[] keyBytes, final String salt, final String prefix) {\\n        final int keyLen = keyBytes.length;\\n\\n        // Extract the real salt from the given string which can be a complete hash string.\\n        String saltString;\\n        if (salt == null) {\\n            saltString = B64.getRandomSalt(8);\\n        } else {\\n            final Pattern p = Pattern.compile(\\\"^\\\" + prefix.replace(\\\"$\\\", \\\"\\\\\\\\$\\\") + \\\"([\\\\\\\\.\\\\\\\\/a-zA-Z0-9]{1,8}).*\\\");\\n            final Matcher m = p.matcher(salt);\\n            if (!m.find()) {\\n                throw new IllegalArgumentException(\\\"Invalid salt value: \\\" + salt);\\n            }\\n            saltString = m.group(1);\\n        }\\n        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\\n\\n        final MessageDigest ctx = DigestUtils.getMd5Digest();\\n\\n        /*\\n         * The password first, since that is what is most unknown\\n         */\\n        ctx.update(keyBytes);\\n\\n        /*\\n         * Then our magic string\\n         */\\n        ctx.update(prefix.getBytes(Charsets.UTF_8));\\n\\n        /*\\n         * Then the raw salt\\n         */\\n        ctx.update(saltBytes);\\n\\n        /*\\n         * Then just as many characters of the MD5(pw,salt,pw)\\n         */\\n        MessageDigest ctx1 = DigestUtils.getMd5Digest();\\n        ctx1.update(keyBytes);\\n        ctx1.update(saltBytes);\\n        ctx1.update(keyBytes);\\n        byte[] finalb = ctx1.digest();\\n        int ii = keyLen;\\n        while (ii > 0) {\\n            ctx.update(finalb, 0, ii > 16 ? 16 : ii);\\n            ii -= 16;\\n        }\\n\\n        /*\\n         * Don't leave anything around in vm they could use.\\n         */\\n        Arrays.fill(finalb, (byte) 0);\\n\\n        /*\\n         * Then something really weird...\\n         */\\n        ii = keyLen;\\n        final int j = 0;\\n        while (ii > 0) {\\n            if ((ii & 1) == 1) {\\n                ctx.update(finalb[j]);\\n            } else {\\n                ctx.update(keyBytes[j]);\\n            }\\n            ii >>= 1;\\n        }\\n\\n        /*\\n         * Now make the output string\\n         */\\n        final StringBuilder passwd = new StringBuilder(prefix + saltString + \\\"$\\\");\\n        finalb = ctx.digest();\\n\\n        /*\\n         * and now, just to make sure things don't run too fast On a 60 Mhz Pentium this takes 34 msec, so you would\\n         * need 30 seconds to build a 1000 entry dictionary...\\n         */\\n        for (int i = 0; i < ROUNDS; i++) {\\n            ctx1 = DigestUtils.getMd5Digest();\\n            if ((i & 1) != 0) {\\n                ctx1.update(keyBytes);\\n            } else {\\n                ctx1.update(finalb, 0, BLOCKSIZE);\\n            }\\n\\n            if (i % 3 != 0) {\\n                ctx1.update(saltBytes);\\n            }\\n\\n            if (i % 7 != 0) {\\n                ctx1.update(keyBytes);\\n            }\\n\\n            if ((i & 1) != 0) {\\n                ctx1.update(finalb, 0, BLOCKSIZE);\\n            } else {\\n                ctx1.update(keyBytes);\\n            }\\n            finalb = ctx1.digest();\\n        }\\n\\n        // The following was nearly identical to the Sha2Crypt code.\\n        // Again, the buflen is not really needed.\\n        // int buflen = MD5_PREFIX.length() - 1 + salt_string.length() + 1 + BLOCKSIZE + 1;\\n        B64.b64from24bit(finalb[0], finalb[6], finalb[12], 4, passwd);\\n        B64.b64from24bit(finalb[1], finalb[7], finalb[13], 4, passwd);\\n        B64.b64from24bit(finalb[2], finalb[8], finalb[14], 4, passwd);\\n        B64.b64from24bit(finalb[3], finalb[9], finalb[15], 4, passwd);\\n        B64.b64from24bit(finalb[4], finalb[10], finalb[5], 4, passwd);\\n        B64.b64from24bit((byte) 0, (byte) 0, finalb[11], 2, passwd);\\n\\n        /*\\n         * Don't leave anything around in vm they could use.\\n         */\\n        // Is there a better way to do this with the JVM?\\n        ctx.reset();\\n        ctx1.reset();\\n        Arrays.fill(keyBytes, (byte) 0);\\n        Arrays.fill(saltBytes, (byte) 0);\\n        Arrays.fill(finalb, (byte) 0);\\n\\n        return passwd.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"byte\"}, {\"name\": \"salt\", \"type\": \"String\"}, {\"name\": \"prefix\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/digest/MessageDigestAlgorithms.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.digest;\\n\\nimport java.security.MessageDigest;\\n\\n/**\\n * Standard {@link MessageDigest} algorithm names from the <cite>Java Cryptography Architecture Standard Algorithm Name\\n * Documentation</cite>.\\n * <p>\\n * This class is immutable and thread-safe.\\n * </p>\\n * <p>\\n * Java 8 and up: SHA-224.\\n * </p>\\n * <p>\\n * Java 9 and up: SHA3-224, SHA3-256, SHA3-384, SHA3-512.\\n * </p>\\n *\\n * @see <a href=\\\"http://docs.oracle.com/javase/6/docs/technotes/guides/security/StandardNames.html#MessageDigest\\\">\\n *      Java 6 Cryptography Architecture Standard Algorithm Name Documentation</a>\\n * @see <a href=\\\"http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#MessageDigest\\\">\\n *      Java 7 Cryptography Architecture Standard Algorithm Name Documentation</a>\\n * @see <a href=\\\"http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest\\\">\\n *      Java 8 Cryptography Architecture Standard Algorithm Name Documentation</a>\\n * @see <a href=\\\"http://download.java.net/java/jdk9/docs/technotes/guides/security/StandardNames.html#MessageDigest\\\">\\n *      Java 9 Cryptography Architecture Standard Algorithm Name Documentation</a>\\n *\\n * @see <a href=\\\"http://dx.doi.org/10.6028/NIST.FIPS.180-4\\\">FIPS PUB 180-4</a>\\n * @see <a href=\\\"http://dx.doi.org/10.6028/NIST.FIPS.202\\\">FIPS PUB 202</a>\\n * @since 1.7\\n * @version $Id: MessageDigestAlgorithms.java 1744728 2016-05-20 12:55:58Z sebb $\\n */\\npublic class MessageDigestAlgorithms {\\n\\n    /**\\n     * The MD2 message digest algorithm defined in RFC 1319.\\n     */\\n    public static final String MD2 = \\\"MD2\\\";\\n\\n    /**\\n     * The MD5 message digest algorithm defined in RFC 1321.\\n     */\\n    public static final String MD5 = \\\"MD5\\\";\\n\\n    /**\\n     * The SHA-1 hash algorithm defined in the FIPS PUB 180-2.\\n     */\\n    public static final String SHA_1 = \\\"SHA-1\\\";\\n\\n    /**\\n     * The SHA-224 hash algorithm defined in the FIPS PUB 180-3.\\n     * <p>\\n     * Present in Oracle Java 8.\\n     * </p>\\n     *\\n     * @since 1.11\\n     */\\n    public static final String SHA_224 = \\\"SHA-224\\\";\\n\\n    /**\\n     * The SHA-256 hash algorithm defined in the FIPS PUB 180-2.\\n     */\\n    public static final String SHA_256 = \\\"SHA-256\\\";\\n\\n    /**\\n     * The SHA-384 hash algorithm defined in the FIPS PUB 180-2.\\n     */\\n    public static final String SHA_384 = \\\"SHA-384\\\";\\n\\n    /**\\n     * The SHA-512 hash algorithm defined in the FIPS PUB 180-2.\\n     */\\n    public static final String SHA_512 = \\\"SHA-512\\\";\\n\\n    /**\\n     * The SHA3-224 hash algorithm defined in the FIPS PUB 202.\\n     * <p>\\n     * Likely to be included in Oracle Java 9 GA.\\n     * </p>\\n     *\\n     * @since 1.11\\n     */\\n    public static final String SHA3_224 = \\\"SHA3-224\\\";\\n\\n    /**\\n     * The SHA3-256 hash algorithm defined in the FIPS PUB 202.\\n     * <p>\\n     * Likely to be included in Oracle Java 9 GA.\\n     * </p>\\n     *\\n     * @since 1.11\\n     */\\n    public static final String SHA3_256 = \\\"SHA3-256\\\";\\n\\n    /**\\n     * The SHA3-384 hash algorithm defined in the FIPS PUB 202.\\n     * <p>\\n     * Likely to be included in Oracle Java 9 GA.\\n     * </p>\\n     *\\n     * @since 1.11\\n     */\\n    public static final String SHA3_384 = \\\"SHA3-384\\\";\\n\\n    /**\\n     * The SHA3-512 hash algorithm defined in the FIPS PUB 202.\\n     * <p>\\n     * Likely to be included in Oracle Java 9 GA.\\n     * </p>\\n     *\\n     * @since 1.11\\n     */\\n    public static final String SHA3_512 = \\\"SHA3-512\\\";\\n\\n    /**\\n     * Gets all constant values defined in this class.\\n     *\\n     * @return all constant values defined in this class.\\n     * @since 1.11\\n     */\\n    public static String[] values() {\\n        // N.B. do not use a constant array here as that can be changed externally by accident or design\\n        return new String[] {\\n            MD2, MD5, SHA_1, SHA_224, SHA_256, SHA_384, SHA_512, SHA3_224, SHA3_256, SHA3_384, SHA3_512\\n        };\\n    }\\n\\n    private MessageDigestAlgorithms() {\\n        // cannot be instantiated.\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"MessageDigestAlgorithms\", \"position\": {\"start_line\": 49, \"end_line\": 148, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class MessageDigestAlgorithms {\\n\\n    /**\\n     * The MD2 message digest algorithm defined in RFC 1319.\\n     */\\n    public static final String MD2 = \\\"MD2\\\";\\n\\n    /**\\n     * The MD5 message digest algorithm defined in RFC 1321.\\n     */\\n    public static final String MD5 = \\\"MD5\\\";\\n\\n    /**\\n     * The SHA-1 hash algorithm defined in the FIPS PUB 180-2.\\n     */\\n    public static final String SHA_1 = \\\"SHA-1\\\";\\n\\n    /**\\n     * The SHA-224 hash algorithm defined in the FIPS PUB 180-3.\\n     * <p>\\n     * Present in Oracle Java 8.\\n     * </p>\\n     *\\n     * @since 1.11\\n     */\\n    public static final String SHA_224 = \\\"SHA-224\\\";\\n\\n    /**\\n     * The SHA-256 hash algorithm defined in the FIPS PUB 180-2.\\n     */\\n    public static final String SHA_256 = \\\"SHA-256\\\";\\n\\n    /**\\n     * The SHA-384 hash algorithm defined in the FIPS PUB 180-2.\\n     */\\n    public static final String SHA_384 = \\\"SHA-384\\\";\\n\\n    /**\\n     * The SHA-512 hash algorithm defined in the FIPS PUB 180-2.\\n     */\\n    public static final String SHA_512 = \\\"SHA-512\\\";\\n\\n    /**\\n     * The SHA3-224 hash algorithm defined in the FIPS PUB 202.\\n     * <p>\\n     * Likely to be included in Oracle Java 9 GA.\\n     * </p>\\n     *\\n     * @since 1.11\\n     */\\n    public static final String SHA3_224 = \\\"SHA3-224\\\";\\n\\n    /**\\n     * The SHA3-256 hash algorithm defined in the FIPS PUB 202.\\n     * <p>\\n     * Likely to be included in Oracle Java 9 GA.\\n     * </p>\\n     *\\n     * @since 1.11\\n     */\\n    public static final String SHA3_256 = \\\"SHA3-256\\\";\\n\\n    /**\\n     * The SHA3-384 hash algorithm defined in the FIPS PUB 202.\\n     * <p>\\n     * Likely to be included in Oracle Java 9 GA.\\n     * </p>\\n     *\\n     * @since 1.11\\n     */\\n    public static final String SHA3_384 = \\\"SHA3-384\\\";\\n\\n    /**\\n     * The SHA3-512 hash algorithm defined in the FIPS PUB 202.\\n     * <p>\\n     * Likely to be included in Oracle Java 9 GA.\\n     * </p>\\n     *\\n     * @since 1.11\\n     */\\n    public static final String SHA3_512 = \\\"SHA3-512\\\";\\n\\n    /**\\n     * Gets all constant values defined in this class.\\n     *\\n     * @return all constant values defined in this class.\\n     * @since 1.11\\n     */\\n    public static String[] values() {\\n        // N.B. do not use a constant array here as that can be changed externally by accident or design\\n        return new String[] {\\n            MD2, MD5, SHA_1, SHA_224, SHA_256, SHA_384, SHA_512, SHA3_224, SHA3_256, SHA3_384, SHA3_512\\n        };\\n    }\\n\\n    private MessageDigestAlgorithms() {\\n        // cannot be instantiated.\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"values\", \"return_type\": \"String\", \"position\": {\"start_line\": 137, \"end_line\": 142, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String[] values() {\\n        // N.B. do not use a constant array here as that can be changed externally by accident or design\\n        return new String[] {\\n            MD2, MD5, SHA_1, SHA_224, SHA_256, SHA_384, SHA_512, SHA3_224, SHA3_256, SHA3_384, SHA3_512\\n        };\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/digest/PureJavaCrc32.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npackage org.apache.commons.codec.digest;\\n\\nimport java.util.zip.Checksum;\\n\\n/**\\n * A pure-java implementation of the CRC32 checksum that uses\\n * the same polynomial as the built-in native CRC32.\\n *\\n * This is to avoid the JNI overhead for certain uses of Checksumming\\n * where many small pieces of data are checksummed in succession.\\n *\\n * The current version is ~10x to 1.8x as fast as Sun's native\\n * java.util.zip.CRC32 in Java 1.6\\n *\\n * Copied from Hadoop 2.6.3.\\n * The code agrees with the following file in the 2.6.3 tag:\\n * https://git-wip-us.apache.org/repos/asf?p=hadoop.git;a=blob_plain;\\n * f=hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/PureJavaCrc32.java;\\n * hb=2120de588b92b9f22b1cc4188761d6a8c61aa778\\n * <p>\\n * This class is Not ThreadSafe\\n *\\n * @see java.util.zip.CRC32\\n * @since 1.11\\n */\\npublic class PureJavaCrc32 implements Checksum {\\n\\n  /** the current CRC value, bit-flipped */\\n  private int crc;\\n\\n  /** Create a new PureJavaCrc32 object. */\\n  public PureJavaCrc32() {\\n    _reset();\\n  }\\n\\n  @Override\\n  public long getValue() {\\n    return (~crc) & 0xffffffffL;\\n  }\\n\\n  @Override\\n  public void reset() {\\n    _reset();\\n  }\\n\\n  // called by ctor, so must not be overrideable\\n  private void _reset() {\\n    crc = 0xffffffff;\\n  }\\n\\n  @Override\\n  public void update(final byte[] b, final int offset, final int len) {\\n    int localCrc = crc;\\n\\n    final int remainder = len & 0x7;\\n    int i = offset;\\n    for(final int end = offset + len - remainder; i < end; i += 8) {\\n      final int x = localCrc ^\\n          ((((b[i  ] << 24) >>> 24) + ((b[i+1] << 24) >>> 16)) +\\n          (((b[i+2] << 24) >>> 8 ) +  (b[i+3] << 24)));\\n\\n      localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^\\n                 (T[((x <<  8) >>> 24) + 0x500] ^ T[ (x        >>> 24) + 0x400])) ^\\n                 ((T[((b[i+4] << 24) >>> 24) + 0x300] ^ T[((b[i+5] << 24) >>> 24) + 0x200]) ^\\n                 (T[((b[i+6] << 24) >>> 24) + 0x100] ^ T[((b[i+7] << 24) >>> 24)]));\\n    }\\n\\n    /* loop unroll - duff's device style */\\n    switch(remainder) {\\n      case 7: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 6: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 5: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 4: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 3: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 2: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 1: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      default:\\n        /* nothing */\\n    }\\n\\n    // Publish crc out to object\\n    crc = localCrc;\\n  }\\n\\n  @Override\\n  final public void update(final int b) {\\n    crc = (crc >>> 8) ^ T[(((crc ^ b) << 24) >>> 24)];\\n  }\\n\\n  /*\\n   * CRC-32 lookup tables generated by the polynomial 0xEDB88320.\\n   * See also TestPureJavaCrc32.Table.\\n   */\\n  private static final int[] T = new int[] {\\n    /* T8_0 */\\n    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,\\n    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\\n    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,\\n    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,\\n    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,\\n    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\\n    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,\\n    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,\\n    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,\\n    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\\n    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,\\n    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\\n    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,\\n    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\\n    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,\\n    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\\n    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,\\n    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\\n    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,\\n    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\\n    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,\\n    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,\\n    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,\\n    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\\n    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,\\n    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,\\n    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,\\n    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,\\n    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,\\n    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\\n    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,\\n    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,\\n    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,\\n    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,\\n    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,\\n    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\\n    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,\\n    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,\\n    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,\\n    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\\n    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,\\n    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\\n    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,\\n    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,\\n    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,\\n    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,\\n    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,\\n    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\\n    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,\\n    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\\n    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,\\n    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,\\n    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,\\n    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\\n    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,\\n    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,\\n    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,\\n    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,\\n    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,\\n    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\\n    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,\\n    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,\\n    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,\\n    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,\\n    /* T8_1 */\\n    0x00000000, 0x191B3141, 0x32366282, 0x2B2D53C3,\\n    0x646CC504, 0x7D77F445, 0x565AA786, 0x4F4196C7,\\n    0xC8D98A08, 0xD1C2BB49, 0xFAEFE88A, 0xE3F4D9CB,\\n    0xACB54F0C, 0xB5AE7E4D, 0x9E832D8E, 0x87981CCF,\\n    0x4AC21251, 0x53D92310, 0x78F470D3, 0x61EF4192,\\n    0x2EAED755, 0x37B5E614, 0x1C98B5D7, 0x05838496,\\n    0x821B9859, 0x9B00A918, 0xB02DFADB, 0xA936CB9A,\\n    0xE6775D5D, 0xFF6C6C1C, 0xD4413FDF, 0xCD5A0E9E,\\n    0x958424A2, 0x8C9F15E3, 0xA7B24620, 0xBEA97761,\\n    0xF1E8E1A6, 0xE8F3D0E7, 0xC3DE8324, 0xDAC5B265,\\n    0x5D5DAEAA, 0x44469FEB, 0x6F6BCC28, 0x7670FD69,\\n    0x39316BAE, 0x202A5AEF, 0x0B07092C, 0x121C386D,\\n    0xDF4636F3, 0xC65D07B2, 0xED705471, 0xF46B6530,\\n    0xBB2AF3F7, 0xA231C2B6, 0x891C9175, 0x9007A034,\\n    0x179FBCFB, 0x0E848DBA, 0x25A9DE79, 0x3CB2EF38,\\n    0x73F379FF, 0x6AE848BE, 0x41C51B7D, 0x58DE2A3C,\\n    0xF0794F05, 0xE9627E44, 0xC24F2D87, 0xDB541CC6,\\n    0x94158A01, 0x8D0EBB40, 0xA623E883, 0xBF38D9C2,\\n    0x38A0C50D, 0x21BBF44C, 0x0A96A78F, 0x138D96CE,\\n    0x5CCC0009, 0x45D73148, 0x6EFA628B, 0x77E153CA,\\n    0xBABB5D54, 0xA3A06C15, 0x888D3FD6, 0x91960E97,\\n    0xDED79850, 0xC7CCA911, 0xECE1FAD2, 0xF5FACB93,\\n    0x7262D75C, 0x6B79E61D, 0x4054B5DE, 0x594F849F,\\n    0x160E1258, 0x0F152319, 0x243870DA, 0x3D23419B,\\n    0x65FD6BA7, 0x7CE65AE6, 0x57CB0925, 0x4ED03864,\\n    0x0191AEA3, 0x188A9FE2, 0x33A7CC21, 0x2ABCFD60,\\n    0xAD24E1AF, 0xB43FD0EE, 0x9F12832D, 0x8609B26C,\\n    0xC94824AB, 0xD05315EA, 0xFB7E4629, 0xE2657768,\\n    0x2F3F79F6, 0x362448B7, 0x1D091B74, 0x04122A35,\\n    0x4B53BCF2, 0x52488DB3, 0x7965DE70, 0x607EEF31,\\n    0xE7E6F3FE, 0xFEFDC2BF, 0xD5D0917C, 0xCCCBA03D,\\n    0x838A36FA, 0x9A9107BB, 0xB1BC5478, 0xA8A76539,\\n    0x3B83984B, 0x2298A90A, 0x09B5FAC9, 0x10AECB88,\\n    0x5FEF5D4F, 0x46F46C0E, 0x6DD93FCD, 0x74C20E8C,\\n    0xF35A1243, 0xEA412302, 0xC16C70C1, 0xD8774180,\\n    0x9736D747, 0x8E2DE606, 0xA500B5C5, 0xBC1B8484,\\n    0x71418A1A, 0x685ABB5B, 0x4377E898, 0x5A6CD9D9,\\n    0x152D4F1E, 0x0C367E5F, 0x271B2D9C, 0x3E001CDD,\\n    0xB9980012, 0xA0833153, 0x8BAE6290, 0x92B553D1,\\n    0xDDF4C516, 0xC4EFF457, 0xEFC2A794, 0xF6D996D5,\\n    0xAE07BCE9, 0xB71C8DA8, 0x9C31DE6B, 0x852AEF2A,\\n    0xCA6B79ED, 0xD37048AC, 0xF85D1B6F, 0xE1462A2E,\\n    0x66DE36E1, 0x7FC507A0, 0x54E85463, 0x4DF36522,\\n    0x02B2F3E5, 0x1BA9C2A4, 0x30849167, 0x299FA026,\\n    0xE4C5AEB8, 0xFDDE9FF9, 0xD6F3CC3A, 0xCFE8FD7B,\\n    0x80A96BBC, 0x99B25AFD, 0xB29F093E, 0xAB84387F,\\n    0x2C1C24B0, 0x350715F1, 0x1E2A4632, 0x07317773,\\n    0x4870E1B4, 0x516BD0F5, 0x7A468336, 0x635DB277,\\n    0xCBFAD74E, 0xD2E1E60F, 0xF9CCB5CC, 0xE0D7848D,\\n    0xAF96124A, 0xB68D230B, 0x9DA070C8, 0x84BB4189,\\n    0x03235D46, 0x1A386C07, 0x31153FC4, 0x280E0E85,\\n    0x674F9842, 0x7E54A903, 0x5579FAC0, 0x4C62CB81,\\n    0x8138C51F, 0x9823F45E, 0xB30EA79D, 0xAA1596DC,\\n    0xE554001B, 0xFC4F315A, 0xD7626299, 0xCE7953D8,\\n    0x49E14F17, 0x50FA7E56, 0x7BD72D95, 0x62CC1CD4,\\n    0x2D8D8A13, 0x3496BB52, 0x1FBBE891, 0x06A0D9D0,\\n    0x5E7EF3EC, 0x4765C2AD, 0x6C48916E, 0x7553A02F,\\n    0x3A1236E8, 0x230907A9, 0x0824546A, 0x113F652B,\\n    0x96A779E4, 0x8FBC48A5, 0xA4911B66, 0xBD8A2A27,\\n    0xF2CBBCE0, 0xEBD08DA1, 0xC0FDDE62, 0xD9E6EF23,\\n    0x14BCE1BD, 0x0DA7D0FC, 0x268A833F, 0x3F91B27E,\\n    0x70D024B9, 0x69CB15F8, 0x42E6463B, 0x5BFD777A,\\n    0xDC656BB5, 0xC57E5AF4, 0xEE530937, 0xF7483876,\\n    0xB809AEB1, 0xA1129FF0, 0x8A3FCC33, 0x9324FD72,\\n    /* T8_2 */\\n    0x00000000, 0x01C26A37, 0x0384D46E, 0x0246BE59,\\n    0x0709A8DC, 0x06CBC2EB, 0x048D7CB2, 0x054F1685,\\n    0x0E1351B8, 0x0FD13B8F, 0x0D9785D6, 0x0C55EFE1,\\n    0x091AF964, 0x08D89353, 0x0A9E2D0A, 0x0B5C473D,\\n    0x1C26A370, 0x1DE4C947, 0x1FA2771E, 0x1E601D29,\\n    0x1B2F0BAC, 0x1AED619B, 0x18ABDFC2, 0x1969B5F5,\\n    0x1235F2C8, 0x13F798FF, 0x11B126A6, 0x10734C91,\\n    0x153C5A14, 0x14FE3023, 0x16B88E7A, 0x177AE44D,\\n    0x384D46E0, 0x398F2CD7, 0x3BC9928E, 0x3A0BF8B9,\\n    0x3F44EE3C, 0x3E86840B, 0x3CC03A52, 0x3D025065,\\n    0x365E1758, 0x379C7D6F, 0x35DAC336, 0x3418A901,\\n    0x3157BF84, 0x3095D5B3, 0x32D36BEA, 0x331101DD,\\n    0x246BE590, 0x25A98FA7, 0x27EF31FE, 0x262D5BC9,\\n    0x23624D4C, 0x22A0277B, 0x20E69922, 0x2124F315,\\n    0x2A78B428, 0x2BBADE1F, 0x29FC6046, 0x283E0A71,\\n    0x2D711CF4, 0x2CB376C3, 0x2EF5C89A, 0x2F37A2AD,\\n    0x709A8DC0, 0x7158E7F7, 0x731E59AE, 0x72DC3399,\\n    0x7793251C, 0x76514F2B, 0x7417F172, 0x75D59B45,\\n    0x7E89DC78, 0x7F4BB64F, 0x7D0D0816, 0x7CCF6221,\\n    0x798074A4, 0x78421E93, 0x7A04A0CA, 0x7BC6CAFD,\\n    0x6CBC2EB0, 0x6D7E4487, 0x6F38FADE, 0x6EFA90E9,\\n    0x6BB5866C, 0x6A77EC5B, 0x68315202, 0x69F33835,\\n    0x62AF7F08, 0x636D153F, 0x612BAB66, 0x60E9C151,\\n    0x65A6D7D4, 0x6464BDE3, 0x662203BA, 0x67E0698D,\\n    0x48D7CB20, 0x4915A117, 0x4B531F4E, 0x4A917579,\\n    0x4FDE63FC, 0x4E1C09CB, 0x4C5AB792, 0x4D98DDA5,\\n    0x46C49A98, 0x4706F0AF, 0x45404EF6, 0x448224C1,\\n    0x41CD3244, 0x400F5873, 0x4249E62A, 0x438B8C1D,\\n    0x54F16850, 0x55330267, 0x5775BC3E, 0x56B7D609,\\n    0x53F8C08C, 0x523AAABB, 0x507C14E2, 0x51BE7ED5,\\n    0x5AE239E8, 0x5B2053DF, 0x5966ED86, 0x58A487B1,\\n    0x5DEB9134, 0x5C29FB03, 0x5E6F455A, 0x5FAD2F6D,\\n    0xE1351B80, 0xE0F771B7, 0xE2B1CFEE, 0xE373A5D9,\\n    0xE63CB35C, 0xE7FED96B, 0xE5B86732, 0xE47A0D05,\\n    0xEF264A38, 0xEEE4200F, 0xECA29E56, 0xED60F461,\\n    0xE82FE2E4, 0xE9ED88D3, 0xEBAB368A, 0xEA695CBD,\\n    0xFD13B8F0, 0xFCD1D2C7, 0xFE976C9E, 0xFF5506A9,\\n    0xFA1A102C, 0xFBD87A1B, 0xF99EC442, 0xF85CAE75,\\n    0xF300E948, 0xF2C2837F, 0xF0843D26, 0xF1465711,\\n    0xF4094194, 0xF5CB2BA3, 0xF78D95FA, 0xF64FFFCD,\\n    0xD9785D60, 0xD8BA3757, 0xDAFC890E, 0xDB3EE339,\\n    0xDE71F5BC, 0xDFB39F8B, 0xDDF521D2, 0xDC374BE5,\\n    0xD76B0CD8, 0xD6A966EF, 0xD4EFD8B6, 0xD52DB281,\\n    0xD062A404, 0xD1A0CE33, 0xD3E6706A, 0xD2241A5D,\\n    0xC55EFE10, 0xC49C9427, 0xC6DA2A7E, 0xC7184049,\\n    0xC25756CC, 0xC3953CFB, 0xC1D382A2, 0xC011E895,\\n    0xCB4DAFA8, 0xCA8FC59F, 0xC8C97BC6, 0xC90B11F1,\\n    0xCC440774, 0xCD866D43, 0xCFC0D31A, 0xCE02B92D,\\n    0x91AF9640, 0x906DFC77, 0x922B422E, 0x93E92819,\\n    0x96A63E9C, 0x976454AB, 0x9522EAF2, 0x94E080C5,\\n    0x9FBCC7F8, 0x9E7EADCF, 0x9C381396, 0x9DFA79A1,\\n    0x98B56F24, 0x99770513, 0x9B31BB4A, 0x9AF3D17D,\\n    0x8D893530, 0x8C4B5F07, 0x8E0DE15E, 0x8FCF8B69,\\n    0x8A809DEC, 0x8B42F7DB, 0x89044982, 0x88C623B5,\\n    0x839A6488, 0x82580EBF, 0x801EB0E6, 0x81DCDAD1,\\n    0x8493CC54, 0x8551A663, 0x8717183A, 0x86D5720D,\\n    0xA9E2D0A0, 0xA820BA97, 0xAA6604CE, 0xABA46EF9,\\n    0xAEEB787C, 0xAF29124B, 0xAD6FAC12, 0xACADC625,\\n    0xA7F18118, 0xA633EB2F, 0xA4755576, 0xA5B73F41,\\n    0xA0F829C4, 0xA13A43F3, 0xA37CFDAA, 0xA2BE979D,\\n    0xB5C473D0, 0xB40619E7, 0xB640A7BE, 0xB782CD89,\\n    0xB2CDDB0C, 0xB30FB13B, 0xB1490F62, 0xB08B6555,\\n    0xBBD72268, 0xBA15485F, 0xB853F606, 0xB9919C31,\\n    0xBCDE8AB4, 0xBD1CE083, 0xBF5A5EDA, 0xBE9834ED,\\n    /* T8_3 */\\n    0x00000000, 0xB8BC6765, 0xAA09C88B, 0x12B5AFEE,\\n    0x8F629757, 0x37DEF032, 0x256B5FDC, 0x9DD738B9,\\n    0xC5B428EF, 0x7D084F8A, 0x6FBDE064, 0xD7018701,\\n    0x4AD6BFB8, 0xF26AD8DD, 0xE0DF7733, 0x58631056,\\n    0x5019579F, 0xE8A530FA, 0xFA109F14, 0x42ACF871,\\n    0xDF7BC0C8, 0x67C7A7AD, 0x75720843, 0xCDCE6F26,\\n    0x95AD7F70, 0x2D111815, 0x3FA4B7FB, 0x8718D09E,\\n    0x1ACFE827, 0xA2738F42, 0xB0C620AC, 0x087A47C9,\\n    0xA032AF3E, 0x188EC85B, 0x0A3B67B5, 0xB28700D0,\\n    0x2F503869, 0x97EC5F0C, 0x8559F0E2, 0x3DE59787,\\n    0x658687D1, 0xDD3AE0B4, 0xCF8F4F5A, 0x7733283F,\\n    0xEAE41086, 0x525877E3, 0x40EDD80D, 0xF851BF68,\\n    0xF02BF8A1, 0x48979FC4, 0x5A22302A, 0xE29E574F,\\n    0x7F496FF6, 0xC7F50893, 0xD540A77D, 0x6DFCC018,\\n    0x359FD04E, 0x8D23B72B, 0x9F9618C5, 0x272A7FA0,\\n    0xBAFD4719, 0x0241207C, 0x10F48F92, 0xA848E8F7,\\n    0x9B14583D, 0x23A83F58, 0x311D90B6, 0x89A1F7D3,\\n    0x1476CF6A, 0xACCAA80F, 0xBE7F07E1, 0x06C36084,\\n    0x5EA070D2, 0xE61C17B7, 0xF4A9B859, 0x4C15DF3C,\\n    0xD1C2E785, 0x697E80E0, 0x7BCB2F0E, 0xC377486B,\\n    0xCB0D0FA2, 0x73B168C7, 0x6104C729, 0xD9B8A04C,\\n    0x446F98F5, 0xFCD3FF90, 0xEE66507E, 0x56DA371B,\\n    0x0EB9274D, 0xB6054028, 0xA4B0EFC6, 0x1C0C88A3,\\n    0x81DBB01A, 0x3967D77F, 0x2BD27891, 0x936E1FF4,\\n    0x3B26F703, 0x839A9066, 0x912F3F88, 0x299358ED,\\n    0xB4446054, 0x0CF80731, 0x1E4DA8DF, 0xA6F1CFBA,\\n    0xFE92DFEC, 0x462EB889, 0x549B1767, 0xEC277002,\\n    0x71F048BB, 0xC94C2FDE, 0xDBF98030, 0x6345E755,\\n    0x6B3FA09C, 0xD383C7F9, 0xC1366817, 0x798A0F72,\\n    0xE45D37CB, 0x5CE150AE, 0x4E54FF40, 0xF6E89825,\\n    0xAE8B8873, 0x1637EF16, 0x048240F8, 0xBC3E279D,\\n    0x21E91F24, 0x99557841, 0x8BE0D7AF, 0x335CB0CA,\\n    0xED59B63B, 0x55E5D15E, 0x47507EB0, 0xFFEC19D5,\\n    0x623B216C, 0xDA874609, 0xC832E9E7, 0x708E8E82,\\n    0x28ED9ED4, 0x9051F9B1, 0x82E4565F, 0x3A58313A,\\n    0xA78F0983, 0x1F336EE6, 0x0D86C108, 0xB53AA66D,\\n    0xBD40E1A4, 0x05FC86C1, 0x1749292F, 0xAFF54E4A,\\n    0x322276F3, 0x8A9E1196, 0x982BBE78, 0x2097D91D,\\n    0x78F4C94B, 0xC048AE2E, 0xD2FD01C0, 0x6A4166A5,\\n    0xF7965E1C, 0x4F2A3979, 0x5D9F9697, 0xE523F1F2,\\n    0x4D6B1905, 0xF5D77E60, 0xE762D18E, 0x5FDEB6EB,\\n    0xC2098E52, 0x7AB5E937, 0x680046D9, 0xD0BC21BC,\\n    0x88DF31EA, 0x3063568F, 0x22D6F961, 0x9A6A9E04,\\n    0x07BDA6BD, 0xBF01C1D8, 0xADB46E36, 0x15080953,\\n    0x1D724E9A, 0xA5CE29FF, 0xB77B8611, 0x0FC7E174,\\n    0x9210D9CD, 0x2AACBEA8, 0x38191146, 0x80A57623,\\n    0xD8C66675, 0x607A0110, 0x72CFAEFE, 0xCA73C99B,\\n    0x57A4F122, 0xEF189647, 0xFDAD39A9, 0x45115ECC,\\n    0x764DEE06, 0xCEF18963, 0xDC44268D, 0x64F841E8,\\n    0xF92F7951, 0x41931E34, 0x5326B1DA, 0xEB9AD6BF,\\n    0xB3F9C6E9, 0x0B45A18C, 0x19F00E62, 0xA14C6907,\\n    0x3C9B51BE, 0x842736DB, 0x96929935, 0x2E2EFE50,\\n    0x2654B999, 0x9EE8DEFC, 0x8C5D7112, 0x34E11677,\\n    0xA9362ECE, 0x118A49AB, 0x033FE645, 0xBB838120,\\n    0xE3E09176, 0x5B5CF613, 0x49E959FD, 0xF1553E98,\\n    0x6C820621, 0xD43E6144, 0xC68BCEAA, 0x7E37A9CF,\\n    0xD67F4138, 0x6EC3265D, 0x7C7689B3, 0xC4CAEED6,\\n    0x591DD66F, 0xE1A1B10A, 0xF3141EE4, 0x4BA87981,\\n    0x13CB69D7, 0xAB770EB2, 0xB9C2A15C, 0x017EC639,\\n    0x9CA9FE80, 0x241599E5, 0x36A0360B, 0x8E1C516E,\\n    0x866616A7, 0x3EDA71C2, 0x2C6FDE2C, 0x94D3B949,\\n    0x090481F0, 0xB1B8E695, 0xA30D497B, 0x1BB12E1E,\\n    0x43D23E48, 0xFB6E592D, 0xE9DBF6C3, 0x516791A6,\\n    0xCCB0A91F, 0x740CCE7A, 0x66B96194, 0xDE0506F1,\\n    /* T8_4 */\\n    0x00000000, 0x3D6029B0, 0x7AC05360, 0x47A07AD0,\\n    0xF580A6C0, 0xC8E08F70, 0x8F40F5A0, 0xB220DC10,\\n    0x30704BC1, 0x0D106271, 0x4AB018A1, 0x77D03111,\\n    0xC5F0ED01, 0xF890C4B1, 0xBF30BE61, 0x825097D1,\\n    0x60E09782, 0x5D80BE32, 0x1A20C4E2, 0x2740ED52,\\n    0x95603142, 0xA80018F2, 0xEFA06222, 0xD2C04B92,\\n    0x5090DC43, 0x6DF0F5F3, 0x2A508F23, 0x1730A693,\\n    0xA5107A83, 0x98705333, 0xDFD029E3, 0xE2B00053,\\n    0xC1C12F04, 0xFCA106B4, 0xBB017C64, 0x866155D4,\\n    0x344189C4, 0x0921A074, 0x4E81DAA4, 0x73E1F314,\\n    0xF1B164C5, 0xCCD14D75, 0x8B7137A5, 0xB6111E15,\\n    0x0431C205, 0x3951EBB5, 0x7EF19165, 0x4391B8D5,\\n    0xA121B886, 0x9C419136, 0xDBE1EBE6, 0xE681C256,\\n    0x54A11E46, 0x69C137F6, 0x2E614D26, 0x13016496,\\n    0x9151F347, 0xAC31DAF7, 0xEB91A027, 0xD6F18997,\\n    0x64D15587, 0x59B17C37, 0x1E1106E7, 0x23712F57,\\n    0x58F35849, 0x659371F9, 0x22330B29, 0x1F532299,\\n    0xAD73FE89, 0x9013D739, 0xD7B3ADE9, 0xEAD38459,\\n    0x68831388, 0x55E33A38, 0x124340E8, 0x2F236958,\\n    0x9D03B548, 0xA0639CF8, 0xE7C3E628, 0xDAA3CF98,\\n    0x3813CFCB, 0x0573E67B, 0x42D39CAB, 0x7FB3B51B,\\n    0xCD93690B, 0xF0F340BB, 0xB7533A6B, 0x8A3313DB,\\n    0x0863840A, 0x3503ADBA, 0x72A3D76A, 0x4FC3FEDA,\\n    0xFDE322CA, 0xC0830B7A, 0x872371AA, 0xBA43581A,\\n    0x9932774D, 0xA4525EFD, 0xE3F2242D, 0xDE920D9D,\\n    0x6CB2D18D, 0x51D2F83D, 0x167282ED, 0x2B12AB5D,\\n    0xA9423C8C, 0x9422153C, 0xD3826FEC, 0xEEE2465C,\\n    0x5CC29A4C, 0x61A2B3FC, 0x2602C92C, 0x1B62E09C,\\n    0xF9D2E0CF, 0xC4B2C97F, 0x8312B3AF, 0xBE729A1F,\\n    0x0C52460F, 0x31326FBF, 0x7692156F, 0x4BF23CDF,\\n    0xC9A2AB0E, 0xF4C282BE, 0xB362F86E, 0x8E02D1DE,\\n    0x3C220DCE, 0x0142247E, 0x46E25EAE, 0x7B82771E,\\n    0xB1E6B092, 0x8C869922, 0xCB26E3F2, 0xF646CA42,\\n    0x44661652, 0x79063FE2, 0x3EA64532, 0x03C66C82,\\n    0x8196FB53, 0xBCF6D2E3, 0xFB56A833, 0xC6368183,\\n    0x74165D93, 0x49767423, 0x0ED60EF3, 0x33B62743,\\n    0xD1062710, 0xEC660EA0, 0xABC67470, 0x96A65DC0,\\n    0x248681D0, 0x19E6A860, 0x5E46D2B0, 0x6326FB00,\\n    0xE1766CD1, 0xDC164561, 0x9BB63FB1, 0xA6D61601,\\n    0x14F6CA11, 0x2996E3A1, 0x6E369971, 0x5356B0C1,\\n    0x70279F96, 0x4D47B626, 0x0AE7CCF6, 0x3787E546,\\n    0x85A73956, 0xB8C710E6, 0xFF676A36, 0xC2074386,\\n    0x4057D457, 0x7D37FDE7, 0x3A978737, 0x07F7AE87,\\n    0xB5D77297, 0x88B75B27, 0xCF1721F7, 0xF2770847,\\n    0x10C70814, 0x2DA721A4, 0x6A075B74, 0x576772C4,\\n    0xE547AED4, 0xD8278764, 0x9F87FDB4, 0xA2E7D404,\\n    0x20B743D5, 0x1DD76A65, 0x5A7710B5, 0x67173905,\\n    0xD537E515, 0xE857CCA5, 0xAFF7B675, 0x92979FC5,\\n    0xE915E8DB, 0xD475C16B, 0x93D5BBBB, 0xAEB5920B,\\n    0x1C954E1B, 0x21F567AB, 0x66551D7B, 0x5B3534CB,\\n    0xD965A31A, 0xE4058AAA, 0xA3A5F07A, 0x9EC5D9CA,\\n    0x2CE505DA, 0x11852C6A, 0x562556BA, 0x6B457F0A,\\n    0x89F57F59, 0xB49556E9, 0xF3352C39, 0xCE550589,\\n    0x7C75D999, 0x4115F029, 0x06B58AF9, 0x3BD5A349,\\n    0xB9853498, 0x84E51D28, 0xC34567F8, 0xFE254E48,\\n    0x4C059258, 0x7165BBE8, 0x36C5C138, 0x0BA5E888,\\n    0x28D4C7DF, 0x15B4EE6F, 0x521494BF, 0x6F74BD0F,\\n    0xDD54611F, 0xE03448AF, 0xA794327F, 0x9AF41BCF,\\n    0x18A48C1E, 0x25C4A5AE, 0x6264DF7E, 0x5F04F6CE,\\n    0xED242ADE, 0xD044036E, 0x97E479BE, 0xAA84500E,\\n    0x4834505D, 0x755479ED, 0x32F4033D, 0x0F942A8D,\\n    0xBDB4F69D, 0x80D4DF2D, 0xC774A5FD, 0xFA148C4D,\\n    0x78441B9C, 0x4524322C, 0x028448FC, 0x3FE4614C,\\n    0x8DC4BD5C, 0xB0A494EC, 0xF704EE3C, 0xCA64C78C,\\n    /* T8_5 */\\n    0x00000000, 0xCB5CD3A5, 0x4DC8A10B, 0x869472AE,\\n    0x9B914216, 0x50CD91B3, 0xD659E31D, 0x1D0530B8,\\n    0xEC53826D, 0x270F51C8, 0xA19B2366, 0x6AC7F0C3,\\n    0x77C2C07B, 0xBC9E13DE, 0x3A0A6170, 0xF156B2D5,\\n    0x03D6029B, 0xC88AD13E, 0x4E1EA390, 0x85427035,\\n    0x9847408D, 0x531B9328, 0xD58FE186, 0x1ED33223,\\n    0xEF8580F6, 0x24D95353, 0xA24D21FD, 0x6911F258,\\n    0x7414C2E0, 0xBF481145, 0x39DC63EB, 0xF280B04E,\\n    0x07AC0536, 0xCCF0D693, 0x4A64A43D, 0x81387798,\\n    0x9C3D4720, 0x57619485, 0xD1F5E62B, 0x1AA9358E,\\n    0xEBFF875B, 0x20A354FE, 0xA6372650, 0x6D6BF5F5,\\n    0x706EC54D, 0xBB3216E8, 0x3DA66446, 0xF6FAB7E3,\\n    0x047A07AD, 0xCF26D408, 0x49B2A6A6, 0x82EE7503,\\n    0x9FEB45BB, 0x54B7961E, 0xD223E4B0, 0x197F3715,\\n    0xE82985C0, 0x23755665, 0xA5E124CB, 0x6EBDF76E,\\n    0x73B8C7D6, 0xB8E41473, 0x3E7066DD, 0xF52CB578,\\n    0x0F580A6C, 0xC404D9C9, 0x4290AB67, 0x89CC78C2,\\n    0x94C9487A, 0x5F959BDF, 0xD901E971, 0x125D3AD4,\\n    0xE30B8801, 0x28575BA4, 0xAEC3290A, 0x659FFAAF,\\n    0x789ACA17, 0xB3C619B2, 0x35526B1C, 0xFE0EB8B9,\\n    0x0C8E08F7, 0xC7D2DB52, 0x4146A9FC, 0x8A1A7A59,\\n    0x971F4AE1, 0x5C439944, 0xDAD7EBEA, 0x118B384F,\\n    0xE0DD8A9A, 0x2B81593F, 0xAD152B91, 0x6649F834,\\n    0x7B4CC88C, 0xB0101B29, 0x36846987, 0xFDD8BA22,\\n    0x08F40F5A, 0xC3A8DCFF, 0x453CAE51, 0x8E607DF4,\\n    0x93654D4C, 0x58399EE9, 0xDEADEC47, 0x15F13FE2,\\n    0xE4A78D37, 0x2FFB5E92, 0xA96F2C3C, 0x6233FF99,\\n    0x7F36CF21, 0xB46A1C84, 0x32FE6E2A, 0xF9A2BD8F,\\n    0x0B220DC1, 0xC07EDE64, 0x46EAACCA, 0x8DB67F6F,\\n    0x90B34FD7, 0x5BEF9C72, 0xDD7BEEDC, 0x16273D79,\\n    0xE7718FAC, 0x2C2D5C09, 0xAAB92EA7, 0x61E5FD02,\\n    0x7CE0CDBA, 0xB7BC1E1F, 0x31286CB1, 0xFA74BF14,\\n    0x1EB014D8, 0xD5ECC77D, 0x5378B5D3, 0x98246676,\\n    0x852156CE, 0x4E7D856B, 0xC8E9F7C5, 0x03B52460,\\n    0xF2E396B5, 0x39BF4510, 0xBF2B37BE, 0x7477E41B,\\n    0x6972D4A3, 0xA22E0706, 0x24BA75A8, 0xEFE6A60D,\\n    0x1D661643, 0xD63AC5E6, 0x50AEB748, 0x9BF264ED,\\n    0x86F75455, 0x4DAB87F0, 0xCB3FF55E, 0x006326FB,\\n    0xF135942E, 0x3A69478B, 0xBCFD3525, 0x77A1E680,\\n    0x6AA4D638, 0xA1F8059D, 0x276C7733, 0xEC30A496,\\n    0x191C11EE, 0xD240C24B, 0x54D4B0E5, 0x9F886340,\\n    0x828D53F8, 0x49D1805D, 0xCF45F2F3, 0x04192156,\\n    0xF54F9383, 0x3E134026, 0xB8873288, 0x73DBE12D,\\n    0x6EDED195, 0xA5820230, 0x2316709E, 0xE84AA33B,\\n    0x1ACA1375, 0xD196C0D0, 0x5702B27E, 0x9C5E61DB,\\n    0x815B5163, 0x4A0782C6, 0xCC93F068, 0x07CF23CD,\\n    0xF6999118, 0x3DC542BD, 0xBB513013, 0x700DE3B6,\\n    0x6D08D30E, 0xA65400AB, 0x20C07205, 0xEB9CA1A0,\\n    0x11E81EB4, 0xDAB4CD11, 0x5C20BFBF, 0x977C6C1A,\\n    0x8A795CA2, 0x41258F07, 0xC7B1FDA9, 0x0CED2E0C,\\n    0xFDBB9CD9, 0x36E74F7C, 0xB0733DD2, 0x7B2FEE77,\\n    0x662ADECF, 0xAD760D6A, 0x2BE27FC4, 0xE0BEAC61,\\n    0x123E1C2F, 0xD962CF8A, 0x5FF6BD24, 0x94AA6E81,\\n    0x89AF5E39, 0x42F38D9C, 0xC467FF32, 0x0F3B2C97,\\n    0xFE6D9E42, 0x35314DE7, 0xB3A53F49, 0x78F9ECEC,\\n    0x65FCDC54, 0xAEA00FF1, 0x28347D5F, 0xE368AEFA,\\n    0x16441B82, 0xDD18C827, 0x5B8CBA89, 0x90D0692C,\\n    0x8DD55994, 0x46898A31, 0xC01DF89F, 0x0B412B3A,\\n    0xFA1799EF, 0x314B4A4A, 0xB7DF38E4, 0x7C83EB41,\\n    0x6186DBF9, 0xAADA085C, 0x2C4E7AF2, 0xE712A957,\\n    0x15921919, 0xDECECABC, 0x585AB812, 0x93066BB7,\\n    0x8E035B0F, 0x455F88AA, 0xC3CBFA04, 0x089729A1,\\n    0xF9C19B74, 0x329D48D1, 0xB4093A7F, 0x7F55E9DA,\\n    0x6250D962, 0xA90C0AC7, 0x2F987869, 0xE4C4ABCC,\\n    /* T8_6 */\\n    0x00000000, 0xA6770BB4, 0x979F1129, 0x31E81A9D,\\n    0xF44F2413, 0x52382FA7, 0x63D0353A, 0xC5A73E8E,\\n    0x33EF4E67, 0x959845D3, 0xA4705F4E, 0x020754FA,\\n    0xC7A06A74, 0x61D761C0, 0x503F7B5D, 0xF64870E9,\\n    0x67DE9CCE, 0xC1A9977A, 0xF0418DE7, 0x56368653,\\n    0x9391B8DD, 0x35E6B369, 0x040EA9F4, 0xA279A240,\\n    0x5431D2A9, 0xF246D91D, 0xC3AEC380, 0x65D9C834,\\n    0xA07EF6BA, 0x0609FD0E, 0x37E1E793, 0x9196EC27,\\n    0xCFBD399C, 0x69CA3228, 0x582228B5, 0xFE552301,\\n    0x3BF21D8F, 0x9D85163B, 0xAC6D0CA6, 0x0A1A0712,\\n    0xFC5277FB, 0x5A257C4F, 0x6BCD66D2, 0xCDBA6D66,\\n    0x081D53E8, 0xAE6A585C, 0x9F8242C1, 0x39F54975,\\n    0xA863A552, 0x0E14AEE6, 0x3FFCB47B, 0x998BBFCF,\\n    0x5C2C8141, 0xFA5B8AF5, 0xCBB39068, 0x6DC49BDC,\\n    0x9B8CEB35, 0x3DFBE081, 0x0C13FA1C, 0xAA64F1A8,\\n    0x6FC3CF26, 0xC9B4C492, 0xF85CDE0F, 0x5E2BD5BB,\\n    0x440B7579, 0xE27C7ECD, 0xD3946450, 0x75E36FE4,\\n    0xB044516A, 0x16335ADE, 0x27DB4043, 0x81AC4BF7,\\n    0x77E43B1E, 0xD19330AA, 0xE07B2A37, 0x460C2183,\\n    0x83AB1F0D, 0x25DC14B9, 0x14340E24, 0xB2430590,\\n    0x23D5E9B7, 0x85A2E203, 0xB44AF89E, 0x123DF32A,\\n    0xD79ACDA4, 0x71EDC610, 0x4005DC8D, 0xE672D739,\\n    0x103AA7D0, 0xB64DAC64, 0x87A5B6F9, 0x21D2BD4D,\\n    0xE47583C3, 0x42028877, 0x73EA92EA, 0xD59D995E,\\n    0x8BB64CE5, 0x2DC14751, 0x1C295DCC, 0xBA5E5678,\\n    0x7FF968F6, 0xD98E6342, 0xE86679DF, 0x4E11726B,\\n    0xB8590282, 0x1E2E0936, 0x2FC613AB, 0x89B1181F,\\n    0x4C162691, 0xEA612D25, 0xDB8937B8, 0x7DFE3C0C,\\n    0xEC68D02B, 0x4A1FDB9F, 0x7BF7C102, 0xDD80CAB6,\\n    0x1827F438, 0xBE50FF8C, 0x8FB8E511, 0x29CFEEA5,\\n    0xDF879E4C, 0x79F095F8, 0x48188F65, 0xEE6F84D1,\\n    0x2BC8BA5F, 0x8DBFB1EB, 0xBC57AB76, 0x1A20A0C2,\\n    0x8816EAF2, 0x2E61E146, 0x1F89FBDB, 0xB9FEF06F,\\n    0x7C59CEE1, 0xDA2EC555, 0xEBC6DFC8, 0x4DB1D47C,\\n    0xBBF9A495, 0x1D8EAF21, 0x2C66B5BC, 0x8A11BE08,\\n    0x4FB68086, 0xE9C18B32, 0xD82991AF, 0x7E5E9A1B,\\n    0xEFC8763C, 0x49BF7D88, 0x78576715, 0xDE206CA1,\\n    0x1B87522F, 0xBDF0599B, 0x8C184306, 0x2A6F48B2,\\n    0xDC27385B, 0x7A5033EF, 0x4BB82972, 0xEDCF22C6,\\n    0x28681C48, 0x8E1F17FC, 0xBFF70D61, 0x198006D5,\\n    0x47ABD36E, 0xE1DCD8DA, 0xD034C247, 0x7643C9F3,\\n    0xB3E4F77D, 0x1593FCC9, 0x247BE654, 0x820CEDE0,\\n    0x74449D09, 0xD23396BD, 0xE3DB8C20, 0x45AC8794,\\n    0x800BB91A, 0x267CB2AE, 0x1794A833, 0xB1E3A387,\\n    0x20754FA0, 0x86024414, 0xB7EA5E89, 0x119D553D,\\n    0xD43A6BB3, 0x724D6007, 0x43A57A9A, 0xE5D2712E,\\n    0x139A01C7, 0xB5ED0A73, 0x840510EE, 0x22721B5A,\\n    0xE7D525D4, 0x41A22E60, 0x704A34FD, 0xD63D3F49,\\n    0xCC1D9F8B, 0x6A6A943F, 0x5B828EA2, 0xFDF58516,\\n    0x3852BB98, 0x9E25B02C, 0xAFCDAAB1, 0x09BAA105,\\n    0xFFF2D1EC, 0x5985DA58, 0x686DC0C5, 0xCE1ACB71,\\n    0x0BBDF5FF, 0xADCAFE4B, 0x9C22E4D6, 0x3A55EF62,\\n    0xABC30345, 0x0DB408F1, 0x3C5C126C, 0x9A2B19D8,\\n    0x5F8C2756, 0xF9FB2CE2, 0xC813367F, 0x6E643DCB,\\n    0x982C4D22, 0x3E5B4696, 0x0FB35C0B, 0xA9C457BF,\\n    0x6C636931, 0xCA146285, 0xFBFC7818, 0x5D8B73AC,\\n    0x03A0A617, 0xA5D7ADA3, 0x943FB73E, 0x3248BC8A,\\n    0xF7EF8204, 0x519889B0, 0x6070932D, 0xC6079899,\\n    0x304FE870, 0x9638E3C4, 0xA7D0F959, 0x01A7F2ED,\\n    0xC400CC63, 0x6277C7D7, 0x539FDD4A, 0xF5E8D6FE,\\n    0x647E3AD9, 0xC209316D, 0xF3E12BF0, 0x55962044,\\n    0x90311ECA, 0x3646157E, 0x07AE0FE3, 0xA1D90457,\\n    0x579174BE, 0xF1E67F0A, 0xC00E6597, 0x66796E23,\\n    0xA3DE50AD, 0x05A95B19, 0x34414184, 0x92364A30,\\n    /* T8_7 */\\n    0x00000000, 0xCCAA009E, 0x4225077D, 0x8E8F07E3,\\n    0x844A0EFA, 0x48E00E64, 0xC66F0987, 0x0AC50919,\\n    0xD3E51BB5, 0x1F4F1B2B, 0x91C01CC8, 0x5D6A1C56,\\n    0x57AF154F, 0x9B0515D1, 0x158A1232, 0xD92012AC,\\n    0x7CBB312B, 0xB01131B5, 0x3E9E3656, 0xF23436C8,\\n    0xF8F13FD1, 0x345B3F4F, 0xBAD438AC, 0x767E3832,\\n    0xAF5E2A9E, 0x63F42A00, 0xED7B2DE3, 0x21D12D7D,\\n    0x2B142464, 0xE7BE24FA, 0x69312319, 0xA59B2387,\\n    0xF9766256, 0x35DC62C8, 0xBB53652B, 0x77F965B5,\\n    0x7D3C6CAC, 0xB1966C32, 0x3F196BD1, 0xF3B36B4F,\\n    0x2A9379E3, 0xE639797D, 0x68B67E9E, 0xA41C7E00,\\n    0xAED97719, 0x62737787, 0xECFC7064, 0x205670FA,\\n    0x85CD537D, 0x496753E3, 0xC7E85400, 0x0B42549E,\\n    0x01875D87, 0xCD2D5D19, 0x43A25AFA, 0x8F085A64,\\n    0x562848C8, 0x9A824856, 0x140D4FB5, 0xD8A74F2B,\\n    0xD2624632, 0x1EC846AC, 0x9047414F, 0x5CED41D1,\\n    0x299DC2ED, 0xE537C273, 0x6BB8C590, 0xA712C50E,\\n    0xADD7CC17, 0x617DCC89, 0xEFF2CB6A, 0x2358CBF4,\\n    0xFA78D958, 0x36D2D9C6, 0xB85DDE25, 0x74F7DEBB,\\n    0x7E32D7A2, 0xB298D73C, 0x3C17D0DF, 0xF0BDD041,\\n    0x5526F3C6, 0x998CF358, 0x1703F4BB, 0xDBA9F425,\\n    0xD16CFD3C, 0x1DC6FDA2, 0x9349FA41, 0x5FE3FADF,\\n    0x86C3E873, 0x4A69E8ED, 0xC4E6EF0E, 0x084CEF90,\\n    0x0289E689, 0xCE23E617, 0x40ACE1F4, 0x8C06E16A,\\n    0xD0EBA0BB, 0x1C41A025, 0x92CEA7C6, 0x5E64A758,\\n    0x54A1AE41, 0x980BAEDF, 0x1684A93C, 0xDA2EA9A2,\\n    0x030EBB0E, 0xCFA4BB90, 0x412BBC73, 0x8D81BCED,\\n    0x8744B5F4, 0x4BEEB56A, 0xC561B289, 0x09CBB217,\\n    0xAC509190, 0x60FA910E, 0xEE7596ED, 0x22DF9673,\\n    0x281A9F6A, 0xE4B09FF4, 0x6A3F9817, 0xA6959889,\\n    0x7FB58A25, 0xB31F8ABB, 0x3D908D58, 0xF13A8DC6,\\n    0xFBFF84DF, 0x37558441, 0xB9DA83A2, 0x7570833C,\\n    0x533B85DA, 0x9F918544, 0x111E82A7, 0xDDB48239,\\n    0xD7718B20, 0x1BDB8BBE, 0x95548C5D, 0x59FE8CC3,\\n    0x80DE9E6F, 0x4C749EF1, 0xC2FB9912, 0x0E51998C,\\n    0x04949095, 0xC83E900B, 0x46B197E8, 0x8A1B9776,\\n    0x2F80B4F1, 0xE32AB46F, 0x6DA5B38C, 0xA10FB312,\\n    0xABCABA0B, 0x6760BA95, 0xE9EFBD76, 0x2545BDE8,\\n    0xFC65AF44, 0x30CFAFDA, 0xBE40A839, 0x72EAA8A7,\\n    0x782FA1BE, 0xB485A120, 0x3A0AA6C3, 0xF6A0A65D,\\n    0xAA4DE78C, 0x66E7E712, 0xE868E0F1, 0x24C2E06F,\\n    0x2E07E976, 0xE2ADE9E8, 0x6C22EE0B, 0xA088EE95,\\n    0x79A8FC39, 0xB502FCA7, 0x3B8DFB44, 0xF727FBDA,\\n    0xFDE2F2C3, 0x3148F25D, 0xBFC7F5BE, 0x736DF520,\\n    0xD6F6D6A7, 0x1A5CD639, 0x94D3D1DA, 0x5879D144,\\n    0x52BCD85D, 0x9E16D8C3, 0x1099DF20, 0xDC33DFBE,\\n    0x0513CD12, 0xC9B9CD8C, 0x4736CA6F, 0x8B9CCAF1,\\n    0x8159C3E8, 0x4DF3C376, 0xC37CC495, 0x0FD6C40B,\\n    0x7AA64737, 0xB60C47A9, 0x3883404A, 0xF42940D4,\\n    0xFEEC49CD, 0x32464953, 0xBCC94EB0, 0x70634E2E,\\n    0xA9435C82, 0x65E95C1C, 0xEB665BFF, 0x27CC5B61,\\n    0x2D095278, 0xE1A352E6, 0x6F2C5505, 0xA386559B,\\n    0x061D761C, 0xCAB77682, 0x44387161, 0x889271FF,\\n    0x825778E6, 0x4EFD7878, 0xC0727F9B, 0x0CD87F05,\\n    0xD5F86DA9, 0x19526D37, 0x97DD6AD4, 0x5B776A4A,\\n    0x51B26353, 0x9D1863CD, 0x1397642E, 0xDF3D64B0,\\n    0x83D02561, 0x4F7A25FF, 0xC1F5221C, 0x0D5F2282,\\n    0x079A2B9B, 0xCB302B05, 0x45BF2CE6, 0x89152C78,\\n    0x50353ED4, 0x9C9F3E4A, 0x121039A9, 0xDEBA3937,\\n    0xD47F302E, 0x18D530B0, 0x965A3753, 0x5AF037CD,\\n    0xFF6B144A, 0x33C114D4, 0xBD4E1337, 0x71E413A9,\\n    0x7B211AB0, 0xB78B1A2E, 0x39041DCD, 0xF5AE1D53,\\n    0x2C8E0FFF, 0xE0240F61, 0x6EAB0882, 0xA201081C,\\n    0xA8C40105, 0x646E019B, 0xEAE10678, 0x264B06E6\\n  };\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"PureJavaCrc32\", \"position\": {\"start_line\": 42, \"end_line\": 632, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class PureJavaCrc32 implements Checksum {\\n\\n  /** the current CRC value, bit-flipped */\\n  private int crc;\\n\\n  /** Create a new PureJavaCrc32 object. */\\n  public PureJavaCrc32() {\\n    _reset();\\n  }\\n\\n  @Override\\n  public long getValue() {\\n    return (~crc) & 0xffffffffL;\\n  }\\n\\n  @Override\\n  public void reset() {\\n    _reset();\\n  }\\n\\n  // called by ctor, so must not be overrideable\\n  private void _reset() {\\n    crc = 0xffffffff;\\n  }\\n\\n  @Override\\n  public void update(final byte[] b, final int offset, final int len) {\\n    int localCrc = crc;\\n\\n    final int remainder = len & 0x7;\\n    int i = offset;\\n    for(final int end = offset + len - remainder; i < end; i += 8) {\\n      final int x = localCrc ^\\n          ((((b[i  ] << 24) >>> 24) + ((b[i+1] << 24) >>> 16)) +\\n          (((b[i+2] << 24) >>> 8 ) +  (b[i+3] << 24)));\\n\\n      localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^\\n                 (T[((x <<  8) >>> 24) + 0x500] ^ T[ (x        >>> 24) + 0x400])) ^\\n                 ((T[((b[i+4] << 24) >>> 24) + 0x300] ^ T[((b[i+5] << 24) >>> 24) + 0x200]) ^\\n                 (T[((b[i+6] << 24) >>> 24) + 0x100] ^ T[((b[i+7] << 24) >>> 24)]));\\n    }\\n\\n    /* loop unroll - duff's device style */\\n    switch(remainder) {\\n      case 7: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 6: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 5: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 4: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 3: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 2: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 1: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      default:\\n        /* nothing */\\n    }\\n\\n    // Publish crc out to object\\n    crc = localCrc;\\n  }\\n\\n  @Override\\n  final public void update(final int b) {\\n    crc = (crc >>> 8) ^ T[(((crc ^ b) << 24) >>> 24)];\\n  }\\n\\n  /*\\n   * CRC-32 lookup tables generated by the polynomial 0xEDB88320.\\n   * See also TestPureJavaCrc32.Table.\\n   */\\n  private static final int[] T = new int[] {\\n    /* T8_0 */\\n    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,\\n    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\\n    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,\\n    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,\\n    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,\\n    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\\n    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,\\n    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,\\n    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,\\n    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\\n    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,\\n    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\\n    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,\\n    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\\n    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,\\n    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\\n    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,\\n    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\\n    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,\\n    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\\n    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,\\n    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,\\n    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,\\n    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\\n    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,\\n    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,\\n    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,\\n    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,\\n    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,\\n    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\\n    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,\\n    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,\\n    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,\\n    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,\\n    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,\\n    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\\n    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,\\n    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,\\n    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,\\n    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\\n    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,\\n    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\\n    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,\\n    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,\\n    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,\\n    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,\\n    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,\\n    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\\n    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,\\n    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\\n    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,\\n    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,\\n    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,\\n    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\\n    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,\\n    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,\\n    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,\\n    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,\\n    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,\\n    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\\n    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,\\n    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,\\n    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,\\n    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,\\n    /* T8_1 */\\n    0x00000000, 0x191B3141, 0x32366282, 0x2B2D53C3,\\n    0x646CC504, 0x7D77F445, 0x565AA786, 0x4F4196C7,\\n    0xC8D98A08, 0xD1C2BB49, 0xFAEFE88A, 0xE3F4D9CB,\\n    0xACB54F0C, 0xB5AE7E4D, 0x9E832D8E, 0x87981CCF,\\n    0x4AC21251, 0x53D92310, 0x78F470D3, 0x61EF4192,\\n    0x2EAED755, 0x37B5E614, 0x1C98B5D7, 0x05838496,\\n    0x821B9859, 0x9B00A918, 0xB02DFADB, 0xA936CB9A,\\n    0xE6775D5D, 0xFF6C6C1C, 0xD4413FDF, 0xCD5A0E9E,\\n    0x958424A2, 0x8C9F15E3, 0xA7B24620, 0xBEA97761,\\n    0xF1E8E1A6, 0xE8F3D0E7, 0xC3DE8324, 0xDAC5B265,\\n    0x5D5DAEAA, 0x44469FEB, 0x6F6BCC28, 0x7670FD69,\\n    0x39316BAE, 0x202A5AEF, 0x0B07092C, 0x121C386D,\\n    0xDF4636F3, 0xC65D07B2, 0xED705471, 0xF46B6530,\\n    0xBB2AF3F7, 0xA231C2B6, 0x891C9175, 0x9007A034,\\n    0x179FBCFB, 0x0E848DBA, 0x25A9DE79, 0x3CB2EF38,\\n    0x73F379FF, 0x6AE848BE, 0x41C51B7D, 0x58DE2A3C,\\n    0xF0794F05, 0xE9627E44, 0xC24F2D87, 0xDB541CC6,\\n    0x94158A01, 0x8D0EBB40, 0xA623E883, 0xBF38D9C2,\\n    0x38A0C50D, 0x21BBF44C, 0x0A96A78F, 0x138D96CE,\\n    0x5CCC0009, 0x45D73148, 0x6EFA628B, 0x77E153CA,\\n    0xBABB5D54, 0xA3A06C15, 0x888D3FD6, 0x91960E97,\\n    0xDED79850, 0xC7CCA911, 0xECE1FAD2, 0xF5FACB93,\\n    0x7262D75C, 0x6B79E61D, 0x4054B5DE, 0x594F849F,\\n    0x160E1258, 0x0F152319, 0x243870DA, 0x3D23419B,\\n    0x65FD6BA7, 0x7CE65AE6, 0x57CB0925, 0x4ED03864,\\n    0x0191AEA3, 0x188A9FE2, 0x33A7CC21, 0x2ABCFD60,\\n    0xAD24E1AF, 0xB43FD0EE, 0x9F12832D, 0x8609B26C,\\n    0xC94824AB, 0xD05315EA, 0xFB7E4629, 0xE2657768,\\n    0x2F3F79F6, 0x362448B7, 0x1D091B74, 0x04122A35,\\n    0x4B53BCF2, 0x52488DB3, 0x7965DE70, 0x607EEF31,\\n    0xE7E6F3FE, 0xFEFDC2BF, 0xD5D0917C, 0xCCCBA03D,\\n    0x838A36FA, 0x9A9107BB, 0xB1BC5478, 0xA8A76539,\\n    0x3B83984B, 0x2298A90A, 0x09B5FAC9, 0x10AECB88,\\n    0x5FEF5D4F, 0x46F46C0E, 0x6DD93FCD, 0x74C20E8C,\\n    0xF35A1243, 0xEA412302, 0xC16C70C1, 0xD8774180,\\n    0x9736D747, 0x8E2DE606, 0xA500B5C5, 0xBC1B8484,\\n    0x71418A1A, 0x685ABB5B, 0x4377E898, 0x5A6CD9D9,\\n    0x152D4F1E, 0x0C367E5F, 0x271B2D9C, 0x3E001CDD,\\n    0xB9980012, 0xA0833153, 0x8BAE6290, 0x92B553D1,\\n    0xDDF4C516, 0xC4EFF457, 0xEFC2A794, 0xF6D996D5,\\n    0xAE07BCE9, 0xB71C8DA8, 0x9C31DE6B, 0x852AEF2A,\\n    0xCA6B79ED, 0xD37048AC, 0xF85D1B6F, 0xE1462A2E,\\n    0x66DE36E1, 0x7FC507A0, 0x54E85463, 0x4DF36522,\\n    0x02B2F3E5, 0x1BA9C2A4, 0x30849167, 0x299FA026,\\n    0xE4C5AEB8, 0xFDDE9FF9, 0xD6F3CC3A, 0xCFE8FD7B,\\n    0x80A96BBC, 0x99B25AFD, 0xB29F093E, 0xAB84387F,\\n    0x2C1C24B0, 0x350715F1, 0x1E2A4632, 0x07317773,\\n    0x4870E1B4, 0x516BD0F5, 0x7A468336, 0x635DB277,\\n    0xCBFAD74E, 0xD2E1E60F, 0xF9CCB5CC, 0xE0D7848D,\\n    0xAF96124A, 0xB68D230B, 0x9DA070C8, 0x84BB4189,\\n    0x03235D46, 0x1A386C07, 0x31153FC4, 0x280E0E85,\\n    0x674F9842, 0x7E54A903, 0x5579FAC0, 0x4C62CB81,\\n    0x8138C51F, 0x9823F45E, 0xB30EA79D, 0xAA1596DC,\\n    0xE554001B, 0xFC4F315A, 0xD7626299, 0xCE7953D8,\\n    0x49E14F17, 0x50FA7E56, 0x7BD72D95, 0x62CC1CD4,\\n    0x2D8D8A13, 0x3496BB52, 0x1FBBE891, 0x06A0D9D0,\\n    0x5E7EF3EC, 0x4765C2AD, 0x6C48916E, 0x7553A02F,\\n    0x3A1236E8, 0x230907A9, 0x0824546A, 0x113F652B,\\n    0x96A779E4, 0x8FBC48A5, 0xA4911B66, 0xBD8A2A27,\\n    0xF2CBBCE0, 0xEBD08DA1, 0xC0FDDE62, 0xD9E6EF23,\\n    0x14BCE1BD, 0x0DA7D0FC, 0x268A833F, 0x3F91B27E,\\n    0x70D024B9, 0x69CB15F8, 0x42E6463B, 0x5BFD777A,\\n    0xDC656BB5, 0xC57E5AF4, 0xEE530937, 0xF7483876,\\n    0xB809AEB1, 0xA1129FF0, 0x8A3FCC33, 0x9324FD72,\\n    /* T8_2 */\\n    0x00000000, 0x01C26A37, 0x0384D46E, 0x0246BE59,\\n    0x0709A8DC, 0x06CBC2EB, 0x048D7CB2, 0x054F1685,\\n    0x0E1351B8, 0x0FD13B8F, 0x0D9785D6, 0x0C55EFE1,\\n    0x091AF964, 0x08D89353, 0x0A9E2D0A, 0x0B5C473D,\\n    0x1C26A370, 0x1DE4C947, 0x1FA2771E, 0x1E601D29,\\n    0x1B2F0BAC, 0x1AED619B, 0x18ABDFC2, 0x1969B5F5,\\n    0x1235F2C8, 0x13F798FF, 0x11B126A6, 0x10734C91,\\n    0x153C5A14, 0x14FE3023, 0x16B88E7A, 0x177AE44D,\\n    0x384D46E0, 0x398F2CD7, 0x3BC9928E, 0x3A0BF8B9,\\n    0x3F44EE3C, 0x3E86840B, 0x3CC03A52, 0x3D025065,\\n    0x365E1758, 0x379C7D6F, 0x35DAC336, 0x3418A901,\\n    0x3157BF84, 0x3095D5B3, 0x32D36BEA, 0x331101DD,\\n    0x246BE590, 0x25A98FA7, 0x27EF31FE, 0x262D5BC9,\\n    0x23624D4C, 0x22A0277B, 0x20E69922, 0x2124F315,\\n    0x2A78B428, 0x2BBADE1F, 0x29FC6046, 0x283E0A71,\\n    0x2D711CF4, 0x2CB376C3, 0x2EF5C89A, 0x2F37A2AD,\\n    0x709A8DC0, 0x7158E7F7, 0x731E59AE, 0x72DC3399,\\n    0x7793251C, 0x76514F2B, 0x7417F172, 0x75D59B45,\\n    0x7E89DC78, 0x7F4BB64F, 0x7D0D0816, 0x7CCF6221,\\n    0x798074A4, 0x78421E93, 0x7A04A0CA, 0x7BC6CAFD,\\n    0x6CBC2EB0, 0x6D7E4487, 0x6F38FADE, 0x6EFA90E9,\\n    0x6BB5866C, 0x6A77EC5B, 0x68315202, 0x69F33835,\\n    0x62AF7F08, 0x636D153F, 0x612BAB66, 0x60E9C151,\\n    0x65A6D7D4, 0x6464BDE3, 0x662203BA, 0x67E0698D,\\n    0x48D7CB20, 0x4915A117, 0x4B531F4E, 0x4A917579,\\n    0x4FDE63FC, 0x4E1C09CB, 0x4C5AB792, 0x4D98DDA5,\\n    0x46C49A98, 0x4706F0AF, 0x45404EF6, 0x448224C1,\\n    0x41CD3244, 0x400F5873, 0x4249E62A, 0x438B8C1D,\\n    0x54F16850, 0x55330267, 0x5775BC3E, 0x56B7D609,\\n    0x53F8C08C, 0x523AAABB, 0x507C14E2, 0x51BE7ED5,\\n    0x5AE239E8, 0x5B2053DF, 0x5966ED86, 0x58A487B1,\\n    0x5DEB9134, 0x5C29FB03, 0x5E6F455A, 0x5FAD2F6D,\\n    0xE1351B80, 0xE0F771B7, 0xE2B1CFEE, 0xE373A5D9,\\n    0xE63CB35C, 0xE7FED96B, 0xE5B86732, 0xE47A0D05,\\n    0xEF264A38, 0xEEE4200F, 0xECA29E56, 0xED60F461,\\n    0xE82FE2E4, 0xE9ED88D3, 0xEBAB368A, 0xEA695CBD,\\n    0xFD13B8F0, 0xFCD1D2C7, 0xFE976C9E, 0xFF5506A9,\\n    0xFA1A102C, 0xFBD87A1B, 0xF99EC442, 0xF85CAE75,\\n    0xF300E948, 0xF2C2837F, 0xF0843D26, 0xF1465711,\\n    0xF4094194, 0xF5CB2BA3, 0xF78D95FA, 0xF64FFFCD,\\n    0xD9785D60, 0xD8BA3757, 0xDAFC890E, 0xDB3EE339,\\n    0xDE71F5BC, 0xDFB39F8B, 0xDDF521D2, 0xDC374BE5,\\n    0xD76B0CD8, 0xD6A966EF, 0xD4EFD8B6, 0xD52DB281,\\n    0xD062A404, 0xD1A0CE33, 0xD3E6706A, 0xD2241A5D,\\n    0xC55EFE10, 0xC49C9427, 0xC6DA2A7E, 0xC7184049,\\n    0xC25756CC, 0xC3953CFB, 0xC1D382A2, 0xC011E895,\\n    0xCB4DAFA8, 0xCA8FC59F, 0xC8C97BC6, 0xC90B11F1,\\n    0xCC440774, 0xCD866D43, 0xCFC0D31A, 0xCE02B92D,\\n    0x91AF9640, 0x906DFC77, 0x922B422E, 0x93E92819,\\n    0x96A63E9C, 0x976454AB, 0x9522EAF2, 0x94E080C5,\\n    0x9FBCC7F8, 0x9E7EADCF, 0x9C381396, 0x9DFA79A1,\\n    0x98B56F24, 0x99770513, 0x9B31BB4A, 0x9AF3D17D,\\n    0x8D893530, 0x8C4B5F07, 0x8E0DE15E, 0x8FCF8B69,\\n    0x8A809DEC, 0x8B42F7DB, 0x89044982, 0x88C623B5,\\n    0x839A6488, 0x82580EBF, 0x801EB0E6, 0x81DCDAD1,\\n    0x8493CC54, 0x8551A663, 0x8717183A, 0x86D5720D,\\n    0xA9E2D0A0, 0xA820BA97, 0xAA6604CE, 0xABA46EF9,\\n    0xAEEB787C, 0xAF29124B, 0xAD6FAC12, 0xACADC625,\\n    0xA7F18118, 0xA633EB2F, 0xA4755576, 0xA5B73F41,\\n    0xA0F829C4, 0xA13A43F3, 0xA37CFDAA, 0xA2BE979D,\\n    0xB5C473D0, 0xB40619E7, 0xB640A7BE, 0xB782CD89,\\n    0xB2CDDB0C, 0xB30FB13B, 0xB1490F62, 0xB08B6555,\\n    0xBBD72268, 0xBA15485F, 0xB853F606, 0xB9919C31,\\n    0xBCDE8AB4, 0xBD1CE083, 0xBF5A5EDA, 0xBE9834ED,\\n    /* T8_3 */\\n    0x00000000, 0xB8BC6765, 0xAA09C88B, 0x12B5AFEE,\\n    0x8F629757, 0x37DEF032, 0x256B5FDC, 0x9DD738B9,\\n    0xC5B428EF, 0x7D084F8A, 0x6FBDE064, 0xD7018701,\\n    0x4AD6BFB8, 0xF26AD8DD, 0xE0DF7733, 0x58631056,\\n    0x5019579F, 0xE8A530FA, 0xFA109F14, 0x42ACF871,\\n    0xDF7BC0C8, 0x67C7A7AD, 0x75720843, 0xCDCE6F26,\\n    0x95AD7F70, 0x2D111815, 0x3FA4B7FB, 0x8718D09E,\\n    0x1ACFE827, 0xA2738F42, 0xB0C620AC, 0x087A47C9,\\n    0xA032AF3E, 0x188EC85B, 0x0A3B67B5, 0xB28700D0,\\n    0x2F503869, 0x97EC5F0C, 0x8559F0E2, 0x3DE59787,\\n    0x658687D1, 0xDD3AE0B4, 0xCF8F4F5A, 0x7733283F,\\n    0xEAE41086, 0x525877E3, 0x40EDD80D, 0xF851BF68,\\n    0xF02BF8A1, 0x48979FC4, 0x5A22302A, 0xE29E574F,\\n    0x7F496FF6, 0xC7F50893, 0xD540A77D, 0x6DFCC018,\\n    0x359FD04E, 0x8D23B72B, 0x9F9618C5, 0x272A7FA0,\\n    0xBAFD4719, 0x0241207C, 0x10F48F92, 0xA848E8F7,\\n    0x9B14583D, 0x23A83F58, 0x311D90B6, 0x89A1F7D3,\\n    0x1476CF6A, 0xACCAA80F, 0xBE7F07E1, 0x06C36084,\\n    0x5EA070D2, 0xE61C17B7, 0xF4A9B859, 0x4C15DF3C,\\n    0xD1C2E785, 0x697E80E0, 0x7BCB2F0E, 0xC377486B,\\n    0xCB0D0FA2, 0x73B168C7, 0x6104C729, 0xD9B8A04C,\\n    0x446F98F5, 0xFCD3FF90, 0xEE66507E, 0x56DA371B,\\n    0x0EB9274D, 0xB6054028, 0xA4B0EFC6, 0x1C0C88A3,\\n    0x81DBB01A, 0x3967D77F, 0x2BD27891, 0x936E1FF4,\\n    0x3B26F703, 0x839A9066, 0x912F3F88, 0x299358ED,\\n    0xB4446054, 0x0CF80731, 0x1E4DA8DF, 0xA6F1CFBA,\\n    0xFE92DFEC, 0x462EB889, 0x549B1767, 0xEC277002,\\n    0x71F048BB, 0xC94C2FDE, 0xDBF98030, 0x6345E755,\\n    0x6B3FA09C, 0xD383C7F9, 0xC1366817, 0x798A0F72,\\n    0xE45D37CB, 0x5CE150AE, 0x4E54FF40, 0xF6E89825,\\n    0xAE8B8873, 0x1637EF16, 0x048240F8, 0xBC3E279D,\\n    0x21E91F24, 0x99557841, 0x8BE0D7AF, 0x335CB0CA,\\n    0xED59B63B, 0x55E5D15E, 0x47507EB0, 0xFFEC19D5,\\n    0x623B216C, 0xDA874609, 0xC832E9E7, 0x708E8E82,\\n    0x28ED9ED4, 0x9051F9B1, 0x82E4565F, 0x3A58313A,\\n    0xA78F0983, 0x1F336EE6, 0x0D86C108, 0xB53AA66D,\\n    0xBD40E1A4, 0x05FC86C1, 0x1749292F, 0xAFF54E4A,\\n    0x322276F3, 0x8A9E1196, 0x982BBE78, 0x2097D91D,\\n    0x78F4C94B, 0xC048AE2E, 0xD2FD01C0, 0x6A4166A5,\\n    0xF7965E1C, 0x4F2A3979, 0x5D9F9697, 0xE523F1F2,\\n    0x4D6B1905, 0xF5D77E60, 0xE762D18E, 0x5FDEB6EB,\\n    0xC2098E52, 0x7AB5E937, 0x680046D9, 0xD0BC21BC,\\n    0x88DF31EA, 0x3063568F, 0x22D6F961, 0x9A6A9E04,\\n    0x07BDA6BD, 0xBF01C1D8, 0xADB46E36, 0x15080953,\\n    0x1D724E9A, 0xA5CE29FF, 0xB77B8611, 0x0FC7E174,\\n    0x9210D9CD, 0x2AACBEA8, 0x38191146, 0x80A57623,\\n    0xD8C66675, 0x607A0110, 0x72CFAEFE, 0xCA73C99B,\\n    0x57A4F122, 0xEF189647, 0xFDAD39A9, 0x45115ECC,\\n    0x764DEE06, 0xCEF18963, 0xDC44268D, 0x64F841E8,\\n    0xF92F7951, 0x41931E34, 0x5326B1DA, 0xEB9AD6BF,\\n    0xB3F9C6E9, 0x0B45A18C, 0x19F00E62, 0xA14C6907,\\n    0x3C9B51BE, 0x842736DB, 0x96929935, 0x2E2EFE50,\\n    0x2654B999, 0x9EE8DEFC, 0x8C5D7112, 0x34E11677,\\n    0xA9362ECE, 0x118A49AB, 0x033FE645, 0xBB838120,\\n    0xE3E09176, 0x5B5CF613, 0x49E959FD, 0xF1553E98,\\n    0x6C820621, 0xD43E6144, 0xC68BCEAA, 0x7E37A9CF,\\n    0xD67F4138, 0x6EC3265D, 0x7C7689B3, 0xC4CAEED6,\\n    0x591DD66F, 0xE1A1B10A, 0xF3141EE4, 0x4BA87981,\\n    0x13CB69D7, 0xAB770EB2, 0xB9C2A15C, 0x017EC639,\\n    0x9CA9FE80, 0x241599E5, 0x36A0360B, 0x8E1C516E,\\n    0x866616A7, 0x3EDA71C2, 0x2C6FDE2C, 0x94D3B949,\\n    0x090481F0, 0xB1B8E695, 0xA30D497B, 0x1BB12E1E,\\n    0x43D23E48, 0xFB6E592D, 0xE9DBF6C3, 0x516791A6,\\n    0xCCB0A91F, 0x740CCE7A, 0x66B96194, 0xDE0506F1,\\n    /* T8_4 */\\n    0x00000000, 0x3D6029B0, 0x7AC05360, 0x47A07AD0,\\n    0xF580A6C0, 0xC8E08F70, 0x8F40F5A0, 0xB220DC10,\\n    0x30704BC1, 0x0D106271, 0x4AB018A1, 0x77D03111,\\n    0xC5F0ED01, 0xF890C4B1, 0xBF30BE61, 0x825097D1,\\n    0x60E09782, 0x5D80BE32, 0x1A20C4E2, 0x2740ED52,\\n    0x95603142, 0xA80018F2, 0xEFA06222, 0xD2C04B92,\\n    0x5090DC43, 0x6DF0F5F3, 0x2A508F23, 0x1730A693,\\n    0xA5107A83, 0x98705333, 0xDFD029E3, 0xE2B00053,\\n    0xC1C12F04, 0xFCA106B4, 0xBB017C64, 0x866155D4,\\n    0x344189C4, 0x0921A074, 0x4E81DAA4, 0x73E1F314,\\n    0xF1B164C5, 0xCCD14D75, 0x8B7137A5, 0xB6111E15,\\n    0x0431C205, 0x3951EBB5, 0x7EF19165, 0x4391B8D5,\\n    0xA121B886, 0x9C419136, 0xDBE1EBE6, 0xE681C256,\\n    0x54A11E46, 0x69C137F6, 0x2E614D26, 0x13016496,\\n    0x9151F347, 0xAC31DAF7, 0xEB91A027, 0xD6F18997,\\n    0x64D15587, 0x59B17C37, 0x1E1106E7, 0x23712F57,\\n    0x58F35849, 0x659371F9, 0x22330B29, 0x1F532299,\\n    0xAD73FE89, 0x9013D739, 0xD7B3ADE9, 0xEAD38459,\\n    0x68831388, 0x55E33A38, 0x124340E8, 0x2F236958,\\n    0x9D03B548, 0xA0639CF8, 0xE7C3E628, 0xDAA3CF98,\\n    0x3813CFCB, 0x0573E67B, 0x42D39CAB, 0x7FB3B51B,\\n    0xCD93690B, 0xF0F340BB, 0xB7533A6B, 0x8A3313DB,\\n    0x0863840A, 0x3503ADBA, 0x72A3D76A, 0x4FC3FEDA,\\n    0xFDE322CA, 0xC0830B7A, 0x872371AA, 0xBA43581A,\\n    0x9932774D, 0xA4525EFD, 0xE3F2242D, 0xDE920D9D,\\n    0x6CB2D18D, 0x51D2F83D, 0x167282ED, 0x2B12AB5D,\\n    0xA9423C8C, 0x9422153C, 0xD3826FEC, 0xEEE2465C,\\n    0x5CC29A4C, 0x61A2B3FC, 0x2602C92C, 0x1B62E09C,\\n    0xF9D2E0CF, 0xC4B2C97F, 0x8312B3AF, 0xBE729A1F,\\n    0x0C52460F, 0x31326FBF, 0x7692156F, 0x4BF23CDF,\\n    0xC9A2AB0E, 0xF4C282BE, 0xB362F86E, 0x8E02D1DE,\\n    0x3C220DCE, 0x0142247E, 0x46E25EAE, 0x7B82771E,\\n    0xB1E6B092, 0x8C869922, 0xCB26E3F2, 0xF646CA42,\\n    0x44661652, 0x79063FE2, 0x3EA64532, 0x03C66C82,\\n    0x8196FB53, 0xBCF6D2E3, 0xFB56A833, 0xC6368183,\\n    0x74165D93, 0x49767423, 0x0ED60EF3, 0x33B62743,\\n    0xD1062710, 0xEC660EA0, 0xABC67470, 0x96A65DC0,\\n    0x248681D0, 0x19E6A860, 0x5E46D2B0, 0x6326FB00,\\n    0xE1766CD1, 0xDC164561, 0x9BB63FB1, 0xA6D61601,\\n    0x14F6CA11, 0x2996E3A1, 0x6E369971, 0x5356B0C1,\\n    0x70279F96, 0x4D47B626, 0x0AE7CCF6, 0x3787E546,\\n    0x85A73956, 0xB8C710E6, 0xFF676A36, 0xC2074386,\\n    0x4057D457, 0x7D37FDE7, 0x3A978737, 0x07F7AE87,\\n    0xB5D77297, 0x88B75B27, 0xCF1721F7, 0xF2770847,\\n    0x10C70814, 0x2DA721A4, 0x6A075B74, 0x576772C4,\\n    0xE547AED4, 0xD8278764, 0x9F87FDB4, 0xA2E7D404,\\n    0x20B743D5, 0x1DD76A65, 0x5A7710B5, 0x67173905,\\n    0xD537E515, 0xE857CCA5, 0xAFF7B675, 0x92979FC5,\\n    0xE915E8DB, 0xD475C16B, 0x93D5BBBB, 0xAEB5920B,\\n    0x1C954E1B, 0x21F567AB, 0x66551D7B, 0x5B3534CB,\\n    0xD965A31A, 0xE4058AAA, 0xA3A5F07A, 0x9EC5D9CA,\\n    0x2CE505DA, 0x11852C6A, 0x562556BA, 0x6B457F0A,\\n    0x89F57F59, 0xB49556E9, 0xF3352C39, 0xCE550589,\\n    0x7C75D999, 0x4115F029, 0x06B58AF9, 0x3BD5A349,\\n    0xB9853498, 0x84E51D28, 0xC34567F8, 0xFE254E48,\\n    0x4C059258, 0x7165BBE8, 0x36C5C138, 0x0BA5E888,\\n    0x28D4C7DF, 0x15B4EE6F, 0x521494BF, 0x6F74BD0F,\\n    0xDD54611F, 0xE03448AF, 0xA794327F, 0x9AF41BCF,\\n    0x18A48C1E, 0x25C4A5AE, 0x6264DF7E, 0x5F04F6CE,\\n    0xED242ADE, 0xD044036E, 0x97E479BE, 0xAA84500E,\\n    0x4834505D, 0x755479ED, 0x32F4033D, 0x0F942A8D,\\n    0xBDB4F69D, 0x80D4DF2D, 0xC774A5FD, 0xFA148C4D,\\n    0x78441B9C, 0x4524322C, 0x028448FC, 0x3FE4614C,\\n    0x8DC4BD5C, 0xB0A494EC, 0xF704EE3C, 0xCA64C78C,\\n    /* T8_5 */\\n    0x00000000, 0xCB5CD3A5, 0x4DC8A10B, 0x869472AE,\\n    0x9B914216, 0x50CD91B3, 0xD659E31D, 0x1D0530B8,\\n    0xEC53826D, 0x270F51C8, 0xA19B2366, 0x6AC7F0C3,\\n    0x77C2C07B, 0xBC9E13DE, 0x3A0A6170, 0xF156B2D5,\\n    0x03D6029B, 0xC88AD13E, 0x4E1EA390, 0x85427035,\\n    0x9847408D, 0x531B9328, 0xD58FE186, 0x1ED33223,\\n    0xEF8580F6, 0x24D95353, 0xA24D21FD, 0x6911F258,\\n    0x7414C2E0, 0xBF481145, 0x39DC63EB, 0xF280B04E,\\n    0x07AC0536, 0xCCF0D693, 0x4A64A43D, 0x81387798,\\n    0x9C3D4720, 0x57619485, 0xD1F5E62B, 0x1AA9358E,\\n    0xEBFF875B, 0x20A354FE, 0xA6372650, 0x6D6BF5F5,\\n    0x706EC54D, 0xBB3216E8, 0x3DA66446, 0xF6FAB7E3,\\n    0x047A07AD, 0xCF26D408, 0x49B2A6A6, 0x82EE7503,\\n    0x9FEB45BB, 0x54B7961E, 0xD223E4B0, 0x197F3715,\\n    0xE82985C0, 0x23755665, 0xA5E124CB, 0x6EBDF76E,\\n    0x73B8C7D6, 0xB8E41473, 0x3E7066DD, 0xF52CB578,\\n    0x0F580A6C, 0xC404D9C9, 0x4290AB67, 0x89CC78C2,\\n    0x94C9487A, 0x5F959BDF, 0xD901E971, 0x125D3AD4,\\n    0xE30B8801, 0x28575BA4, 0xAEC3290A, 0x659FFAAF,\\n    0x789ACA17, 0xB3C619B2, 0x35526B1C, 0xFE0EB8B9,\\n    0x0C8E08F7, 0xC7D2DB52, 0x4146A9FC, 0x8A1A7A59,\\n    0x971F4AE1, 0x5C439944, 0xDAD7EBEA, 0x118B384F,\\n    0xE0DD8A9A, 0x2B81593F, 0xAD152B91, 0x6649F834,\\n    0x7B4CC88C, 0xB0101B29, 0x36846987, 0xFDD8BA22,\\n    0x08F40F5A, 0xC3A8DCFF, 0x453CAE51, 0x8E607DF4,\\n    0x93654D4C, 0x58399EE9, 0xDEADEC47, 0x15F13FE2,\\n    0xE4A78D37, 0x2FFB5E92, 0xA96F2C3C, 0x6233FF99,\\n    0x7F36CF21, 0xB46A1C84, 0x32FE6E2A, 0xF9A2BD8F,\\n    0x0B220DC1, 0xC07EDE64, 0x46EAACCA, 0x8DB67F6F,\\n    0x90B34FD7, 0x5BEF9C72, 0xDD7BEEDC, 0x16273D79,\\n    0xE7718FAC, 0x2C2D5C09, 0xAAB92EA7, 0x61E5FD02,\\n    0x7CE0CDBA, 0xB7BC1E1F, 0x31286CB1, 0xFA74BF14,\\n    0x1EB014D8, 0xD5ECC77D, 0x5378B5D3, 0x98246676,\\n    0x852156CE, 0x4E7D856B, 0xC8E9F7C5, 0x03B52460,\\n    0xF2E396B5, 0x39BF4510, 0xBF2B37BE, 0x7477E41B,\\n    0x6972D4A3, 0xA22E0706, 0x24BA75A8, 0xEFE6A60D,\\n    0x1D661643, 0xD63AC5E6, 0x50AEB748, 0x9BF264ED,\\n    0x86F75455, 0x4DAB87F0, 0xCB3FF55E, 0x006326FB,\\n    0xF135942E, 0x3A69478B, 0xBCFD3525, 0x77A1E680,\\n    0x6AA4D638, 0xA1F8059D, 0x276C7733, 0xEC30A496,\\n    0x191C11EE, 0xD240C24B, 0x54D4B0E5, 0x9F886340,\\n    0x828D53F8, 0x49D1805D, 0xCF45F2F3, 0x04192156,\\n    0xF54F9383, 0x3E134026, 0xB8873288, 0x73DBE12D,\\n    0x6EDED195, 0xA5820230, 0x2316709E, 0xE84AA33B,\\n    0x1ACA1375, 0xD196C0D0, 0x5702B27E, 0x9C5E61DB,\\n    0x815B5163, 0x4A0782C6, 0xCC93F068, 0x07CF23CD,\\n    0xF6999118, 0x3DC542BD, 0xBB513013, 0x700DE3B6,\\n    0x6D08D30E, 0xA65400AB, 0x20C07205, 0xEB9CA1A0,\\n    0x11E81EB4, 0xDAB4CD11, 0x5C20BFBF, 0x977C6C1A,\\n    0x8A795CA2, 0x41258F07, 0xC7B1FDA9, 0x0CED2E0C,\\n    0xFDBB9CD9, 0x36E74F7C, 0xB0733DD2, 0x7B2FEE77,\\n    0x662ADECF, 0xAD760D6A, 0x2BE27FC4, 0xE0BEAC61,\\n    0x123E1C2F, 0xD962CF8A, 0x5FF6BD24, 0x94AA6E81,\\n    0x89AF5E39, 0x42F38D9C, 0xC467FF32, 0x0F3B2C97,\\n    0xFE6D9E42, 0x35314DE7, 0xB3A53F49, 0x78F9ECEC,\\n    0x65FCDC54, 0xAEA00FF1, 0x28347D5F, 0xE368AEFA,\\n    0x16441B82, 0xDD18C827, 0x5B8CBA89, 0x90D0692C,\\n    0x8DD55994, 0x46898A31, 0xC01DF89F, 0x0B412B3A,\\n    0xFA1799EF, 0x314B4A4A, 0xB7DF38E4, 0x7C83EB41,\\n    0x6186DBF9, 0xAADA085C, 0x2C4E7AF2, 0xE712A957,\\n    0x15921919, 0xDECECABC, 0x585AB812, 0x93066BB7,\\n    0x8E035B0F, 0x455F88AA, 0xC3CBFA04, 0x089729A1,\\n    0xF9C19B74, 0x329D48D1, 0xB4093A7F, 0x7F55E9DA,\\n    0x6250D962, 0xA90C0AC7, 0x2F987869, 0xE4C4ABCC,\\n    /* T8_6 */\\n    0x00000000, 0xA6770BB4, 0x979F1129, 0x31E81A9D,\\n    0xF44F2413, 0x52382FA7, 0x63D0353A, 0xC5A73E8E,\\n    0x33EF4E67, 0x959845D3, 0xA4705F4E, 0x020754FA,\\n    0xC7A06A74, 0x61D761C0, 0x503F7B5D, 0xF64870E9,\\n    0x67DE9CCE, 0xC1A9977A, 0xF0418DE7, 0x56368653,\\n    0x9391B8DD, 0x35E6B369, 0x040EA9F4, 0xA279A240,\\n    0x5431D2A9, 0xF246D91D, 0xC3AEC380, 0x65D9C834,\\n    0xA07EF6BA, 0x0609FD0E, 0x37E1E793, 0x9196EC27,\\n    0xCFBD399C, 0x69CA3228, 0x582228B5, 0xFE552301,\\n    0x3BF21D8F, 0x9D85163B, 0xAC6D0CA6, 0x0A1A0712,\\n    0xFC5277FB, 0x5A257C4F, 0x6BCD66D2, 0xCDBA6D66,\\n    0x081D53E8, 0xAE6A585C, 0x9F8242C1, 0x39F54975,\\n    0xA863A552, 0x0E14AEE6, 0x3FFCB47B, 0x998BBFCF,\\n    0x5C2C8141, 0xFA5B8AF5, 0xCBB39068, 0x6DC49BDC,\\n    0x9B8CEB35, 0x3DFBE081, 0x0C13FA1C, 0xAA64F1A8,\\n    0x6FC3CF26, 0xC9B4C492, 0xF85CDE0F, 0x5E2BD5BB,\\n    0x440B7579, 0xE27C7ECD, 0xD3946450, 0x75E36FE4,\\n    0xB044516A, 0x16335ADE, 0x27DB4043, 0x81AC4BF7,\\n    0x77E43B1E, 0xD19330AA, 0xE07B2A37, 0x460C2183,\\n    0x83AB1F0D, 0x25DC14B9, 0x14340E24, 0xB2430590,\\n    0x23D5E9B7, 0x85A2E203, 0xB44AF89E, 0x123DF32A,\\n    0xD79ACDA4, 0x71EDC610, 0x4005DC8D, 0xE672D739,\\n    0x103AA7D0, 0xB64DAC64, 0x87A5B6F9, 0x21D2BD4D,\\n    0xE47583C3, 0x42028877, 0x73EA92EA, 0xD59D995E,\\n    0x8BB64CE5, 0x2DC14751, 0x1C295DCC, 0xBA5E5678,\\n    0x7FF968F6, 0xD98E6342, 0xE86679DF, 0x4E11726B,\\n    0xB8590282, 0x1E2E0936, 0x2FC613AB, 0x89B1181F,\\n    0x4C162691, 0xEA612D25, 0xDB8937B8, 0x7DFE3C0C,\\n    0xEC68D02B, 0x4A1FDB9F, 0x7BF7C102, 0xDD80CAB6,\\n    0x1827F438, 0xBE50FF8C, 0x8FB8E511, 0x29CFEEA5,\\n    0xDF879E4C, 0x79F095F8, 0x48188F65, 0xEE6F84D1,\\n    0x2BC8BA5F, 0x8DBFB1EB, 0xBC57AB76, 0x1A20A0C2,\\n    0x8816EAF2, 0x2E61E146, 0x1F89FBDB, 0xB9FEF06F,\\n    0x7C59CEE1, 0xDA2EC555, 0xEBC6DFC8, 0x4DB1D47C,\\n    0xBBF9A495, 0x1D8EAF21, 0x2C66B5BC, 0x8A11BE08,\\n    0x4FB68086, 0xE9C18B32, 0xD82991AF, 0x7E5E9A1B,\\n    0xEFC8763C, 0x49BF7D88, 0x78576715, 0xDE206CA1,\\n    0x1B87522F, 0xBDF0599B, 0x8C184306, 0x2A6F48B2,\\n    0xDC27385B, 0x7A5033EF, 0x4BB82972, 0xEDCF22C6,\\n    0x28681C48, 0x8E1F17FC, 0xBFF70D61, 0x198006D5,\\n    0x47ABD36E, 0xE1DCD8DA, 0xD034C247, 0x7643C9F3,\\n    0xB3E4F77D, 0x1593FCC9, 0x247BE654, 0x820CEDE0,\\n    0x74449D09, 0xD23396BD, 0xE3DB8C20, 0x45AC8794,\\n    0x800BB91A, 0x267CB2AE, 0x1794A833, 0xB1E3A387,\\n    0x20754FA0, 0x86024414, 0xB7EA5E89, 0x119D553D,\\n    0xD43A6BB3, 0x724D6007, 0x43A57A9A, 0xE5D2712E,\\n    0x139A01C7, 0xB5ED0A73, 0x840510EE, 0x22721B5A,\\n    0xE7D525D4, 0x41A22E60, 0x704A34FD, 0xD63D3F49,\\n    0xCC1D9F8B, 0x6A6A943F, 0x5B828EA2, 0xFDF58516,\\n    0x3852BB98, 0x9E25B02C, 0xAFCDAAB1, 0x09BAA105,\\n    0xFFF2D1EC, 0x5985DA58, 0x686DC0C5, 0xCE1ACB71,\\n    0x0BBDF5FF, 0xADCAFE4B, 0x9C22E4D6, 0x3A55EF62,\\n    0xABC30345, 0x0DB408F1, 0x3C5C126C, 0x9A2B19D8,\\n    0x5F8C2756, 0xF9FB2CE2, 0xC813367F, 0x6E643DCB,\\n    0x982C4D22, 0x3E5B4696, 0x0FB35C0B, 0xA9C457BF,\\n    0x6C636931, 0xCA146285, 0xFBFC7818, 0x5D8B73AC,\\n    0x03A0A617, 0xA5D7ADA3, 0x943FB73E, 0x3248BC8A,\\n    0xF7EF8204, 0x519889B0, 0x6070932D, 0xC6079899,\\n    0x304FE870, 0x9638E3C4, 0xA7D0F959, 0x01A7F2ED,\\n    0xC400CC63, 0x6277C7D7, 0x539FDD4A, 0xF5E8D6FE,\\n    0x647E3AD9, 0xC209316D, 0xF3E12BF0, 0x55962044,\\n    0x90311ECA, 0x3646157E, 0x07AE0FE3, 0xA1D90457,\\n    0x579174BE, 0xF1E67F0A, 0xC00E6597, 0x66796E23,\\n    0xA3DE50AD, 0x05A95B19, 0x34414184, 0x92364A30,\\n    /* T8_7 */\\n    0x00000000, 0xCCAA009E, 0x4225077D, 0x8E8F07E3,\\n    0x844A0EFA, 0x48E00E64, 0xC66F0987, 0x0AC50919,\\n    0xD3E51BB5, 0x1F4F1B2B, 0x91C01CC8, 0x5D6A1C56,\\n    0x57AF154F, 0x9B0515D1, 0x158A1232, 0xD92012AC,\\n    0x7CBB312B, 0xB01131B5, 0x3E9E3656, 0xF23436C8,\\n    0xF8F13FD1, 0x345B3F4F, 0xBAD438AC, 0x767E3832,\\n    0xAF5E2A9E, 0x63F42A00, 0xED7B2DE3, 0x21D12D7D,\\n    0x2B142464, 0xE7BE24FA, 0x69312319, 0xA59B2387,\\n    0xF9766256, 0x35DC62C8, 0xBB53652B, 0x77F965B5,\\n    0x7D3C6CAC, 0xB1966C32, 0x3F196BD1, 0xF3B36B4F,\\n    0x2A9379E3, 0xE639797D, 0x68B67E9E, 0xA41C7E00,\\n    0xAED97719, 0x62737787, 0xECFC7064, 0x205670FA,\\n    0x85CD537D, 0x496753E3, 0xC7E85400, 0x0B42549E,\\n    0x01875D87, 0xCD2D5D19, 0x43A25AFA, 0x8F085A64,\\n    0x562848C8, 0x9A824856, 0x140D4FB5, 0xD8A74F2B,\\n    0xD2624632, 0x1EC846AC, 0x9047414F, 0x5CED41D1,\\n    0x299DC2ED, 0xE537C273, 0x6BB8C590, 0xA712C50E,\\n    0xADD7CC17, 0x617DCC89, 0xEFF2CB6A, 0x2358CBF4,\\n    0xFA78D958, 0x36D2D9C6, 0xB85DDE25, 0x74F7DEBB,\\n    0x7E32D7A2, 0xB298D73C, 0x3C17D0DF, 0xF0BDD041,\\n    0x5526F3C6, 0x998CF358, 0x1703F4BB, 0xDBA9F425,\\n    0xD16CFD3C, 0x1DC6FDA2, 0x9349FA41, 0x5FE3FADF,\\n    0x86C3E873, 0x4A69E8ED, 0xC4E6EF0E, 0x084CEF90,\\n    0x0289E689, 0xCE23E617, 0x40ACE1F4, 0x8C06E16A,\\n    0xD0EBA0BB, 0x1C41A025, 0x92CEA7C6, 0x5E64A758,\\n    0x54A1AE41, 0x980BAEDF, 0x1684A93C, 0xDA2EA9A2,\\n    0x030EBB0E, 0xCFA4BB90, 0x412BBC73, 0x8D81BCED,\\n    0x8744B5F4, 0x4BEEB56A, 0xC561B289, 0x09CBB217,\\n    0xAC509190, 0x60FA910E, 0xEE7596ED, 0x22DF9673,\\n    0x281A9F6A, 0xE4B09FF4, 0x6A3F9817, 0xA6959889,\\n    0x7FB58A25, 0xB31F8ABB, 0x3D908D58, 0xF13A8DC6,\\n    0xFBFF84DF, 0x37558441, 0xB9DA83A2, 0x7570833C,\\n    0x533B85DA, 0x9F918544, 0x111E82A7, 0xDDB48239,\\n    0xD7718B20, 0x1BDB8BBE, 0x95548C5D, 0x59FE8CC3,\\n    0x80DE9E6F, 0x4C749EF1, 0xC2FB9912, 0x0E51998C,\\n    0x04949095, 0xC83E900B, 0x46B197E8, 0x8A1B9776,\\n    0x2F80B4F1, 0xE32AB46F, 0x6DA5B38C, 0xA10FB312,\\n    0xABCABA0B, 0x6760BA95, 0xE9EFBD76, 0x2545BDE8,\\n    0xFC65AF44, 0x30CFAFDA, 0xBE40A839, 0x72EAA8A7,\\n    0x782FA1BE, 0xB485A120, 0x3A0AA6C3, 0xF6A0A65D,\\n    0xAA4DE78C, 0x66E7E712, 0xE868E0F1, 0x24C2E06F,\\n    0x2E07E976, 0xE2ADE9E8, 0x6C22EE0B, 0xA088EE95,\\n    0x79A8FC39, 0xB502FCA7, 0x3B8DFB44, 0xF727FBDA,\\n    0xFDE2F2C3, 0x3148F25D, 0xBFC7F5BE, 0x736DF520,\\n    0xD6F6D6A7, 0x1A5CD639, 0x94D3D1DA, 0x5879D144,\\n    0x52BCD85D, 0x9E16D8C3, 0x1099DF20, 0xDC33DFBE,\\n    0x0513CD12, 0xC9B9CD8C, 0x4736CA6F, 0x8B9CCAF1,\\n    0x8159C3E8, 0x4DF3C376, 0xC37CC495, 0x0FD6C40B,\\n    0x7AA64737, 0xB60C47A9, 0x3883404A, 0xF42940D4,\\n    0xFEEC49CD, 0x32464953, 0xBCC94EB0, 0x70634E2E,\\n    0xA9435C82, 0x65E95C1C, 0xEB665BFF, 0x27CC5B61,\\n    0x2D095278, 0xE1A352E6, 0x6F2C5505, 0xA386559B,\\n    0x061D761C, 0xCAB77682, 0x44387161, 0x889271FF,\\n    0x825778E6, 0x4EFD7878, 0xC0727F9B, 0x0CD87F05,\\n    0xD5F86DA9, 0x19526D37, 0x97DD6AD4, 0x5B776A4A,\\n    0x51B26353, 0x9D1863CD, 0x1397642E, 0xDF3D64B0,\\n    0x83D02561, 0x4F7A25FF, 0xC1F5221C, 0x0D5F2282,\\n    0x079A2B9B, 0xCB302B05, 0x45BF2CE6, 0x89152C78,\\n    0x50353ED4, 0x9C9F3E4A, 0x121039A9, 0xDEBA3937,\\n    0xD47F302E, 0x18D530B0, 0x965A3753, 0x5AF037CD,\\n    0xFF6B144A, 0x33C114D4, 0xBD4E1337, 0x71E413A9,\\n    0x7B211AB0, 0xB78B1A2E, 0x39041DCD, 0xF5AE1D53,\\n    0x2C8E0FFF, 0xE0240F61, 0x6EAB0882, 0xA201081C,\\n    0xA8C40105, 0x646E019B, 0xEAE10678, 0x264B06E6\\n  };\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"getValue\", \"return_type\": \"long\", \"position\": {\"start_line\": 53, \"end_line\": 55, \"start_column\": 10, \"end_column\": 3}, \"code\": \"long getValue() {\\n    return (~crc) & 0xffffffffL;\\n  }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"reset\", \"return_type\": \"void\", \"position\": {\"start_line\": 58, \"end_line\": 60, \"start_column\": 10, \"end_column\": 3}, \"code\": \"void reset() {\\n    _reset();\\n  }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"_reset\", \"return_type\": \"void\", \"position\": {\"start_line\": 63, \"end_line\": 65, \"start_column\": 11, \"end_column\": 3}, \"code\": \"void _reset() {\\n    crc = 0xffffffff;\\n  }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"update\", \"return_type\": \"void\", \"position\": {\"start_line\": 68, \"end_line\": 99, \"start_column\": 10, \"end_column\": 3}, \"code\": \"void update(final byte[] b, final int offset, final int len) {\\n    int localCrc = crc;\\n\\n    final int remainder = len & 0x7;\\n    int i = offset;\\n    for(final int end = offset + len - remainder; i < end; i += 8) {\\n      final int x = localCrc ^\\n          ((((b[i  ] << 24) >>> 24) + ((b[i+1] << 24) >>> 16)) +\\n          (((b[i+2] << 24) >>> 8 ) +  (b[i+3] << 24)));\\n\\n      localCrc = ((T[((x << 24) >>> 24) + 0x700] ^ T[((x << 16) >>> 24) + 0x600]) ^\\n                 (T[((x <<  8) >>> 24) + 0x500] ^ T[ (x        >>> 24) + 0x400])) ^\\n                 ((T[((b[i+4] << 24) >>> 24) + 0x300] ^ T[((b[i+5] << 24) >>> 24) + 0x200]) ^\\n                 (T[((b[i+6] << 24) >>> 24) + 0x100] ^ T[((b[i+7] << 24) >>> 24)]));\\n    }\\n\\n    /* loop unroll - duff's device style */\\n    switch(remainder) {\\n      case 7: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 6: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 5: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 4: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 3: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 2: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      case 1: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];\\n      default:\\n        /* nothing */\\n    }\\n\\n    // Publish crc out to object\\n    crc = localCrc;\\n  }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"byte\"}, {\"name\": \"offset\", \"type\": \"int\"}, {\"name\": \"len\", \"type\": \"int\"}]}, {\"name\": \"update\", \"return_type\": \"void\", \"position\": {\"start_line\": 102, \"end_line\": 104, \"start_column\": 16, \"end_column\": 3}, \"code\": \"void update(final int b) {\\n    crc = (crc >>> 8) ^ T[(((crc ^ b) << 24) >>> 24)];\\n  }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"int\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/digest/PureJavaCrc32C.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n/*\\n * Some portions of this file Copyright (c) 2004-2006 Intel Corportation\\n * and licensed under the BSD license.\\n */\\npackage org.apache.commons.codec.digest;\\n\\nimport java.util.zip.Checksum;\\n\\n/**\\n * A pure-java implementation of the CRC32 checksum that uses\\n * the CRC32-C polynomial, the same polynomial used by iSCSI\\n * and implemented on many Intel chipsets supporting SSE4.2.\\n *\\n * Copied from Hadoop 2.3.6:\\n * https://git-wip-us.apache.org/repos/asf?p=hadoop.git;a=blob_plain;\\n * f=hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/PureJavaCrc32C.java;\\n * hb=2120de588b92b9f22b1cc4188761d6a8c61aa778\\n * <p>\\n * This class is Not ThreadSafe\\n * @since 1.11\\n */\\npublic class PureJavaCrc32C implements Checksum {\\n\\n  /** the current CRC value, bit-flipped */\\n  private int crc;\\n\\n  /** Create a new PureJavaCrc32 object. */\\n  public PureJavaCrc32C() {\\n    reset();\\n  }\\n\\n  @Override\\n  public long getValue() {\\n    final long ret = crc;\\n    return (~ret) & 0xffffffffL;\\n  }\\n\\n  @Override\\n  public void reset() {\\n    crc = 0xffffffff;\\n  }\\n\\n  @Override\\n  public void update(final byte[] b, int off, int len) {\\n    int localCrc = crc;\\n\\n    while(len > 7) {\\n      final int c0 =(b[off+0] ^ localCrc) & 0xff;\\n      final int c1 =(b[off+1] ^ (localCrc >>>= 8)) & 0xff;\\n      final int c2 =(b[off+2] ^ (localCrc >>>= 8)) & 0xff;\\n      final int c3 =(b[off+3] ^ (localCrc >>>= 8)) & 0xff;\\n      localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^\\n                 (T[T8_5_start + c2] ^ T[T8_4_start + c3]);\\n\\n      final int c4 = b[off+4] & 0xff;\\n      final int c5 = b[off+5] & 0xff;\\n      final int c6 = b[off+6] & 0xff;\\n      final int c7 = b[off+7] & 0xff;\\n\\n      localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^\\n                  (T[T8_1_start + c6] ^ T[T8_0_start + c7]);\\n\\n      off += 8;\\n      len -= 8;\\n    }\\n\\n    /* loop unroll - duff's device style */\\n    switch(len) {\\n      case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 5: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 4: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 3: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 2: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 1: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      default:\\n        break; // satisfy Findbugs\\n    }\\n\\n    // Publish crc out to object\\n    crc = localCrc;\\n  }\\n\\n  @Override\\n  final public void update(final int b) {\\n    crc = (crc >>> 8) ^ T[T8_0_start + ((crc ^ b) & 0xff)];\\n  }\\n\\n  // CRC polynomial tables generated by:\\n  // java -cp build/test/classes/:build/classes/ \\\\\\n  //   org.apache.hadoop.util.TestPureJavaCrc32\\\\$Table 82F63B78\\n\\n  private static final int T8_0_start = 0*256;\\n  private static final int T8_1_start = 1*256;\\n  private static final int T8_2_start = 2*256;\\n  private static final int T8_3_start = 3*256;\\n  private static final int T8_4_start = 4*256;\\n  private static final int T8_5_start = 5*256;\\n  private static final int T8_6_start = 6*256;\\n  private static final int T8_7_start = 7*256;\\n\\n  private static final int[] T = new int[] {\\n    /* T8_0 */\\n    0x00000000, 0xF26B8303, 0xE13B70F7, 0x1350F3F4,\\n    0xC79A971F, 0x35F1141C, 0x26A1E7E8, 0xD4CA64EB,\\n    0x8AD958CF, 0x78B2DBCC, 0x6BE22838, 0x9989AB3B,\\n    0x4D43CFD0, 0xBF284CD3, 0xAC78BF27, 0x5E133C24,\\n    0x105EC76F, 0xE235446C, 0xF165B798, 0x030E349B,\\n    0xD7C45070, 0x25AFD373, 0x36FF2087, 0xC494A384,\\n    0x9A879FA0, 0x68EC1CA3, 0x7BBCEF57, 0x89D76C54,\\n    0x5D1D08BF, 0xAF768BBC, 0xBC267848, 0x4E4DFB4B,\\n    0x20BD8EDE, 0xD2D60DDD, 0xC186FE29, 0x33ED7D2A,\\n    0xE72719C1, 0x154C9AC2, 0x061C6936, 0xF477EA35,\\n    0xAA64D611, 0x580F5512, 0x4B5FA6E6, 0xB93425E5,\\n    0x6DFE410E, 0x9F95C20D, 0x8CC531F9, 0x7EAEB2FA,\\n    0x30E349B1, 0xC288CAB2, 0xD1D83946, 0x23B3BA45,\\n    0xF779DEAE, 0x05125DAD, 0x1642AE59, 0xE4292D5A,\\n    0xBA3A117E, 0x4851927D, 0x5B016189, 0xA96AE28A,\\n    0x7DA08661, 0x8FCB0562, 0x9C9BF696, 0x6EF07595,\\n    0x417B1DBC, 0xB3109EBF, 0xA0406D4B, 0x522BEE48,\\n    0x86E18AA3, 0x748A09A0, 0x67DAFA54, 0x95B17957,\\n    0xCBA24573, 0x39C9C670, 0x2A993584, 0xD8F2B687,\\n    0x0C38D26C, 0xFE53516F, 0xED03A29B, 0x1F682198,\\n    0x5125DAD3, 0xA34E59D0, 0xB01EAA24, 0x42752927,\\n    0x96BF4DCC, 0x64D4CECF, 0x77843D3B, 0x85EFBE38,\\n    0xDBFC821C, 0x2997011F, 0x3AC7F2EB, 0xC8AC71E8,\\n    0x1C661503, 0xEE0D9600, 0xFD5D65F4, 0x0F36E6F7,\\n    0x61C69362, 0x93AD1061, 0x80FDE395, 0x72966096,\\n    0xA65C047D, 0x5437877E, 0x4767748A, 0xB50CF789,\\n    0xEB1FCBAD, 0x197448AE, 0x0A24BB5A, 0xF84F3859,\\n    0x2C855CB2, 0xDEEEDFB1, 0xCDBE2C45, 0x3FD5AF46,\\n    0x7198540D, 0x83F3D70E, 0x90A324FA, 0x62C8A7F9,\\n    0xB602C312, 0x44694011, 0x5739B3E5, 0xA55230E6,\\n    0xFB410CC2, 0x092A8FC1, 0x1A7A7C35, 0xE811FF36,\\n    0x3CDB9BDD, 0xCEB018DE, 0xDDE0EB2A, 0x2F8B6829,\\n    0x82F63B78, 0x709DB87B, 0x63CD4B8F, 0x91A6C88C,\\n    0x456CAC67, 0xB7072F64, 0xA457DC90, 0x563C5F93,\\n    0x082F63B7, 0xFA44E0B4, 0xE9141340, 0x1B7F9043,\\n    0xCFB5F4A8, 0x3DDE77AB, 0x2E8E845F, 0xDCE5075C,\\n    0x92A8FC17, 0x60C37F14, 0x73938CE0, 0x81F80FE3,\\n    0x55326B08, 0xA759E80B, 0xB4091BFF, 0x466298FC,\\n    0x1871A4D8, 0xEA1A27DB, 0xF94AD42F, 0x0B21572C,\\n    0xDFEB33C7, 0x2D80B0C4, 0x3ED04330, 0xCCBBC033,\\n    0xA24BB5A6, 0x502036A5, 0x4370C551, 0xB11B4652,\\n    0x65D122B9, 0x97BAA1BA, 0x84EA524E, 0x7681D14D,\\n    0x2892ED69, 0xDAF96E6A, 0xC9A99D9E, 0x3BC21E9D,\\n    0xEF087A76, 0x1D63F975, 0x0E330A81, 0xFC588982,\\n    0xB21572C9, 0x407EF1CA, 0x532E023E, 0xA145813D,\\n    0x758FE5D6, 0x87E466D5, 0x94B49521, 0x66DF1622,\\n    0x38CC2A06, 0xCAA7A905, 0xD9F75AF1, 0x2B9CD9F2,\\n    0xFF56BD19, 0x0D3D3E1A, 0x1E6DCDEE, 0xEC064EED,\\n    0xC38D26C4, 0x31E6A5C7, 0x22B65633, 0xD0DDD530,\\n    0x0417B1DB, 0xF67C32D8, 0xE52CC12C, 0x1747422F,\\n    0x49547E0B, 0xBB3FFD08, 0xA86F0EFC, 0x5A048DFF,\\n    0x8ECEE914, 0x7CA56A17, 0x6FF599E3, 0x9D9E1AE0,\\n    0xD3D3E1AB, 0x21B862A8, 0x32E8915C, 0xC083125F,\\n    0x144976B4, 0xE622F5B7, 0xF5720643, 0x07198540,\\n    0x590AB964, 0xAB613A67, 0xB831C993, 0x4A5A4A90,\\n    0x9E902E7B, 0x6CFBAD78, 0x7FAB5E8C, 0x8DC0DD8F,\\n    0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE,\\n    0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,\\n    0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321,\\n    0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,\\n    0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81,\\n    0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,\\n    0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E,\\n    0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351,\\n    /* T8_1 */\\n    0x00000000, 0x13A29877, 0x274530EE, 0x34E7A899,\\n    0x4E8A61DC, 0x5D28F9AB, 0x69CF5132, 0x7A6DC945,\\n    0x9D14C3B8, 0x8EB65BCF, 0xBA51F356, 0xA9F36B21,\\n    0xD39EA264, 0xC03C3A13, 0xF4DB928A, 0xE7790AFD,\\n    0x3FC5F181, 0x2C6769F6, 0x1880C16F, 0x0B225918,\\n    0x714F905D, 0x62ED082A, 0x560AA0B3, 0x45A838C4,\\n    0xA2D13239, 0xB173AA4E, 0x859402D7, 0x96369AA0,\\n    0xEC5B53E5, 0xFFF9CB92, 0xCB1E630B, 0xD8BCFB7C,\\n    0x7F8BE302, 0x6C297B75, 0x58CED3EC, 0x4B6C4B9B,\\n    0x310182DE, 0x22A31AA9, 0x1644B230, 0x05E62A47,\\n    0xE29F20BA, 0xF13DB8CD, 0xC5DA1054, 0xD6788823,\\n    0xAC154166, 0xBFB7D911, 0x8B507188, 0x98F2E9FF,\\n    0x404E1283, 0x53EC8AF4, 0x670B226D, 0x74A9BA1A,\\n    0x0EC4735F, 0x1D66EB28, 0x298143B1, 0x3A23DBC6,\\n    0xDD5AD13B, 0xCEF8494C, 0xFA1FE1D5, 0xE9BD79A2,\\n    0x93D0B0E7, 0x80722890, 0xB4958009, 0xA737187E,\\n    0xFF17C604, 0xECB55E73, 0xD852F6EA, 0xCBF06E9D,\\n    0xB19DA7D8, 0xA23F3FAF, 0x96D89736, 0x857A0F41,\\n    0x620305BC, 0x71A19DCB, 0x45463552, 0x56E4AD25,\\n    0x2C896460, 0x3F2BFC17, 0x0BCC548E, 0x186ECCF9,\\n    0xC0D23785, 0xD370AFF2, 0xE797076B, 0xF4359F1C,\\n    0x8E585659, 0x9DFACE2E, 0xA91D66B7, 0xBABFFEC0,\\n    0x5DC6F43D, 0x4E646C4A, 0x7A83C4D3, 0x69215CA4,\\n    0x134C95E1, 0x00EE0D96, 0x3409A50F, 0x27AB3D78,\\n    0x809C2506, 0x933EBD71, 0xA7D915E8, 0xB47B8D9F,\\n    0xCE1644DA, 0xDDB4DCAD, 0xE9537434, 0xFAF1EC43,\\n    0x1D88E6BE, 0x0E2A7EC9, 0x3ACDD650, 0x296F4E27,\\n    0x53028762, 0x40A01F15, 0x7447B78C, 0x67E52FFB,\\n    0xBF59D487, 0xACFB4CF0, 0x981CE469, 0x8BBE7C1E,\\n    0xF1D3B55B, 0xE2712D2C, 0xD69685B5, 0xC5341DC2,\\n    0x224D173F, 0x31EF8F48, 0x050827D1, 0x16AABFA6,\\n    0x6CC776E3, 0x7F65EE94, 0x4B82460D, 0x5820DE7A,\\n    0xFBC3FAF9, 0xE861628E, 0xDC86CA17, 0xCF245260,\\n    0xB5499B25, 0xA6EB0352, 0x920CABCB, 0x81AE33BC,\\n    0x66D73941, 0x7575A136, 0x419209AF, 0x523091D8,\\n    0x285D589D, 0x3BFFC0EA, 0x0F186873, 0x1CBAF004,\\n    0xC4060B78, 0xD7A4930F, 0xE3433B96, 0xF0E1A3E1,\\n    0x8A8C6AA4, 0x992EF2D3, 0xADC95A4A, 0xBE6BC23D,\\n    0x5912C8C0, 0x4AB050B7, 0x7E57F82E, 0x6DF56059,\\n    0x1798A91C, 0x043A316B, 0x30DD99F2, 0x237F0185,\\n    0x844819FB, 0x97EA818C, 0xA30D2915, 0xB0AFB162,\\n    0xCAC27827, 0xD960E050, 0xED8748C9, 0xFE25D0BE,\\n    0x195CDA43, 0x0AFE4234, 0x3E19EAAD, 0x2DBB72DA,\\n    0x57D6BB9F, 0x447423E8, 0x70938B71, 0x63311306,\\n    0xBB8DE87A, 0xA82F700D, 0x9CC8D894, 0x8F6A40E3,\\n    0xF50789A6, 0xE6A511D1, 0xD242B948, 0xC1E0213F,\\n    0x26992BC2, 0x353BB3B5, 0x01DC1B2C, 0x127E835B,\\n    0x68134A1E, 0x7BB1D269, 0x4F567AF0, 0x5CF4E287,\\n    0x04D43CFD, 0x1776A48A, 0x23910C13, 0x30339464,\\n    0x4A5E5D21, 0x59FCC556, 0x6D1B6DCF, 0x7EB9F5B8,\\n    0x99C0FF45, 0x8A626732, 0xBE85CFAB, 0xAD2757DC,\\n    0xD74A9E99, 0xC4E806EE, 0xF00FAE77, 0xE3AD3600,\\n    0x3B11CD7C, 0x28B3550B, 0x1C54FD92, 0x0FF665E5,\\n    0x759BACA0, 0x663934D7, 0x52DE9C4E, 0x417C0439,\\n    0xA6050EC4, 0xB5A796B3, 0x81403E2A, 0x92E2A65D,\\n    0xE88F6F18, 0xFB2DF76F, 0xCFCA5FF6, 0xDC68C781,\\n    0x7B5FDFFF, 0x68FD4788, 0x5C1AEF11, 0x4FB87766,\\n    0x35D5BE23, 0x26772654, 0x12908ECD, 0x013216BA,\\n    0xE64B1C47, 0xF5E98430, 0xC10E2CA9, 0xD2ACB4DE,\\n    0xA8C17D9B, 0xBB63E5EC, 0x8F844D75, 0x9C26D502,\\n    0x449A2E7E, 0x5738B609, 0x63DF1E90, 0x707D86E7,\\n    0x0A104FA2, 0x19B2D7D5, 0x2D557F4C, 0x3EF7E73B,\\n    0xD98EEDC6, 0xCA2C75B1, 0xFECBDD28, 0xED69455F,\\n    0x97048C1A, 0x84A6146D, 0xB041BCF4, 0xA3E32483,\\n    /* T8_2 */\\n    0x00000000, 0xA541927E, 0x4F6F520D, 0xEA2EC073,\\n    0x9EDEA41A, 0x3B9F3664, 0xD1B1F617, 0x74F06469,\\n    0x38513EC5, 0x9D10ACBB, 0x773E6CC8, 0xD27FFEB6,\\n    0xA68F9ADF, 0x03CE08A1, 0xE9E0C8D2, 0x4CA15AAC,\\n    0x70A27D8A, 0xD5E3EFF4, 0x3FCD2F87, 0x9A8CBDF9,\\n    0xEE7CD990, 0x4B3D4BEE, 0xA1138B9D, 0x045219E3,\\n    0x48F3434F, 0xEDB2D131, 0x079C1142, 0xA2DD833C,\\n    0xD62DE755, 0x736C752B, 0x9942B558, 0x3C032726,\\n    0xE144FB14, 0x4405696A, 0xAE2BA919, 0x0B6A3B67,\\n    0x7F9A5F0E, 0xDADBCD70, 0x30F50D03, 0x95B49F7D,\\n    0xD915C5D1, 0x7C5457AF, 0x967A97DC, 0x333B05A2,\\n    0x47CB61CB, 0xE28AF3B5, 0x08A433C6, 0xADE5A1B8,\\n    0x91E6869E, 0x34A714E0, 0xDE89D493, 0x7BC846ED,\\n    0x0F382284, 0xAA79B0FA, 0x40577089, 0xE516E2F7,\\n    0xA9B7B85B, 0x0CF62A25, 0xE6D8EA56, 0x43997828,\\n    0x37691C41, 0x92288E3F, 0x78064E4C, 0xDD47DC32,\\n    0xC76580D9, 0x622412A7, 0x880AD2D4, 0x2D4B40AA,\\n    0x59BB24C3, 0xFCFAB6BD, 0x16D476CE, 0xB395E4B0,\\n    0xFF34BE1C, 0x5A752C62, 0xB05BEC11, 0x151A7E6F,\\n    0x61EA1A06, 0xC4AB8878, 0x2E85480B, 0x8BC4DA75,\\n    0xB7C7FD53, 0x12866F2D, 0xF8A8AF5E, 0x5DE93D20,\\n    0x29195949, 0x8C58CB37, 0x66760B44, 0xC337993A,\\n    0x8F96C396, 0x2AD751E8, 0xC0F9919B, 0x65B803E5,\\n    0x1148678C, 0xB409F5F2, 0x5E273581, 0xFB66A7FF,\\n    0x26217BCD, 0x8360E9B3, 0x694E29C0, 0xCC0FBBBE,\\n    0xB8FFDFD7, 0x1DBE4DA9, 0xF7908DDA, 0x52D11FA4,\\n    0x1E704508, 0xBB31D776, 0x511F1705, 0xF45E857B,\\n    0x80AEE112, 0x25EF736C, 0xCFC1B31F, 0x6A802161,\\n    0x56830647, 0xF3C29439, 0x19EC544A, 0xBCADC634,\\n    0xC85DA25D, 0x6D1C3023, 0x8732F050, 0x2273622E,\\n    0x6ED23882, 0xCB93AAFC, 0x21BD6A8F, 0x84FCF8F1,\\n    0xF00C9C98, 0x554D0EE6, 0xBF63CE95, 0x1A225CEB,\\n    0x8B277743, 0x2E66E53D, 0xC448254E, 0x6109B730,\\n    0x15F9D359, 0xB0B84127, 0x5A968154, 0xFFD7132A,\\n    0xB3764986, 0x1637DBF8, 0xFC191B8B, 0x595889F5,\\n    0x2DA8ED9C, 0x88E97FE2, 0x62C7BF91, 0xC7862DEF,\\n    0xFB850AC9, 0x5EC498B7, 0xB4EA58C4, 0x11ABCABA,\\n    0x655BAED3, 0xC01A3CAD, 0x2A34FCDE, 0x8F756EA0,\\n    0xC3D4340C, 0x6695A672, 0x8CBB6601, 0x29FAF47F,\\n    0x5D0A9016, 0xF84B0268, 0x1265C21B, 0xB7245065,\\n    0x6A638C57, 0xCF221E29, 0x250CDE5A, 0x804D4C24,\\n    0xF4BD284D, 0x51FCBA33, 0xBBD27A40, 0x1E93E83E,\\n    0x5232B292, 0xF77320EC, 0x1D5DE09F, 0xB81C72E1,\\n    0xCCEC1688, 0x69AD84F6, 0x83834485, 0x26C2D6FB,\\n    0x1AC1F1DD, 0xBF8063A3, 0x55AEA3D0, 0xF0EF31AE,\\n    0x841F55C7, 0x215EC7B9, 0xCB7007CA, 0x6E3195B4,\\n    0x2290CF18, 0x87D15D66, 0x6DFF9D15, 0xC8BE0F6B,\\n    0xBC4E6B02, 0x190FF97C, 0xF321390F, 0x5660AB71,\\n    0x4C42F79A, 0xE90365E4, 0x032DA597, 0xA66C37E9,\\n    0xD29C5380, 0x77DDC1FE, 0x9DF3018D, 0x38B293F3,\\n    0x7413C95F, 0xD1525B21, 0x3B7C9B52, 0x9E3D092C,\\n    0xEACD6D45, 0x4F8CFF3B, 0xA5A23F48, 0x00E3AD36,\\n    0x3CE08A10, 0x99A1186E, 0x738FD81D, 0xD6CE4A63,\\n    0xA23E2E0A, 0x077FBC74, 0xED517C07, 0x4810EE79,\\n    0x04B1B4D5, 0xA1F026AB, 0x4BDEE6D8, 0xEE9F74A6,\\n    0x9A6F10CF, 0x3F2E82B1, 0xD50042C2, 0x7041D0BC,\\n    0xAD060C8E, 0x08479EF0, 0xE2695E83, 0x4728CCFD,\\n    0x33D8A894, 0x96993AEA, 0x7CB7FA99, 0xD9F668E7,\\n    0x9557324B, 0x3016A035, 0xDA386046, 0x7F79F238,\\n    0x0B899651, 0xAEC8042F, 0x44E6C45C, 0xE1A75622,\\n    0xDDA47104, 0x78E5E37A, 0x92CB2309, 0x378AB177,\\n    0x437AD51E, 0xE63B4760, 0x0C158713, 0xA954156D,\\n    0xE5F54FC1, 0x40B4DDBF, 0xAA9A1DCC, 0x0FDB8FB2,\\n    0x7B2BEBDB, 0xDE6A79A5, 0x3444B9D6, 0x91052BA8,\\n    /* T8_3 */\\n    0x00000000, 0xDD45AAB8, 0xBF672381, 0x62228939,\\n    0x7B2231F3, 0xA6679B4B, 0xC4451272, 0x1900B8CA,\\n    0xF64463E6, 0x2B01C95E, 0x49234067, 0x9466EADF,\\n    0x8D665215, 0x5023F8AD, 0x32017194, 0xEF44DB2C,\\n    0xE964B13D, 0x34211B85, 0x560392BC, 0x8B463804,\\n    0x924680CE, 0x4F032A76, 0x2D21A34F, 0xF06409F7,\\n    0x1F20D2DB, 0xC2657863, 0xA047F15A, 0x7D025BE2,\\n    0x6402E328, 0xB9474990, 0xDB65C0A9, 0x06206A11,\\n    0xD725148B, 0x0A60BE33, 0x6842370A, 0xB5079DB2,\\n    0xAC072578, 0x71428FC0, 0x136006F9, 0xCE25AC41,\\n    0x2161776D, 0xFC24DDD5, 0x9E0654EC, 0x4343FE54,\\n    0x5A43469E, 0x8706EC26, 0xE524651F, 0x3861CFA7,\\n    0x3E41A5B6, 0xE3040F0E, 0x81268637, 0x5C632C8F,\\n    0x45639445, 0x98263EFD, 0xFA04B7C4, 0x27411D7C,\\n    0xC805C650, 0x15406CE8, 0x7762E5D1, 0xAA274F69,\\n    0xB327F7A3, 0x6E625D1B, 0x0C40D422, 0xD1057E9A,\\n    0xABA65FE7, 0x76E3F55F, 0x14C17C66, 0xC984D6DE,\\n    0xD0846E14, 0x0DC1C4AC, 0x6FE34D95, 0xB2A6E72D,\\n    0x5DE23C01, 0x80A796B9, 0xE2851F80, 0x3FC0B538,\\n    0x26C00DF2, 0xFB85A74A, 0x99A72E73, 0x44E284CB,\\n    0x42C2EEDA, 0x9F874462, 0xFDA5CD5B, 0x20E067E3,\\n    0x39E0DF29, 0xE4A57591, 0x8687FCA8, 0x5BC25610,\\n    0xB4868D3C, 0x69C32784, 0x0BE1AEBD, 0xD6A40405,\\n    0xCFA4BCCF, 0x12E11677, 0x70C39F4E, 0xAD8635F6,\\n    0x7C834B6C, 0xA1C6E1D4, 0xC3E468ED, 0x1EA1C255,\\n    0x07A17A9F, 0xDAE4D027, 0xB8C6591E, 0x6583F3A6,\\n    0x8AC7288A, 0x57828232, 0x35A00B0B, 0xE8E5A1B3,\\n    0xF1E51979, 0x2CA0B3C1, 0x4E823AF8, 0x93C79040,\\n    0x95E7FA51, 0x48A250E9, 0x2A80D9D0, 0xF7C57368,\\n    0xEEC5CBA2, 0x3380611A, 0x51A2E823, 0x8CE7429B,\\n    0x63A399B7, 0xBEE6330F, 0xDCC4BA36, 0x0181108E,\\n    0x1881A844, 0xC5C402FC, 0xA7E68BC5, 0x7AA3217D,\\n    0x52A0C93F, 0x8FE56387, 0xEDC7EABE, 0x30824006,\\n    0x2982F8CC, 0xF4C75274, 0x96E5DB4D, 0x4BA071F5,\\n    0xA4E4AAD9, 0x79A10061, 0x1B838958, 0xC6C623E0,\\n    0xDFC69B2A, 0x02833192, 0x60A1B8AB, 0xBDE41213,\\n    0xBBC47802, 0x6681D2BA, 0x04A35B83, 0xD9E6F13B,\\n    0xC0E649F1, 0x1DA3E349, 0x7F816A70, 0xA2C4C0C8,\\n    0x4D801BE4, 0x90C5B15C, 0xF2E73865, 0x2FA292DD,\\n    0x36A22A17, 0xEBE780AF, 0x89C50996, 0x5480A32E,\\n    0x8585DDB4, 0x58C0770C, 0x3AE2FE35, 0xE7A7548D,\\n    0xFEA7EC47, 0x23E246FF, 0x41C0CFC6, 0x9C85657E,\\n    0x73C1BE52, 0xAE8414EA, 0xCCA69DD3, 0x11E3376B,\\n    0x08E38FA1, 0xD5A62519, 0xB784AC20, 0x6AC10698,\\n    0x6CE16C89, 0xB1A4C631, 0xD3864F08, 0x0EC3E5B0,\\n    0x17C35D7A, 0xCA86F7C2, 0xA8A47EFB, 0x75E1D443,\\n    0x9AA50F6F, 0x47E0A5D7, 0x25C22CEE, 0xF8878656,\\n    0xE1873E9C, 0x3CC29424, 0x5EE01D1D, 0x83A5B7A5,\\n    0xF90696D8, 0x24433C60, 0x4661B559, 0x9B241FE1,\\n    0x8224A72B, 0x5F610D93, 0x3D4384AA, 0xE0062E12,\\n    0x0F42F53E, 0xD2075F86, 0xB025D6BF, 0x6D607C07,\\n    0x7460C4CD, 0xA9256E75, 0xCB07E74C, 0x16424DF4,\\n    0x106227E5, 0xCD278D5D, 0xAF050464, 0x7240AEDC,\\n    0x6B401616, 0xB605BCAE, 0xD4273597, 0x09629F2F,\\n    0xE6264403, 0x3B63EEBB, 0x59416782, 0x8404CD3A,\\n    0x9D0475F0, 0x4041DF48, 0x22635671, 0xFF26FCC9,\\n    0x2E238253, 0xF36628EB, 0x9144A1D2, 0x4C010B6A,\\n    0x5501B3A0, 0x88441918, 0xEA669021, 0x37233A99,\\n    0xD867E1B5, 0x05224B0D, 0x6700C234, 0xBA45688C,\\n    0xA345D046, 0x7E007AFE, 0x1C22F3C7, 0xC167597F,\\n    0xC747336E, 0x1A0299D6, 0x782010EF, 0xA565BA57,\\n    0xBC65029D, 0x6120A825, 0x0302211C, 0xDE478BA4,\\n    0x31035088, 0xEC46FA30, 0x8E647309, 0x5321D9B1,\\n    0x4A21617B, 0x9764CBC3, 0xF54642FA, 0x2803E842,\\n    /* T8_4 */\\n    0x00000000, 0x38116FAC, 0x7022DF58, 0x4833B0F4,\\n    0xE045BEB0, 0xD854D11C, 0x906761E8, 0xA8760E44,\\n    0xC5670B91, 0xFD76643D, 0xB545D4C9, 0x8D54BB65,\\n    0x2522B521, 0x1D33DA8D, 0x55006A79, 0x6D1105D5,\\n    0x8F2261D3, 0xB7330E7F, 0xFF00BE8B, 0xC711D127,\\n    0x6F67DF63, 0x5776B0CF, 0x1F45003B, 0x27546F97,\\n    0x4A456A42, 0x725405EE, 0x3A67B51A, 0x0276DAB6,\\n    0xAA00D4F2, 0x9211BB5E, 0xDA220BAA, 0xE2336406,\\n    0x1BA8B557, 0x23B9DAFB, 0x6B8A6A0F, 0x539B05A3,\\n    0xFBED0BE7, 0xC3FC644B, 0x8BCFD4BF, 0xB3DEBB13,\\n    0xDECFBEC6, 0xE6DED16A, 0xAEED619E, 0x96FC0E32,\\n    0x3E8A0076, 0x069B6FDA, 0x4EA8DF2E, 0x76B9B082,\\n    0x948AD484, 0xAC9BBB28, 0xE4A80BDC, 0xDCB96470,\\n    0x74CF6A34, 0x4CDE0598, 0x04EDB56C, 0x3CFCDAC0,\\n    0x51EDDF15, 0x69FCB0B9, 0x21CF004D, 0x19DE6FE1,\\n    0xB1A861A5, 0x89B90E09, 0xC18ABEFD, 0xF99BD151,\\n    0x37516AAE, 0x0F400502, 0x4773B5F6, 0x7F62DA5A,\\n    0xD714D41E, 0xEF05BBB2, 0xA7360B46, 0x9F2764EA,\\n    0xF236613F, 0xCA270E93, 0x8214BE67, 0xBA05D1CB,\\n    0x1273DF8F, 0x2A62B023, 0x625100D7, 0x5A406F7B,\\n    0xB8730B7D, 0x806264D1, 0xC851D425, 0xF040BB89,\\n    0x5836B5CD, 0x6027DA61, 0x28146A95, 0x10050539,\\n    0x7D1400EC, 0x45056F40, 0x0D36DFB4, 0x3527B018,\\n    0x9D51BE5C, 0xA540D1F0, 0xED736104, 0xD5620EA8,\\n    0x2CF9DFF9, 0x14E8B055, 0x5CDB00A1, 0x64CA6F0D,\\n    0xCCBC6149, 0xF4AD0EE5, 0xBC9EBE11, 0x848FD1BD,\\n    0xE99ED468, 0xD18FBBC4, 0x99BC0B30, 0xA1AD649C,\\n    0x09DB6AD8, 0x31CA0574, 0x79F9B580, 0x41E8DA2C,\\n    0xA3DBBE2A, 0x9BCAD186, 0xD3F96172, 0xEBE80EDE,\\n    0x439E009A, 0x7B8F6F36, 0x33BCDFC2, 0x0BADB06E,\\n    0x66BCB5BB, 0x5EADDA17, 0x169E6AE3, 0x2E8F054F,\\n    0x86F90B0B, 0xBEE864A7, 0xF6DBD453, 0xCECABBFF,\\n    0x6EA2D55C, 0x56B3BAF0, 0x1E800A04, 0x269165A8,\\n    0x8EE76BEC, 0xB6F60440, 0xFEC5B4B4, 0xC6D4DB18,\\n    0xABC5DECD, 0x93D4B161, 0xDBE70195, 0xE3F66E39,\\n    0x4B80607D, 0x73910FD1, 0x3BA2BF25, 0x03B3D089,\\n    0xE180B48F, 0xD991DB23, 0x91A26BD7, 0xA9B3047B,\\n    0x01C50A3F, 0x39D46593, 0x71E7D567, 0x49F6BACB,\\n    0x24E7BF1E, 0x1CF6D0B2, 0x54C56046, 0x6CD40FEA,\\n    0xC4A201AE, 0xFCB36E02, 0xB480DEF6, 0x8C91B15A,\\n    0x750A600B, 0x4D1B0FA7, 0x0528BF53, 0x3D39D0FF,\\n    0x954FDEBB, 0xAD5EB117, 0xE56D01E3, 0xDD7C6E4F,\\n    0xB06D6B9A, 0x887C0436, 0xC04FB4C2, 0xF85EDB6E,\\n    0x5028D52A, 0x6839BA86, 0x200A0A72, 0x181B65DE,\\n    0xFA2801D8, 0xC2396E74, 0x8A0ADE80, 0xB21BB12C,\\n    0x1A6DBF68, 0x227CD0C4, 0x6A4F6030, 0x525E0F9C,\\n    0x3F4F0A49, 0x075E65E5, 0x4F6DD511, 0x777CBABD,\\n    0xDF0AB4F9, 0xE71BDB55, 0xAF286BA1, 0x9739040D,\\n    0x59F3BFF2, 0x61E2D05E, 0x29D160AA, 0x11C00F06,\\n    0xB9B60142, 0x81A76EEE, 0xC994DE1A, 0xF185B1B6,\\n    0x9C94B463, 0xA485DBCF, 0xECB66B3B, 0xD4A70497,\\n    0x7CD10AD3, 0x44C0657F, 0x0CF3D58B, 0x34E2BA27,\\n    0xD6D1DE21, 0xEEC0B18D, 0xA6F30179, 0x9EE26ED5,\\n    0x36946091, 0x0E850F3D, 0x46B6BFC9, 0x7EA7D065,\\n    0x13B6D5B0, 0x2BA7BA1C, 0x63940AE8, 0x5B856544,\\n    0xF3F36B00, 0xCBE204AC, 0x83D1B458, 0xBBC0DBF4,\\n    0x425B0AA5, 0x7A4A6509, 0x3279D5FD, 0x0A68BA51,\\n    0xA21EB415, 0x9A0FDBB9, 0xD23C6B4D, 0xEA2D04E1,\\n    0x873C0134, 0xBF2D6E98, 0xF71EDE6C, 0xCF0FB1C0,\\n    0x6779BF84, 0x5F68D028, 0x175B60DC, 0x2F4A0F70,\\n    0xCD796B76, 0xF56804DA, 0xBD5BB42E, 0x854ADB82,\\n    0x2D3CD5C6, 0x152DBA6A, 0x5D1E0A9E, 0x650F6532,\\n    0x081E60E7, 0x300F0F4B, 0x783CBFBF, 0x402DD013,\\n    0xE85BDE57, 0xD04AB1FB, 0x9879010F, 0xA0686EA3,\\n    /* T8_5 */\\n    0x00000000, 0xEF306B19, 0xDB8CA0C3, 0x34BCCBDA,\\n    0xB2F53777, 0x5DC55C6E, 0x697997B4, 0x8649FCAD,\\n    0x6006181F, 0x8F367306, 0xBB8AB8DC, 0x54BAD3C5,\\n    0xD2F32F68, 0x3DC34471, 0x097F8FAB, 0xE64FE4B2,\\n    0xC00C303E, 0x2F3C5B27, 0x1B8090FD, 0xF4B0FBE4,\\n    0x72F90749, 0x9DC96C50, 0xA975A78A, 0x4645CC93,\\n    0xA00A2821, 0x4F3A4338, 0x7B8688E2, 0x94B6E3FB,\\n    0x12FF1F56, 0xFDCF744F, 0xC973BF95, 0x2643D48C,\\n    0x85F4168D, 0x6AC47D94, 0x5E78B64E, 0xB148DD57,\\n    0x370121FA, 0xD8314AE3, 0xEC8D8139, 0x03BDEA20,\\n    0xE5F20E92, 0x0AC2658B, 0x3E7EAE51, 0xD14EC548,\\n    0x570739E5, 0xB83752FC, 0x8C8B9926, 0x63BBF23F,\\n    0x45F826B3, 0xAAC84DAA, 0x9E748670, 0x7144ED69,\\n    0xF70D11C4, 0x183D7ADD, 0x2C81B107, 0xC3B1DA1E,\\n    0x25FE3EAC, 0xCACE55B5, 0xFE729E6F, 0x1142F576,\\n    0x970B09DB, 0x783B62C2, 0x4C87A918, 0xA3B7C201,\\n    0x0E045BEB, 0xE13430F2, 0xD588FB28, 0x3AB89031,\\n    0xBCF16C9C, 0x53C10785, 0x677DCC5F, 0x884DA746,\\n    0x6E0243F4, 0x813228ED, 0xB58EE337, 0x5ABE882E,\\n    0xDCF77483, 0x33C71F9A, 0x077BD440, 0xE84BBF59,\\n    0xCE086BD5, 0x213800CC, 0x1584CB16, 0xFAB4A00F,\\n    0x7CFD5CA2, 0x93CD37BB, 0xA771FC61, 0x48419778,\\n    0xAE0E73CA, 0x413E18D3, 0x7582D309, 0x9AB2B810,\\n    0x1CFB44BD, 0xF3CB2FA4, 0xC777E47E, 0x28478F67,\\n    0x8BF04D66, 0x64C0267F, 0x507CEDA5, 0xBF4C86BC,\\n    0x39057A11, 0xD6351108, 0xE289DAD2, 0x0DB9B1CB,\\n    0xEBF65579, 0x04C63E60, 0x307AF5BA, 0xDF4A9EA3,\\n    0x5903620E, 0xB6330917, 0x828FC2CD, 0x6DBFA9D4,\\n    0x4BFC7D58, 0xA4CC1641, 0x9070DD9B, 0x7F40B682,\\n    0xF9094A2F, 0x16392136, 0x2285EAEC, 0xCDB581F5,\\n    0x2BFA6547, 0xC4CA0E5E, 0xF076C584, 0x1F46AE9D,\\n    0x990F5230, 0x763F3929, 0x4283F2F3, 0xADB399EA,\\n    0x1C08B7D6, 0xF338DCCF, 0xC7841715, 0x28B47C0C,\\n    0xAEFD80A1, 0x41CDEBB8, 0x75712062, 0x9A414B7B,\\n    0x7C0EAFC9, 0x933EC4D0, 0xA7820F0A, 0x48B26413,\\n    0xCEFB98BE, 0x21CBF3A7, 0x1577387D, 0xFA475364,\\n    0xDC0487E8, 0x3334ECF1, 0x0788272B, 0xE8B84C32,\\n    0x6EF1B09F, 0x81C1DB86, 0xB57D105C, 0x5A4D7B45,\\n    0xBC029FF7, 0x5332F4EE, 0x678E3F34, 0x88BE542D,\\n    0x0EF7A880, 0xE1C7C399, 0xD57B0843, 0x3A4B635A,\\n    0x99FCA15B, 0x76CCCA42, 0x42700198, 0xAD406A81,\\n    0x2B09962C, 0xC439FD35, 0xF08536EF, 0x1FB55DF6,\\n    0xF9FAB944, 0x16CAD25D, 0x22761987, 0xCD46729E,\\n    0x4B0F8E33, 0xA43FE52A, 0x90832EF0, 0x7FB345E9,\\n    0x59F09165, 0xB6C0FA7C, 0x827C31A6, 0x6D4C5ABF,\\n    0xEB05A612, 0x0435CD0B, 0x308906D1, 0xDFB96DC8,\\n    0x39F6897A, 0xD6C6E263, 0xE27A29B9, 0x0D4A42A0,\\n    0x8B03BE0D, 0x6433D514, 0x508F1ECE, 0xBFBF75D7,\\n    0x120CEC3D, 0xFD3C8724, 0xC9804CFE, 0x26B027E7,\\n    0xA0F9DB4A, 0x4FC9B053, 0x7B757B89, 0x94451090,\\n    0x720AF422, 0x9D3A9F3B, 0xA98654E1, 0x46B63FF8,\\n    0xC0FFC355, 0x2FCFA84C, 0x1B736396, 0xF443088F,\\n    0xD200DC03, 0x3D30B71A, 0x098C7CC0, 0xE6BC17D9,\\n    0x60F5EB74, 0x8FC5806D, 0xBB794BB7, 0x544920AE,\\n    0xB206C41C, 0x5D36AF05, 0x698A64DF, 0x86BA0FC6,\\n    0x00F3F36B, 0xEFC39872, 0xDB7F53A8, 0x344F38B1,\\n    0x97F8FAB0, 0x78C891A9, 0x4C745A73, 0xA344316A,\\n    0x250DCDC7, 0xCA3DA6DE, 0xFE816D04, 0x11B1061D,\\n    0xF7FEE2AF, 0x18CE89B6, 0x2C72426C, 0xC3422975,\\n    0x450BD5D8, 0xAA3BBEC1, 0x9E87751B, 0x71B71E02,\\n    0x57F4CA8E, 0xB8C4A197, 0x8C786A4D, 0x63480154,\\n    0xE501FDF9, 0x0A3196E0, 0x3E8D5D3A, 0xD1BD3623,\\n    0x37F2D291, 0xD8C2B988, 0xEC7E7252, 0x034E194B,\\n    0x8507E5E6, 0x6A378EFF, 0x5E8B4525, 0xB1BB2E3C,\\n    /* T8_6 */\\n    0x00000000, 0x68032CC8, 0xD0065990, 0xB8057558,\\n    0xA5E0C5D1, 0xCDE3E919, 0x75E69C41, 0x1DE5B089,\\n    0x4E2DFD53, 0x262ED19B, 0x9E2BA4C3, 0xF628880B,\\n    0xEBCD3882, 0x83CE144A, 0x3BCB6112, 0x53C84DDA,\\n    0x9C5BFAA6, 0xF458D66E, 0x4C5DA336, 0x245E8FFE,\\n    0x39BB3F77, 0x51B813BF, 0xE9BD66E7, 0x81BE4A2F,\\n    0xD27607F5, 0xBA752B3D, 0x02705E65, 0x6A7372AD,\\n    0x7796C224, 0x1F95EEEC, 0xA7909BB4, 0xCF93B77C,\\n    0x3D5B83BD, 0x5558AF75, 0xED5DDA2D, 0x855EF6E5,\\n    0x98BB466C, 0xF0B86AA4, 0x48BD1FFC, 0x20BE3334,\\n    0x73767EEE, 0x1B755226, 0xA370277E, 0xCB730BB6,\\n    0xD696BB3F, 0xBE9597F7, 0x0690E2AF, 0x6E93CE67,\\n    0xA100791B, 0xC90355D3, 0x7106208B, 0x19050C43,\\n    0x04E0BCCA, 0x6CE39002, 0xD4E6E55A, 0xBCE5C992,\\n    0xEF2D8448, 0x872EA880, 0x3F2BDDD8, 0x5728F110,\\n    0x4ACD4199, 0x22CE6D51, 0x9ACB1809, 0xF2C834C1,\\n    0x7AB7077A, 0x12B42BB2, 0xAAB15EEA, 0xC2B27222,\\n    0xDF57C2AB, 0xB754EE63, 0x0F519B3B, 0x6752B7F3,\\n    0x349AFA29, 0x5C99D6E1, 0xE49CA3B9, 0x8C9F8F71,\\n    0x917A3FF8, 0xF9791330, 0x417C6668, 0x297F4AA0,\\n    0xE6ECFDDC, 0x8EEFD114, 0x36EAA44C, 0x5EE98884,\\n    0x430C380D, 0x2B0F14C5, 0x930A619D, 0xFB094D55,\\n    0xA8C1008F, 0xC0C22C47, 0x78C7591F, 0x10C475D7,\\n    0x0D21C55E, 0x6522E996, 0xDD279CCE, 0xB524B006,\\n    0x47EC84C7, 0x2FEFA80F, 0x97EADD57, 0xFFE9F19F,\\n    0xE20C4116, 0x8A0F6DDE, 0x320A1886, 0x5A09344E,\\n    0x09C17994, 0x61C2555C, 0xD9C72004, 0xB1C40CCC,\\n    0xAC21BC45, 0xC422908D, 0x7C27E5D5, 0x1424C91D,\\n    0xDBB77E61, 0xB3B452A9, 0x0BB127F1, 0x63B20B39,\\n    0x7E57BBB0, 0x16549778, 0xAE51E220, 0xC652CEE8,\\n    0x959A8332, 0xFD99AFFA, 0x459CDAA2, 0x2D9FF66A,\\n    0x307A46E3, 0x58796A2B, 0xE07C1F73, 0x887F33BB,\\n    0xF56E0EF4, 0x9D6D223C, 0x25685764, 0x4D6B7BAC,\\n    0x508ECB25, 0x388DE7ED, 0x808892B5, 0xE88BBE7D,\\n    0xBB43F3A7, 0xD340DF6F, 0x6B45AA37, 0x034686FF,\\n    0x1EA33676, 0x76A01ABE, 0xCEA56FE6, 0xA6A6432E,\\n    0x6935F452, 0x0136D89A, 0xB933ADC2, 0xD130810A,\\n    0xCCD53183, 0xA4D61D4B, 0x1CD36813, 0x74D044DB,\\n    0x27180901, 0x4F1B25C9, 0xF71E5091, 0x9F1D7C59,\\n    0x82F8CCD0, 0xEAFBE018, 0x52FE9540, 0x3AFDB988,\\n    0xC8358D49, 0xA036A181, 0x1833D4D9, 0x7030F811,\\n    0x6DD54898, 0x05D66450, 0xBDD31108, 0xD5D03DC0,\\n    0x8618701A, 0xEE1B5CD2, 0x561E298A, 0x3E1D0542,\\n    0x23F8B5CB, 0x4BFB9903, 0xF3FEEC5B, 0x9BFDC093,\\n    0x546E77EF, 0x3C6D5B27, 0x84682E7F, 0xEC6B02B7,\\n    0xF18EB23E, 0x998D9EF6, 0x2188EBAE, 0x498BC766,\\n    0x1A438ABC, 0x7240A674, 0xCA45D32C, 0xA246FFE4,\\n    0xBFA34F6D, 0xD7A063A5, 0x6FA516FD, 0x07A63A35,\\n    0x8FD9098E, 0xE7DA2546, 0x5FDF501E, 0x37DC7CD6,\\n    0x2A39CC5F, 0x423AE097, 0xFA3F95CF, 0x923CB907,\\n    0xC1F4F4DD, 0xA9F7D815, 0x11F2AD4D, 0x79F18185,\\n    0x6414310C, 0x0C171DC4, 0xB412689C, 0xDC114454,\\n    0x1382F328, 0x7B81DFE0, 0xC384AAB8, 0xAB878670,\\n    0xB66236F9, 0xDE611A31, 0x66646F69, 0x0E6743A1,\\n    0x5DAF0E7B, 0x35AC22B3, 0x8DA957EB, 0xE5AA7B23,\\n    0xF84FCBAA, 0x904CE762, 0x2849923A, 0x404ABEF2,\\n    0xB2828A33, 0xDA81A6FB, 0x6284D3A3, 0x0A87FF6B,\\n    0x17624FE2, 0x7F61632A, 0xC7641672, 0xAF673ABA,\\n    0xFCAF7760, 0x94AC5BA8, 0x2CA92EF0, 0x44AA0238,\\n    0x594FB2B1, 0x314C9E79, 0x8949EB21, 0xE14AC7E9,\\n    0x2ED97095, 0x46DA5C5D, 0xFEDF2905, 0x96DC05CD,\\n    0x8B39B544, 0xE33A998C, 0x5B3FECD4, 0x333CC01C,\\n    0x60F48DC6, 0x08F7A10E, 0xB0F2D456, 0xD8F1F89E,\\n    0xC5144817, 0xAD1764DF, 0x15121187, 0x7D113D4F,\\n    /* T8_7 */\\n    0x00000000, 0x493C7D27, 0x9278FA4E, 0xDB448769,\\n    0x211D826D, 0x6821FF4A, 0xB3657823, 0xFA590504,\\n    0x423B04DA, 0x0B0779FD, 0xD043FE94, 0x997F83B3,\\n    0x632686B7, 0x2A1AFB90, 0xF15E7CF9, 0xB86201DE,\\n    0x847609B4, 0xCD4A7493, 0x160EF3FA, 0x5F328EDD,\\n    0xA56B8BD9, 0xEC57F6FE, 0x37137197, 0x7E2F0CB0,\\n    0xC64D0D6E, 0x8F717049, 0x5435F720, 0x1D098A07,\\n    0xE7508F03, 0xAE6CF224, 0x7528754D, 0x3C14086A,\\n    0x0D006599, 0x443C18BE, 0x9F789FD7, 0xD644E2F0,\\n    0x2C1DE7F4, 0x65219AD3, 0xBE651DBA, 0xF759609D,\\n    0x4F3B6143, 0x06071C64, 0xDD439B0D, 0x947FE62A,\\n    0x6E26E32E, 0x271A9E09, 0xFC5E1960, 0xB5626447,\\n    0x89766C2D, 0xC04A110A, 0x1B0E9663, 0x5232EB44,\\n    0xA86BEE40, 0xE1579367, 0x3A13140E, 0x732F6929,\\n    0xCB4D68F7, 0x827115D0, 0x593592B9, 0x1009EF9E,\\n    0xEA50EA9A, 0xA36C97BD, 0x782810D4, 0x31146DF3,\\n    0x1A00CB32, 0x533CB615, 0x8878317C, 0xC1444C5B,\\n    0x3B1D495F, 0x72213478, 0xA965B311, 0xE059CE36,\\n    0x583BCFE8, 0x1107B2CF, 0xCA4335A6, 0x837F4881,\\n    0x79264D85, 0x301A30A2, 0xEB5EB7CB, 0xA262CAEC,\\n    0x9E76C286, 0xD74ABFA1, 0x0C0E38C8, 0x453245EF,\\n    0xBF6B40EB, 0xF6573DCC, 0x2D13BAA5, 0x642FC782,\\n    0xDC4DC65C, 0x9571BB7B, 0x4E353C12, 0x07094135,\\n    0xFD504431, 0xB46C3916, 0x6F28BE7F, 0x2614C358,\\n    0x1700AEAB, 0x5E3CD38C, 0x857854E5, 0xCC4429C2,\\n    0x361D2CC6, 0x7F2151E1, 0xA465D688, 0xED59ABAF,\\n    0x553BAA71, 0x1C07D756, 0xC743503F, 0x8E7F2D18,\\n    0x7426281C, 0x3D1A553B, 0xE65ED252, 0xAF62AF75,\\n    0x9376A71F, 0xDA4ADA38, 0x010E5D51, 0x48322076,\\n    0xB26B2572, 0xFB575855, 0x2013DF3C, 0x692FA21B,\\n    0xD14DA3C5, 0x9871DEE2, 0x4335598B, 0x0A0924AC,\\n    0xF05021A8, 0xB96C5C8F, 0x6228DBE6, 0x2B14A6C1,\\n    0x34019664, 0x7D3DEB43, 0xA6796C2A, 0xEF45110D,\\n    0x151C1409, 0x5C20692E, 0x8764EE47, 0xCE589360,\\n    0x763A92BE, 0x3F06EF99, 0xE44268F0, 0xAD7E15D7,\\n    0x572710D3, 0x1E1B6DF4, 0xC55FEA9D, 0x8C6397BA,\\n    0xB0779FD0, 0xF94BE2F7, 0x220F659E, 0x6B3318B9,\\n    0x916A1DBD, 0xD856609A, 0x0312E7F3, 0x4A2E9AD4,\\n    0xF24C9B0A, 0xBB70E62D, 0x60346144, 0x29081C63,\\n    0xD3511967, 0x9A6D6440, 0x4129E329, 0x08159E0E,\\n    0x3901F3FD, 0x703D8EDA, 0xAB7909B3, 0xE2457494,\\n    0x181C7190, 0x51200CB7, 0x8A648BDE, 0xC358F6F9,\\n    0x7B3AF727, 0x32068A00, 0xE9420D69, 0xA07E704E,\\n    0x5A27754A, 0x131B086D, 0xC85F8F04, 0x8163F223,\\n    0xBD77FA49, 0xF44B876E, 0x2F0F0007, 0x66337D20,\\n    0x9C6A7824, 0xD5560503, 0x0E12826A, 0x472EFF4D,\\n    0xFF4CFE93, 0xB67083B4, 0x6D3404DD, 0x240879FA,\\n    0xDE517CFE, 0x976D01D9, 0x4C2986B0, 0x0515FB97,\\n    0x2E015D56, 0x673D2071, 0xBC79A718, 0xF545DA3F,\\n    0x0F1CDF3B, 0x4620A21C, 0x9D642575, 0xD4585852,\\n    0x6C3A598C, 0x250624AB, 0xFE42A3C2, 0xB77EDEE5,\\n    0x4D27DBE1, 0x041BA6C6, 0xDF5F21AF, 0x96635C88,\\n    0xAA7754E2, 0xE34B29C5, 0x380FAEAC, 0x7133D38B,\\n    0x8B6AD68F, 0xC256ABA8, 0x19122CC1, 0x502E51E6,\\n    0xE84C5038, 0xA1702D1F, 0x7A34AA76, 0x3308D751,\\n    0xC951D255, 0x806DAF72, 0x5B29281B, 0x1215553C,\\n    0x230138CF, 0x6A3D45E8, 0xB179C281, 0xF845BFA6,\\n    0x021CBAA2, 0x4B20C785, 0x906440EC, 0xD9583DCB,\\n    0x613A3C15, 0x28064132, 0xF342C65B, 0xBA7EBB7C,\\n    0x4027BE78, 0x091BC35F, 0xD25F4436, 0x9B633911,\\n    0xA777317B, 0xEE4B4C5C, 0x350FCB35, 0x7C33B612,\\n    0x866AB316, 0xCF56CE31, 0x14124958, 0x5D2E347F,\\n    0xE54C35A1, 0xAC704886, 0x7734CFEF, 0x3E08B2C8,\\n    0xC451B7CC, 0x8D6DCAEB, 0x56294D82, 0x1F1530A5\\n  };\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"PureJavaCrc32C\", \"position\": {\"start_line\": 38, \"end_line\": 640, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class PureJavaCrc32C implements Checksum {\\n\\n  /** the current CRC value, bit-flipped */\\n  private int crc;\\n\\n  /** Create a new PureJavaCrc32 object. */\\n  public PureJavaCrc32C() {\\n    reset();\\n  }\\n\\n  @Override\\n  public long getValue() {\\n    final long ret = crc;\\n    return (~ret) & 0xffffffffL;\\n  }\\n\\n  @Override\\n  public void reset() {\\n    crc = 0xffffffff;\\n  }\\n\\n  @Override\\n  public void update(final byte[] b, int off, int len) {\\n    int localCrc = crc;\\n\\n    while(len > 7) {\\n      final int c0 =(b[off+0] ^ localCrc) & 0xff;\\n      final int c1 =(b[off+1] ^ (localCrc >>>= 8)) & 0xff;\\n      final int c2 =(b[off+2] ^ (localCrc >>>= 8)) & 0xff;\\n      final int c3 =(b[off+3] ^ (localCrc >>>= 8)) & 0xff;\\n      localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^\\n                 (T[T8_5_start + c2] ^ T[T8_4_start + c3]);\\n\\n      final int c4 = b[off+4] & 0xff;\\n      final int c5 = b[off+5] & 0xff;\\n      final int c6 = b[off+6] & 0xff;\\n      final int c7 = b[off+7] & 0xff;\\n\\n      localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^\\n                  (T[T8_1_start + c6] ^ T[T8_0_start + c7]);\\n\\n      off += 8;\\n      len -= 8;\\n    }\\n\\n    /* loop unroll - duff's device style */\\n    switch(len) {\\n      case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 5: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 4: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 3: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 2: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 1: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      default:\\n        break; // satisfy Findbugs\\n    }\\n\\n    // Publish crc out to object\\n    crc = localCrc;\\n  }\\n\\n  @Override\\n  final public void update(final int b) {\\n    crc = (crc >>> 8) ^ T[T8_0_start + ((crc ^ b) & 0xff)];\\n  }\\n\\n  // CRC polynomial tables generated by:\\n  // java -cp build/test/classes/:build/classes/ \\\\\\n  //   org.apache.hadoop.util.TestPureJavaCrc32\\\\$Table 82F63B78\\n\\n  private static final int T8_0_start = 0*256;\\n  private static final int T8_1_start = 1*256;\\n  private static final int T8_2_start = 2*256;\\n  private static final int T8_3_start = 3*256;\\n  private static final int T8_4_start = 4*256;\\n  private static final int T8_5_start = 5*256;\\n  private static final int T8_6_start = 6*256;\\n  private static final int T8_7_start = 7*256;\\n\\n  private static final int[] T = new int[] {\\n    /* T8_0 */\\n    0x00000000, 0xF26B8303, 0xE13B70F7, 0x1350F3F4,\\n    0xC79A971F, 0x35F1141C, 0x26A1E7E8, 0xD4CA64EB,\\n    0x8AD958CF, 0x78B2DBCC, 0x6BE22838, 0x9989AB3B,\\n    0x4D43CFD0, 0xBF284CD3, 0xAC78BF27, 0x5E133C24,\\n    0x105EC76F, 0xE235446C, 0xF165B798, 0x030E349B,\\n    0xD7C45070, 0x25AFD373, 0x36FF2087, 0xC494A384,\\n    0x9A879FA0, 0x68EC1CA3, 0x7BBCEF57, 0x89D76C54,\\n    0x5D1D08BF, 0xAF768BBC, 0xBC267848, 0x4E4DFB4B,\\n    0x20BD8EDE, 0xD2D60DDD, 0xC186FE29, 0x33ED7D2A,\\n    0xE72719C1, 0x154C9AC2, 0x061C6936, 0xF477EA35,\\n    0xAA64D611, 0x580F5512, 0x4B5FA6E6, 0xB93425E5,\\n    0x6DFE410E, 0x9F95C20D, 0x8CC531F9, 0x7EAEB2FA,\\n    0x30E349B1, 0xC288CAB2, 0xD1D83946, 0x23B3BA45,\\n    0xF779DEAE, 0x05125DAD, 0x1642AE59, 0xE4292D5A,\\n    0xBA3A117E, 0x4851927D, 0x5B016189, 0xA96AE28A,\\n    0x7DA08661, 0x8FCB0562, 0x9C9BF696, 0x6EF07595,\\n    0x417B1DBC, 0xB3109EBF, 0xA0406D4B, 0x522BEE48,\\n    0x86E18AA3, 0x748A09A0, 0x67DAFA54, 0x95B17957,\\n    0xCBA24573, 0x39C9C670, 0x2A993584, 0xD8F2B687,\\n    0x0C38D26C, 0xFE53516F, 0xED03A29B, 0x1F682198,\\n    0x5125DAD3, 0xA34E59D0, 0xB01EAA24, 0x42752927,\\n    0x96BF4DCC, 0x64D4CECF, 0x77843D3B, 0x85EFBE38,\\n    0xDBFC821C, 0x2997011F, 0x3AC7F2EB, 0xC8AC71E8,\\n    0x1C661503, 0xEE0D9600, 0xFD5D65F4, 0x0F36E6F7,\\n    0x61C69362, 0x93AD1061, 0x80FDE395, 0x72966096,\\n    0xA65C047D, 0x5437877E, 0x4767748A, 0xB50CF789,\\n    0xEB1FCBAD, 0x197448AE, 0x0A24BB5A, 0xF84F3859,\\n    0x2C855CB2, 0xDEEEDFB1, 0xCDBE2C45, 0x3FD5AF46,\\n    0x7198540D, 0x83F3D70E, 0x90A324FA, 0x62C8A7F9,\\n    0xB602C312, 0x44694011, 0x5739B3E5, 0xA55230E6,\\n    0xFB410CC2, 0x092A8FC1, 0x1A7A7C35, 0xE811FF36,\\n    0x3CDB9BDD, 0xCEB018DE, 0xDDE0EB2A, 0x2F8B6829,\\n    0x82F63B78, 0x709DB87B, 0x63CD4B8F, 0x91A6C88C,\\n    0x456CAC67, 0xB7072F64, 0xA457DC90, 0x563C5F93,\\n    0x082F63B7, 0xFA44E0B4, 0xE9141340, 0x1B7F9043,\\n    0xCFB5F4A8, 0x3DDE77AB, 0x2E8E845F, 0xDCE5075C,\\n    0x92A8FC17, 0x60C37F14, 0x73938CE0, 0x81F80FE3,\\n    0x55326B08, 0xA759E80B, 0xB4091BFF, 0x466298FC,\\n    0x1871A4D8, 0xEA1A27DB, 0xF94AD42F, 0x0B21572C,\\n    0xDFEB33C7, 0x2D80B0C4, 0x3ED04330, 0xCCBBC033,\\n    0xA24BB5A6, 0x502036A5, 0x4370C551, 0xB11B4652,\\n    0x65D122B9, 0x97BAA1BA, 0x84EA524E, 0x7681D14D,\\n    0x2892ED69, 0xDAF96E6A, 0xC9A99D9E, 0x3BC21E9D,\\n    0xEF087A76, 0x1D63F975, 0x0E330A81, 0xFC588982,\\n    0xB21572C9, 0x407EF1CA, 0x532E023E, 0xA145813D,\\n    0x758FE5D6, 0x87E466D5, 0x94B49521, 0x66DF1622,\\n    0x38CC2A06, 0xCAA7A905, 0xD9F75AF1, 0x2B9CD9F2,\\n    0xFF56BD19, 0x0D3D3E1A, 0x1E6DCDEE, 0xEC064EED,\\n    0xC38D26C4, 0x31E6A5C7, 0x22B65633, 0xD0DDD530,\\n    0x0417B1DB, 0xF67C32D8, 0xE52CC12C, 0x1747422F,\\n    0x49547E0B, 0xBB3FFD08, 0xA86F0EFC, 0x5A048DFF,\\n    0x8ECEE914, 0x7CA56A17, 0x6FF599E3, 0x9D9E1AE0,\\n    0xD3D3E1AB, 0x21B862A8, 0x32E8915C, 0xC083125F,\\n    0x144976B4, 0xE622F5B7, 0xF5720643, 0x07198540,\\n    0x590AB964, 0xAB613A67, 0xB831C993, 0x4A5A4A90,\\n    0x9E902E7B, 0x6CFBAD78, 0x7FAB5E8C, 0x8DC0DD8F,\\n    0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE,\\n    0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,\\n    0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321,\\n    0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,\\n    0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81,\\n    0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,\\n    0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E,\\n    0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351,\\n    /* T8_1 */\\n    0x00000000, 0x13A29877, 0x274530EE, 0x34E7A899,\\n    0x4E8A61DC, 0x5D28F9AB, 0x69CF5132, 0x7A6DC945,\\n    0x9D14C3B8, 0x8EB65BCF, 0xBA51F356, 0xA9F36B21,\\n    0xD39EA264, 0xC03C3A13, 0xF4DB928A, 0xE7790AFD,\\n    0x3FC5F181, 0x2C6769F6, 0x1880C16F, 0x0B225918,\\n    0x714F905D, 0x62ED082A, 0x560AA0B3, 0x45A838C4,\\n    0xA2D13239, 0xB173AA4E, 0x859402D7, 0x96369AA0,\\n    0xEC5B53E5, 0xFFF9CB92, 0xCB1E630B, 0xD8BCFB7C,\\n    0x7F8BE302, 0x6C297B75, 0x58CED3EC, 0x4B6C4B9B,\\n    0x310182DE, 0x22A31AA9, 0x1644B230, 0x05E62A47,\\n    0xE29F20BA, 0xF13DB8CD, 0xC5DA1054, 0xD6788823,\\n    0xAC154166, 0xBFB7D911, 0x8B507188, 0x98F2E9FF,\\n    0x404E1283, 0x53EC8AF4, 0x670B226D, 0x74A9BA1A,\\n    0x0EC4735F, 0x1D66EB28, 0x298143B1, 0x3A23DBC6,\\n    0xDD5AD13B, 0xCEF8494C, 0xFA1FE1D5, 0xE9BD79A2,\\n    0x93D0B0E7, 0x80722890, 0xB4958009, 0xA737187E,\\n    0xFF17C604, 0xECB55E73, 0xD852F6EA, 0xCBF06E9D,\\n    0xB19DA7D8, 0xA23F3FAF, 0x96D89736, 0x857A0F41,\\n    0x620305BC, 0x71A19DCB, 0x45463552, 0x56E4AD25,\\n    0x2C896460, 0x3F2BFC17, 0x0BCC548E, 0x186ECCF9,\\n    0xC0D23785, 0xD370AFF2, 0xE797076B, 0xF4359F1C,\\n    0x8E585659, 0x9DFACE2E, 0xA91D66B7, 0xBABFFEC0,\\n    0x5DC6F43D, 0x4E646C4A, 0x7A83C4D3, 0x69215CA4,\\n    0x134C95E1, 0x00EE0D96, 0x3409A50F, 0x27AB3D78,\\n    0x809C2506, 0x933EBD71, 0xA7D915E8, 0xB47B8D9F,\\n    0xCE1644DA, 0xDDB4DCAD, 0xE9537434, 0xFAF1EC43,\\n    0x1D88E6BE, 0x0E2A7EC9, 0x3ACDD650, 0x296F4E27,\\n    0x53028762, 0x40A01F15, 0x7447B78C, 0x67E52FFB,\\n    0xBF59D487, 0xACFB4CF0, 0x981CE469, 0x8BBE7C1E,\\n    0xF1D3B55B, 0xE2712D2C, 0xD69685B5, 0xC5341DC2,\\n    0x224D173F, 0x31EF8F48, 0x050827D1, 0x16AABFA6,\\n    0x6CC776E3, 0x7F65EE94, 0x4B82460D, 0x5820DE7A,\\n    0xFBC3FAF9, 0xE861628E, 0xDC86CA17, 0xCF245260,\\n    0xB5499B25, 0xA6EB0352, 0x920CABCB, 0x81AE33BC,\\n    0x66D73941, 0x7575A136, 0x419209AF, 0x523091D8,\\n    0x285D589D, 0x3BFFC0EA, 0x0F186873, 0x1CBAF004,\\n    0xC4060B78, 0xD7A4930F, 0xE3433B96, 0xF0E1A3E1,\\n    0x8A8C6AA4, 0x992EF2D3, 0xADC95A4A, 0xBE6BC23D,\\n    0x5912C8C0, 0x4AB050B7, 0x7E57F82E, 0x6DF56059,\\n    0x1798A91C, 0x043A316B, 0x30DD99F2, 0x237F0185,\\n    0x844819FB, 0x97EA818C, 0xA30D2915, 0xB0AFB162,\\n    0xCAC27827, 0xD960E050, 0xED8748C9, 0xFE25D0BE,\\n    0x195CDA43, 0x0AFE4234, 0x3E19EAAD, 0x2DBB72DA,\\n    0x57D6BB9F, 0x447423E8, 0x70938B71, 0x63311306,\\n    0xBB8DE87A, 0xA82F700D, 0x9CC8D894, 0x8F6A40E3,\\n    0xF50789A6, 0xE6A511D1, 0xD242B948, 0xC1E0213F,\\n    0x26992BC2, 0x353BB3B5, 0x01DC1B2C, 0x127E835B,\\n    0x68134A1E, 0x7BB1D269, 0x4F567AF0, 0x5CF4E287,\\n    0x04D43CFD, 0x1776A48A, 0x23910C13, 0x30339464,\\n    0x4A5E5D21, 0x59FCC556, 0x6D1B6DCF, 0x7EB9F5B8,\\n    0x99C0FF45, 0x8A626732, 0xBE85CFAB, 0xAD2757DC,\\n    0xD74A9E99, 0xC4E806EE, 0xF00FAE77, 0xE3AD3600,\\n    0x3B11CD7C, 0x28B3550B, 0x1C54FD92, 0x0FF665E5,\\n    0x759BACA0, 0x663934D7, 0x52DE9C4E, 0x417C0439,\\n    0xA6050EC4, 0xB5A796B3, 0x81403E2A, 0x92E2A65D,\\n    0xE88F6F18, 0xFB2DF76F, 0xCFCA5FF6, 0xDC68C781,\\n    0x7B5FDFFF, 0x68FD4788, 0x5C1AEF11, 0x4FB87766,\\n    0x35D5BE23, 0x26772654, 0x12908ECD, 0x013216BA,\\n    0xE64B1C47, 0xF5E98430, 0xC10E2CA9, 0xD2ACB4DE,\\n    0xA8C17D9B, 0xBB63E5EC, 0x8F844D75, 0x9C26D502,\\n    0x449A2E7E, 0x5738B609, 0x63DF1E90, 0x707D86E7,\\n    0x0A104FA2, 0x19B2D7D5, 0x2D557F4C, 0x3EF7E73B,\\n    0xD98EEDC6, 0xCA2C75B1, 0xFECBDD28, 0xED69455F,\\n    0x97048C1A, 0x84A6146D, 0xB041BCF4, 0xA3E32483,\\n    /* T8_2 */\\n    0x00000000, 0xA541927E, 0x4F6F520D, 0xEA2EC073,\\n    0x9EDEA41A, 0x3B9F3664, 0xD1B1F617, 0x74F06469,\\n    0x38513EC5, 0x9D10ACBB, 0x773E6CC8, 0xD27FFEB6,\\n    0xA68F9ADF, 0x03CE08A1, 0xE9E0C8D2, 0x4CA15AAC,\\n    0x70A27D8A, 0xD5E3EFF4, 0x3FCD2F87, 0x9A8CBDF9,\\n    0xEE7CD990, 0x4B3D4BEE, 0xA1138B9D, 0x045219E3,\\n    0x48F3434F, 0xEDB2D131, 0x079C1142, 0xA2DD833C,\\n    0xD62DE755, 0x736C752B, 0x9942B558, 0x3C032726,\\n    0xE144FB14, 0x4405696A, 0xAE2BA919, 0x0B6A3B67,\\n    0x7F9A5F0E, 0xDADBCD70, 0x30F50D03, 0x95B49F7D,\\n    0xD915C5D1, 0x7C5457AF, 0x967A97DC, 0x333B05A2,\\n    0x47CB61CB, 0xE28AF3B5, 0x08A433C6, 0xADE5A1B8,\\n    0x91E6869E, 0x34A714E0, 0xDE89D493, 0x7BC846ED,\\n    0x0F382284, 0xAA79B0FA, 0x40577089, 0xE516E2F7,\\n    0xA9B7B85B, 0x0CF62A25, 0xE6D8EA56, 0x43997828,\\n    0x37691C41, 0x92288E3F, 0x78064E4C, 0xDD47DC32,\\n    0xC76580D9, 0x622412A7, 0x880AD2D4, 0x2D4B40AA,\\n    0x59BB24C3, 0xFCFAB6BD, 0x16D476CE, 0xB395E4B0,\\n    0xFF34BE1C, 0x5A752C62, 0xB05BEC11, 0x151A7E6F,\\n    0x61EA1A06, 0xC4AB8878, 0x2E85480B, 0x8BC4DA75,\\n    0xB7C7FD53, 0x12866F2D, 0xF8A8AF5E, 0x5DE93D20,\\n    0x29195949, 0x8C58CB37, 0x66760B44, 0xC337993A,\\n    0x8F96C396, 0x2AD751E8, 0xC0F9919B, 0x65B803E5,\\n    0x1148678C, 0xB409F5F2, 0x5E273581, 0xFB66A7FF,\\n    0x26217BCD, 0x8360E9B3, 0x694E29C0, 0xCC0FBBBE,\\n    0xB8FFDFD7, 0x1DBE4DA9, 0xF7908DDA, 0x52D11FA4,\\n    0x1E704508, 0xBB31D776, 0x511F1705, 0xF45E857B,\\n    0x80AEE112, 0x25EF736C, 0xCFC1B31F, 0x6A802161,\\n    0x56830647, 0xF3C29439, 0x19EC544A, 0xBCADC634,\\n    0xC85DA25D, 0x6D1C3023, 0x8732F050, 0x2273622E,\\n    0x6ED23882, 0xCB93AAFC, 0x21BD6A8F, 0x84FCF8F1,\\n    0xF00C9C98, 0x554D0EE6, 0xBF63CE95, 0x1A225CEB,\\n    0x8B277743, 0x2E66E53D, 0xC448254E, 0x6109B730,\\n    0x15F9D359, 0xB0B84127, 0x5A968154, 0xFFD7132A,\\n    0xB3764986, 0x1637DBF8, 0xFC191B8B, 0x595889F5,\\n    0x2DA8ED9C, 0x88E97FE2, 0x62C7BF91, 0xC7862DEF,\\n    0xFB850AC9, 0x5EC498B7, 0xB4EA58C4, 0x11ABCABA,\\n    0x655BAED3, 0xC01A3CAD, 0x2A34FCDE, 0x8F756EA0,\\n    0xC3D4340C, 0x6695A672, 0x8CBB6601, 0x29FAF47F,\\n    0x5D0A9016, 0xF84B0268, 0x1265C21B, 0xB7245065,\\n    0x6A638C57, 0xCF221E29, 0x250CDE5A, 0x804D4C24,\\n    0xF4BD284D, 0x51FCBA33, 0xBBD27A40, 0x1E93E83E,\\n    0x5232B292, 0xF77320EC, 0x1D5DE09F, 0xB81C72E1,\\n    0xCCEC1688, 0x69AD84F6, 0x83834485, 0x26C2D6FB,\\n    0x1AC1F1DD, 0xBF8063A3, 0x55AEA3D0, 0xF0EF31AE,\\n    0x841F55C7, 0x215EC7B9, 0xCB7007CA, 0x6E3195B4,\\n    0x2290CF18, 0x87D15D66, 0x6DFF9D15, 0xC8BE0F6B,\\n    0xBC4E6B02, 0x190FF97C, 0xF321390F, 0x5660AB71,\\n    0x4C42F79A, 0xE90365E4, 0x032DA597, 0xA66C37E9,\\n    0xD29C5380, 0x77DDC1FE, 0x9DF3018D, 0x38B293F3,\\n    0x7413C95F, 0xD1525B21, 0x3B7C9B52, 0x9E3D092C,\\n    0xEACD6D45, 0x4F8CFF3B, 0xA5A23F48, 0x00E3AD36,\\n    0x3CE08A10, 0x99A1186E, 0x738FD81D, 0xD6CE4A63,\\n    0xA23E2E0A, 0x077FBC74, 0xED517C07, 0x4810EE79,\\n    0x04B1B4D5, 0xA1F026AB, 0x4BDEE6D8, 0xEE9F74A6,\\n    0x9A6F10CF, 0x3F2E82B1, 0xD50042C2, 0x7041D0BC,\\n    0xAD060C8E, 0x08479EF0, 0xE2695E83, 0x4728CCFD,\\n    0x33D8A894, 0x96993AEA, 0x7CB7FA99, 0xD9F668E7,\\n    0x9557324B, 0x3016A035, 0xDA386046, 0x7F79F238,\\n    0x0B899651, 0xAEC8042F, 0x44E6C45C, 0xE1A75622,\\n    0xDDA47104, 0x78E5E37A, 0x92CB2309, 0x378AB177,\\n    0x437AD51E, 0xE63B4760, 0x0C158713, 0xA954156D,\\n    0xE5F54FC1, 0x40B4DDBF, 0xAA9A1DCC, 0x0FDB8FB2,\\n    0x7B2BEBDB, 0xDE6A79A5, 0x3444B9D6, 0x91052BA8,\\n    /* T8_3 */\\n    0x00000000, 0xDD45AAB8, 0xBF672381, 0x62228939,\\n    0x7B2231F3, 0xA6679B4B, 0xC4451272, 0x1900B8CA,\\n    0xF64463E6, 0x2B01C95E, 0x49234067, 0x9466EADF,\\n    0x8D665215, 0x5023F8AD, 0x32017194, 0xEF44DB2C,\\n    0xE964B13D, 0x34211B85, 0x560392BC, 0x8B463804,\\n    0x924680CE, 0x4F032A76, 0x2D21A34F, 0xF06409F7,\\n    0x1F20D2DB, 0xC2657863, 0xA047F15A, 0x7D025BE2,\\n    0x6402E328, 0xB9474990, 0xDB65C0A9, 0x06206A11,\\n    0xD725148B, 0x0A60BE33, 0x6842370A, 0xB5079DB2,\\n    0xAC072578, 0x71428FC0, 0x136006F9, 0xCE25AC41,\\n    0x2161776D, 0xFC24DDD5, 0x9E0654EC, 0x4343FE54,\\n    0x5A43469E, 0x8706EC26, 0xE524651F, 0x3861CFA7,\\n    0x3E41A5B6, 0xE3040F0E, 0x81268637, 0x5C632C8F,\\n    0x45639445, 0x98263EFD, 0xFA04B7C4, 0x27411D7C,\\n    0xC805C650, 0x15406CE8, 0x7762E5D1, 0xAA274F69,\\n    0xB327F7A3, 0x6E625D1B, 0x0C40D422, 0xD1057E9A,\\n    0xABA65FE7, 0x76E3F55F, 0x14C17C66, 0xC984D6DE,\\n    0xD0846E14, 0x0DC1C4AC, 0x6FE34D95, 0xB2A6E72D,\\n    0x5DE23C01, 0x80A796B9, 0xE2851F80, 0x3FC0B538,\\n    0x26C00DF2, 0xFB85A74A, 0x99A72E73, 0x44E284CB,\\n    0x42C2EEDA, 0x9F874462, 0xFDA5CD5B, 0x20E067E3,\\n    0x39E0DF29, 0xE4A57591, 0x8687FCA8, 0x5BC25610,\\n    0xB4868D3C, 0x69C32784, 0x0BE1AEBD, 0xD6A40405,\\n    0xCFA4BCCF, 0x12E11677, 0x70C39F4E, 0xAD8635F6,\\n    0x7C834B6C, 0xA1C6E1D4, 0xC3E468ED, 0x1EA1C255,\\n    0x07A17A9F, 0xDAE4D027, 0xB8C6591E, 0x6583F3A6,\\n    0x8AC7288A, 0x57828232, 0x35A00B0B, 0xE8E5A1B3,\\n    0xF1E51979, 0x2CA0B3C1, 0x4E823AF8, 0x93C79040,\\n    0x95E7FA51, 0x48A250E9, 0x2A80D9D0, 0xF7C57368,\\n    0xEEC5CBA2, 0x3380611A, 0x51A2E823, 0x8CE7429B,\\n    0x63A399B7, 0xBEE6330F, 0xDCC4BA36, 0x0181108E,\\n    0x1881A844, 0xC5C402FC, 0xA7E68BC5, 0x7AA3217D,\\n    0x52A0C93F, 0x8FE56387, 0xEDC7EABE, 0x30824006,\\n    0x2982F8CC, 0xF4C75274, 0x96E5DB4D, 0x4BA071F5,\\n    0xA4E4AAD9, 0x79A10061, 0x1B838958, 0xC6C623E0,\\n    0xDFC69B2A, 0x02833192, 0x60A1B8AB, 0xBDE41213,\\n    0xBBC47802, 0x6681D2BA, 0x04A35B83, 0xD9E6F13B,\\n    0xC0E649F1, 0x1DA3E349, 0x7F816A70, 0xA2C4C0C8,\\n    0x4D801BE4, 0x90C5B15C, 0xF2E73865, 0x2FA292DD,\\n    0x36A22A17, 0xEBE780AF, 0x89C50996, 0x5480A32E,\\n    0x8585DDB4, 0x58C0770C, 0x3AE2FE35, 0xE7A7548D,\\n    0xFEA7EC47, 0x23E246FF, 0x41C0CFC6, 0x9C85657E,\\n    0x73C1BE52, 0xAE8414EA, 0xCCA69DD3, 0x11E3376B,\\n    0x08E38FA1, 0xD5A62519, 0xB784AC20, 0x6AC10698,\\n    0x6CE16C89, 0xB1A4C631, 0xD3864F08, 0x0EC3E5B0,\\n    0x17C35D7A, 0xCA86F7C2, 0xA8A47EFB, 0x75E1D443,\\n    0x9AA50F6F, 0x47E0A5D7, 0x25C22CEE, 0xF8878656,\\n    0xE1873E9C, 0x3CC29424, 0x5EE01D1D, 0x83A5B7A5,\\n    0xF90696D8, 0x24433C60, 0x4661B559, 0x9B241FE1,\\n    0x8224A72B, 0x5F610D93, 0x3D4384AA, 0xE0062E12,\\n    0x0F42F53E, 0xD2075F86, 0xB025D6BF, 0x6D607C07,\\n    0x7460C4CD, 0xA9256E75, 0xCB07E74C, 0x16424DF4,\\n    0x106227E5, 0xCD278D5D, 0xAF050464, 0x7240AEDC,\\n    0x6B401616, 0xB605BCAE, 0xD4273597, 0x09629F2F,\\n    0xE6264403, 0x3B63EEBB, 0x59416782, 0x8404CD3A,\\n    0x9D0475F0, 0x4041DF48, 0x22635671, 0xFF26FCC9,\\n    0x2E238253, 0xF36628EB, 0x9144A1D2, 0x4C010B6A,\\n    0x5501B3A0, 0x88441918, 0xEA669021, 0x37233A99,\\n    0xD867E1B5, 0x05224B0D, 0x6700C234, 0xBA45688C,\\n    0xA345D046, 0x7E007AFE, 0x1C22F3C7, 0xC167597F,\\n    0xC747336E, 0x1A0299D6, 0x782010EF, 0xA565BA57,\\n    0xBC65029D, 0x6120A825, 0x0302211C, 0xDE478BA4,\\n    0x31035088, 0xEC46FA30, 0x8E647309, 0x5321D9B1,\\n    0x4A21617B, 0x9764CBC3, 0xF54642FA, 0x2803E842,\\n    /* T8_4 */\\n    0x00000000, 0x38116FAC, 0x7022DF58, 0x4833B0F4,\\n    0xE045BEB0, 0xD854D11C, 0x906761E8, 0xA8760E44,\\n    0xC5670B91, 0xFD76643D, 0xB545D4C9, 0x8D54BB65,\\n    0x2522B521, 0x1D33DA8D, 0x55006A79, 0x6D1105D5,\\n    0x8F2261D3, 0xB7330E7F, 0xFF00BE8B, 0xC711D127,\\n    0x6F67DF63, 0x5776B0CF, 0x1F45003B, 0x27546F97,\\n    0x4A456A42, 0x725405EE, 0x3A67B51A, 0x0276DAB6,\\n    0xAA00D4F2, 0x9211BB5E, 0xDA220BAA, 0xE2336406,\\n    0x1BA8B557, 0x23B9DAFB, 0x6B8A6A0F, 0x539B05A3,\\n    0xFBED0BE7, 0xC3FC644B, 0x8BCFD4BF, 0xB3DEBB13,\\n    0xDECFBEC6, 0xE6DED16A, 0xAEED619E, 0x96FC0E32,\\n    0x3E8A0076, 0x069B6FDA, 0x4EA8DF2E, 0x76B9B082,\\n    0x948AD484, 0xAC9BBB28, 0xE4A80BDC, 0xDCB96470,\\n    0x74CF6A34, 0x4CDE0598, 0x04EDB56C, 0x3CFCDAC0,\\n    0x51EDDF15, 0x69FCB0B9, 0x21CF004D, 0x19DE6FE1,\\n    0xB1A861A5, 0x89B90E09, 0xC18ABEFD, 0xF99BD151,\\n    0x37516AAE, 0x0F400502, 0x4773B5F6, 0x7F62DA5A,\\n    0xD714D41E, 0xEF05BBB2, 0xA7360B46, 0x9F2764EA,\\n    0xF236613F, 0xCA270E93, 0x8214BE67, 0xBA05D1CB,\\n    0x1273DF8F, 0x2A62B023, 0x625100D7, 0x5A406F7B,\\n    0xB8730B7D, 0x806264D1, 0xC851D425, 0xF040BB89,\\n    0x5836B5CD, 0x6027DA61, 0x28146A95, 0x10050539,\\n    0x7D1400EC, 0x45056F40, 0x0D36DFB4, 0x3527B018,\\n    0x9D51BE5C, 0xA540D1F0, 0xED736104, 0xD5620EA8,\\n    0x2CF9DFF9, 0x14E8B055, 0x5CDB00A1, 0x64CA6F0D,\\n    0xCCBC6149, 0xF4AD0EE5, 0xBC9EBE11, 0x848FD1BD,\\n    0xE99ED468, 0xD18FBBC4, 0x99BC0B30, 0xA1AD649C,\\n    0x09DB6AD8, 0x31CA0574, 0x79F9B580, 0x41E8DA2C,\\n    0xA3DBBE2A, 0x9BCAD186, 0xD3F96172, 0xEBE80EDE,\\n    0x439E009A, 0x7B8F6F36, 0x33BCDFC2, 0x0BADB06E,\\n    0x66BCB5BB, 0x5EADDA17, 0x169E6AE3, 0x2E8F054F,\\n    0x86F90B0B, 0xBEE864A7, 0xF6DBD453, 0xCECABBFF,\\n    0x6EA2D55C, 0x56B3BAF0, 0x1E800A04, 0x269165A8,\\n    0x8EE76BEC, 0xB6F60440, 0xFEC5B4B4, 0xC6D4DB18,\\n    0xABC5DECD, 0x93D4B161, 0xDBE70195, 0xE3F66E39,\\n    0x4B80607D, 0x73910FD1, 0x3BA2BF25, 0x03B3D089,\\n    0xE180B48F, 0xD991DB23, 0x91A26BD7, 0xA9B3047B,\\n    0x01C50A3F, 0x39D46593, 0x71E7D567, 0x49F6BACB,\\n    0x24E7BF1E, 0x1CF6D0B2, 0x54C56046, 0x6CD40FEA,\\n    0xC4A201AE, 0xFCB36E02, 0xB480DEF6, 0x8C91B15A,\\n    0x750A600B, 0x4D1B0FA7, 0x0528BF53, 0x3D39D0FF,\\n    0x954FDEBB, 0xAD5EB117, 0xE56D01E3, 0xDD7C6E4F,\\n    0xB06D6B9A, 0x887C0436, 0xC04FB4C2, 0xF85EDB6E,\\n    0x5028D52A, 0x6839BA86, 0x200A0A72, 0x181B65DE,\\n    0xFA2801D8, 0xC2396E74, 0x8A0ADE80, 0xB21BB12C,\\n    0x1A6DBF68, 0x227CD0C4, 0x6A4F6030, 0x525E0F9C,\\n    0x3F4F0A49, 0x075E65E5, 0x4F6DD511, 0x777CBABD,\\n    0xDF0AB4F9, 0xE71BDB55, 0xAF286BA1, 0x9739040D,\\n    0x59F3BFF2, 0x61E2D05E, 0x29D160AA, 0x11C00F06,\\n    0xB9B60142, 0x81A76EEE, 0xC994DE1A, 0xF185B1B6,\\n    0x9C94B463, 0xA485DBCF, 0xECB66B3B, 0xD4A70497,\\n    0x7CD10AD3, 0x44C0657F, 0x0CF3D58B, 0x34E2BA27,\\n    0xD6D1DE21, 0xEEC0B18D, 0xA6F30179, 0x9EE26ED5,\\n    0x36946091, 0x0E850F3D, 0x46B6BFC9, 0x7EA7D065,\\n    0x13B6D5B0, 0x2BA7BA1C, 0x63940AE8, 0x5B856544,\\n    0xF3F36B00, 0xCBE204AC, 0x83D1B458, 0xBBC0DBF4,\\n    0x425B0AA5, 0x7A4A6509, 0x3279D5FD, 0x0A68BA51,\\n    0xA21EB415, 0x9A0FDBB9, 0xD23C6B4D, 0xEA2D04E1,\\n    0x873C0134, 0xBF2D6E98, 0xF71EDE6C, 0xCF0FB1C0,\\n    0x6779BF84, 0x5F68D028, 0x175B60DC, 0x2F4A0F70,\\n    0xCD796B76, 0xF56804DA, 0xBD5BB42E, 0x854ADB82,\\n    0x2D3CD5C6, 0x152DBA6A, 0x5D1E0A9E, 0x650F6532,\\n    0x081E60E7, 0x300F0F4B, 0x783CBFBF, 0x402DD013,\\n    0xE85BDE57, 0xD04AB1FB, 0x9879010F, 0xA0686EA3,\\n    /* T8_5 */\\n    0x00000000, 0xEF306B19, 0xDB8CA0C3, 0x34BCCBDA,\\n    0xB2F53777, 0x5DC55C6E, 0x697997B4, 0x8649FCAD,\\n    0x6006181F, 0x8F367306, 0xBB8AB8DC, 0x54BAD3C5,\\n    0xD2F32F68, 0x3DC34471, 0x097F8FAB, 0xE64FE4B2,\\n    0xC00C303E, 0x2F3C5B27, 0x1B8090FD, 0xF4B0FBE4,\\n    0x72F90749, 0x9DC96C50, 0xA975A78A, 0x4645CC93,\\n    0xA00A2821, 0x4F3A4338, 0x7B8688E2, 0x94B6E3FB,\\n    0x12FF1F56, 0xFDCF744F, 0xC973BF95, 0x2643D48C,\\n    0x85F4168D, 0x6AC47D94, 0x5E78B64E, 0xB148DD57,\\n    0x370121FA, 0xD8314AE3, 0xEC8D8139, 0x03BDEA20,\\n    0xE5F20E92, 0x0AC2658B, 0x3E7EAE51, 0xD14EC548,\\n    0x570739E5, 0xB83752FC, 0x8C8B9926, 0x63BBF23F,\\n    0x45F826B3, 0xAAC84DAA, 0x9E748670, 0x7144ED69,\\n    0xF70D11C4, 0x183D7ADD, 0x2C81B107, 0xC3B1DA1E,\\n    0x25FE3EAC, 0xCACE55B5, 0xFE729E6F, 0x1142F576,\\n    0x970B09DB, 0x783B62C2, 0x4C87A918, 0xA3B7C201,\\n    0x0E045BEB, 0xE13430F2, 0xD588FB28, 0x3AB89031,\\n    0xBCF16C9C, 0x53C10785, 0x677DCC5F, 0x884DA746,\\n    0x6E0243F4, 0x813228ED, 0xB58EE337, 0x5ABE882E,\\n    0xDCF77483, 0x33C71F9A, 0x077BD440, 0xE84BBF59,\\n    0xCE086BD5, 0x213800CC, 0x1584CB16, 0xFAB4A00F,\\n    0x7CFD5CA2, 0x93CD37BB, 0xA771FC61, 0x48419778,\\n    0xAE0E73CA, 0x413E18D3, 0x7582D309, 0x9AB2B810,\\n    0x1CFB44BD, 0xF3CB2FA4, 0xC777E47E, 0x28478F67,\\n    0x8BF04D66, 0x64C0267F, 0x507CEDA5, 0xBF4C86BC,\\n    0x39057A11, 0xD6351108, 0xE289DAD2, 0x0DB9B1CB,\\n    0xEBF65579, 0x04C63E60, 0x307AF5BA, 0xDF4A9EA3,\\n    0x5903620E, 0xB6330917, 0x828FC2CD, 0x6DBFA9D4,\\n    0x4BFC7D58, 0xA4CC1641, 0x9070DD9B, 0x7F40B682,\\n    0xF9094A2F, 0x16392136, 0x2285EAEC, 0xCDB581F5,\\n    0x2BFA6547, 0xC4CA0E5E, 0xF076C584, 0x1F46AE9D,\\n    0x990F5230, 0x763F3929, 0x4283F2F3, 0xADB399EA,\\n    0x1C08B7D6, 0xF338DCCF, 0xC7841715, 0x28B47C0C,\\n    0xAEFD80A1, 0x41CDEBB8, 0x75712062, 0x9A414B7B,\\n    0x7C0EAFC9, 0x933EC4D0, 0xA7820F0A, 0x48B26413,\\n    0xCEFB98BE, 0x21CBF3A7, 0x1577387D, 0xFA475364,\\n    0xDC0487E8, 0x3334ECF1, 0x0788272B, 0xE8B84C32,\\n    0x6EF1B09F, 0x81C1DB86, 0xB57D105C, 0x5A4D7B45,\\n    0xBC029FF7, 0x5332F4EE, 0x678E3F34, 0x88BE542D,\\n    0x0EF7A880, 0xE1C7C399, 0xD57B0843, 0x3A4B635A,\\n    0x99FCA15B, 0x76CCCA42, 0x42700198, 0xAD406A81,\\n    0x2B09962C, 0xC439FD35, 0xF08536EF, 0x1FB55DF6,\\n    0xF9FAB944, 0x16CAD25D, 0x22761987, 0xCD46729E,\\n    0x4B0F8E33, 0xA43FE52A, 0x90832EF0, 0x7FB345E9,\\n    0x59F09165, 0xB6C0FA7C, 0x827C31A6, 0x6D4C5ABF,\\n    0xEB05A612, 0x0435CD0B, 0x308906D1, 0xDFB96DC8,\\n    0x39F6897A, 0xD6C6E263, 0xE27A29B9, 0x0D4A42A0,\\n    0x8B03BE0D, 0x6433D514, 0x508F1ECE, 0xBFBF75D7,\\n    0x120CEC3D, 0xFD3C8724, 0xC9804CFE, 0x26B027E7,\\n    0xA0F9DB4A, 0x4FC9B053, 0x7B757B89, 0x94451090,\\n    0x720AF422, 0x9D3A9F3B, 0xA98654E1, 0x46B63FF8,\\n    0xC0FFC355, 0x2FCFA84C, 0x1B736396, 0xF443088F,\\n    0xD200DC03, 0x3D30B71A, 0x098C7CC0, 0xE6BC17D9,\\n    0x60F5EB74, 0x8FC5806D, 0xBB794BB7, 0x544920AE,\\n    0xB206C41C, 0x5D36AF05, 0x698A64DF, 0x86BA0FC6,\\n    0x00F3F36B, 0xEFC39872, 0xDB7F53A8, 0x344F38B1,\\n    0x97F8FAB0, 0x78C891A9, 0x4C745A73, 0xA344316A,\\n    0x250DCDC7, 0xCA3DA6DE, 0xFE816D04, 0x11B1061D,\\n    0xF7FEE2AF, 0x18CE89B6, 0x2C72426C, 0xC3422975,\\n    0x450BD5D8, 0xAA3BBEC1, 0x9E87751B, 0x71B71E02,\\n    0x57F4CA8E, 0xB8C4A197, 0x8C786A4D, 0x63480154,\\n    0xE501FDF9, 0x0A3196E0, 0x3E8D5D3A, 0xD1BD3623,\\n    0x37F2D291, 0xD8C2B988, 0xEC7E7252, 0x034E194B,\\n    0x8507E5E6, 0x6A378EFF, 0x5E8B4525, 0xB1BB2E3C,\\n    /* T8_6 */\\n    0x00000000, 0x68032CC8, 0xD0065990, 0xB8057558,\\n    0xA5E0C5D1, 0xCDE3E919, 0x75E69C41, 0x1DE5B089,\\n    0x4E2DFD53, 0x262ED19B, 0x9E2BA4C3, 0xF628880B,\\n    0xEBCD3882, 0x83CE144A, 0x3BCB6112, 0x53C84DDA,\\n    0x9C5BFAA6, 0xF458D66E, 0x4C5DA336, 0x245E8FFE,\\n    0x39BB3F77, 0x51B813BF, 0xE9BD66E7, 0x81BE4A2F,\\n    0xD27607F5, 0xBA752B3D, 0x02705E65, 0x6A7372AD,\\n    0x7796C224, 0x1F95EEEC, 0xA7909BB4, 0xCF93B77C,\\n    0x3D5B83BD, 0x5558AF75, 0xED5DDA2D, 0x855EF6E5,\\n    0x98BB466C, 0xF0B86AA4, 0x48BD1FFC, 0x20BE3334,\\n    0x73767EEE, 0x1B755226, 0xA370277E, 0xCB730BB6,\\n    0xD696BB3F, 0xBE9597F7, 0x0690E2AF, 0x6E93CE67,\\n    0xA100791B, 0xC90355D3, 0x7106208B, 0x19050C43,\\n    0x04E0BCCA, 0x6CE39002, 0xD4E6E55A, 0xBCE5C992,\\n    0xEF2D8448, 0x872EA880, 0x3F2BDDD8, 0x5728F110,\\n    0x4ACD4199, 0x22CE6D51, 0x9ACB1809, 0xF2C834C1,\\n    0x7AB7077A, 0x12B42BB2, 0xAAB15EEA, 0xC2B27222,\\n    0xDF57C2AB, 0xB754EE63, 0x0F519B3B, 0x6752B7F3,\\n    0x349AFA29, 0x5C99D6E1, 0xE49CA3B9, 0x8C9F8F71,\\n    0x917A3FF8, 0xF9791330, 0x417C6668, 0x297F4AA0,\\n    0xE6ECFDDC, 0x8EEFD114, 0x36EAA44C, 0x5EE98884,\\n    0x430C380D, 0x2B0F14C5, 0x930A619D, 0xFB094D55,\\n    0xA8C1008F, 0xC0C22C47, 0x78C7591F, 0x10C475D7,\\n    0x0D21C55E, 0x6522E996, 0xDD279CCE, 0xB524B006,\\n    0x47EC84C7, 0x2FEFA80F, 0x97EADD57, 0xFFE9F19F,\\n    0xE20C4116, 0x8A0F6DDE, 0x320A1886, 0x5A09344E,\\n    0x09C17994, 0x61C2555C, 0xD9C72004, 0xB1C40CCC,\\n    0xAC21BC45, 0xC422908D, 0x7C27E5D5, 0x1424C91D,\\n    0xDBB77E61, 0xB3B452A9, 0x0BB127F1, 0x63B20B39,\\n    0x7E57BBB0, 0x16549778, 0xAE51E220, 0xC652CEE8,\\n    0x959A8332, 0xFD99AFFA, 0x459CDAA2, 0x2D9FF66A,\\n    0x307A46E3, 0x58796A2B, 0xE07C1F73, 0x887F33BB,\\n    0xF56E0EF4, 0x9D6D223C, 0x25685764, 0x4D6B7BAC,\\n    0x508ECB25, 0x388DE7ED, 0x808892B5, 0xE88BBE7D,\\n    0xBB43F3A7, 0xD340DF6F, 0x6B45AA37, 0x034686FF,\\n    0x1EA33676, 0x76A01ABE, 0xCEA56FE6, 0xA6A6432E,\\n    0x6935F452, 0x0136D89A, 0xB933ADC2, 0xD130810A,\\n    0xCCD53183, 0xA4D61D4B, 0x1CD36813, 0x74D044DB,\\n    0x27180901, 0x4F1B25C9, 0xF71E5091, 0x9F1D7C59,\\n    0x82F8CCD0, 0xEAFBE018, 0x52FE9540, 0x3AFDB988,\\n    0xC8358D49, 0xA036A181, 0x1833D4D9, 0x7030F811,\\n    0x6DD54898, 0x05D66450, 0xBDD31108, 0xD5D03DC0,\\n    0x8618701A, 0xEE1B5CD2, 0x561E298A, 0x3E1D0542,\\n    0x23F8B5CB, 0x4BFB9903, 0xF3FEEC5B, 0x9BFDC093,\\n    0x546E77EF, 0x3C6D5B27, 0x84682E7F, 0xEC6B02B7,\\n    0xF18EB23E, 0x998D9EF6, 0x2188EBAE, 0x498BC766,\\n    0x1A438ABC, 0x7240A674, 0xCA45D32C, 0xA246FFE4,\\n    0xBFA34F6D, 0xD7A063A5, 0x6FA516FD, 0x07A63A35,\\n    0x8FD9098E, 0xE7DA2546, 0x5FDF501E, 0x37DC7CD6,\\n    0x2A39CC5F, 0x423AE097, 0xFA3F95CF, 0x923CB907,\\n    0xC1F4F4DD, 0xA9F7D815, 0x11F2AD4D, 0x79F18185,\\n    0x6414310C, 0x0C171DC4, 0xB412689C, 0xDC114454,\\n    0x1382F328, 0x7B81DFE0, 0xC384AAB8, 0xAB878670,\\n    0xB66236F9, 0xDE611A31, 0x66646F69, 0x0E6743A1,\\n    0x5DAF0E7B, 0x35AC22B3, 0x8DA957EB, 0xE5AA7B23,\\n    0xF84FCBAA, 0x904CE762, 0x2849923A, 0x404ABEF2,\\n    0xB2828A33, 0xDA81A6FB, 0x6284D3A3, 0x0A87FF6B,\\n    0x17624FE2, 0x7F61632A, 0xC7641672, 0xAF673ABA,\\n    0xFCAF7760, 0x94AC5BA8, 0x2CA92EF0, 0x44AA0238,\\n    0x594FB2B1, 0x314C9E79, 0x8949EB21, 0xE14AC7E9,\\n    0x2ED97095, 0x46DA5C5D, 0xFEDF2905, 0x96DC05CD,\\n    0x8B39B544, 0xE33A998C, 0x5B3FECD4, 0x333CC01C,\\n    0x60F48DC6, 0x08F7A10E, 0xB0F2D456, 0xD8F1F89E,\\n    0xC5144817, 0xAD1764DF, 0x15121187, 0x7D113D4F,\\n    /* T8_7 */\\n    0x00000000, 0x493C7D27, 0x9278FA4E, 0xDB448769,\\n    0x211D826D, 0x6821FF4A, 0xB3657823, 0xFA590504,\\n    0x423B04DA, 0x0B0779FD, 0xD043FE94, 0x997F83B3,\\n    0x632686B7, 0x2A1AFB90, 0xF15E7CF9, 0xB86201DE,\\n    0x847609B4, 0xCD4A7493, 0x160EF3FA, 0x5F328EDD,\\n    0xA56B8BD9, 0xEC57F6FE, 0x37137197, 0x7E2F0CB0,\\n    0xC64D0D6E, 0x8F717049, 0x5435F720, 0x1D098A07,\\n    0xE7508F03, 0xAE6CF224, 0x7528754D, 0x3C14086A,\\n    0x0D006599, 0x443C18BE, 0x9F789FD7, 0xD644E2F0,\\n    0x2C1DE7F4, 0x65219AD3, 0xBE651DBA, 0xF759609D,\\n    0x4F3B6143, 0x06071C64, 0xDD439B0D, 0x947FE62A,\\n    0x6E26E32E, 0x271A9E09, 0xFC5E1960, 0xB5626447,\\n    0x89766C2D, 0xC04A110A, 0x1B0E9663, 0x5232EB44,\\n    0xA86BEE40, 0xE1579367, 0x3A13140E, 0x732F6929,\\n    0xCB4D68F7, 0x827115D0, 0x593592B9, 0x1009EF9E,\\n    0xEA50EA9A, 0xA36C97BD, 0x782810D4, 0x31146DF3,\\n    0x1A00CB32, 0x533CB615, 0x8878317C, 0xC1444C5B,\\n    0x3B1D495F, 0x72213478, 0xA965B311, 0xE059CE36,\\n    0x583BCFE8, 0x1107B2CF, 0xCA4335A6, 0x837F4881,\\n    0x79264D85, 0x301A30A2, 0xEB5EB7CB, 0xA262CAEC,\\n    0x9E76C286, 0xD74ABFA1, 0x0C0E38C8, 0x453245EF,\\n    0xBF6B40EB, 0xF6573DCC, 0x2D13BAA5, 0x642FC782,\\n    0xDC4DC65C, 0x9571BB7B, 0x4E353C12, 0x07094135,\\n    0xFD504431, 0xB46C3916, 0x6F28BE7F, 0x2614C358,\\n    0x1700AEAB, 0x5E3CD38C, 0x857854E5, 0xCC4429C2,\\n    0x361D2CC6, 0x7F2151E1, 0xA465D688, 0xED59ABAF,\\n    0x553BAA71, 0x1C07D756, 0xC743503F, 0x8E7F2D18,\\n    0x7426281C, 0x3D1A553B, 0xE65ED252, 0xAF62AF75,\\n    0x9376A71F, 0xDA4ADA38, 0x010E5D51, 0x48322076,\\n    0xB26B2572, 0xFB575855, 0x2013DF3C, 0x692FA21B,\\n    0xD14DA3C5, 0x9871DEE2, 0x4335598B, 0x0A0924AC,\\n    0xF05021A8, 0xB96C5C8F, 0x6228DBE6, 0x2B14A6C1,\\n    0x34019664, 0x7D3DEB43, 0xA6796C2A, 0xEF45110D,\\n    0x151C1409, 0x5C20692E, 0x8764EE47, 0xCE589360,\\n    0x763A92BE, 0x3F06EF99, 0xE44268F0, 0xAD7E15D7,\\n    0x572710D3, 0x1E1B6DF4, 0xC55FEA9D, 0x8C6397BA,\\n    0xB0779FD0, 0xF94BE2F7, 0x220F659E, 0x6B3318B9,\\n    0x916A1DBD, 0xD856609A, 0x0312E7F3, 0x4A2E9AD4,\\n    0xF24C9B0A, 0xBB70E62D, 0x60346144, 0x29081C63,\\n    0xD3511967, 0x9A6D6440, 0x4129E329, 0x08159E0E,\\n    0x3901F3FD, 0x703D8EDA, 0xAB7909B3, 0xE2457494,\\n    0x181C7190, 0x51200CB7, 0x8A648BDE, 0xC358F6F9,\\n    0x7B3AF727, 0x32068A00, 0xE9420D69, 0xA07E704E,\\n    0x5A27754A, 0x131B086D, 0xC85F8F04, 0x8163F223,\\n    0xBD77FA49, 0xF44B876E, 0x2F0F0007, 0x66337D20,\\n    0x9C6A7824, 0xD5560503, 0x0E12826A, 0x472EFF4D,\\n    0xFF4CFE93, 0xB67083B4, 0x6D3404DD, 0x240879FA,\\n    0xDE517CFE, 0x976D01D9, 0x4C2986B0, 0x0515FB97,\\n    0x2E015D56, 0x673D2071, 0xBC79A718, 0xF545DA3F,\\n    0x0F1CDF3B, 0x4620A21C, 0x9D642575, 0xD4585852,\\n    0x6C3A598C, 0x250624AB, 0xFE42A3C2, 0xB77EDEE5,\\n    0x4D27DBE1, 0x041BA6C6, 0xDF5F21AF, 0x96635C88,\\n    0xAA7754E2, 0xE34B29C5, 0x380FAEAC, 0x7133D38B,\\n    0x8B6AD68F, 0xC256ABA8, 0x19122CC1, 0x502E51E6,\\n    0xE84C5038, 0xA1702D1F, 0x7A34AA76, 0x3308D751,\\n    0xC951D255, 0x806DAF72, 0x5B29281B, 0x1215553C,\\n    0x230138CF, 0x6A3D45E8, 0xB179C281, 0xF845BFA6,\\n    0x021CBAA2, 0x4B20C785, 0x906440EC, 0xD9583DCB,\\n    0x613A3C15, 0x28064132, 0xF342C65B, 0xBA7EBB7C,\\n    0x4027BE78, 0x091BC35F, 0xD25F4436, 0x9B633911,\\n    0xA777317B, 0xEE4B4C5C, 0x350FCB35, 0x7C33B612,\\n    0x866AB316, 0xCF56CE31, 0x14124958, 0x5D2E347F,\\n    0xE54C35A1, 0xAC704886, 0x7734CFEF, 0x3E08B2C8,\\n    0xC451B7CC, 0x8D6DCAEB, 0x56294D82, 0x1F1530A5\\n  };\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"getValue\", \"return_type\": \"long\", \"position\": {\"start_line\": 49, \"end_line\": 52, \"start_column\": 10, \"end_column\": 3}, \"code\": \"long getValue() {\\n    final long ret = crc;\\n    return (~ret) & 0xffffffffL;\\n  }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"reset\", \"return_type\": \"void\", \"position\": {\"start_line\": 55, \"end_line\": 57, \"start_column\": 10, \"end_column\": 3}, \"code\": \"void reset() {\\n    crc = 0xffffffff;\\n  }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"update\", \"return_type\": \"void\", \"position\": {\"start_line\": 60, \"end_line\": 98, \"start_column\": 10, \"end_column\": 3}, \"code\": \"void update(final byte[] b, int off, int len) {\\n    int localCrc = crc;\\n\\n    while(len > 7) {\\n      final int c0 =(b[off+0] ^ localCrc) & 0xff;\\n      final int c1 =(b[off+1] ^ (localCrc >>>= 8)) & 0xff;\\n      final int c2 =(b[off+2] ^ (localCrc >>>= 8)) & 0xff;\\n      final int c3 =(b[off+3] ^ (localCrc >>>= 8)) & 0xff;\\n      localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1]) ^\\n                 (T[T8_5_start + c2] ^ T[T8_4_start + c3]);\\n\\n      final int c4 = b[off+4] & 0xff;\\n      final int c5 = b[off+5] & 0xff;\\n      final int c6 = b[off+6] & 0xff;\\n      final int c7 = b[off+7] & 0xff;\\n\\n      localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5]) ^\\n                  (T[T8_1_start + c6] ^ T[T8_0_start + c7]);\\n\\n      off += 8;\\n      len -= 8;\\n    }\\n\\n    /* loop unroll - duff's device style */\\n    switch(len) {\\n      case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 5: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 4: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 3: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 2: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      case 1: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];\\n      default:\\n        break; // satisfy Findbugs\\n    }\\n\\n    // Publish crc out to object\\n    crc = localCrc;\\n  }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"byte\"}, {\"name\": \"off\", \"type\": \"int\"}, {\"name\": \"len\", \"type\": \"int\"}]}, {\"name\": \"update\", \"return_type\": \"void\", \"position\": {\"start_line\": 101, \"end_line\": 103, \"start_column\": 16, \"end_column\": 3}, \"code\": \"void update(final int b) {\\n    crc = (crc >>> 8) ^ T[T8_0_start + ((crc ^ b) & 0xff)];\\n  }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"int\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/digest/Sha2Crypt.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npackage org.apache.commons.codec.digest;\\n\\nimport java.security.MessageDigest;\\nimport java.security.NoSuchAlgorithmException;\\nimport java.util.Arrays;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\nimport org.apache.commons.codec.Charsets;\\n\\n/**\\n * SHA2-based Unix crypt implementation.\\n * <p>\\n * Based on the C implementation released into the Public Domain by Ulrich Drepper &lt;drepper@redhat.com&gt;\\n * http://www.akkadia.org/drepper/SHA-crypt.txt\\n * <p>\\n * Conversion to Kotlin and from there to Java in 2012 by Christian Hammers &lt;ch@lathspell.de&gt; and likewise put\\n * into the Public Domain.\\n * <p>\\n * This class is immutable and thread-safe.\\n *\\n * @version $Id: Sha2Crypt.java 1744746 2016-05-20 14:19:43Z sebb $\\n * @since 1.7\\n */\\npublic class Sha2Crypt {\\n\\n    /** Default number of rounds if not explicitly specified. */\\n    private static final int ROUNDS_DEFAULT = 5000;\\n\\n    /** Maximum number of rounds. */\\n    private static final int ROUNDS_MAX = 999999999;\\n\\n    /** Minimum number of rounds. */\\n    private static final int ROUNDS_MIN = 1000;\\n\\n    /** Prefix for optional rounds specification. */\\n    private static final String ROUNDS_PREFIX = \\\"rounds=\\\";\\n\\n    /** The number of bytes the final hash value will have (SHA-256 variant). */\\n    private static final int SHA256_BLOCKSIZE = 32;\\n\\n    /** The prefixes that can be used to identify this crypt() variant (SHA-256). */\\n    static final String SHA256_PREFIX = \\\"$5$\\\";\\n\\n    /** The number of bytes the final hash value will have (SHA-512 variant). */\\n    private static final int SHA512_BLOCKSIZE = 64;\\n\\n    /** The prefixes that can be used to identify this crypt() variant (SHA-512). */\\n    static final String SHA512_PREFIX = \\\"$6$\\\";\\n\\n    /** The pattern to match valid salt values. */\\n    private static final Pattern SALT_PATTERN = Pattern\\n            .compile(\\\"^\\\\\\\\$([56])\\\\\\\\$(rounds=(\\\\\\\\d+)\\\\\\\\$)?([\\\\\\\\.\\\\\\\\/a-zA-Z0-9]{1,16}).*\\\");\\n\\n    /**\\n     * Generates a libc crypt() compatible \\\"$5$\\\" hash value with random salt.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext to hash\\n     * @return complete hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String sha256Crypt(final byte[] keyBytes) {\\n        return sha256Crypt(keyBytes, null);\\n    }\\n\\n    /**\\n     * Generates a libc6 crypt() compatible \\\"$5$\\\" hash value.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext to hash\\n     * @param salt\\n     *            real salt value without prefix or \\\"rounds=\\\"\\n     * @return complete hash value including salt\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String sha256Crypt(final byte[] keyBytes, String salt) {\\n        if (salt == null) {\\n            salt = SHA256_PREFIX + B64.getRandomSalt(8);\\n        }\\n        return sha2Crypt(keyBytes, salt, SHA256_PREFIX, SHA256_BLOCKSIZE, MessageDigestAlgorithms.SHA_256);\\n    }\\n\\n    /**\\n     * Generates a libc6 crypt() compatible \\\"$5$\\\" or \\\"$6$\\\" SHA2 based hash value.\\n     * <p>\\n     * This is a nearly line by line conversion of the original C function. The numbered comments are from the algorithm\\n     * description, the short C-style ones from the original C code and the ones with \\\"Remark\\\" from me.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext to hash\\n     * @param salt\\n     *            real salt value without prefix or \\\"rounds=\\\"\\n     * @param saltPrefix\\n     *            either $5$ or $6$\\n     * @param blocksize\\n     *            a value that differs between $5$ and $6$\\n     * @param algorithm\\n     *            {@link MessageDigest} algorithm identifier string\\n     * @return complete hash value including prefix and salt\\n     * @throws IllegalArgumentException\\n     *             if the given salt is <code>null</code> or does not match the allowed pattern\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught\\n     * @see MessageDigestAlgorithms\\n     */\\n    private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix,\\n            final int blocksize, final String algorithm) {\\n\\n        final int keyLen = keyBytes.length;\\n\\n        // Extracts effective salt and the number of rounds from the given salt.\\n        int rounds = ROUNDS_DEFAULT;\\n        boolean roundsCustom = false;\\n        if (salt == null) {\\n            throw new IllegalArgumentException(\\\"Salt must not be null\\\");\\n        }\\n\\n        final Matcher m = SALT_PATTERN.matcher(salt);\\n        if (!m.find()) {\\n            throw new IllegalArgumentException(\\\"Invalid salt value: \\\" + salt);\\n        }\\n        if (m.group(3) != null) {\\n            rounds = Integer.parseInt(m.group(3));\\n            rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));\\n            roundsCustom = true;\\n        }\\n        final String saltString = m.group(4);\\n        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\\n        final int saltLen = saltBytes.length;\\n\\n        // 1. start digest A\\n        // Prepare for the real work.\\n        MessageDigest ctx = DigestUtils.getDigest(algorithm);\\n\\n        // 2. the password string is added to digest A\\n        /*\\n         * Add the key string.\\n         */\\n        ctx.update(keyBytes);\\n\\n        // 3. the salt string is added to digest A. This is just the salt string\\n        // itself without the enclosing '$', without the magic salt_prefix $5$ and\\n        // $6$ respectively and without the rounds=<N> specification.\\n        //\\n        // NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed\\n        // necessary since it is a constant string and does not add security\\n        // and /possibly/ allows a plain text attack. Since the rounds=<N>\\n        // specification should never be added this would also create an\\n        // inconsistency.\\n        /*\\n         * The last part is the salt string. This must be at most 16 characters and it ends at the first `$' character\\n         * (for compatibility with existing implementations).\\n         */\\n        ctx.update(saltBytes);\\n\\n        // 4. start digest B\\n        /*\\n         * Compute alternate sha512 sum with input KEY, SALT, and KEY. The final result will be added to the first\\n         * context.\\n         */\\n        MessageDigest altCtx = DigestUtils.getDigest(algorithm);\\n\\n        // 5. add the password to digest B\\n        /*\\n         * Add key.\\n         */\\n        altCtx.update(keyBytes);\\n\\n        // 6. add the salt string to digest B\\n        /*\\n         * Add salt.\\n         */\\n        altCtx.update(saltBytes);\\n\\n        // 7. add the password again to digest B\\n        /*\\n         * Add key again.\\n         */\\n        altCtx.update(keyBytes);\\n\\n        // 8. finish digest B\\n        /*\\n         * Now get result of this (32 bytes) and add it to the other context.\\n         */\\n        byte[] altResult = altCtx.digest();\\n\\n        // 9. For each block of 32 or 64 bytes in the password string (excluding\\n        // the terminating NUL in the C representation), add digest B to digest A\\n        /*\\n         * Add for any character in the key one byte of the alternate sum.\\n         */\\n        /*\\n         * (Remark: the C code comment seems wrong for key length > 32!)\\n         */\\n        int cnt = keyBytes.length;\\n        while (cnt > blocksize) {\\n            ctx.update(altResult, 0, blocksize);\\n            cnt -= blocksize;\\n        }\\n\\n        // 10. For the remaining N bytes of the password string add the first\\n        // N bytes of digest B to digest A\\n        ctx.update(altResult, 0, cnt);\\n\\n        // 11. For each bit of the binary representation of the length of the\\n        // password string up to and including the highest 1-digit, starting\\n        // from to lowest bit position (numeric value 1):\\n        //\\n        // a) for a 1-digit add digest B to digest A\\n        //\\n        // b) for a 0-digit add the password string\\n        //\\n        // NB: this step differs significantly from the MD5 algorithm. It\\n        // adds more randomness.\\n        /*\\n         * Take the binary representation of the length of the key and for every 1 add the alternate sum, for every 0\\n         * the key.\\n         */\\n        cnt = keyBytes.length;\\n        while (cnt > 0) {\\n            if ((cnt & 1) != 0) {\\n                ctx.update(altResult, 0, blocksize);\\n            } else {\\n                ctx.update(keyBytes);\\n            }\\n            cnt >>= 1;\\n        }\\n\\n        // 12. finish digest A\\n        /*\\n         * Create intermediate result.\\n         */\\n        altResult = ctx.digest();\\n\\n        // 13. start digest DP\\n        /*\\n         * Start computation of P byte sequence.\\n         */\\n        altCtx = DigestUtils.getDigest(algorithm);\\n\\n        // 14. for every byte in the password (excluding the terminating NUL byte\\n        // in the C representation of the string)\\n        //\\n        // add the password to digest DP\\n        /*\\n         * For every character in the password add the entire password.\\n         */\\n        for (int i = 1; i <= keyLen; i++) {\\n            altCtx.update(keyBytes);\\n        }\\n\\n        // 15. finish digest DP\\n        /*\\n         * Finish the digest.\\n         */\\n        byte[] tempResult = altCtx.digest();\\n\\n        // 16. produce byte sequence P of the same length as the password where\\n        //\\n        // a) for each block of 32 or 64 bytes of length of the password string\\n        // the entire digest DP is used\\n        //\\n        // b) for the remaining N (up to 31 or 63) bytes use the first N\\n        // bytes of digest DP\\n        /*\\n         * Create byte sequence P.\\n         */\\n        final byte[] pBytes = new byte[keyLen];\\n        int cp = 0;\\n        while (cp < keyLen - blocksize) {\\n            System.arraycopy(tempResult, 0, pBytes, cp, blocksize);\\n            cp += blocksize;\\n        }\\n        System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);\\n\\n        // 17. start digest DS\\n        /*\\n         * Start computation of S byte sequence.\\n         */\\n        altCtx = DigestUtils.getDigest(algorithm);\\n\\n        // 18. repeast the following 16+A[0] times, where A[0] represents the first\\n        // byte in digest A interpreted as an 8-bit unsigned value\\n        //\\n        // add the salt to digest DS\\n        /*\\n         * For every character in the password add the entire password.\\n         */\\n        for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {\\n            altCtx.update(saltBytes);\\n        }\\n\\n        // 19. finish digest DS\\n        /*\\n         * Finish the digest.\\n         */\\n        tempResult = altCtx.digest();\\n\\n        // 20. produce byte sequence S of the same length as the salt string where\\n        //\\n        // a) for each block of 32 or 64 bytes of length of the salt string\\n        // the entire digest DS is used\\n        //\\n        // b) for the remaining N (up to 31 or 63) bytes use the first N\\n        // bytes of digest DS\\n        /*\\n         * Create byte sequence S.\\n         */\\n        // Remark: The salt is limited to 16 chars, how does this make sense?\\n        final byte[] sBytes = new byte[saltLen];\\n        cp = 0;\\n        while (cp < saltLen - blocksize) {\\n            System.arraycopy(tempResult, 0, sBytes, cp, blocksize);\\n            cp += blocksize;\\n        }\\n        System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);\\n\\n        // 21. repeat a loop according to the number specified in the rounds=<N>\\n        // specification in the salt (or the default value if none is\\n        // present). Each round is numbered, starting with 0 and up to N-1.\\n        //\\n        // The loop uses a digest as input. In the first round it is the\\n        // digest produced in step 12. In the latter steps it is the digest\\n        // produced in step 21.h. The following text uses the notation\\n        // \\\"digest A/C\\\" to describe this behavior.\\n        /*\\n         * Repeatedly run the collected hash value through sha512 to burn CPU cycles.\\n         */\\n        for (int i = 0; i <= rounds - 1; i++) {\\n            // a) start digest C\\n            /*\\n             * New context.\\n             */\\n            ctx = DigestUtils.getDigest(algorithm);\\n\\n            // b) for odd round numbers add the byte sequense P to digest C\\n            // c) for even round numbers add digest A/C\\n            /*\\n             * Add key or last result.\\n             */\\n            if ((i & 1) != 0) {\\n                ctx.update(pBytes, 0, keyLen);\\n            } else {\\n                ctx.update(altResult, 0, blocksize);\\n            }\\n\\n            // d) for all round numbers not divisible by 3 add the byte sequence S\\n            /*\\n             * Add salt for numbers not divisible by 3.\\n             */\\n            if (i % 3 != 0) {\\n                ctx.update(sBytes, 0, saltLen);\\n            }\\n\\n            // e) for all round numbers not divisible by 7 add the byte sequence P\\n            /*\\n             * Add key for numbers not divisible by 7.\\n             */\\n            if (i % 7 != 0) {\\n                ctx.update(pBytes, 0, keyLen);\\n            }\\n\\n            // f) for odd round numbers add digest A/C\\n            // g) for even round numbers add the byte sequence P\\n            /*\\n             * Add key or last result.\\n             */\\n            if ((i & 1) != 0) {\\n                ctx.update(altResult, 0, blocksize);\\n            } else {\\n                ctx.update(pBytes, 0, keyLen);\\n            }\\n\\n            // h) finish digest C.\\n            /*\\n             * Create intermediate result.\\n             */\\n            altResult = ctx.digest();\\n        }\\n\\n        // 22. Produce the output string. This is an ASCII string of the maximum\\n        // size specified above, consisting of multiple pieces:\\n        //\\n        // a) the salt salt_prefix, $5$ or $6$ respectively\\n        //\\n        // b) the rounds=<N> specification, if one was present in the input\\n        // salt string. A trailing '$' is added in this case to separate\\n        // the rounds specification from the following text.\\n        //\\n        // c) the salt string truncated to 16 characters\\n        //\\n        // d) a '$' character\\n        /*\\n         * Now we can construct the result string. It consists of three parts.\\n         */\\n        final StringBuilder buffer = new StringBuilder(saltPrefix);\\n        if (roundsCustom) {\\n            buffer.append(ROUNDS_PREFIX);\\n            buffer.append(rounds);\\n            buffer.append(\\\"$\\\");\\n        }\\n        buffer.append(saltString);\\n        buffer.append(\\\"$\\\");\\n\\n        // e) the base-64 encoded final C digest. The encoding used is as\\n        // follows:\\n        // [...]\\n        //\\n        // Each group of three bytes from the digest produces four\\n        // characters as output:\\n        //\\n        // 1. character: the six low bits of the first byte\\n        // 2. character: the two high bits of the first byte and the\\n        // four low bytes from the second byte\\n        // 3. character: the four high bytes from the second byte and\\n        // the two low bits from the third byte\\n        // 4. character: the six high bits from the third byte\\n        //\\n        // The groups of three bytes are as follows (in this sequence).\\n        // These are the indices into the byte array containing the\\n        // digest, starting with index 0. For the last group there are\\n        // not enough bytes left in the digest and the value zero is used\\n        // in its place. This group also produces only three or two\\n        // characters as output for SHA-512 and SHA-512 respectively.\\n\\n        // This was just a safeguard in the C implementation:\\n        // int buflen = salt_prefix.length() - 1 + ROUNDS_PREFIX.length() + 9 + 1 + salt_string.length() + 1 + 86 + 1;\\n\\n        if (blocksize == 32) {\\n            B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);\\n            B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);\\n            B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);\\n            B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);\\n            B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);\\n            B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);\\n            B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);\\n            B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);\\n            B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);\\n            B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);\\n            B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);\\n        } else {\\n            B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);\\n            B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);\\n            B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);\\n            B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);\\n            B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);\\n            B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);\\n            B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);\\n            B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);\\n            B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);\\n            B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);\\n            B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);\\n            B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);\\n            B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);\\n            B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);\\n            B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);\\n            B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);\\n            B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);\\n            B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);\\n            B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);\\n            B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);\\n            B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);\\n            B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);\\n        }\\n\\n        /*\\n         * Clear the buffer for the intermediate result so that people attaching to processes or reading core dumps\\n         * cannot get any information.\\n         */\\n        // Is there a better way to do this with the JVM?\\n        Arrays.fill(tempResult, (byte) 0);\\n        Arrays.fill(pBytes, (byte) 0);\\n        Arrays.fill(sBytes, (byte) 0);\\n        ctx.reset();\\n        altCtx.reset();\\n        Arrays.fill(keyBytes, (byte) 0);\\n        Arrays.fill(saltBytes, (byte) 0);\\n\\n        return buffer.toString();\\n    }\\n\\n    /**\\n     * Generates a libc crypt() compatible \\\"$6$\\\" hash value with random salt.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext to hash\\n     * @return complete hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String sha512Crypt(final byte[] keyBytes) {\\n        return sha512Crypt(keyBytes, null);\\n    }\\n\\n    /**\\n     * Generates a libc6 crypt() compatible \\\"$6$\\\" hash value.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext to hash\\n     * @param salt\\n     *            real salt value without prefix or \\\"rounds=\\\"\\n     * @return complete hash value including salt\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String sha512Crypt(final byte[] keyBytes, String salt) {\\n        if (salt == null) {\\n            salt = SHA512_PREFIX + B64.getRandomSalt(8);\\n        }\\n        return sha2Crypt(keyBytes, salt, SHA512_PREFIX, SHA512_BLOCKSIZE, MessageDigestAlgorithms.SHA_512);\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Sha2Crypt\", \"position\": {\"start_line\": 41, \"end_line\": 545, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Sha2Crypt {\\n\\n    /** Default number of rounds if not explicitly specified. */\\n    private static final int ROUNDS_DEFAULT = 5000;\\n\\n    /** Maximum number of rounds. */\\n    private static final int ROUNDS_MAX = 999999999;\\n\\n    /** Minimum number of rounds. */\\n    private static final int ROUNDS_MIN = 1000;\\n\\n    /** Prefix for optional rounds specification. */\\n    private static final String ROUNDS_PREFIX = \\\"rounds=\\\";\\n\\n    /** The number of bytes the final hash value will have (SHA-256 variant). */\\n    private static final int SHA256_BLOCKSIZE = 32;\\n\\n    /** The prefixes that can be used to identify this crypt() variant (SHA-256). */\\n    static final String SHA256_PREFIX = \\\"$5$\\\";\\n\\n    /** The number of bytes the final hash value will have (SHA-512 variant). */\\n    private static final int SHA512_BLOCKSIZE = 64;\\n\\n    /** The prefixes that can be used to identify this crypt() variant (SHA-512). */\\n    static final String SHA512_PREFIX = \\\"$6$\\\";\\n\\n    /** The pattern to match valid salt values. */\\n    private static final Pattern SALT_PATTERN = Pattern\\n            .compile(\\\"^\\\\\\\\$([56])\\\\\\\\$(rounds=(\\\\\\\\d+)\\\\\\\\$)?([\\\\\\\\.\\\\\\\\/a-zA-Z0-9]{1,16}).*\\\");\\n\\n    /**\\n     * Generates a libc crypt() compatible \\\"$5$\\\" hash value with random salt.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext to hash\\n     * @return complete hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String sha256Crypt(final byte[] keyBytes) {\\n        return sha256Crypt(keyBytes, null);\\n    }\\n\\n    /**\\n     * Generates a libc6 crypt() compatible \\\"$5$\\\" hash value.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext to hash\\n     * @param salt\\n     *            real salt value without prefix or \\\"rounds=\\\"\\n     * @return complete hash value including salt\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String sha256Crypt(final byte[] keyBytes, String salt) {\\n        if (salt == null) {\\n            salt = SHA256_PREFIX + B64.getRandomSalt(8);\\n        }\\n        return sha2Crypt(keyBytes, salt, SHA256_PREFIX, SHA256_BLOCKSIZE, MessageDigestAlgorithms.SHA_256);\\n    }\\n\\n    /**\\n     * Generates a libc6 crypt() compatible \\\"$5$\\\" or \\\"$6$\\\" SHA2 based hash value.\\n     * <p>\\n     * This is a nearly line by line conversion of the original C function. The numbered comments are from the algorithm\\n     * description, the short C-style ones from the original C code and the ones with \\\"Remark\\\" from me.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext to hash\\n     * @param salt\\n     *            real salt value without prefix or \\\"rounds=\\\"\\n     * @param saltPrefix\\n     *            either $5$ or $6$\\n     * @param blocksize\\n     *            a value that differs between $5$ and $6$\\n     * @param algorithm\\n     *            {@link MessageDigest} algorithm identifier string\\n     * @return complete hash value including prefix and salt\\n     * @throws IllegalArgumentException\\n     *             if the given salt is <code>null</code> or does not match the allowed pattern\\n     * @throws IllegalArgumentException\\n     *             when a {@link NoSuchAlgorithmException} is caught\\n     * @see MessageDigestAlgorithms\\n     */\\n    private static String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix,\\n            final int blocksize, final String algorithm) {\\n\\n        final int keyLen = keyBytes.length;\\n\\n        // Extracts effective salt and the number of rounds from the given salt.\\n        int rounds = ROUNDS_DEFAULT;\\n        boolean roundsCustom = false;\\n        if (salt == null) {\\n            throw new IllegalArgumentException(\\\"Salt must not be null\\\");\\n        }\\n\\n        final Matcher m = SALT_PATTERN.matcher(salt);\\n        if (!m.find()) {\\n            throw new IllegalArgumentException(\\\"Invalid salt value: \\\" + salt);\\n        }\\n        if (m.group(3) != null) {\\n            rounds = Integer.parseInt(m.group(3));\\n            rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));\\n            roundsCustom = true;\\n        }\\n        final String saltString = m.group(4);\\n        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\\n        final int saltLen = saltBytes.length;\\n\\n        // 1. start digest A\\n        // Prepare for the real work.\\n        MessageDigest ctx = DigestUtils.getDigest(algorithm);\\n\\n        // 2. the password string is added to digest A\\n        /*\\n         * Add the key string.\\n         */\\n        ctx.update(keyBytes);\\n\\n        // 3. the salt string is added to digest A. This is just the salt string\\n        // itself without the enclosing '$', without the magic salt_prefix $5$ and\\n        // $6$ respectively and without the rounds=<N> specification.\\n        //\\n        // NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed\\n        // necessary since it is a constant string and does not add security\\n        // and /possibly/ allows a plain text attack. Since the rounds=<N>\\n        // specification should never be added this would also create an\\n        // inconsistency.\\n        /*\\n         * The last part is the salt string. This must be at most 16 characters and it ends at the first `$' character\\n         * (for compatibility with existing implementations).\\n         */\\n        ctx.update(saltBytes);\\n\\n        // 4. start digest B\\n        /*\\n         * Compute alternate sha512 sum with input KEY, SALT, and KEY. The final result will be added to the first\\n         * context.\\n         */\\n        MessageDigest altCtx = DigestUtils.getDigest(algorithm);\\n\\n        // 5. add the password to digest B\\n        /*\\n         * Add key.\\n         */\\n        altCtx.update(keyBytes);\\n\\n        // 6. add the salt string to digest B\\n        /*\\n         * Add salt.\\n         */\\n        altCtx.update(saltBytes);\\n\\n        // 7. add the password again to digest B\\n        /*\\n         * Add key again.\\n         */\\n        altCtx.update(keyBytes);\\n\\n        // 8. finish digest B\\n        /*\\n         * Now get result of this (32 bytes) and add it to the other context.\\n         */\\n        byte[] altResult = altCtx.digest();\\n\\n        // 9. For each block of 32 or 64 bytes in the password string (excluding\\n        // the terminating NUL in the C representation), add digest B to digest A\\n        /*\\n         * Add for any character in the key one byte of the alternate sum.\\n         */\\n        /*\\n         * (Remark: the C code comment seems wrong for key length > 32!)\\n         */\\n        int cnt = keyBytes.length;\\n        while (cnt > blocksize) {\\n            ctx.update(altResult, 0, blocksize);\\n            cnt -= blocksize;\\n        }\\n\\n        // 10. For the remaining N bytes of the password string add the first\\n        // N bytes of digest B to digest A\\n        ctx.update(altResult, 0, cnt);\\n\\n        // 11. For each bit of the binary representation of the length of the\\n        // password string up to and including the highest 1-digit, starting\\n        // from to lowest bit position (numeric value 1):\\n        //\\n        // a) for a 1-digit add digest B to digest A\\n        //\\n        // b) for a 0-digit add the password string\\n        //\\n        // NB: this step differs significantly from the MD5 algorithm. It\\n        // adds more randomness.\\n        /*\\n         * Take the binary representation of the length of the key and for every 1 add the alternate sum, for every 0\\n         * the key.\\n         */\\n        cnt = keyBytes.length;\\n        while (cnt > 0) {\\n            if ((cnt & 1) != 0) {\\n                ctx.update(altResult, 0, blocksize);\\n            } else {\\n                ctx.update(keyBytes);\\n            }\\n            cnt >>= 1;\\n        }\\n\\n        // 12. finish digest A\\n        /*\\n         * Create intermediate result.\\n         */\\n        altResult = ctx.digest();\\n\\n        // 13. start digest DP\\n        /*\\n         * Start computation of P byte sequence.\\n         */\\n        altCtx = DigestUtils.getDigest(algorithm);\\n\\n        // 14. for every byte in the password (excluding the terminating NUL byte\\n        // in the C representation of the string)\\n        //\\n        // add the password to digest DP\\n        /*\\n         * For every character in the password add the entire password.\\n         */\\n        for (int i = 1; i <= keyLen; i++) {\\n            altCtx.update(keyBytes);\\n        }\\n\\n        // 15. finish digest DP\\n        /*\\n         * Finish the digest.\\n         */\\n        byte[] tempResult = altCtx.digest();\\n\\n        // 16. produce byte sequence P of the same length as the password where\\n        //\\n        // a) for each block of 32 or 64 bytes of length of the password string\\n        // the entire digest DP is used\\n        //\\n        // b) for the remaining N (up to 31 or 63) bytes use the first N\\n        // bytes of digest DP\\n        /*\\n         * Create byte sequence P.\\n         */\\n        final byte[] pBytes = new byte[keyLen];\\n        int cp = 0;\\n        while (cp < keyLen - blocksize) {\\n            System.arraycopy(tempResult, 0, pBytes, cp, blocksize);\\n            cp += blocksize;\\n        }\\n        System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);\\n\\n        // 17. start digest DS\\n        /*\\n         * Start computation of S byte sequence.\\n         */\\n        altCtx = DigestUtils.getDigest(algorithm);\\n\\n        // 18. repeast the following 16+A[0] times, where A[0] represents the first\\n        // byte in digest A interpreted as an 8-bit unsigned value\\n        //\\n        // add the salt to digest DS\\n        /*\\n         * For every character in the password add the entire password.\\n         */\\n        for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {\\n            altCtx.update(saltBytes);\\n        }\\n\\n        // 19. finish digest DS\\n        /*\\n         * Finish the digest.\\n         */\\n        tempResult = altCtx.digest();\\n\\n        // 20. produce byte sequence S of the same length as the salt string where\\n        //\\n        // a) for each block of 32 or 64 bytes of length of the salt string\\n        // the entire digest DS is used\\n        //\\n        // b) for the remaining N (up to 31 or 63) bytes use the first N\\n        // bytes of digest DS\\n        /*\\n         * Create byte sequence S.\\n         */\\n        // Remark: The salt is limited to 16 chars, how does this make sense?\\n        final byte[] sBytes = new byte[saltLen];\\n        cp = 0;\\n        while (cp < saltLen - blocksize) {\\n            System.arraycopy(tempResult, 0, sBytes, cp, blocksize);\\n            cp += blocksize;\\n        }\\n        System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);\\n\\n        // 21. repeat a loop according to the number specified in the rounds=<N>\\n        // specification in the salt (or the default value if none is\\n        // present). Each round is numbered, starting with 0 and up to N-1.\\n        //\\n        // The loop uses a digest as input. In the first round it is the\\n        // digest produced in step 12. In the latter steps it is the digest\\n        // produced in step 21.h. The following text uses the notation\\n        // \\\"digest A/C\\\" to describe this behavior.\\n        /*\\n         * Repeatedly run the collected hash value through sha512 to burn CPU cycles.\\n         */\\n        for (int i = 0; i <= rounds - 1; i++) {\\n            // a) start digest C\\n            /*\\n             * New context.\\n             */\\n            ctx = DigestUtils.getDigest(algorithm);\\n\\n            // b) for odd round numbers add the byte sequense P to digest C\\n            // c) for even round numbers add digest A/C\\n            /*\\n             * Add key or last result.\\n             */\\n            if ((i & 1) != 0) {\\n                ctx.update(pBytes, 0, keyLen);\\n            } else {\\n                ctx.update(altResult, 0, blocksize);\\n            }\\n\\n            // d) for all round numbers not divisible by 3 add the byte sequence S\\n            /*\\n             * Add salt for numbers not divisible by 3.\\n             */\\n            if (i % 3 != 0) {\\n                ctx.update(sBytes, 0, saltLen);\\n            }\\n\\n            // e) for all round numbers not divisible by 7 add the byte sequence P\\n            /*\\n             * Add key for numbers not divisible by 7.\\n             */\\n            if (i % 7 != 0) {\\n                ctx.update(pBytes, 0, keyLen);\\n            }\\n\\n            // f) for odd round numbers add digest A/C\\n            // g) for even round numbers add the byte sequence P\\n            /*\\n             * Add key or last result.\\n             */\\n            if ((i & 1) != 0) {\\n                ctx.update(altResult, 0, blocksize);\\n            } else {\\n                ctx.update(pBytes, 0, keyLen);\\n            }\\n\\n            // h) finish digest C.\\n            /*\\n             * Create intermediate result.\\n             */\\n            altResult = ctx.digest();\\n        }\\n\\n        // 22. Produce the output string. This is an ASCII string of the maximum\\n        // size specified above, consisting of multiple pieces:\\n        //\\n        // a) the salt salt_prefix, $5$ or $6$ respectively\\n        //\\n        // b) the rounds=<N> specification, if one was present in the input\\n        // salt string. A trailing '$' is added in this case to separate\\n        // the rounds specification from the following text.\\n        //\\n        // c) the salt string truncated to 16 characters\\n        //\\n        // d) a '$' character\\n        /*\\n         * Now we can construct the result string. It consists of three parts.\\n         */\\n        final StringBuilder buffer = new StringBuilder(saltPrefix);\\n        if (roundsCustom) {\\n            buffer.append(ROUNDS_PREFIX);\\n            buffer.append(rounds);\\n            buffer.append(\\\"$\\\");\\n        }\\n        buffer.append(saltString);\\n        buffer.append(\\\"$\\\");\\n\\n        // e) the base-64 encoded final C digest. The encoding used is as\\n        // follows:\\n        // [...]\\n        //\\n        // Each group of three bytes from the digest produces four\\n        // characters as output:\\n        //\\n        // 1. character: the six low bits of the first byte\\n        // 2. character: the two high bits of the first byte and the\\n        // four low bytes from the second byte\\n        // 3. character: the four high bytes from the second byte and\\n        // the two low bits from the third byte\\n        // 4. character: the six high bits from the third byte\\n        //\\n        // The groups of three bytes are as follows (in this sequence).\\n        // These are the indices into the byte array containing the\\n        // digest, starting with index 0. For the last group there are\\n        // not enough bytes left in the digest and the value zero is used\\n        // in its place. This group also produces only three or two\\n        // characters as output for SHA-512 and SHA-512 respectively.\\n\\n        // This was just a safeguard in the C implementation:\\n        // int buflen = salt_prefix.length() - 1 + ROUNDS_PREFIX.length() + 9 + 1 + salt_string.length() + 1 + 86 + 1;\\n\\n        if (blocksize == 32) {\\n            B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);\\n            B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);\\n            B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);\\n            B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);\\n            B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);\\n            B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);\\n            B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);\\n            B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);\\n            B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);\\n            B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);\\n            B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);\\n        } else {\\n            B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);\\n            B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);\\n            B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);\\n            B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);\\n            B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);\\n            B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);\\n            B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);\\n            B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);\\n            B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);\\n            B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);\\n            B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);\\n            B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);\\n            B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);\\n            B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);\\n            B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);\\n            B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);\\n            B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);\\n            B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);\\n            B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);\\n            B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);\\n            B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);\\n            B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);\\n        }\\n\\n        /*\\n         * Clear the buffer for the intermediate result so that people attaching to processes or reading core dumps\\n         * cannot get any information.\\n         */\\n        // Is there a better way to do this with the JVM?\\n        Arrays.fill(tempResult, (byte) 0);\\n        Arrays.fill(pBytes, (byte) 0);\\n        Arrays.fill(sBytes, (byte) 0);\\n        ctx.reset();\\n        altCtx.reset();\\n        Arrays.fill(keyBytes, (byte) 0);\\n        Arrays.fill(saltBytes, (byte) 0);\\n\\n        return buffer.toString();\\n    }\\n\\n    /**\\n     * Generates a libc crypt() compatible \\\"$6$\\\" hash value with random salt.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext to hash\\n     * @return complete hash value\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String sha512Crypt(final byte[] keyBytes) {\\n        return sha512Crypt(keyBytes, null);\\n    }\\n\\n    /**\\n     * Generates a libc6 crypt() compatible \\\"$6$\\\" hash value.\\n     * <p>\\n     * See {@link Crypt#crypt(String, String)} for details.\\n     *\\n     * @param keyBytes\\n     *            plaintext to hash\\n     * @param salt\\n     *            real salt value without prefix or \\\"rounds=\\\"\\n     * @return complete hash value including salt\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     * @throws RuntimeException\\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\\n     */\\n    public static String sha512Crypt(final byte[] keyBytes, String salt) {\\n        if (salt == null) {\\n            salt = SHA512_PREFIX + B64.getRandomSalt(8);\\n        }\\n        return sha2Crypt(keyBytes, salt, SHA512_PREFIX, SHA512_BLOCKSIZE, MessageDigestAlgorithms.SHA_512);\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"sha256Crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 82, \"end_line\": 84, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha256Crypt(final byte[] keyBytes) {\\n        return sha256Crypt(keyBytes, null);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"byte\"}]}, {\"name\": \"sha256Crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 101, \"end_line\": 106, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha256Crypt(final byte[] keyBytes, String salt) {\\n        if (salt == null) {\\n            salt = SHA256_PREFIX + B64.getRandomSalt(8);\\n        }\\n        return sha2Crypt(keyBytes, salt, SHA256_PREFIX, SHA256_BLOCKSIZE, MessageDigestAlgorithms.SHA_256);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"byte\"}, {\"name\": \"salt\", \"type\": \"String\"}]}, {\"name\": \"sha2Crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 133, \"end_line\": 507, \"start_column\": 20, \"end_column\": 5}, \"code\": \"String sha2Crypt(final byte[] keyBytes, final String salt, final String saltPrefix,\\n            final int blocksize, final String algorithm) {\\n\\n        final int keyLen = keyBytes.length;\\n\\n        // Extracts effective salt and the number of rounds from the given salt.\\n        int rounds = ROUNDS_DEFAULT;\\n        boolean roundsCustom = false;\\n        if (salt == null) {\\n            throw new IllegalArgumentException(\\\"Salt must not be null\\\");\\n        }\\n\\n        final Matcher m = SALT_PATTERN.matcher(salt);\\n        if (!m.find()) {\\n            throw new IllegalArgumentException(\\\"Invalid salt value: \\\" + salt);\\n        }\\n        if (m.group(3) != null) {\\n            rounds = Integer.parseInt(m.group(3));\\n            rounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));\\n            roundsCustom = true;\\n        }\\n        final String saltString = m.group(4);\\n        final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8);\\n        final int saltLen = saltBytes.length;\\n\\n        // 1. start digest A\\n        // Prepare for the real work.\\n        MessageDigest ctx = DigestUtils.getDigest(algorithm);\\n\\n        // 2. the password string is added to digest A\\n        /*\\n         * Add the key string.\\n         */\\n        ctx.update(keyBytes);\\n\\n        // 3. the salt string is added to digest A. This is just the salt string\\n        // itself without the enclosing '$', without the magic salt_prefix $5$ and\\n        // $6$ respectively and without the rounds=<N> specification.\\n        //\\n        // NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed\\n        // necessary since it is a constant string and does not add security\\n        // and /possibly/ allows a plain text attack. Since the rounds=<N>\\n        // specification should never be added this would also create an\\n        // inconsistency.\\n        /*\\n         * The last part is the salt string. This must be at most 16 characters and it ends at the first `$' character\\n         * (for compatibility with existing implementations).\\n         */\\n        ctx.update(saltBytes);\\n\\n        // 4. start digest B\\n        /*\\n         * Compute alternate sha512 sum with input KEY, SALT, and KEY. The final result will be added to the first\\n         * context.\\n         */\\n        MessageDigest altCtx = DigestUtils.getDigest(algorithm);\\n\\n        // 5. add the password to digest B\\n        /*\\n         * Add key.\\n         */\\n        altCtx.update(keyBytes);\\n\\n        // 6. add the salt string to digest B\\n        /*\\n         * Add salt.\\n         */\\n        altCtx.update(saltBytes);\\n\\n        // 7. add the password again to digest B\\n        /*\\n         * Add key again.\\n         */\\n        altCtx.update(keyBytes);\\n\\n        // 8. finish digest B\\n        /*\\n         * Now get result of this (32 bytes) and add it to the other context.\\n         */\\n        byte[] altResult = altCtx.digest();\\n\\n        // 9. For each block of 32 or 64 bytes in the password string (excluding\\n        // the terminating NUL in the C representation), add digest B to digest A\\n        /*\\n         * Add for any character in the key one byte of the alternate sum.\\n         */\\n        /*\\n         * (Remark: the C code comment seems wrong for key length > 32!)\\n         */\\n        int cnt = keyBytes.length;\\n        while (cnt > blocksize) {\\n            ctx.update(altResult, 0, blocksize);\\n            cnt -= blocksize;\\n        }\\n\\n        // 10. For the remaining N bytes of the password string add the first\\n        // N bytes of digest B to digest A\\n        ctx.update(altResult, 0, cnt);\\n\\n        // 11. For each bit of the binary representation of the length of the\\n        // password string up to and including the highest 1-digit, starting\\n        // from to lowest bit position (numeric value 1):\\n        //\\n        // a) for a 1-digit add digest B to digest A\\n        //\\n        // b) for a 0-digit add the password string\\n        //\\n        // NB: this step differs significantly from the MD5 algorithm. It\\n        // adds more randomness.\\n        /*\\n         * Take the binary representation of the length of the key and for every 1 add the alternate sum, for every 0\\n         * the key.\\n         */\\n        cnt = keyBytes.length;\\n        while (cnt > 0) {\\n            if ((cnt & 1) != 0) {\\n                ctx.update(altResult, 0, blocksize);\\n            } else {\\n                ctx.update(keyBytes);\\n            }\\n            cnt >>= 1;\\n        }\\n\\n        // 12. finish digest A\\n        /*\\n         * Create intermediate result.\\n         */\\n        altResult = ctx.digest();\\n\\n        // 13. start digest DP\\n        /*\\n         * Start computation of P byte sequence.\\n         */\\n        altCtx = DigestUtils.getDigest(algorithm);\\n\\n        // 14. for every byte in the password (excluding the terminating NUL byte\\n        // in the C representation of the string)\\n        //\\n        // add the password to digest DP\\n        /*\\n         * For every character in the password add the entire password.\\n         */\\n        for (int i = 1; i <= keyLen; i++) {\\n            altCtx.update(keyBytes);\\n        }\\n\\n        // 15. finish digest DP\\n        /*\\n         * Finish the digest.\\n         */\\n        byte[] tempResult = altCtx.digest();\\n\\n        // 16. produce byte sequence P of the same length as the password where\\n        //\\n        // a) for each block of 32 or 64 bytes of length of the password string\\n        // the entire digest DP is used\\n        //\\n        // b) for the remaining N (up to 31 or 63) bytes use the first N\\n        // bytes of digest DP\\n        /*\\n         * Create byte sequence P.\\n         */\\n        final byte[] pBytes = new byte[keyLen];\\n        int cp = 0;\\n        while (cp < keyLen - blocksize) {\\n            System.arraycopy(tempResult, 0, pBytes, cp, blocksize);\\n            cp += blocksize;\\n        }\\n        System.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);\\n\\n        // 17. start digest DS\\n        /*\\n         * Start computation of S byte sequence.\\n         */\\n        altCtx = DigestUtils.getDigest(algorithm);\\n\\n        // 18. repeast the following 16+A[0] times, where A[0] represents the first\\n        // byte in digest A interpreted as an 8-bit unsigned value\\n        //\\n        // add the salt to digest DS\\n        /*\\n         * For every character in the password add the entire password.\\n         */\\n        for (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {\\n            altCtx.update(saltBytes);\\n        }\\n\\n        // 19. finish digest DS\\n        /*\\n         * Finish the digest.\\n         */\\n        tempResult = altCtx.digest();\\n\\n        // 20. produce byte sequence S of the same length as the salt string where\\n        //\\n        // a) for each block of 32 or 64 bytes of length of the salt string\\n        // the entire digest DS is used\\n        //\\n        // b) for the remaining N (up to 31 or 63) bytes use the first N\\n        // bytes of digest DS\\n        /*\\n         * Create byte sequence S.\\n         */\\n        // Remark: The salt is limited to 16 chars, how does this make sense?\\n        final byte[] sBytes = new byte[saltLen];\\n        cp = 0;\\n        while (cp < saltLen - blocksize) {\\n            System.arraycopy(tempResult, 0, sBytes, cp, blocksize);\\n            cp += blocksize;\\n        }\\n        System.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);\\n\\n        // 21. repeat a loop according to the number specified in the rounds=<N>\\n        // specification in the salt (or the default value if none is\\n        // present). Each round is numbered, starting with 0 and up to N-1.\\n        //\\n        // The loop uses a digest as input. In the first round it is the\\n        // digest produced in step 12. In the latter steps it is the digest\\n        // produced in step 21.h. The following text uses the notation\\n        // \\\"digest A/C\\\" to describe this behavior.\\n        /*\\n         * Repeatedly run the collected hash value through sha512 to burn CPU cycles.\\n         */\\n        for (int i = 0; i <= rounds - 1; i++) {\\n            // a) start digest C\\n            /*\\n             * New context.\\n             */\\n            ctx = DigestUtils.getDigest(algorithm);\\n\\n            // b) for odd round numbers add the byte sequense P to digest C\\n            // c) for even round numbers add digest A/C\\n            /*\\n             * Add key or last result.\\n             */\\n            if ((i & 1) != 0) {\\n                ctx.update(pBytes, 0, keyLen);\\n            } else {\\n                ctx.update(altResult, 0, blocksize);\\n            }\\n\\n            // d) for all round numbers not divisible by 3 add the byte sequence S\\n            /*\\n             * Add salt for numbers not divisible by 3.\\n             */\\n            if (i % 3 != 0) {\\n                ctx.update(sBytes, 0, saltLen);\\n            }\\n\\n            // e) for all round numbers not divisible by 7 add the byte sequence P\\n            /*\\n             * Add key for numbers not divisible by 7.\\n             */\\n            if (i % 7 != 0) {\\n                ctx.update(pBytes, 0, keyLen);\\n            }\\n\\n            // f) for odd round numbers add digest A/C\\n            // g) for even round numbers add the byte sequence P\\n            /*\\n             * Add key or last result.\\n             */\\n            if ((i & 1) != 0) {\\n                ctx.update(altResult, 0, blocksize);\\n            } else {\\n                ctx.update(pBytes, 0, keyLen);\\n            }\\n\\n            // h) finish digest C.\\n            /*\\n             * Create intermediate result.\\n             */\\n            altResult = ctx.digest();\\n        }\\n\\n        // 22. Produce the output string. This is an ASCII string of the maximum\\n        // size specified above, consisting of multiple pieces:\\n        //\\n        // a) the salt salt_prefix, $5$ or $6$ respectively\\n        //\\n        // b) the rounds=<N> specification, if one was present in the input\\n        // salt string. A trailing '$' is added in this case to separate\\n        // the rounds specification from the following text.\\n        //\\n        // c) the salt string truncated to 16 characters\\n        //\\n        // d) a '$' character\\n        /*\\n         * Now we can construct the result string. It consists of three parts.\\n         */\\n        final StringBuilder buffer = new StringBuilder(saltPrefix);\\n        if (roundsCustom) {\\n            buffer.append(ROUNDS_PREFIX);\\n            buffer.append(rounds);\\n            buffer.append(\\\"$\\\");\\n        }\\n        buffer.append(saltString);\\n        buffer.append(\\\"$\\\");\\n\\n        // e) the base-64 encoded final C digest. The encoding used is as\\n        // follows:\\n        // [...]\\n        //\\n        // Each group of three bytes from the digest produces four\\n        // characters as output:\\n        //\\n        // 1. character: the six low bits of the first byte\\n        // 2. character: the two high bits of the first byte and the\\n        // four low bytes from the second byte\\n        // 3. character: the four high bytes from the second byte and\\n        // the two low bits from the third byte\\n        // 4. character: the six high bits from the third byte\\n        //\\n        // The groups of three bytes are as follows (in this sequence).\\n        // These are the indices into the byte array containing the\\n        // digest, starting with index 0. For the last group there are\\n        // not enough bytes left in the digest and the value zero is used\\n        // in its place. This group also produces only three or two\\n        // characters as output for SHA-512 and SHA-512 respectively.\\n\\n        // This was just a safeguard in the C implementation:\\n        // int buflen = salt_prefix.length() - 1 + ROUNDS_PREFIX.length() + 9 + 1 + salt_string.length() + 1 + 86 + 1;\\n\\n        if (blocksize == 32) {\\n            B64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);\\n            B64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);\\n            B64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);\\n            B64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);\\n            B64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);\\n            B64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);\\n            B64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);\\n            B64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);\\n            B64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);\\n            B64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);\\n            B64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);\\n        } else {\\n            B64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);\\n            B64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);\\n            B64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);\\n            B64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);\\n            B64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);\\n            B64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);\\n            B64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);\\n            B64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);\\n            B64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);\\n            B64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);\\n            B64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);\\n            B64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);\\n            B64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);\\n            B64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);\\n            B64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);\\n            B64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);\\n            B64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);\\n            B64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);\\n            B64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);\\n            B64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);\\n            B64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);\\n            B64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);\\n        }\\n\\n        /*\\n         * Clear the buffer for the intermediate result so that people attaching to processes or reading core dumps\\n         * cannot get any information.\\n         */\\n        // Is there a better way to do this with the JVM?\\n        Arrays.fill(tempResult, (byte) 0);\\n        Arrays.fill(pBytes, (byte) 0);\\n        Arrays.fill(sBytes, (byte) 0);\\n        ctx.reset();\\n        altCtx.reset();\\n        Arrays.fill(keyBytes, (byte) 0);\\n        Arrays.fill(saltBytes, (byte) 0);\\n\\n        return buffer.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"byte\"}, {\"name\": \"salt\", \"type\": \"String\"}, {\"name\": \"saltPrefix\", \"type\": \"String\"}, {\"name\": \"blocksize\", \"type\": \"int\"}, {\"name\": \"algorithm\", \"type\": \"String\"}]}, {\"name\": \"sha512Crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 520, \"end_line\": 522, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha512Crypt(final byte[] keyBytes) {\\n        return sha512Crypt(keyBytes, null);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"byte\"}]}, {\"name\": \"sha512Crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 539, \"end_line\": 544, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String sha512Crypt(final byte[] keyBytes, String salt) {\\n        if (salt == null) {\\n            salt = SHA512_PREFIX + B64.getRandomSalt(8);\\n        }\\n        return sha2Crypt(keyBytes, salt, SHA512_PREFIX, SHA512_BLOCKSIZE, MessageDigestAlgorithms.SHA_512);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"keyBytes\", \"type\": \"byte\"}, {\"name\": \"salt\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/digest/UnixCrypt.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npackage org.apache.commons.codec.digest;\\n\\nimport java.util.Random;\\n\\nimport org.apache.commons.codec.Charsets;\\n\\n/**\\n * Unix crypt(3) algorithm implementation.\\n * <p>\\n * This class only implements the traditional 56 bit DES based algorithm. Please use DigestUtils.crypt() for a method\\n * that distinguishes between all the algorithms supported in the current glibc's crypt().\\n * <p>\\n * The Java implementation was taken from the JetSpeed Portal project (see\\n * org.apache.jetspeed.services.security.ldap.UnixCrypt).\\n * <p>\\n * This class is slightly incompatible if the given salt contains characters that are not part of the allowed range\\n * [a-zA-Z0-9./].\\n * <p>\\n * This class is immutable and thread-safe.\\n *\\n * @version $Id: UnixCrypt.java 1429868 2013-01-07 16:08:05Z ggregory $\\n * @since 1.7\\n */\\npublic class UnixCrypt {\\n\\n    private static final int CON_SALT[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 5, 6,\\n            7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\\n            34, 35, 36, 37, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\\n            54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0, 0, 0, 0 };\\n\\n    private static final int COV2CHAR[] = { 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70,\\n            71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,\\n            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122 };\\n\\n    private static final char SALT_CHARS[] = \\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./\\\"\\n            .toCharArray();\\n\\n    private static final boolean SHIFT2[] = { false, false, true, true, true, true, true, true, false, true, true,\\n            true, true, true, true, false };\\n\\n    private static final int SKB[][] = {\\n            { 0, 16, 0x20000000, 0x20000010, 0x10000, 0x10010, 0x20010000, 0x20010010, 2048, 2064, 0x20000800,\\n                    0x20000810, 0x10800, 0x10810, 0x20010800, 0x20010810, 32, 48, 0x20000020, 0x20000030, 0x10020,\\n                    0x10030, 0x20010020, 0x20010030, 2080, 2096, 0x20000820, 0x20000830, 0x10820, 0x10830, 0x20010820,\\n                    0x20010830, 0x80000, 0x80010, 0x20080000, 0x20080010, 0x90000, 0x90010, 0x20090000, 0x20090010,\\n                    0x80800, 0x80810, 0x20080800, 0x20080810, 0x90800, 0x90810, 0x20090800, 0x20090810, 0x80020,\\n                    0x80030, 0x20080020, 0x20080030, 0x90020, 0x90030, 0x20090020, 0x20090030, 0x80820, 0x80830,\\n                    0x20080820, 0x20080830, 0x90820, 0x90830, 0x20090820, 0x20090830 },\\n            { 0, 0x2000000, 8192, 0x2002000, 0x200000, 0x2200000, 0x202000, 0x2202000, 4, 0x2000004, 8196, 0x2002004,\\n                    0x200004, 0x2200004, 0x202004, 0x2202004, 1024, 0x2000400, 9216, 0x2002400, 0x200400, 0x2200400,\\n                    0x202400, 0x2202400, 1028, 0x2000404, 9220, 0x2002404, 0x200404, 0x2200404, 0x202404, 0x2202404,\\n                    0x10000000, 0x12000000, 0x10002000, 0x12002000, 0x10200000, 0x12200000, 0x10202000, 0x12202000,\\n                    0x10000004, 0x12000004, 0x10002004, 0x12002004, 0x10200004, 0x12200004, 0x10202004, 0x12202004,\\n                    0x10000400, 0x12000400, 0x10002400, 0x12002400, 0x10200400, 0x12200400, 0x10202400, 0x12202400,\\n                    0x10000404, 0x12000404, 0x10002404, 0x12002404, 0x10200404, 0x12200404, 0x10202404, 0x12202404 },\\n            { 0, 1, 0x40000, 0x40001, 0x1000000, 0x1000001, 0x1040000, 0x1040001, 2, 3, 0x40002, 0x40003, 0x1000002,\\n                    0x1000003, 0x1040002, 0x1040003, 512, 513, 0x40200, 0x40201, 0x1000200, 0x1000201, 0x1040200,\\n                    0x1040201, 514, 515, 0x40202, 0x40203, 0x1000202, 0x1000203, 0x1040202, 0x1040203, 0x8000000,\\n                    0x8000001, 0x8040000, 0x8040001, 0x9000000, 0x9000001, 0x9040000, 0x9040001, 0x8000002, 0x8000003,\\n                    0x8040002, 0x8040003, 0x9000002, 0x9000003, 0x9040002, 0x9040003, 0x8000200, 0x8000201, 0x8040200,\\n                    0x8040201, 0x9000200, 0x9000201, 0x9040200, 0x9040201, 0x8000202, 0x8000203, 0x8040202, 0x8040203,\\n                    0x9000202, 0x9000203, 0x9040202, 0x9040203 },\\n            { 0, 0x100000, 256, 0x100100, 8, 0x100008, 264, 0x100108, 4096, 0x101000, 4352, 0x101100, 4104, 0x101008,\\n                    4360, 0x101108, 0x4000000, 0x4100000, 0x4000100, 0x4100100, 0x4000008, 0x4100008, 0x4000108,\\n                    0x4100108, 0x4001000, 0x4101000, 0x4001100, 0x4101100, 0x4001008, 0x4101008, 0x4001108, 0x4101108,\\n                    0x20000, 0x120000, 0x20100, 0x120100, 0x20008, 0x120008, 0x20108, 0x120108, 0x21000, 0x121000,\\n                    0x21100, 0x121100, 0x21008, 0x121008, 0x21108, 0x121108, 0x4020000, 0x4120000, 0x4020100,\\n                    0x4120100, 0x4020008, 0x4120008, 0x4020108, 0x4120108, 0x4021000, 0x4121000, 0x4021100, 0x4121100,\\n                    0x4021008, 0x4121008, 0x4021108, 0x4121108 },\\n            { 0, 0x10000000, 0x10000, 0x10010000, 4, 0x10000004, 0x10004, 0x10010004, 0x20000000, 0x30000000,\\n                    0x20010000, 0x30010000, 0x20000004, 0x30000004, 0x20010004, 0x30010004, 0x100000, 0x10100000,\\n                    0x110000, 0x10110000, 0x100004, 0x10100004, 0x110004, 0x10110004, 0x20100000, 0x30100000,\\n                    0x20110000, 0x30110000, 0x20100004, 0x30100004, 0x20110004, 0x30110004, 4096, 0x10001000, 0x11000,\\n                    0x10011000, 4100, 0x10001004, 0x11004, 0x10011004, 0x20001000, 0x30001000, 0x20011000, 0x30011000,\\n                    0x20001004, 0x30001004, 0x20011004, 0x30011004, 0x101000, 0x10101000, 0x111000, 0x10111000,\\n                    0x101004, 0x10101004, 0x111004, 0x10111004, 0x20101000, 0x30101000, 0x20111000, 0x30111000,\\n                    0x20101004, 0x30101004, 0x20111004, 0x30111004 },\\n            { 0, 0x8000000, 8, 0x8000008, 1024, 0x8000400, 1032, 0x8000408, 0x20000, 0x8020000, 0x20008, 0x8020008,\\n                    0x20400, 0x8020400, 0x20408, 0x8020408, 1, 0x8000001, 9, 0x8000009, 1025, 0x8000401, 1033,\\n                    0x8000409, 0x20001, 0x8020001, 0x20009, 0x8020009, 0x20401, 0x8020401, 0x20409, 0x8020409,\\n                    0x2000000, 0xa000000, 0x2000008, 0xa000008, 0x2000400, 0xa000400, 0x2000408, 0xa000408, 0x2020000,\\n                    0xa020000, 0x2020008, 0xa020008, 0x2020400, 0xa020400, 0x2020408, 0xa020408, 0x2000001, 0xa000001,\\n                    0x2000009, 0xa000009, 0x2000401, 0xa000401, 0x2000409, 0xa000409, 0x2020001, 0xa020001, 0x2020009,\\n                    0xa020009, 0x2020401, 0xa020401, 0x2020409, 0xa020409 },\\n            { 0, 256, 0x80000, 0x80100, 0x1000000, 0x1000100, 0x1080000, 0x1080100, 16, 272, 0x80010, 0x80110,\\n                    0x1000010, 0x1000110, 0x1080010, 0x1080110, 0x200000, 0x200100, 0x280000, 0x280100, 0x1200000,\\n                    0x1200100, 0x1280000, 0x1280100, 0x200010, 0x200110, 0x280010, 0x280110, 0x1200010, 0x1200110,\\n                    0x1280010, 0x1280110, 512, 768, 0x80200, 0x80300, 0x1000200, 0x1000300, 0x1080200, 0x1080300, 528,\\n                    784, 0x80210, 0x80310, 0x1000210, 0x1000310, 0x1080210, 0x1080310, 0x200200, 0x200300, 0x280200,\\n                    0x280300, 0x1200200, 0x1200300, 0x1280200, 0x1280300, 0x200210, 0x200310, 0x280210, 0x280310,\\n                    0x1200210, 0x1200310, 0x1280210, 0x1280310 },\\n            { 0, 0x4000000, 0x40000, 0x4040000, 2, 0x4000002, 0x40002, 0x4040002, 8192, 0x4002000, 0x42000, 0x4042000,\\n                    8194, 0x4002002, 0x42002, 0x4042002, 32, 0x4000020, 0x40020, 0x4040020, 34, 0x4000022, 0x40022,\\n                    0x4040022, 8224, 0x4002020, 0x42020, 0x4042020, 8226, 0x4002022, 0x42022, 0x4042022, 2048,\\n                    0x4000800, 0x40800, 0x4040800, 2050, 0x4000802, 0x40802, 0x4040802, 10240, 0x4002800, 0x42800,\\n                    0x4042800, 10242, 0x4002802, 0x42802, 0x4042802, 2080, 0x4000820, 0x40820, 0x4040820, 2082,\\n                    0x4000822, 0x40822, 0x4040822, 10272, 0x4002820, 0x42820, 0x4042820, 10274, 0x4002822, 0x42822,\\n                    0x4042822 } };\\n\\n    private static final int SPTRANS[][] = {\\n            { 0x820200, 0x20000, 0x80800000, 0x80820200, 0x800000, 0x80020200, 0x80020000, 0x80800000, 0x80020200,\\n                    0x820200, 0x820000, 0x80000200, 0x80800200, 0x800000, 0, 0x80020000, 0x20000, 0x80000000,\\n                    0x800200, 0x20200, 0x80820200, 0x820000, 0x80000200, 0x800200, 0x80000000, 512, 0x20200,\\n                    0x80820000, 512, 0x80800200, 0x80820000, 0, 0, 0x80820200, 0x800200, 0x80020000, 0x820200,\\n                    0x20000, 0x80000200, 0x800200, 0x80820000, 512, 0x20200, 0x80800000, 0x80020200, 0x80000000,\\n                    0x80800000, 0x820000, 0x80820200, 0x20200, 0x820000, 0x80800200, 0x800000, 0x80000200, 0x80020000,\\n                    0, 0x20000, 0x800000, 0x80800200, 0x820200, 0x80000000, 0x80820000, 512, 0x80020200 },\\n            { 0x10042004, 0, 0x42000, 0x10040000, 0x10000004, 8196, 0x10002000, 0x42000, 8192, 0x10040004, 4,\\n                    0x10002000, 0x40004, 0x10042000, 0x10040000, 4, 0x40000, 0x10002004, 0x10040004, 8192, 0x42004,\\n                    0x10000000, 0, 0x40004, 0x10002004, 0x42004, 0x10042000, 0x10000004, 0x10000000, 0x40000, 8196,\\n                    0x10042004, 0x40004, 0x10042000, 0x10002000, 0x42004, 0x10042004, 0x40004, 0x10000004, 0,\\n                    0x10000000, 8196, 0x40000, 0x10040004, 8192, 0x10000000, 0x42004, 0x10002004, 0x10042000, 8192, 0,\\n                    0x10000004, 4, 0x10042004, 0x42000, 0x10040000, 0x10040004, 0x40000, 8196, 0x10002000, 0x10002004,\\n                    4, 0x10040000, 0x42000 },\\n            { 0x41000000, 0x1010040, 64, 0x41000040, 0x40010000, 0x1000000, 0x41000040, 0x10040, 0x1000040, 0x10000,\\n                    0x1010000, 0x40000000, 0x41010040, 0x40000040, 0x40000000, 0x41010000, 0, 0x40010000, 0x1010040,\\n                    64, 0x40000040, 0x41010040, 0x10000, 0x41000000, 0x41010000, 0x1000040, 0x40010040, 0x1010000,\\n                    0x10040, 0, 0x1000000, 0x40010040, 0x1010040, 64, 0x40000000, 0x10000, 0x40000040, 0x40010000,\\n                    0x1010000, 0x41000040, 0, 0x1010040, 0x10040, 0x41010000, 0x40010000, 0x1000000, 0x41010040,\\n                    0x40000000, 0x40010040, 0x41000000, 0x1000000, 0x41010040, 0x10000, 0x1000040, 0x41000040,\\n                    0x10040, 0x1000040, 0, 0x41010000, 0x40000040, 0x41000000, 0x40010040, 64, 0x1010000 },\\n            { 0x100402, 0x4000400, 2, 0x4100402, 0, 0x4100000, 0x4000402, 0x100002, 0x4100400, 0x4000002, 0x4000000,\\n                    1026, 0x4000002, 0x100402, 0x100000, 0x4000000, 0x4100002, 0x100400, 1024, 2, 0x100400, 0x4000402,\\n                    0x4100000, 1024, 1026, 0, 0x100002, 0x4100400, 0x4000400, 0x4100002, 0x4100402, 0x100000,\\n                    0x4100002, 1026, 0x100000, 0x4000002, 0x100400, 0x4000400, 2, 0x4100000, 0x4000402, 0, 1024,\\n                    0x100002, 0, 0x4100002, 0x4100400, 1024, 0x4000000, 0x4100402, 0x100402, 0x100000, 0x4100402, 2,\\n                    0x4000400, 0x100402, 0x100002, 0x100400, 0x4100000, 0x4000402, 1026, 0x4000000, 0x4000002,\\n                    0x4100400 },\\n            { 0x2000000, 16384, 256, 0x2004108, 0x2004008, 0x2000100, 16648, 0x2004000, 16384, 8, 0x2000008, 16640,\\n                    0x2000108, 0x2004008, 0x2004100, 0, 16640, 0x2000000, 16392, 264, 0x2000100, 16648, 0, 0x2000008,\\n                    8, 0x2000108, 0x2004108, 16392, 0x2004000, 256, 264, 0x2004100, 0x2004100, 0x2000108, 16392,\\n                    0x2004000, 16384, 8, 0x2000008, 0x2000100, 0x2000000, 16640, 0x2004108, 0, 16648, 0x2000000, 256,\\n                    16392, 0x2000108, 256, 0, 0x2004108, 0x2004008, 0x2004100, 264, 16384, 16640, 0x2004008,\\n                    0x2000100, 264, 8, 16648, 0x2004000, 0x2000008 },\\n            { 0x20000010, 0x80010, 0, 0x20080800, 0x80010, 2048, 0x20000810, 0x80000, 2064, 0x20080810, 0x80800,\\n                    0x20000000, 0x20000800, 0x20000010, 0x20080000, 0x80810, 0x80000, 0x20000810, 0x20080010, 0, 2048,\\n                    16, 0x20080800, 0x20080010, 0x20080810, 0x20080000, 0x20000000, 2064, 16, 0x80800, 0x80810,\\n                    0x20000800, 2064, 0x20000000, 0x20000800, 0x80810, 0x20080800, 0x80010, 0, 0x20000800, 0x20000000,\\n                    2048, 0x20080010, 0x80000, 0x80010, 0x20080810, 0x80800, 16, 0x20080810, 0x80800, 0x80000,\\n                    0x20000810, 0x20000010, 0x20080000, 0x80810, 0, 2048, 0x20000010, 0x20000810, 0x20080800,\\n                    0x20080000, 2064, 16, 0x20080010 },\\n            { 4096, 128, 0x400080, 0x400001, 0x401081, 4097, 4224, 0, 0x400000, 0x400081, 129, 0x401000, 1, 0x401080,\\n                    0x401000, 129, 0x400081, 4096, 4097, 0x401081, 0, 0x400080, 0x400001, 4224, 0x401001, 4225,\\n                    0x401080, 1, 4225, 0x401001, 128, 0x400000, 4225, 0x401000, 0x401001, 129, 4096, 128, 0x400000,\\n                    0x401001, 0x400081, 4225, 4224, 0, 128, 0x400001, 1, 0x400080, 0, 0x400081, 0x400080, 4224, 129,\\n                    4096, 0x401081, 0x400000, 0x401080, 1, 4097, 0x401081, 0x400001, 0x401080, 0x401000, 4097 },\\n            { 0x8200020, 0x8208000, 32800, 0, 0x8008000, 0x200020, 0x8200000, 0x8208020, 32, 0x8000000, 0x208000,\\n                    32800, 0x208020, 0x8008020, 0x8000020, 0x8200000, 32768, 0x208020, 0x200020, 0x8008000, 0x8208020,\\n                    0x8000020, 0, 0x208000, 0x8000000, 0x200000, 0x8008020, 0x8200020, 0x200000, 32768, 0x8208000, 32,\\n                    0x200000, 32768, 0x8000020, 0x8208020, 32800, 0x8000000, 0, 0x208000, 0x8200020, 0x8008020,\\n                    0x8008000, 0x200020, 0x8208000, 32, 0x200020, 0x8008000, 0x8208020, 0x200000, 0x8200000,\\n                    0x8000020, 0x208000, 32800, 0x8008020, 0x8200000, 32, 0x8208000, 0x208020, 0, 0x8000000,\\n                    0x8200020, 32768, 0x208020 } };\\n\\n    /**\\n     * Generates a crypt(3) compatible hash using the DES algorithm.\\n     * <p>\\n     * As no salt is given, a random one will be used.\\n     *\\n     * @param original\\n     *            plaintext password\\n     * @return a 13 character string starting with the salt string\\n     */\\n    public static String crypt(final byte[] original) {\\n        return crypt(original, null);\\n    }\\n\\n    /**\\n     * Generates a crypt(3) compatible hash using the DES algorithm.\\n     * <p>\\n     * Using unspecified characters as salt results incompatible hash values.\\n     *\\n     * @param original\\n     *            plaintext password\\n     * @param salt\\n     *            a two character string drawn from [a-zA-Z0-9./] or null for a random one\\n     * @return a 13 character string starting with the salt string\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     */\\n    public static String crypt(final byte[] original, String salt) {\\n        if (salt == null) {\\n            final Random randomGenerator = new Random();\\n            final int numSaltChars = SALT_CHARS.length;\\n            salt = \\\"\\\" + SALT_CHARS[randomGenerator.nextInt(numSaltChars)] +\\n                    SALT_CHARS[randomGenerator.nextInt(numSaltChars)];\\n        } else if (!salt.matches(\\\"^[\\\" + B64.B64T + \\\"]{2,}$\\\")) {\\n            throw new IllegalArgumentException(\\\"Invalid salt value: \\\" + salt);\\n        }\\n\\n        final StringBuilder buffer = new StringBuilder(\\\"             \\\");\\n        final char charZero = salt.charAt(0);\\n        final char charOne = salt.charAt(1);\\n        buffer.setCharAt(0, charZero);\\n        buffer.setCharAt(1, charOne);\\n        final int eSwap0 = CON_SALT[charZero];\\n        final int eSwap1 = CON_SALT[charOne] << 4;\\n        final byte key[] = new byte[8];\\n        for (int i = 0; i < key.length; i++) {\\n            key[i] = 0;\\n        }\\n\\n        for (int i = 0; i < key.length && i < original.length; i++) {\\n            final int iChar = original[i];\\n            key[i] = (byte) (iChar << 1);\\n        }\\n\\n        final int schedule[] = desSetKey(key);\\n        final int out[] = body(schedule, eSwap0, eSwap1);\\n        final byte b[] = new byte[9];\\n        intToFourBytes(out[0], b, 0);\\n        intToFourBytes(out[1], b, 4);\\n        b[8] = 0;\\n        int i = 2;\\n        int y = 0;\\n        int u = 128;\\n        for (; i < 13; i++) {\\n            int j = 0;\\n            int c = 0;\\n            for (; j < 6; j++) {\\n                c <<= 1;\\n                if ((b[y] & u) != 0) {\\n                    c |= 0x1;\\n                }\\n                u >>>= 1;\\n                if (u == 0) {\\n                    y++;\\n                    u = 128;\\n                }\\n                buffer.setCharAt(i, (char) COV2CHAR[c]);\\n            }\\n        }\\n        return buffer.toString();\\n    }\\n\\n    /**\\n     * Generates a crypt(3) compatible hash using the DES algorithm.\\n     * <p>\\n     * As no salt is given, a random one is used.\\n     *\\n     * @param original\\n     *            plaintext password\\n     * @return a 13 character string starting with the salt string\\n     */\\n    public static String crypt(final String original) {\\n        return crypt(original.getBytes(Charsets.UTF_8));\\n    }\\n\\n    /**\\n     * Generates a crypt(3) compatible hash using the DES algorithm.\\n     *\\n     * @param original\\n     *            plaintext password\\n     * @param salt\\n     *            a two character string drawn from [a-zA-Z0-9./] or null for a random one\\n     * @return a 13 character string starting with the salt string\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     */\\n    public static String crypt(final String original, final String salt) {\\n        return crypt(original.getBytes(Charsets.UTF_8), salt);\\n    }\\n\\n    private static int[] body(final int schedule[], final int eSwap0, final int eSwap1) {\\n        int left = 0;\\n        int right = 0;\\n        int t = 0;\\n        for (int j = 0; j < 25; j++) {\\n            for (int i = 0; i < 32; i += 4) {\\n                left = dEncrypt(left, right, i, eSwap0, eSwap1, schedule);\\n                right = dEncrypt(right, left, i + 2, eSwap0, eSwap1, schedule);\\n            }\\n            t = left;\\n            left = right;\\n            right = t;\\n        }\\n\\n        t = right;\\n        right = left >>> 1 | left << 31;\\n        left = t >>> 1 | t << 31;\\n        final int results[] = new int[2];\\n        permOp(right, left, 1, 0x55555555, results);\\n        right = results[0];\\n        left = results[1];\\n        permOp(left, right, 8, 0xff00ff, results);\\n        left = results[0];\\n        right = results[1];\\n        permOp(right, left, 2, 0x33333333, results);\\n        right = results[0];\\n        left = results[1];\\n        permOp(left, right, 16, 65535, results);\\n        left = results[0];\\n        right = results[1];\\n        permOp(right, left, 4, 0xf0f0f0f, results);\\n        right = results[0];\\n        left = results[1];\\n        final int out[] = new int[2];\\n        out[0] = left;\\n        out[1] = right;\\n        return out;\\n    }\\n\\n    private static int byteToUnsigned(final byte b) {\\n        final int value = b;\\n        return value < 0 ? value + 256 : value;\\n    }\\n\\n    private static int dEncrypt(int el, final int r, final int s, final int e0, final int e1, final int sArr[]) {\\n        int v = r ^ r >>> 16;\\n        int u = v & e0;\\n        v &= e1;\\n        u = u ^ u << 16 ^ r ^ sArr[s];\\n        int t = v ^ v << 16 ^ r ^ sArr[s + 1];\\n        t = t >>> 4 | t << 28;\\n        el ^= SPTRANS[1][t & 0x3f] | SPTRANS[3][t >>> 8 & 0x3f] | SPTRANS[5][t >>> 16 & 0x3f] |\\n                SPTRANS[7][t >>> 24 & 0x3f] | SPTRANS[0][u & 0x3f] | SPTRANS[2][u >>> 8 & 0x3f] |\\n                SPTRANS[4][u >>> 16 & 0x3f] | SPTRANS[6][u >>> 24 & 0x3f];\\n        return el;\\n    }\\n\\n    private static int[] desSetKey(final byte key[]) {\\n        final int schedule[] = new int[32];\\n        int c = fourBytesToInt(key, 0);\\n        int d = fourBytesToInt(key, 4);\\n        final int results[] = new int[2];\\n        permOp(d, c, 4, 0xf0f0f0f, results);\\n        d = results[0];\\n        c = results[1];\\n        c = hPermOp(c, -2, 0xcccc0000);\\n        d = hPermOp(d, -2, 0xcccc0000);\\n        permOp(d, c, 1, 0x55555555, results);\\n        d = results[0];\\n        c = results[1];\\n        permOp(c, d, 8, 0xff00ff, results);\\n        c = results[0];\\n        d = results[1];\\n        permOp(d, c, 1, 0x55555555, results);\\n        d = results[0];\\n        c = results[1];\\n        d = (d & 0xff) << 16 | d & 0xff00 | (d & 0xff0000) >>> 16 | (c & 0xf0000000) >>> 4;\\n        c &= 0xfffffff;\\n        int j = 0;\\n        for (int i = 0; i < 16; i++) {\\n            if (SHIFT2[i]) {\\n                c = c >>> 2 | c << 26;\\n                d = d >>> 2 | d << 26;\\n            } else {\\n                c = c >>> 1 | c << 27;\\n                d = d >>> 1 | d << 27;\\n            }\\n            c &= 0xfffffff;\\n            d &= 0xfffffff;\\n            int s = SKB[0][c & 0x3f] | SKB[1][c >>> 6 & 0x3 | c >>> 7 & 0x3c] |\\n                    SKB[2][c >>> 13 & 0xf | c >>> 14 & 0x30] |\\n                    SKB[3][c >>> 20 & 0x1 | c >>> 21 & 0x6 | c >>> 22 & 0x38];\\n            final int t = SKB[4][d & 0x3f] | SKB[5][d >>> 7 & 0x3 | d >>> 8 & 0x3c] | SKB[6][d >>> 15 & 0x3f] |\\n                    SKB[7][d >>> 21 & 0xf | d >>> 22 & 0x30];\\n            schedule[j++] = (t << 16 | s & 0xffff);\\n            s = s >>> 16 | t & 0xffff0000;\\n            s = s << 4 | s >>> 28;\\n            schedule[j++] = s;\\n        }\\n\\n        return schedule;\\n    }\\n\\n    private static int fourBytesToInt(final byte b[], int offset) {\\n        int value = byteToUnsigned(b[offset++]);\\n        value |= byteToUnsigned(b[offset++]) << 8;\\n        value |= byteToUnsigned(b[offset++]) << 16;\\n        value |= byteToUnsigned(b[offset++]) << 24;\\n        return value;\\n    }\\n\\n    private static int hPermOp(int a, final int n, final int m) {\\n        final int t = (a << 16 - n ^ a) & m;\\n        a = a ^ t ^ t >>> 16 - n;\\n        return a;\\n    }\\n\\n    private static void intToFourBytes(final int iValue, final byte b[], int offset) {\\n        b[offset++] = (byte) (iValue & 0xff);\\n        b[offset++] = (byte) (iValue >>> 8 & 0xff);\\n        b[offset++] = (byte) (iValue >>> 16 & 0xff);\\n        b[offset++] = (byte) (iValue >>> 24 & 0xff);\\n    }\\n\\n    private static void permOp(int a, int b, final int n, final int m, final int results[]) {\\n        final int t = (a >>> n ^ b) & m;\\n        a ^= t << n;\\n        b ^= t;\\n        results[0] = a;\\n        results[1] = b;\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"UnixCrypt\", \"position\": {\"start_line\": 40, \"end_line\": 413, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class UnixCrypt {\\n\\n    private static final int CON_SALT[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 5, 6,\\n            7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\\n            34, 35, 36, 37, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\\n            54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0, 0, 0, 0 };\\n\\n    private static final int COV2CHAR[] = { 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70,\\n            71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,\\n            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122 };\\n\\n    private static final char SALT_CHARS[] = \\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./\\\"\\n            .toCharArray();\\n\\n    private static final boolean SHIFT2[] = { false, false, true, true, true, true, true, true, false, true, true,\\n            true, true, true, true, false };\\n\\n    private static final int SKB[][] = {\\n            { 0, 16, 0x20000000, 0x20000010, 0x10000, 0x10010, 0x20010000, 0x20010010, 2048, 2064, 0x20000800,\\n                    0x20000810, 0x10800, 0x10810, 0x20010800, 0x20010810, 32, 48, 0x20000020, 0x20000030, 0x10020,\\n                    0x10030, 0x20010020, 0x20010030, 2080, 2096, 0x20000820, 0x20000830, 0x10820, 0x10830, 0x20010820,\\n                    0x20010830, 0x80000, 0x80010, 0x20080000, 0x20080010, 0x90000, 0x90010, 0x20090000, 0x20090010,\\n                    0x80800, 0x80810, 0x20080800, 0x20080810, 0x90800, 0x90810, 0x20090800, 0x20090810, 0x80020,\\n                    0x80030, 0x20080020, 0x20080030, 0x90020, 0x90030, 0x20090020, 0x20090030, 0x80820, 0x80830,\\n                    0x20080820, 0x20080830, 0x90820, 0x90830, 0x20090820, 0x20090830 },\\n            { 0, 0x2000000, 8192, 0x2002000, 0x200000, 0x2200000, 0x202000, 0x2202000, 4, 0x2000004, 8196, 0x2002004,\\n                    0x200004, 0x2200004, 0x202004, 0x2202004, 1024, 0x2000400, 9216, 0x2002400, 0x200400, 0x2200400,\\n                    0x202400, 0x2202400, 1028, 0x2000404, 9220, 0x2002404, 0x200404, 0x2200404, 0x202404, 0x2202404,\\n                    0x10000000, 0x12000000, 0x10002000, 0x12002000, 0x10200000, 0x12200000, 0x10202000, 0x12202000,\\n                    0x10000004, 0x12000004, 0x10002004, 0x12002004, 0x10200004, 0x12200004, 0x10202004, 0x12202004,\\n                    0x10000400, 0x12000400, 0x10002400, 0x12002400, 0x10200400, 0x12200400, 0x10202400, 0x12202400,\\n                    0x10000404, 0x12000404, 0x10002404, 0x12002404, 0x10200404, 0x12200404, 0x10202404, 0x12202404 },\\n            { 0, 1, 0x40000, 0x40001, 0x1000000, 0x1000001, 0x1040000, 0x1040001, 2, 3, 0x40002, 0x40003, 0x1000002,\\n                    0x1000003, 0x1040002, 0x1040003, 512, 513, 0x40200, 0x40201, 0x1000200, 0x1000201, 0x1040200,\\n                    0x1040201, 514, 515, 0x40202, 0x40203, 0x1000202, 0x1000203, 0x1040202, 0x1040203, 0x8000000,\\n                    0x8000001, 0x8040000, 0x8040001, 0x9000000, 0x9000001, 0x9040000, 0x9040001, 0x8000002, 0x8000003,\\n                    0x8040002, 0x8040003, 0x9000002, 0x9000003, 0x9040002, 0x9040003, 0x8000200, 0x8000201, 0x8040200,\\n                    0x8040201, 0x9000200, 0x9000201, 0x9040200, 0x9040201, 0x8000202, 0x8000203, 0x8040202, 0x8040203,\\n                    0x9000202, 0x9000203, 0x9040202, 0x9040203 },\\n            { 0, 0x100000, 256, 0x100100, 8, 0x100008, 264, 0x100108, 4096, 0x101000, 4352, 0x101100, 4104, 0x101008,\\n                    4360, 0x101108, 0x4000000, 0x4100000, 0x4000100, 0x4100100, 0x4000008, 0x4100008, 0x4000108,\\n                    0x4100108, 0x4001000, 0x4101000, 0x4001100, 0x4101100, 0x4001008, 0x4101008, 0x4001108, 0x4101108,\\n                    0x20000, 0x120000, 0x20100, 0x120100, 0x20008, 0x120008, 0x20108, 0x120108, 0x21000, 0x121000,\\n                    0x21100, 0x121100, 0x21008, 0x121008, 0x21108, 0x121108, 0x4020000, 0x4120000, 0x4020100,\\n                    0x4120100, 0x4020008, 0x4120008, 0x4020108, 0x4120108, 0x4021000, 0x4121000, 0x4021100, 0x4121100,\\n                    0x4021008, 0x4121008, 0x4021108, 0x4121108 },\\n            { 0, 0x10000000, 0x10000, 0x10010000, 4, 0x10000004, 0x10004, 0x10010004, 0x20000000, 0x30000000,\\n                    0x20010000, 0x30010000, 0x20000004, 0x30000004, 0x20010004, 0x30010004, 0x100000, 0x10100000,\\n                    0x110000, 0x10110000, 0x100004, 0x10100004, 0x110004, 0x10110004, 0x20100000, 0x30100000,\\n                    0x20110000, 0x30110000, 0x20100004, 0x30100004, 0x20110004, 0x30110004, 4096, 0x10001000, 0x11000,\\n                    0x10011000, 4100, 0x10001004, 0x11004, 0x10011004, 0x20001000, 0x30001000, 0x20011000, 0x30011000,\\n                    0x20001004, 0x30001004, 0x20011004, 0x30011004, 0x101000, 0x10101000, 0x111000, 0x10111000,\\n                    0x101004, 0x10101004, 0x111004, 0x10111004, 0x20101000, 0x30101000, 0x20111000, 0x30111000,\\n                    0x20101004, 0x30101004, 0x20111004, 0x30111004 },\\n            { 0, 0x8000000, 8, 0x8000008, 1024, 0x8000400, 1032, 0x8000408, 0x20000, 0x8020000, 0x20008, 0x8020008,\\n                    0x20400, 0x8020400, 0x20408, 0x8020408, 1, 0x8000001, 9, 0x8000009, 1025, 0x8000401, 1033,\\n                    0x8000409, 0x20001, 0x8020001, 0x20009, 0x8020009, 0x20401, 0x8020401, 0x20409, 0x8020409,\\n                    0x2000000, 0xa000000, 0x2000008, 0xa000008, 0x2000400, 0xa000400, 0x2000408, 0xa000408, 0x2020000,\\n                    0xa020000, 0x2020008, 0xa020008, 0x2020400, 0xa020400, 0x2020408, 0xa020408, 0x2000001, 0xa000001,\\n                    0x2000009, 0xa000009, 0x2000401, 0xa000401, 0x2000409, 0xa000409, 0x2020001, 0xa020001, 0x2020009,\\n                    0xa020009, 0x2020401, 0xa020401, 0x2020409, 0xa020409 },\\n            { 0, 256, 0x80000, 0x80100, 0x1000000, 0x1000100, 0x1080000, 0x1080100, 16, 272, 0x80010, 0x80110,\\n                    0x1000010, 0x1000110, 0x1080010, 0x1080110, 0x200000, 0x200100, 0x280000, 0x280100, 0x1200000,\\n                    0x1200100, 0x1280000, 0x1280100, 0x200010, 0x200110, 0x280010, 0x280110, 0x1200010, 0x1200110,\\n                    0x1280010, 0x1280110, 512, 768, 0x80200, 0x80300, 0x1000200, 0x1000300, 0x1080200, 0x1080300, 528,\\n                    784, 0x80210, 0x80310, 0x1000210, 0x1000310, 0x1080210, 0x1080310, 0x200200, 0x200300, 0x280200,\\n                    0x280300, 0x1200200, 0x1200300, 0x1280200, 0x1280300, 0x200210, 0x200310, 0x280210, 0x280310,\\n                    0x1200210, 0x1200310, 0x1280210, 0x1280310 },\\n            { 0, 0x4000000, 0x40000, 0x4040000, 2, 0x4000002, 0x40002, 0x4040002, 8192, 0x4002000, 0x42000, 0x4042000,\\n                    8194, 0x4002002, 0x42002, 0x4042002, 32, 0x4000020, 0x40020, 0x4040020, 34, 0x4000022, 0x40022,\\n                    0x4040022, 8224, 0x4002020, 0x42020, 0x4042020, 8226, 0x4002022, 0x42022, 0x4042022, 2048,\\n                    0x4000800, 0x40800, 0x4040800, 2050, 0x4000802, 0x40802, 0x4040802, 10240, 0x4002800, 0x42800,\\n                    0x4042800, 10242, 0x4002802, 0x42802, 0x4042802, 2080, 0x4000820, 0x40820, 0x4040820, 2082,\\n                    0x4000822, 0x40822, 0x4040822, 10272, 0x4002820, 0x42820, 0x4042820, 10274, 0x4002822, 0x42822,\\n                    0x4042822 } };\\n\\n    private static final int SPTRANS[][] = {\\n            { 0x820200, 0x20000, 0x80800000, 0x80820200, 0x800000, 0x80020200, 0x80020000, 0x80800000, 0x80020200,\\n                    0x820200, 0x820000, 0x80000200, 0x80800200, 0x800000, 0, 0x80020000, 0x20000, 0x80000000,\\n                    0x800200, 0x20200, 0x80820200, 0x820000, 0x80000200, 0x800200, 0x80000000, 512, 0x20200,\\n                    0x80820000, 512, 0x80800200, 0x80820000, 0, 0, 0x80820200, 0x800200, 0x80020000, 0x820200,\\n                    0x20000, 0x80000200, 0x800200, 0x80820000, 512, 0x20200, 0x80800000, 0x80020200, 0x80000000,\\n                    0x80800000, 0x820000, 0x80820200, 0x20200, 0x820000, 0x80800200, 0x800000, 0x80000200, 0x80020000,\\n                    0, 0x20000, 0x800000, 0x80800200, 0x820200, 0x80000000, 0x80820000, 512, 0x80020200 },\\n            { 0x10042004, 0, 0x42000, 0x10040000, 0x10000004, 8196, 0x10002000, 0x42000, 8192, 0x10040004, 4,\\n                    0x10002000, 0x40004, 0x10042000, 0x10040000, 4, 0x40000, 0x10002004, 0x10040004, 8192, 0x42004,\\n                    0x10000000, 0, 0x40004, 0x10002004, 0x42004, 0x10042000, 0x10000004, 0x10000000, 0x40000, 8196,\\n                    0x10042004, 0x40004, 0x10042000, 0x10002000, 0x42004, 0x10042004, 0x40004, 0x10000004, 0,\\n                    0x10000000, 8196, 0x40000, 0x10040004, 8192, 0x10000000, 0x42004, 0x10002004, 0x10042000, 8192, 0,\\n                    0x10000004, 4, 0x10042004, 0x42000, 0x10040000, 0x10040004, 0x40000, 8196, 0x10002000, 0x10002004,\\n                    4, 0x10040000, 0x42000 },\\n            { 0x41000000, 0x1010040, 64, 0x41000040, 0x40010000, 0x1000000, 0x41000040, 0x10040, 0x1000040, 0x10000,\\n                    0x1010000, 0x40000000, 0x41010040, 0x40000040, 0x40000000, 0x41010000, 0, 0x40010000, 0x1010040,\\n                    64, 0x40000040, 0x41010040, 0x10000, 0x41000000, 0x41010000, 0x1000040, 0x40010040, 0x1010000,\\n                    0x10040, 0, 0x1000000, 0x40010040, 0x1010040, 64, 0x40000000, 0x10000, 0x40000040, 0x40010000,\\n                    0x1010000, 0x41000040, 0, 0x1010040, 0x10040, 0x41010000, 0x40010000, 0x1000000, 0x41010040,\\n                    0x40000000, 0x40010040, 0x41000000, 0x1000000, 0x41010040, 0x10000, 0x1000040, 0x41000040,\\n                    0x10040, 0x1000040, 0, 0x41010000, 0x40000040, 0x41000000, 0x40010040, 64, 0x1010000 },\\n            { 0x100402, 0x4000400, 2, 0x4100402, 0, 0x4100000, 0x4000402, 0x100002, 0x4100400, 0x4000002, 0x4000000,\\n                    1026, 0x4000002, 0x100402, 0x100000, 0x4000000, 0x4100002, 0x100400, 1024, 2, 0x100400, 0x4000402,\\n                    0x4100000, 1024, 1026, 0, 0x100002, 0x4100400, 0x4000400, 0x4100002, 0x4100402, 0x100000,\\n                    0x4100002, 1026, 0x100000, 0x4000002, 0x100400, 0x4000400, 2, 0x4100000, 0x4000402, 0, 1024,\\n                    0x100002, 0, 0x4100002, 0x4100400, 1024, 0x4000000, 0x4100402, 0x100402, 0x100000, 0x4100402, 2,\\n                    0x4000400, 0x100402, 0x100002, 0x100400, 0x4100000, 0x4000402, 1026, 0x4000000, 0x4000002,\\n                    0x4100400 },\\n            { 0x2000000, 16384, 256, 0x2004108, 0x2004008, 0x2000100, 16648, 0x2004000, 16384, 8, 0x2000008, 16640,\\n                    0x2000108, 0x2004008, 0x2004100, 0, 16640, 0x2000000, 16392, 264, 0x2000100, 16648, 0, 0x2000008,\\n                    8, 0x2000108, 0x2004108, 16392, 0x2004000, 256, 264, 0x2004100, 0x2004100, 0x2000108, 16392,\\n                    0x2004000, 16384, 8, 0x2000008, 0x2000100, 0x2000000, 16640, 0x2004108, 0, 16648, 0x2000000, 256,\\n                    16392, 0x2000108, 256, 0, 0x2004108, 0x2004008, 0x2004100, 264, 16384, 16640, 0x2004008,\\n                    0x2000100, 264, 8, 16648, 0x2004000, 0x2000008 },\\n            { 0x20000010, 0x80010, 0, 0x20080800, 0x80010, 2048, 0x20000810, 0x80000, 2064, 0x20080810, 0x80800,\\n                    0x20000000, 0x20000800, 0x20000010, 0x20080000, 0x80810, 0x80000, 0x20000810, 0x20080010, 0, 2048,\\n                    16, 0x20080800, 0x20080010, 0x20080810, 0x20080000, 0x20000000, 2064, 16, 0x80800, 0x80810,\\n                    0x20000800, 2064, 0x20000000, 0x20000800, 0x80810, 0x20080800, 0x80010, 0, 0x20000800, 0x20000000,\\n                    2048, 0x20080010, 0x80000, 0x80010, 0x20080810, 0x80800, 16, 0x20080810, 0x80800, 0x80000,\\n                    0x20000810, 0x20000010, 0x20080000, 0x80810, 0, 2048, 0x20000010, 0x20000810, 0x20080800,\\n                    0x20080000, 2064, 16, 0x20080010 },\\n            { 4096, 128, 0x400080, 0x400001, 0x401081, 4097, 4224, 0, 0x400000, 0x400081, 129, 0x401000, 1, 0x401080,\\n                    0x401000, 129, 0x400081, 4096, 4097, 0x401081, 0, 0x400080, 0x400001, 4224, 0x401001, 4225,\\n                    0x401080, 1, 4225, 0x401001, 128, 0x400000, 4225, 0x401000, 0x401001, 129, 4096, 128, 0x400000,\\n                    0x401001, 0x400081, 4225, 4224, 0, 128, 0x400001, 1, 0x400080, 0, 0x400081, 0x400080, 4224, 129,\\n                    4096, 0x401081, 0x400000, 0x401080, 1, 4097, 0x401081, 0x400001, 0x401080, 0x401000, 4097 },\\n            { 0x8200020, 0x8208000, 32800, 0, 0x8008000, 0x200020, 0x8200000, 0x8208020, 32, 0x8000000, 0x208000,\\n                    32800, 0x208020, 0x8008020, 0x8000020, 0x8200000, 32768, 0x208020, 0x200020, 0x8008000, 0x8208020,\\n                    0x8000020, 0, 0x208000, 0x8000000, 0x200000, 0x8008020, 0x8200020, 0x200000, 32768, 0x8208000, 32,\\n                    0x200000, 32768, 0x8000020, 0x8208020, 32800, 0x8000000, 0, 0x208000, 0x8200020, 0x8008020,\\n                    0x8008000, 0x200020, 0x8208000, 32, 0x200020, 0x8008000, 0x8208020, 0x200000, 0x8200000,\\n                    0x8000020, 0x208000, 32800, 0x8008020, 0x8200000, 32, 0x8208000, 0x208020, 0, 0x8000000,\\n                    0x8200020, 32768, 0x208020 } };\\n\\n    /**\\n     * Generates a crypt(3) compatible hash using the DES algorithm.\\n     * <p>\\n     * As no salt is given, a random one will be used.\\n     *\\n     * @param original\\n     *            plaintext password\\n     * @return a 13 character string starting with the salt string\\n     */\\n    public static String crypt(final byte[] original) {\\n        return crypt(original, null);\\n    }\\n\\n    /**\\n     * Generates a crypt(3) compatible hash using the DES algorithm.\\n     * <p>\\n     * Using unspecified characters as salt results incompatible hash values.\\n     *\\n     * @param original\\n     *            plaintext password\\n     * @param salt\\n     *            a two character string drawn from [a-zA-Z0-9./] or null for a random one\\n     * @return a 13 character string starting with the salt string\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     */\\n    public static String crypt(final byte[] original, String salt) {\\n        if (salt == null) {\\n            final Random randomGenerator = new Random();\\n            final int numSaltChars = SALT_CHARS.length;\\n            salt = \\\"\\\" + SALT_CHARS[randomGenerator.nextInt(numSaltChars)] +\\n                    SALT_CHARS[randomGenerator.nextInt(numSaltChars)];\\n        } else if (!salt.matches(\\\"^[\\\" + B64.B64T + \\\"]{2,}$\\\")) {\\n            throw new IllegalArgumentException(\\\"Invalid salt value: \\\" + salt);\\n        }\\n\\n        final StringBuilder buffer = new StringBuilder(\\\"             \\\");\\n        final char charZero = salt.charAt(0);\\n        final char charOne = salt.charAt(1);\\n        buffer.setCharAt(0, charZero);\\n        buffer.setCharAt(1, charOne);\\n        final int eSwap0 = CON_SALT[charZero];\\n        final int eSwap1 = CON_SALT[charOne] << 4;\\n        final byte key[] = new byte[8];\\n        for (int i = 0; i < key.length; i++) {\\n            key[i] = 0;\\n        }\\n\\n        for (int i = 0; i < key.length && i < original.length; i++) {\\n            final int iChar = original[i];\\n            key[i] = (byte) (iChar << 1);\\n        }\\n\\n        final int schedule[] = desSetKey(key);\\n        final int out[] = body(schedule, eSwap0, eSwap1);\\n        final byte b[] = new byte[9];\\n        intToFourBytes(out[0], b, 0);\\n        intToFourBytes(out[1], b, 4);\\n        b[8] = 0;\\n        int i = 2;\\n        int y = 0;\\n        int u = 128;\\n        for (; i < 13; i++) {\\n            int j = 0;\\n            int c = 0;\\n            for (; j < 6; j++) {\\n                c <<= 1;\\n                if ((b[y] & u) != 0) {\\n                    c |= 0x1;\\n                }\\n                u >>>= 1;\\n                if (u == 0) {\\n                    y++;\\n                    u = 128;\\n                }\\n                buffer.setCharAt(i, (char) COV2CHAR[c]);\\n            }\\n        }\\n        return buffer.toString();\\n    }\\n\\n    /**\\n     * Generates a crypt(3) compatible hash using the DES algorithm.\\n     * <p>\\n     * As no salt is given, a random one is used.\\n     *\\n     * @param original\\n     *            plaintext password\\n     * @return a 13 character string starting with the salt string\\n     */\\n    public static String crypt(final String original) {\\n        return crypt(original.getBytes(Charsets.UTF_8));\\n    }\\n\\n    /**\\n     * Generates a crypt(3) compatible hash using the DES algorithm.\\n     *\\n     * @param original\\n     *            plaintext password\\n     * @param salt\\n     *            a two character string drawn from [a-zA-Z0-9./] or null for a random one\\n     * @return a 13 character string starting with the salt string\\n     * @throws IllegalArgumentException\\n     *             if the salt does not match the allowed pattern\\n     */\\n    public static String crypt(final String original, final String salt) {\\n        return crypt(original.getBytes(Charsets.UTF_8), salt);\\n    }\\n\\n    private static int[] body(final int schedule[], final int eSwap0, final int eSwap1) {\\n        int left = 0;\\n        int right = 0;\\n        int t = 0;\\n        for (int j = 0; j < 25; j++) {\\n            for (int i = 0; i < 32; i += 4) {\\n                left = dEncrypt(left, right, i, eSwap0, eSwap1, schedule);\\n                right = dEncrypt(right, left, i + 2, eSwap0, eSwap1, schedule);\\n            }\\n            t = left;\\n            left = right;\\n            right = t;\\n        }\\n\\n        t = right;\\n        right = left >>> 1 | left << 31;\\n        left = t >>> 1 | t << 31;\\n        final int results[] = new int[2];\\n        permOp(right, left, 1, 0x55555555, results);\\n        right = results[0];\\n        left = results[1];\\n        permOp(left, right, 8, 0xff00ff, results);\\n        left = results[0];\\n        right = results[1];\\n        permOp(right, left, 2, 0x33333333, results);\\n        right = results[0];\\n        left = results[1];\\n        permOp(left, right, 16, 65535, results);\\n        left = results[0];\\n        right = results[1];\\n        permOp(right, left, 4, 0xf0f0f0f, results);\\n        right = results[0];\\n        left = results[1];\\n        final int out[] = new int[2];\\n        out[0] = left;\\n        out[1] = right;\\n        return out;\\n    }\\n\\n    private static int byteToUnsigned(final byte b) {\\n        final int value = b;\\n        return value < 0 ? value + 256 : value;\\n    }\\n\\n    private static int dEncrypt(int el, final int r, final int s, final int e0, final int e1, final int sArr[]) {\\n        int v = r ^ r >>> 16;\\n        int u = v & e0;\\n        v &= e1;\\n        u = u ^ u << 16 ^ r ^ sArr[s];\\n        int t = v ^ v << 16 ^ r ^ sArr[s + 1];\\n        t = t >>> 4 | t << 28;\\n        el ^= SPTRANS[1][t & 0x3f] | SPTRANS[3][t >>> 8 & 0x3f] | SPTRANS[5][t >>> 16 & 0x3f] |\\n                SPTRANS[7][t >>> 24 & 0x3f] | SPTRANS[0][u & 0x3f] | SPTRANS[2][u >>> 8 & 0x3f] |\\n                SPTRANS[4][u >>> 16 & 0x3f] | SPTRANS[6][u >>> 24 & 0x3f];\\n        return el;\\n    }\\n\\n    private static int[] desSetKey(final byte key[]) {\\n        final int schedule[] = new int[32];\\n        int c = fourBytesToInt(key, 0);\\n        int d = fourBytesToInt(key, 4);\\n        final int results[] = new int[2];\\n        permOp(d, c, 4, 0xf0f0f0f, results);\\n        d = results[0];\\n        c = results[1];\\n        c = hPermOp(c, -2, 0xcccc0000);\\n        d = hPermOp(d, -2, 0xcccc0000);\\n        permOp(d, c, 1, 0x55555555, results);\\n        d = results[0];\\n        c = results[1];\\n        permOp(c, d, 8, 0xff00ff, results);\\n        c = results[0];\\n        d = results[1];\\n        permOp(d, c, 1, 0x55555555, results);\\n        d = results[0];\\n        c = results[1];\\n        d = (d & 0xff) << 16 | d & 0xff00 | (d & 0xff0000) >>> 16 | (c & 0xf0000000) >>> 4;\\n        c &= 0xfffffff;\\n        int j = 0;\\n        for (int i = 0; i < 16; i++) {\\n            if (SHIFT2[i]) {\\n                c = c >>> 2 | c << 26;\\n                d = d >>> 2 | d << 26;\\n            } else {\\n                c = c >>> 1 | c << 27;\\n                d = d >>> 1 | d << 27;\\n            }\\n            c &= 0xfffffff;\\n            d &= 0xfffffff;\\n            int s = SKB[0][c & 0x3f] | SKB[1][c >>> 6 & 0x3 | c >>> 7 & 0x3c] |\\n                    SKB[2][c >>> 13 & 0xf | c >>> 14 & 0x30] |\\n                    SKB[3][c >>> 20 & 0x1 | c >>> 21 & 0x6 | c >>> 22 & 0x38];\\n            final int t = SKB[4][d & 0x3f] | SKB[5][d >>> 7 & 0x3 | d >>> 8 & 0x3c] | SKB[6][d >>> 15 & 0x3f] |\\n                    SKB[7][d >>> 21 & 0xf | d >>> 22 & 0x30];\\n            schedule[j++] = (t << 16 | s & 0xffff);\\n            s = s >>> 16 | t & 0xffff0000;\\n            s = s << 4 | s >>> 28;\\n            schedule[j++] = s;\\n        }\\n\\n        return schedule;\\n    }\\n\\n    private static int fourBytesToInt(final byte b[], int offset) {\\n        int value = byteToUnsigned(b[offset++]);\\n        value |= byteToUnsigned(b[offset++]) << 8;\\n        value |= byteToUnsigned(b[offset++]) << 16;\\n        value |= byteToUnsigned(b[offset++]) << 24;\\n        return value;\\n    }\\n\\n    private static int hPermOp(int a, final int n, final int m) {\\n        final int t = (a << 16 - n ^ a) & m;\\n        a = a ^ t ^ t >>> 16 - n;\\n        return a;\\n    }\\n\\n    private static void intToFourBytes(final int iValue, final byte b[], int offset) {\\n        b[offset++] = (byte) (iValue & 0xff);\\n        b[offset++] = (byte) (iValue >>> 8 & 0xff);\\n        b[offset++] = (byte) (iValue >>> 16 & 0xff);\\n        b[offset++] = (byte) (iValue >>> 24 & 0xff);\\n    }\\n\\n    private static void permOp(int a, int b, final int n, final int m, final int results[]) {\\n        final int t = (a >>> n ^ b) & m;\\n        a ^= t << n;\\n        b ^= t;\\n        results[0] = a;\\n        results[1] = b;\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 181, \"end_line\": 183, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String crypt(final byte[] original) {\\n        return crypt(original, null);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"original\", \"type\": \"byte\"}]}, {\"name\": \"crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 198, \"end_line\": 251, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String crypt(final byte[] original, String salt) {\\n        if (salt == null) {\\n            final Random randomGenerator = new Random();\\n            final int numSaltChars = SALT_CHARS.length;\\n            salt = \\\"\\\" + SALT_CHARS[randomGenerator.nextInt(numSaltChars)] +\\n                    SALT_CHARS[randomGenerator.nextInt(numSaltChars)];\\n        } else if (!salt.matches(\\\"^[\\\" + B64.B64T + \\\"]{2,}$\\\")) {\\n            throw new IllegalArgumentException(\\\"Invalid salt value: \\\" + salt);\\n        }\\n\\n        final StringBuilder buffer = new StringBuilder(\\\"             \\\");\\n        final char charZero = salt.charAt(0);\\n        final char charOne = salt.charAt(1);\\n        buffer.setCharAt(0, charZero);\\n        buffer.setCharAt(1, charOne);\\n        final int eSwap0 = CON_SALT[charZero];\\n        final int eSwap1 = CON_SALT[charOne] << 4;\\n        final byte key[] = new byte[8];\\n        for (int i = 0; i < key.length; i++) {\\n            key[i] = 0;\\n        }\\n\\n        for (int i = 0; i < key.length && i < original.length; i++) {\\n            final int iChar = original[i];\\n            key[i] = (byte) (iChar << 1);\\n        }\\n\\n        final int schedule[] = desSetKey(key);\\n        final int out[] = body(schedule, eSwap0, eSwap1);\\n        final byte b[] = new byte[9];\\n        intToFourBytes(out[0], b, 0);\\n        intToFourBytes(out[1], b, 4);\\n        b[8] = 0;\\n        int i = 2;\\n        int y = 0;\\n        int u = 128;\\n        for (; i < 13; i++) {\\n            int j = 0;\\n            int c = 0;\\n            for (; j < 6; j++) {\\n                c <<= 1;\\n                if ((b[y] & u) != 0) {\\n                    c |= 0x1;\\n                }\\n                u >>>= 1;\\n                if (u == 0) {\\n                    y++;\\n                    u = 128;\\n                }\\n                buffer.setCharAt(i, (char) COV2CHAR[c]);\\n            }\\n        }\\n        return buffer.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"original\", \"type\": \"byte\"}, {\"name\": \"salt\", \"type\": \"String\"}]}, {\"name\": \"crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 262, \"end_line\": 264, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String crypt(final String original) {\\n        return crypt(original.getBytes(Charsets.UTF_8));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"original\", \"type\": \"String\"}]}, {\"name\": \"crypt\", \"return_type\": \"String\", \"position\": {\"start_line\": 277, \"end_line\": 279, \"start_column\": 19, \"end_column\": 5}, \"code\": \"String crypt(final String original, final String salt) {\\n        return crypt(original.getBytes(Charsets.UTF_8), salt);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"original\", \"type\": \"String\"}, {\"name\": \"salt\", \"type\": \"String\"}]}, {\"name\": \"body\", \"return_type\": \"int\", \"position\": {\"start_line\": 281, \"end_line\": 318, \"start_column\": 20, \"end_column\": 5}, \"code\": \"int[] body(final int schedule[], final int eSwap0, final int eSwap1) {\\n        int left = 0;\\n        int right = 0;\\n        int t = 0;\\n        for (int j = 0; j < 25; j++) {\\n            for (int i = 0; i < 32; i += 4) {\\n                left = dEncrypt(left, right, i, eSwap0, eSwap1, schedule);\\n                right = dEncrypt(right, left, i + 2, eSwap0, eSwap1, schedule);\\n            }\\n            t = left;\\n            left = right;\\n            right = t;\\n        }\\n\\n        t = right;\\n        right = left >>> 1 | left << 31;\\n        left = t >>> 1 | t << 31;\\n        final int results[] = new int[2];\\n        permOp(right, left, 1, 0x55555555, results);\\n        right = results[0];\\n        left = results[1];\\n        permOp(left, right, 8, 0xff00ff, results);\\n        left = results[0];\\n        right = results[1];\\n        permOp(right, left, 2, 0x33333333, results);\\n        right = results[0];\\n        left = results[1];\\n        permOp(left, right, 16, 65535, results);\\n        left = results[0];\\n        right = results[1];\\n        permOp(right, left, 4, 0xf0f0f0f, results);\\n        right = results[0];\\n        left = results[1];\\n        final int out[] = new int[2];\\n        out[0] = left;\\n        out[1] = right;\\n        return out;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"schedule\", \"type\": \"int\"}, {\"name\": \"eSwap0\", \"type\": \"int\"}, {\"name\": \"eSwap1\", \"type\": \"int\"}]}, {\"name\": \"byteToUnsigned\", \"return_type\": \"int\", \"position\": {\"start_line\": 320, \"end_line\": 323, \"start_column\": 20, \"end_column\": 5}, \"code\": \"int byteToUnsigned(final byte b) {\\n        final int value = b;\\n        return value < 0 ? value + 256 : value;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"byte\"}]}, {\"name\": \"dEncrypt\", \"return_type\": \"int\", \"position\": {\"start_line\": 325, \"end_line\": 336, \"start_column\": 20, \"end_column\": 5}, \"code\": \"int dEncrypt(int el, final int r, final int s, final int e0, final int e1, final int sArr[]) {\\n        int v = r ^ r >>> 16;\\n        int u = v & e0;\\n        v &= e1;\\n        u = u ^ u << 16 ^ r ^ sArr[s];\\n        int t = v ^ v << 16 ^ r ^ sArr[s + 1];\\n        t = t >>> 4 | t << 28;\\n        el ^= SPTRANS[1][t & 0x3f] | SPTRANS[3][t >>> 8 & 0x3f] | SPTRANS[5][t >>> 16 & 0x3f] |\\n                SPTRANS[7][t >>> 24 & 0x3f] | SPTRANS[0][u & 0x3f] | SPTRANS[2][u >>> 8 & 0x3f] |\\n                SPTRANS[4][u >>> 16 & 0x3f] | SPTRANS[6][u >>> 24 & 0x3f];\\n        return el;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"el\", \"type\": \"int\"}, {\"name\": \"r\", \"type\": \"int\"}, {\"name\": \"s\", \"type\": \"int\"}, {\"name\": \"e0\", \"type\": \"int\"}, {\"name\": \"e1\", \"type\": \"int\"}, {\"name\": \"sArr\", \"type\": \"int\"}]}, {\"name\": \"desSetKey\", \"return_type\": \"int\", \"position\": {\"start_line\": 338, \"end_line\": 382, \"start_column\": 20, \"end_column\": 5}, \"code\": \"int[] desSetKey(final byte key[]) {\\n        final int schedule[] = new int[32];\\n        int c = fourBytesToInt(key, 0);\\n        int d = fourBytesToInt(key, 4);\\n        final int results[] = new int[2];\\n        permOp(d, c, 4, 0xf0f0f0f, results);\\n        d = results[0];\\n        c = results[1];\\n        c = hPermOp(c, -2, 0xcccc0000);\\n        d = hPermOp(d, -2, 0xcccc0000);\\n        permOp(d, c, 1, 0x55555555, results);\\n        d = results[0];\\n        c = results[1];\\n        permOp(c, d, 8, 0xff00ff, results);\\n        c = results[0];\\n        d = results[1];\\n        permOp(d, c, 1, 0x55555555, results);\\n        d = results[0];\\n        c = results[1];\\n        d = (d & 0xff) << 16 | d & 0xff00 | (d & 0xff0000) >>> 16 | (c & 0xf0000000) >>> 4;\\n        c &= 0xfffffff;\\n        int j = 0;\\n        for (int i = 0; i < 16; i++) {\\n            if (SHIFT2[i]) {\\n                c = c >>> 2 | c << 26;\\n                d = d >>> 2 | d << 26;\\n            } else {\\n                c = c >>> 1 | c << 27;\\n                d = d >>> 1 | d << 27;\\n            }\\n            c &= 0xfffffff;\\n            d &= 0xfffffff;\\n            int s = SKB[0][c & 0x3f] | SKB[1][c >>> 6 & 0x3 | c >>> 7 & 0x3c] |\\n                    SKB[2][c >>> 13 & 0xf | c >>> 14 & 0x30] |\\n                    SKB[3][c >>> 20 & 0x1 | c >>> 21 & 0x6 | c >>> 22 & 0x38];\\n            final int t = SKB[4][d & 0x3f] | SKB[5][d >>> 7 & 0x3 | d >>> 8 & 0x3c] | SKB[6][d >>> 15 & 0x3f] |\\n                    SKB[7][d >>> 21 & 0xf | d >>> 22 & 0x30];\\n            schedule[j++] = (t << 16 | s & 0xffff);\\n            s = s >>> 16 | t & 0xffff0000;\\n            s = s << 4 | s >>> 28;\\n            schedule[j++] = s;\\n        }\\n\\n        return schedule;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"key\", \"type\": \"byte\"}]}, {\"name\": \"fourBytesToInt\", \"return_type\": \"int\", \"position\": {\"start_line\": 384, \"end_line\": 390, \"start_column\": 20, \"end_column\": 5}, \"code\": \"int fourBytesToInt(final byte b[], int offset) {\\n        int value = byteToUnsigned(b[offset++]);\\n        value |= byteToUnsigned(b[offset++]) << 8;\\n        value |= byteToUnsigned(b[offset++]) << 16;\\n        value |= byteToUnsigned(b[offset++]) << 24;\\n        return value;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"byte\"}, {\"name\": \"offset\", \"type\": \"int\"}]}, {\"name\": \"hPermOp\", \"return_type\": \"int\", \"position\": {\"start_line\": 392, \"end_line\": 396, \"start_column\": 20, \"end_column\": 5}, \"code\": \"int hPermOp(int a, final int n, final int m) {\\n        final int t = (a << 16 - n ^ a) & m;\\n        a = a ^ t ^ t >>> 16 - n;\\n        return a;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"a\", \"type\": \"int\"}, {\"name\": \"n\", \"type\": \"int\"}, {\"name\": \"m\", \"type\": \"int\"}]}, {\"name\": \"intToFourBytes\", \"return_type\": \"void\", \"position\": {\"start_line\": 398, \"end_line\": 403, \"start_column\": 20, \"end_column\": 5}, \"code\": \"void intToFourBytes(final int iValue, final byte b[], int offset) {\\n        b[offset++] = (byte) (iValue & 0xff);\\n        b[offset++] = (byte) (iValue >>> 8 & 0xff);\\n        b[offset++] = (byte) (iValue >>> 16 & 0xff);\\n        b[offset++] = (byte) (iValue >>> 24 & 0xff);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"iValue\", \"type\": \"int\"}, {\"name\": \"b\", \"type\": \"byte\"}, {\"name\": \"offset\", \"type\": \"int\"}]}, {\"name\": \"permOp\", \"return_type\": \"void\", \"position\": {\"start_line\": 405, \"end_line\": 411, \"start_column\": 20, \"end_column\": 5}, \"code\": \"void permOp(int a, int b, final int n, final int m, final int results[]) {\\n        final int t = (a >>> n ^ b) & m;\\n        a ^= t << n;\\n        b ^= t;\\n        results[0] = a;\\n        results[1] = b;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"a\", \"type\": \"int\"}, {\"name\": \"b\", \"type\": \"int\"}, {\"name\": \"n\", \"type\": \"int\"}, {\"name\": \"m\", \"type\": \"int\"}, {\"name\": \"results\", \"type\": \"int\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/digest/XXHash32.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one\\n * or more contributor license agreements.  See the NOTICE file\\n * distributed with this work for additional information\\n * regarding copyright ownership.  The ASF licenses this file\\n * to you under the Apache License, Version 2.0 (the\\n * \\\"License\\\"); you may not use this file except in compliance\\n * with the License.  You may obtain a copy of the License at\\n *\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing,\\n * software distributed under the License is distributed on an\\n * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n * KIND, either express or implied.  See the License for the\\n * specific language governing permissions and limitations\\n * under the License.\\n */\\npackage org.apache.commons.codec.digest;\\n\\nimport static java.lang.Integer.rotateLeft;\\n\\nimport java.util.zip.Checksum;\\n\\n/**\\n * Implementation of the xxhash32 hash algorithm.\\n *\\n * <p>Copied from Commons Compress 1.14\\n * <a href=\\\"https://git-wip-us.apache.org/repos/asf?p=commons-compress.git;a=blob;f=src/main/java/org/apache/commons/compress/compressors/lz4/XXHash32.java;h=a406ffc197449be594d46f0d2712b2d4786a1e68;hb=HEAD\\\">https://git-wip-us.apache.org/repos/asf?p=commons-compress.git;a=blob;f=src/main/java/org/apache/commons/compress/compressors/lz4/XXHash32.java;h=a406ffc197449be594d46f0d2712b2d4786a1e68;hb=HEAD</a></p>\\n * <p>NotThreadSafe</p>\\n * @see <a href=\\\"http://cyan4973.github.io/xxHash/\\\">xxHash</a>\\n * @since 1.11\\n */\\npublic class XXHash32 implements Checksum {\\n\\n    private static final int BUF_SIZE = 16;\\n    private static final int ROTATE_BITS = 13;\\n\\n    private static final int PRIME1 = (int) 2654435761l;\\n    private static final int PRIME2 = (int) 2246822519l;\\n    private static final int PRIME3 = (int) 3266489917l;\\n    private static final int PRIME4 =  668265263;\\n    private static final int PRIME5 =  374761393;\\n\\n    private final byte[] oneByte = new byte[1];\\n    private final int[] state = new int[4];\\n    // Note: the code used to use ByteBuffer but the manual method is 50% faster\\n    // See: http://git-wip-us.apache.org/repos/asf/commons-compress/diff/2f56fb5c\\n    private final byte[] buffer = new byte[BUF_SIZE];\\n    private final int seed;\\n\\n    private int totalLen;\\n    private int pos;\\n\\n    /**\\n     * Creates an XXHash32 instance with a seed of 0.\\n     */\\n    public XXHash32() {\\n        this(0);\\n    }\\n\\n    /**\\n     * Creates an XXHash32 instance.\\n     * @param seed the seed to use\\n     */\\n    public XXHash32(final int seed) {\\n        this.seed = seed;\\n        initializeState();\\n    }\\n\\n    @Override\\n    public void reset() {\\n        initializeState();\\n        totalLen = 0;\\n        pos = 0;\\n    }\\n\\n    @Override\\n    public void update(final int b) {\\n        oneByte[0] = (byte) (b & 0xff);\\n        update(oneByte, 0, 1);\\n    }\\n\\n    @Override\\n    public void update(final byte[] b, int off, final int len) {\\n        if (len <= 0) {\\n            return;\\n        }\\n        totalLen += len;\\n\\n        final int end = off + len;\\n\\n        if (pos + len < BUF_SIZE) {\\n            System.arraycopy(b, off, buffer, pos, len);\\n            pos += len;\\n            return;\\n        }\\n\\n        if (pos > 0) {\\n            final int size = BUF_SIZE - pos;\\n            System.arraycopy(b, off, buffer, pos, size);\\n            process(buffer, 0);\\n            off += size;\\n        }\\n\\n        final int limit = end - BUF_SIZE;\\n        while (off <= limit) {\\n            process(b, off);\\n            off += BUF_SIZE;\\n        }\\n\\n        if (off < end) {\\n            pos = end - off;\\n            System.arraycopy(b, off, buffer, 0, pos);\\n        }\\n    }\\n\\n    @Override\\n    public long getValue() {\\n        int hash;\\n        if (totalLen > BUF_SIZE) {\\n            hash =\\n                rotateLeft(state[0],  1) +\\n                rotateLeft(state[1],  7) +\\n                rotateLeft(state[2], 12) +\\n                rotateLeft(state[3], 18);\\n        } else {\\n            hash = state[2] + PRIME5;\\n        }\\n        hash += totalLen;\\n\\n        int idx = 0;\\n        final int limit = pos - 4;\\n        for (; idx <= limit; idx += 4) {\\n            hash = rotateLeft(hash + getInt(buffer, idx) * PRIME3, 17) * PRIME4;\\n        }\\n        while (idx < pos) {\\n            hash = rotateLeft(hash + (buffer[idx++] & 0xff) * PRIME5, 11) * PRIME1;\\n        }\\n\\n        hash ^= hash >>> 15;\\n        hash *= PRIME2;\\n        hash ^= hash >>> 13;\\n        hash *= PRIME3;\\n        hash ^= hash >>> 16;\\n        return hash & 0xffffffffl;\\n    }\\n\\n    private static int getInt(final byte[] buffer, final int idx) {\\n        return (int) (fromLittleEndian(buffer, idx, 4) & 0xffffffffl);\\n    }\\n\\n    private void initializeState() {\\n        state[0] = seed + PRIME1 + PRIME2;\\n        state[1] = seed + PRIME2;\\n        state[2] = seed;\\n        state[3] = seed - PRIME1;\\n    }\\n\\n    private void process(final byte[] b, final int offset) {\\n        // local shadows for performance\\n        int s0 = state[0];\\n        int s1 = state[1];\\n        int s2 = state[2];\\n        int s3 = state[3];\\n\\n        s0 = rotateLeft(s0 + getInt(b, offset) * PRIME2, ROTATE_BITS) * PRIME1;\\n        s1 = rotateLeft(s1 + getInt(b, offset + 4) * PRIME2, ROTATE_BITS) * PRIME1;\\n        s2 = rotateLeft(s2 + getInt(b, offset + 8) * PRIME2, ROTATE_BITS) * PRIME1;\\n        s3 = rotateLeft(s3 + getInt(b, offset + 12) * PRIME2, ROTATE_BITS) * PRIME1;\\n\\n        state[0] = s0;\\n        state[1] = s1;\\n        state[2] = s2;\\n        state[3] = s3;\\n\\n        pos = 0;\\n    }\\n\\n    /**\\n     * Reads the given byte array as a little endian long.\\n     * @param bytes the byte array to convert\\n     * @param off the offset into the array that starts the value\\n     * @param length the number of bytes representing the value\\n     * @return the number read\\n     * @throws IllegalArgumentException if len is bigger than eight\\n     */\\n    private static long fromLittleEndian(final byte[] bytes, final int off, final int length) {\\n        if (length > 8) {\\n            throw new IllegalArgumentException(\\\"can't read more than eight bytes into a long value\\\");\\n        }\\n        long l = 0;\\n        for (int i = 0; i < length; i++) {\\n            l |= (bytes[off + i] & 0xffl) << (8 * i);\\n        }\\n        return l;\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"XXHash32\", \"position\": {\"start_line\": 34, \"end_line\": 198, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class XXHash32 implements Checksum {\\n\\n    private static final int BUF_SIZE = 16;\\n    private static final int ROTATE_BITS = 13;\\n\\n    private static final int PRIME1 = (int) 2654435761l;\\n    private static final int PRIME2 = (int) 2246822519l;\\n    private static final int PRIME3 = (int) 3266489917l;\\n    private static final int PRIME4 =  668265263;\\n    private static final int PRIME5 =  374761393;\\n\\n    private final byte[] oneByte = new byte[1];\\n    private final int[] state = new int[4];\\n    // Note: the code used to use ByteBuffer but the manual method is 50% faster\\n    // See: http://git-wip-us.apache.org/repos/asf/commons-compress/diff/2f56fb5c\\n    private final byte[] buffer = new byte[BUF_SIZE];\\n    private final int seed;\\n\\n    private int totalLen;\\n    private int pos;\\n\\n    /**\\n     * Creates an XXHash32 instance with a seed of 0.\\n     */\\n    public XXHash32() {\\n        this(0);\\n    }\\n\\n    /**\\n     * Creates an XXHash32 instance.\\n     * @param seed the seed to use\\n     */\\n    public XXHash32(final int seed) {\\n        this.seed = seed;\\n        initializeState();\\n    }\\n\\n    @Override\\n    public void reset() {\\n        initializeState();\\n        totalLen = 0;\\n        pos = 0;\\n    }\\n\\n    @Override\\n    public void update(final int b) {\\n        oneByte[0] = (byte) (b & 0xff);\\n        update(oneByte, 0, 1);\\n    }\\n\\n    @Override\\n    public void update(final byte[] b, int off, final int len) {\\n        if (len <= 0) {\\n            return;\\n        }\\n        totalLen += len;\\n\\n        final int end = off + len;\\n\\n        if (pos + len < BUF_SIZE) {\\n            System.arraycopy(b, off, buffer, pos, len);\\n            pos += len;\\n            return;\\n        }\\n\\n        if (pos > 0) {\\n            final int size = BUF_SIZE - pos;\\n            System.arraycopy(b, off, buffer, pos, size);\\n            process(buffer, 0);\\n            off += size;\\n        }\\n\\n        final int limit = end - BUF_SIZE;\\n        while (off <= limit) {\\n            process(b, off);\\n            off += BUF_SIZE;\\n        }\\n\\n        if (off < end) {\\n            pos = end - off;\\n            System.arraycopy(b, off, buffer, 0, pos);\\n        }\\n    }\\n\\n    @Override\\n    public long getValue() {\\n        int hash;\\n        if (totalLen > BUF_SIZE) {\\n            hash =\\n                rotateLeft(state[0],  1) +\\n                rotateLeft(state[1],  7) +\\n                rotateLeft(state[2], 12) +\\n                rotateLeft(state[3], 18);\\n        } else {\\n            hash = state[2] + PRIME5;\\n        }\\n        hash += totalLen;\\n\\n        int idx = 0;\\n        final int limit = pos - 4;\\n        for (; idx <= limit; idx += 4) {\\n            hash = rotateLeft(hash + getInt(buffer, idx) * PRIME3, 17) * PRIME4;\\n        }\\n        while (idx < pos) {\\n            hash = rotateLeft(hash + (buffer[idx++] & 0xff) * PRIME5, 11) * PRIME1;\\n        }\\n\\n        hash ^= hash >>> 15;\\n        hash *= PRIME2;\\n        hash ^= hash >>> 13;\\n        hash *= PRIME3;\\n        hash ^= hash >>> 16;\\n        return hash & 0xffffffffl;\\n    }\\n\\n    private static int getInt(final byte[] buffer, final int idx) {\\n        return (int) (fromLittleEndian(buffer, idx, 4) & 0xffffffffl);\\n    }\\n\\n    private void initializeState() {\\n        state[0] = seed + PRIME1 + PRIME2;\\n        state[1] = seed + PRIME2;\\n        state[2] = seed;\\n        state[3] = seed - PRIME1;\\n    }\\n\\n    private void process(final byte[] b, final int offset) {\\n        // local shadows for performance\\n        int s0 = state[0];\\n        int s1 = state[1];\\n        int s2 = state[2];\\n        int s3 = state[3];\\n\\n        s0 = rotateLeft(s0 + getInt(b, offset) * PRIME2, ROTATE_BITS) * PRIME1;\\n        s1 = rotateLeft(s1 + getInt(b, offset + 4) * PRIME2, ROTATE_BITS) * PRIME1;\\n        s2 = rotateLeft(s2 + getInt(b, offset + 8) * PRIME2, ROTATE_BITS) * PRIME1;\\n        s3 = rotateLeft(s3 + getInt(b, offset + 12) * PRIME2, ROTATE_BITS) * PRIME1;\\n\\n        state[0] = s0;\\n        state[1] = s1;\\n        state[2] = s2;\\n        state[3] = s3;\\n\\n        pos = 0;\\n    }\\n\\n    /**\\n     * Reads the given byte array as a little endian long.\\n     * @param bytes the byte array to convert\\n     * @param off the offset into the array that starts the value\\n     * @param length the number of bytes representing the value\\n     * @return the number read\\n     * @throws IllegalArgumentException if len is bigger than eight\\n     */\\n    private static long fromLittleEndian(final byte[] bytes, final int off, final int length) {\\n        if (length > 8) {\\n            throw new IllegalArgumentException(\\\"can't read more than eight bytes into a long value\\\");\\n        }\\n        long l = 0;\\n        for (int i = 0; i < length; i++) {\\n            l |= (bytes[off + i] & 0xffl) << (8 * i);\\n        }\\n        return l;\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"reset\", \"return_type\": \"void\", \"position\": {\"start_line\": 72, \"end_line\": 76, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void reset() {\\n        initializeState();\\n        totalLen = 0;\\n        pos = 0;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"update\", \"return_type\": \"void\", \"position\": {\"start_line\": 79, \"end_line\": 82, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void update(final int b) {\\n        oneByte[0] = (byte) (b & 0xff);\\n        update(oneByte, 0, 1);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"int\"}]}, {\"name\": \"update\", \"return_type\": \"void\", \"position\": {\"start_line\": 85, \"end_line\": 116, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void update(final byte[] b, int off, final int len) {\\n        if (len <= 0) {\\n            return;\\n        }\\n        totalLen += len;\\n\\n        final int end = off + len;\\n\\n        if (pos + len < BUF_SIZE) {\\n            System.arraycopy(b, off, buffer, pos, len);\\n            pos += len;\\n            return;\\n        }\\n\\n        if (pos > 0) {\\n            final int size = BUF_SIZE - pos;\\n            System.arraycopy(b, off, buffer, pos, size);\\n            process(buffer, 0);\\n            off += size;\\n        }\\n\\n        final int limit = end - BUF_SIZE;\\n        while (off <= limit) {\\n            process(b, off);\\n            off += BUF_SIZE;\\n        }\\n\\n        if (off < end) {\\n            pos = end - off;\\n            System.arraycopy(b, off, buffer, 0, pos);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"byte\"}, {\"name\": \"off\", \"type\": \"int\"}, {\"name\": \"len\", \"type\": \"int\"}]}, {\"name\": \"getValue\", \"return_type\": \"long\", \"position\": {\"start_line\": 119, \"end_line\": 147, \"start_column\": 12, \"end_column\": 5}, \"code\": \"long getValue() {\\n        int hash;\\n        if (totalLen > BUF_SIZE) {\\n            hash =\\n                rotateLeft(state[0],  1) +\\n                rotateLeft(state[1],  7) +\\n                rotateLeft(state[2], 12) +\\n                rotateLeft(state[3], 18);\\n        } else {\\n            hash = state[2] + PRIME5;\\n        }\\n        hash += totalLen;\\n\\n        int idx = 0;\\n        final int limit = pos - 4;\\n        for (; idx <= limit; idx += 4) {\\n            hash = rotateLeft(hash + getInt(buffer, idx) * PRIME3, 17) * PRIME4;\\n        }\\n        while (idx < pos) {\\n            hash = rotateLeft(hash + (buffer[idx++] & 0xff) * PRIME5, 11) * PRIME1;\\n        }\\n\\n        hash ^= hash >>> 15;\\n        hash *= PRIME2;\\n        hash ^= hash >>> 13;\\n        hash *= PRIME3;\\n        hash ^= hash >>> 16;\\n        return hash & 0xffffffffl;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getInt\", \"return_type\": \"int\", \"position\": {\"start_line\": 149, \"end_line\": 151, \"start_column\": 20, \"end_column\": 5}, \"code\": \"int getInt(final byte[] buffer, final int idx) {\\n        return (int) (fromLittleEndian(buffer, idx, 4) & 0xffffffffl);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"buffer\", \"type\": \"byte\"}, {\"name\": \"idx\", \"type\": \"int\"}]}, {\"name\": \"initializeState\", \"return_type\": \"void\", \"position\": {\"start_line\": 153, \"end_line\": 158, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void initializeState() {\\n        state[0] = seed + PRIME1 + PRIME2;\\n        state[1] = seed + PRIME2;\\n        state[2] = seed;\\n        state[3] = seed - PRIME1;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"process\", \"return_type\": \"void\", \"position\": {\"start_line\": 160, \"end_line\": 178, \"start_column\": 13, \"end_column\": 5}, \"code\": \"void process(final byte[] b, final int offset) {\\n        // local shadows for performance\\n        int s0 = state[0];\\n        int s1 = state[1];\\n        int s2 = state[2];\\n        int s3 = state[3];\\n\\n        s0 = rotateLeft(s0 + getInt(b, offset) * PRIME2, ROTATE_BITS) * PRIME1;\\n        s1 = rotateLeft(s1 + getInt(b, offset + 4) * PRIME2, ROTATE_BITS) * PRIME1;\\n        s2 = rotateLeft(s2 + getInt(b, offset + 8) * PRIME2, ROTATE_BITS) * PRIME1;\\n        s3 = rotateLeft(s3 + getInt(b, offset + 12) * PRIME2, ROTATE_BITS) * PRIME1;\\n\\n        state[0] = s0;\\n        state[1] = s1;\\n        state[2] = s2;\\n        state[3] = s3;\\n\\n        pos = 0;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"byte\"}, {\"name\": \"offset\", \"type\": \"int\"}]}, {\"name\": \"fromLittleEndian\", \"return_type\": \"long\", \"position\": {\"start_line\": 188, \"end_line\": 197, \"start_column\": 20, \"end_column\": 5}, \"code\": \"long fromLittleEndian(final byte[] bytes, final int off, final int length) {\\n        if (length > 8) {\\n            throw new IllegalArgumentException(\\\"can't read more than eight bytes into a long value\\\");\\n        }\\n        long l = 0;\\n        for (int i = 0; i < length; i++) {\\n            l |= (bytes[off + i] & 0xffl) << (8 * i);\\n        }\\n        return l;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}, {\"name\": \"off\", \"type\": \"int\"}, {\"name\": \"length\", \"type\": \"int\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/AbstractCaverphone.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language;\\n\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringEncoder;\\n\\n/**\\n * Encodes a string into a Caverphone value.\\n *\\n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\\n * algorithm:\\n *\\n * <p>This class is immutable and thread-safe.</p>\\n *\\n * @version $Id: Caverphone.java 1075947 2011-03-01 17:56:14Z ggregory $\\n * @see <a href=\\\"http://en.wikipedia.org/wiki/Caverphone\\\">Wikipedia - Caverphone</a>\\n * @since 1.5\\n */\\npublic abstract class AbstractCaverphone implements StringEncoder {\\n\\n    /**\\n     * Creates an instance of the Caverphone encoder\\n     */\\n    public AbstractCaverphone() {\\n        super();\\n    }\\n\\n    /**\\n     * Encodes an Object using the caverphone algorithm. This method is provided in order to satisfy the requirements of\\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\\n     *\\n     * @param source\\n     *            Object to encode\\n     * @return An object (or type java.lang.String) containing the caverphone code which corresponds to the String\\n     *         supplied.\\n     * @throws EncoderException\\n     *             if the parameter supplied is not of type java.lang.String\\n     */\\n    @Override\\n    public Object encode(final Object source) throws EncoderException {\\n        if (!(source instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Caverphone encode is not of type java.lang.String\\\");\\n        }\\n        return this.encode((String) source);\\n    }\\n\\n    /**\\n     * Tests if the encodings of two strings are equal.\\n     *\\n     * This method might be promoted to a new AbstractStringEncoder superclass.\\n     *\\n     * @param str1\\n     *            First of two strings to compare\\n     * @param str2\\n     *            Second of two strings to compare\\n     * @return <code>true</code> if the encodings of these strings are identical, <code>false</code> otherwise.\\n     * @throws EncoderException\\n     *             thrown if there is an error condition during the encoding process.\\n     */\\n    public boolean isEncodeEqual(final String str1, final String str2) throws EncoderException {\\n        return this.encode(str1).equals(this.encode(str2));\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"AbstractCaverphone\", \"position\": {\"start_line\": 35, \"end_line\": 80, \"start_column\": 17, \"end_column\": 1}, \"code\": \"class AbstractCaverphone implements StringEncoder {\\n\\n    /**\\n     * Creates an instance of the Caverphone encoder\\n     */\\n    public AbstractCaverphone() {\\n        super();\\n    }\\n\\n    /**\\n     * Encodes an Object using the caverphone algorithm. This method is provided in order to satisfy the requirements of\\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\\n     *\\n     * @param source\\n     *            Object to encode\\n     * @return An object (or type java.lang.String) containing the caverphone code which corresponds to the String\\n     *         supplied.\\n     * @throws EncoderException\\n     *             if the parameter supplied is not of type java.lang.String\\n     */\\n    @Override\\n    public Object encode(final Object source) throws EncoderException {\\n        if (!(source instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Caverphone encode is not of type java.lang.String\\\");\\n        }\\n        return this.encode((String) source);\\n    }\\n\\n    /**\\n     * Tests if the encodings of two strings are equal.\\n     *\\n     * This method might be promoted to a new AbstractStringEncoder superclass.\\n     *\\n     * @param str1\\n     *            First of two strings to compare\\n     * @param str2\\n     *            Second of two strings to compare\\n     * @return <code>true</code> if the encodings of these strings are identical, <code>false</code> otherwise.\\n     * @throws EncoderException\\n     *             thrown if there is an error condition during the encoding process.\\n     */\\n    public boolean isEncodeEqual(final String str1, final String str2) throws EncoderException {\\n        return this.encode(str1).equals(this.encode(str2));\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 56, \"end_line\": 61, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object source) throws EncoderException {\\n        if (!(source instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Caverphone encode is not of type java.lang.String\\\");\\n        }\\n        return this.encode((String) source);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"Object\"}]}, {\"name\": \"isEncodeEqual\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 76, \"end_line\": 78, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isEncodeEqual(final String str1, final String str2) throws EncoderException {\\n        return this.encode(str1).equals(this.encode(str2));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str1\", \"type\": \"String\"}, {\"name\": \"str2\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/Caverphone.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language;\\n\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringEncoder;\\n\\n/**\\n * Encodes a string into a Caverphone 2.0 value. Delegate to a {@link Caverphone2} instance.\\n *\\n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\\n * algorithm:\\n *\\n * @version $Id: Caverphone.java 1079535 2011-03-08 20:54:37Z ggregory $\\n * @see <a href=\\\"http://en.wikipedia.org/wiki/Caverphone\\\">Wikipedia - Caverphone</a>\\n * @see <a href=\\\"http://caversham.otago.ac.nz/files/working/ctp150804.pdf\\\">Caverphone 2.0 specification</a>\\n * @since 1.4\\n * @deprecated 1.5 Replaced by {@link Caverphone2}, will be removed in 2.0.\\n */\\n@Deprecated\\npublic class Caverphone implements StringEncoder {\\n\\n    /**\\n     * Delegate to a {@link Caverphone2} instance to avoid code duplication.\\n     */\\n    final private Caverphone2 encoder = new Caverphone2();\\n\\n    /**\\n     * Creates an instance of the Caverphone encoder\\n     */\\n    public Caverphone() {\\n        super();\\n    }\\n\\n    /**\\n     * Encodes the given String into a Caverphone value.\\n     *\\n     * @param source\\n     *            String the source string\\n     * @return A caverphone code for the given String\\n     */\\n    public String caverphone(final String source) {\\n        return this.encoder.encode(source);\\n    }\\n\\n    /**\\n     * Encodes an Object using the caverphone algorithm. This method is provided in order to satisfy the requirements of\\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\\n     *\\n     * @param obj\\n     *            Object to encode\\n     * @return An object (or type java.lang.String) containing the caverphone code which corresponds to the String\\n     *         supplied.\\n     * @throws EncoderException\\n     *             if the parameter supplied is not of type java.lang.String\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Caverphone encode is not of type java.lang.String\\\");\\n        }\\n        return this.caverphone((String) obj);\\n    }\\n\\n    /**\\n     * Encodes a String using the Caverphone algorithm.\\n     *\\n     * @param str\\n     *            String object to encode\\n     * @return The caverphone code corresponding to the String supplied\\n     */\\n    @Override\\n    public String encode(final String str) {\\n        return this.caverphone(str);\\n    }\\n\\n    /**\\n     * Tests if the caverphones of two strings are identical.\\n     *\\n     * @param str1\\n     *            First of two strings to compare\\n     * @param str2\\n     *            Second of two strings to compare\\n     * @return <code>true</code> if the caverphones of these strings are identical, <code>false</code> otherwise.\\n     */\\n    public boolean isCaverphoneEqual(final String str1, final String str2) {\\n        return this.caverphone(str1).equals(this.caverphone(str2));\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Caverphone\", \"position\": {\"start_line\": 36, \"end_line\": 105, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Caverphone implements StringEncoder {\\n\\n    /**\\n     * Delegate to a {@link Caverphone2} instance to avoid code duplication.\\n     */\\n    final private Caverphone2 encoder = new Caverphone2();\\n\\n    /**\\n     * Creates an instance of the Caverphone encoder\\n     */\\n    public Caverphone() {\\n        super();\\n    }\\n\\n    /**\\n     * Encodes the given String into a Caverphone value.\\n     *\\n     * @param source\\n     *            String the source string\\n     * @return A caverphone code for the given String\\n     */\\n    public String caverphone(final String source) {\\n        return this.encoder.encode(source);\\n    }\\n\\n    /**\\n     * Encodes an Object using the caverphone algorithm. This method is provided in order to satisfy the requirements of\\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\\n     *\\n     * @param obj\\n     *            Object to encode\\n     * @return An object (or type java.lang.String) containing the caverphone code which corresponds to the String\\n     *         supplied.\\n     * @throws EncoderException\\n     *             if the parameter supplied is not of type java.lang.String\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Caverphone encode is not of type java.lang.String\\\");\\n        }\\n        return this.caverphone((String) obj);\\n    }\\n\\n    /**\\n     * Encodes a String using the Caverphone algorithm.\\n     *\\n     * @param str\\n     *            String object to encode\\n     * @return The caverphone code corresponding to the String supplied\\n     */\\n    @Override\\n    public String encode(final String str) {\\n        return this.caverphone(str);\\n    }\\n\\n    /**\\n     * Tests if the caverphones of two strings are identical.\\n     *\\n     * @param str1\\n     *            First of two strings to compare\\n     * @param str2\\n     *            Second of two strings to compare\\n     * @return <code>true</code> if the caverphones of these strings are identical, <code>false</code> otherwise.\\n     */\\n    public boolean isCaverphoneEqual(final String str1, final String str2) {\\n        return this.caverphone(str1).equals(this.caverphone(str2));\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"caverphone\", \"return_type\": \"String\", \"position\": {\"start_line\": 57, \"end_line\": 59, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String caverphone(final String source) {\\n        return this.encoder.encode(source);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 73, \"end_line\": 78, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Caverphone encode is not of type java.lang.String\\\");\\n        }\\n        return this.caverphone((String) obj);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 88, \"end_line\": 90, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str) {\\n        return this.caverphone(str);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"isCaverphoneEqual\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 101, \"end_line\": 103, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isCaverphoneEqual(final String str1, final String str2) {\\n        return this.caverphone(str1).equals(this.caverphone(str2));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str1\", \"type\": \"String\"}, {\"name\": \"str2\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/Caverphone1.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language;\\n\\n/**\\n * Encodes a string into a Caverphone 1.0 value.\\n *\\n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 1.0\\n * algorithm:\\n *\\n * @version $Id: Caverphone.java 1075947 2011-03-01 17:56:14Z ggregory $\\n * @see <a href=\\\"http://en.wikipedia.org/wiki/Caverphone\\\">Wikipedia - Caverphone</a>\\n * @see <a href=\\\"http://caversham.otago.ac.nz/files/working/ctp060902.pdf\\\">Caverphone 1.0 specification</a>\\n * @since 1.5\\n *\\n * <p>This class is immutable and thread-safe.</p>\\n */\\npublic class Caverphone1 extends AbstractCaverphone {\\n\\n    private static final String SIX_1 = \\\"111111\\\";\\n\\n    /**\\n     * Encodes the given String into a Caverphone value.\\n     *\\n     * @param source\\n     *            String the source string\\n     * @return A caverphone code for the given String\\n     */\\n    @Override\\n    public String encode(final String source) {\\n        String txt = source;\\n        if (txt == null || txt.length() == 0) {\\n            return SIX_1;\\n        }\\n\\n        // 1. Convert to lowercase\\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\\n\\n        // 2. Remove anything not A-Z\\n        txt = txt.replaceAll(\\\"[^a-z]\\\", \\\"\\\");\\n\\n        // 3. Handle various start options\\n        // 2 is a temporary placeholder to indicate a consonant which we are no longer interested in.\\n        txt = txt.replaceAll(\\\"^cough\\\", \\\"cou2f\\\");\\n        txt = txt.replaceAll(\\\"^rough\\\", \\\"rou2f\\\");\\n        txt = txt.replaceAll(\\\"^tough\\\", \\\"tou2f\\\");\\n        txt = txt.replaceAll(\\\"^enough\\\", \\\"enou2f\\\");\\n        txt = txt.replaceAll(\\\"^gn\\\", \\\"2n\\\");\\n\\n        // End\\n        txt = txt.replaceAll(\\\"mb$\\\", \\\"m2\\\");\\n\\n        // 4. Handle replacements\\n        txt = txt.replaceAll(\\\"cq\\\", \\\"2q\\\");\\n        txt = txt.replaceAll(\\\"ci\\\", \\\"si\\\");\\n        txt = txt.replaceAll(\\\"ce\\\", \\\"se\\\");\\n        txt = txt.replaceAll(\\\"cy\\\", \\\"sy\\\");\\n        txt = txt.replaceAll(\\\"tch\\\", \\\"2ch\\\");\\n        txt = txt.replaceAll(\\\"c\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"q\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"x\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"v\\\", \\\"f\\\");\\n        txt = txt.replaceAll(\\\"dg\\\", \\\"2g\\\");\\n        txt = txt.replaceAll(\\\"tio\\\", \\\"sio\\\");\\n        txt = txt.replaceAll(\\\"tia\\\", \\\"sia\\\");\\n        txt = txt.replaceAll(\\\"d\\\", \\\"t\\\");\\n        txt = txt.replaceAll(\\\"ph\\\", \\\"fh\\\");\\n        txt = txt.replaceAll(\\\"b\\\", \\\"p\\\");\\n        txt = txt.replaceAll(\\\"sh\\\", \\\"s2\\\");\\n        txt = txt.replaceAll(\\\"z\\\", \\\"s\\\");\\n        txt = txt.replaceAll(\\\"^[aeiou]\\\", \\\"A\\\");\\n        // 3 is a temporary placeholder marking a vowel\\n        txt = txt.replaceAll(\\\"[aeiou]\\\", \\\"3\\\");\\n        txt = txt.replaceAll(\\\"3gh3\\\", \\\"3kh3\\\");\\n        txt = txt.replaceAll(\\\"gh\\\", \\\"22\\\");\\n        txt = txt.replaceAll(\\\"g\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"s+\\\", \\\"S\\\");\\n        txt = txt.replaceAll(\\\"t+\\\", \\\"T\\\");\\n        txt = txt.replaceAll(\\\"p+\\\", \\\"P\\\");\\n        txt = txt.replaceAll(\\\"k+\\\", \\\"K\\\");\\n        txt = txt.replaceAll(\\\"f+\\\", \\\"F\\\");\\n        txt = txt.replaceAll(\\\"m+\\\", \\\"M\\\");\\n        txt = txt.replaceAll(\\\"n+\\\", \\\"N\\\");\\n        txt = txt.replaceAll(\\\"w3\\\", \\\"W3\\\");\\n        txt = txt.replaceAll(\\\"wy\\\", \\\"Wy\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"wh3\\\", \\\"Wh3\\\");\\n        txt = txt.replaceAll(\\\"why\\\", \\\"Why\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"w\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"^h\\\", \\\"A\\\");\\n        txt = txt.replaceAll(\\\"h\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"r3\\\", \\\"R3\\\");\\n        txt = txt.replaceAll(\\\"ry\\\", \\\"Ry\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"r\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"l3\\\", \\\"L3\\\");\\n        txt = txt.replaceAll(\\\"ly\\\", \\\"Ly\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"l\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"j\\\", \\\"y\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"y3\\\", \\\"Y3\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"y\\\", \\\"2\\\"); // 1.0 only\\n\\n        // 5. Handle removals\\n        txt = txt.replaceAll(\\\"2\\\", \\\"\\\");\\n        txt = txt.replaceAll(\\\"3\\\", \\\"\\\");\\n\\n        // 6. put ten 1s on the end\\n        txt = txt + SIX_1;\\n\\n        // 7. take the first six characters as the code\\n        return txt.substring(0, SIX_1.length());\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Caverphone1\", \"position\": {\"start_line\": 33, \"end_line\": 127, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Caverphone1 extends AbstractCaverphone {\\n\\n    private static final String SIX_1 = \\\"111111\\\";\\n\\n    /**\\n     * Encodes the given String into a Caverphone value.\\n     *\\n     * @param source\\n     *            String the source string\\n     * @return A caverphone code for the given String\\n     */\\n    @Override\\n    public String encode(final String source) {\\n        String txt = source;\\n        if (txt == null || txt.length() == 0) {\\n            return SIX_1;\\n        }\\n\\n        // 1. Convert to lowercase\\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\\n\\n        // 2. Remove anything not A-Z\\n        txt = txt.replaceAll(\\\"[^a-z]\\\", \\\"\\\");\\n\\n        // 3. Handle various start options\\n        // 2 is a temporary placeholder to indicate a consonant which we are no longer interested in.\\n        txt = txt.replaceAll(\\\"^cough\\\", \\\"cou2f\\\");\\n        txt = txt.replaceAll(\\\"^rough\\\", \\\"rou2f\\\");\\n        txt = txt.replaceAll(\\\"^tough\\\", \\\"tou2f\\\");\\n        txt = txt.replaceAll(\\\"^enough\\\", \\\"enou2f\\\");\\n        txt = txt.replaceAll(\\\"^gn\\\", \\\"2n\\\");\\n\\n        // End\\n        txt = txt.replaceAll(\\\"mb$\\\", \\\"m2\\\");\\n\\n        // 4. Handle replacements\\n        txt = txt.replaceAll(\\\"cq\\\", \\\"2q\\\");\\n        txt = txt.replaceAll(\\\"ci\\\", \\\"si\\\");\\n        txt = txt.replaceAll(\\\"ce\\\", \\\"se\\\");\\n        txt = txt.replaceAll(\\\"cy\\\", \\\"sy\\\");\\n        txt = txt.replaceAll(\\\"tch\\\", \\\"2ch\\\");\\n        txt = txt.replaceAll(\\\"c\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"q\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"x\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"v\\\", \\\"f\\\");\\n        txt = txt.replaceAll(\\\"dg\\\", \\\"2g\\\");\\n        txt = txt.replaceAll(\\\"tio\\\", \\\"sio\\\");\\n        txt = txt.replaceAll(\\\"tia\\\", \\\"sia\\\");\\n        txt = txt.replaceAll(\\\"d\\\", \\\"t\\\");\\n        txt = txt.replaceAll(\\\"ph\\\", \\\"fh\\\");\\n        txt = txt.replaceAll(\\\"b\\\", \\\"p\\\");\\n        txt = txt.replaceAll(\\\"sh\\\", \\\"s2\\\");\\n        txt = txt.replaceAll(\\\"z\\\", \\\"s\\\");\\n        txt = txt.replaceAll(\\\"^[aeiou]\\\", \\\"A\\\");\\n        // 3 is a temporary placeholder marking a vowel\\n        txt = txt.replaceAll(\\\"[aeiou]\\\", \\\"3\\\");\\n        txt = txt.replaceAll(\\\"3gh3\\\", \\\"3kh3\\\");\\n        txt = txt.replaceAll(\\\"gh\\\", \\\"22\\\");\\n        txt = txt.replaceAll(\\\"g\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"s+\\\", \\\"S\\\");\\n        txt = txt.replaceAll(\\\"t+\\\", \\\"T\\\");\\n        txt = txt.replaceAll(\\\"p+\\\", \\\"P\\\");\\n        txt = txt.replaceAll(\\\"k+\\\", \\\"K\\\");\\n        txt = txt.replaceAll(\\\"f+\\\", \\\"F\\\");\\n        txt = txt.replaceAll(\\\"m+\\\", \\\"M\\\");\\n        txt = txt.replaceAll(\\\"n+\\\", \\\"N\\\");\\n        txt = txt.replaceAll(\\\"w3\\\", \\\"W3\\\");\\n        txt = txt.replaceAll(\\\"wy\\\", \\\"Wy\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"wh3\\\", \\\"Wh3\\\");\\n        txt = txt.replaceAll(\\\"why\\\", \\\"Why\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"w\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"^h\\\", \\\"A\\\");\\n        txt = txt.replaceAll(\\\"h\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"r3\\\", \\\"R3\\\");\\n        txt = txt.replaceAll(\\\"ry\\\", \\\"Ry\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"r\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"l3\\\", \\\"L3\\\");\\n        txt = txt.replaceAll(\\\"ly\\\", \\\"Ly\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"l\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"j\\\", \\\"y\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"y3\\\", \\\"Y3\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"y\\\", \\\"2\\\"); // 1.0 only\\n\\n        // 5. Handle removals\\n        txt = txt.replaceAll(\\\"2\\\", \\\"\\\");\\n        txt = txt.replaceAll(\\\"3\\\", \\\"\\\");\\n\\n        // 6. put ten 1s on the end\\n        txt = txt + SIX_1;\\n\\n        // 7. take the first six characters as the code\\n        return txt.substring(0, SIX_1.length());\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 45, \"end_line\": 125, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String source) {\\n        String txt = source;\\n        if (txt == null || txt.length() == 0) {\\n            return SIX_1;\\n        }\\n\\n        // 1. Convert to lowercase\\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\\n\\n        // 2. Remove anything not A-Z\\n        txt = txt.replaceAll(\\\"[^a-z]\\\", \\\"\\\");\\n\\n        // 3. Handle various start options\\n        // 2 is a temporary placeholder to indicate a consonant which we are no longer interested in.\\n        txt = txt.replaceAll(\\\"^cough\\\", \\\"cou2f\\\");\\n        txt = txt.replaceAll(\\\"^rough\\\", \\\"rou2f\\\");\\n        txt = txt.replaceAll(\\\"^tough\\\", \\\"tou2f\\\");\\n        txt = txt.replaceAll(\\\"^enough\\\", \\\"enou2f\\\");\\n        txt = txt.replaceAll(\\\"^gn\\\", \\\"2n\\\");\\n\\n        // End\\n        txt = txt.replaceAll(\\\"mb$\\\", \\\"m2\\\");\\n\\n        // 4. Handle replacements\\n        txt = txt.replaceAll(\\\"cq\\\", \\\"2q\\\");\\n        txt = txt.replaceAll(\\\"ci\\\", \\\"si\\\");\\n        txt = txt.replaceAll(\\\"ce\\\", \\\"se\\\");\\n        txt = txt.replaceAll(\\\"cy\\\", \\\"sy\\\");\\n        txt = txt.replaceAll(\\\"tch\\\", \\\"2ch\\\");\\n        txt = txt.replaceAll(\\\"c\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"q\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"x\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"v\\\", \\\"f\\\");\\n        txt = txt.replaceAll(\\\"dg\\\", \\\"2g\\\");\\n        txt = txt.replaceAll(\\\"tio\\\", \\\"sio\\\");\\n        txt = txt.replaceAll(\\\"tia\\\", \\\"sia\\\");\\n        txt = txt.replaceAll(\\\"d\\\", \\\"t\\\");\\n        txt = txt.replaceAll(\\\"ph\\\", \\\"fh\\\");\\n        txt = txt.replaceAll(\\\"b\\\", \\\"p\\\");\\n        txt = txt.replaceAll(\\\"sh\\\", \\\"s2\\\");\\n        txt = txt.replaceAll(\\\"z\\\", \\\"s\\\");\\n        txt = txt.replaceAll(\\\"^[aeiou]\\\", \\\"A\\\");\\n        // 3 is a temporary placeholder marking a vowel\\n        txt = txt.replaceAll(\\\"[aeiou]\\\", \\\"3\\\");\\n        txt = txt.replaceAll(\\\"3gh3\\\", \\\"3kh3\\\");\\n        txt = txt.replaceAll(\\\"gh\\\", \\\"22\\\");\\n        txt = txt.replaceAll(\\\"g\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"s+\\\", \\\"S\\\");\\n        txt = txt.replaceAll(\\\"t+\\\", \\\"T\\\");\\n        txt = txt.replaceAll(\\\"p+\\\", \\\"P\\\");\\n        txt = txt.replaceAll(\\\"k+\\\", \\\"K\\\");\\n        txt = txt.replaceAll(\\\"f+\\\", \\\"F\\\");\\n        txt = txt.replaceAll(\\\"m+\\\", \\\"M\\\");\\n        txt = txt.replaceAll(\\\"n+\\\", \\\"N\\\");\\n        txt = txt.replaceAll(\\\"w3\\\", \\\"W3\\\");\\n        txt = txt.replaceAll(\\\"wy\\\", \\\"Wy\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"wh3\\\", \\\"Wh3\\\");\\n        txt = txt.replaceAll(\\\"why\\\", \\\"Why\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"w\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"^h\\\", \\\"A\\\");\\n        txt = txt.replaceAll(\\\"h\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"r3\\\", \\\"R3\\\");\\n        txt = txt.replaceAll(\\\"ry\\\", \\\"Ry\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"r\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"l3\\\", \\\"L3\\\");\\n        txt = txt.replaceAll(\\\"ly\\\", \\\"Ly\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"l\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"j\\\", \\\"y\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"y3\\\", \\\"Y3\\\"); // 1.0 only\\n        txt = txt.replaceAll(\\\"y\\\", \\\"2\\\"); // 1.0 only\\n\\n        // 5. Handle removals\\n        txt = txt.replaceAll(\\\"2\\\", \\\"\\\");\\n        txt = txt.replaceAll(\\\"3\\\", \\\"\\\");\\n\\n        // 6. put ten 1s on the end\\n        txt = txt + SIX_1;\\n\\n        // 7. take the first six characters as the code\\n        return txt.substring(0, SIX_1.length());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/Caverphone2.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language;\\n\\n/**\\n * Encodes a string into a Caverphone 2.0 value.\\n *\\n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\\n * algorithm:\\n *\\n * @version $Id: Caverphone.java 1075947 2011-03-01 17:56:14Z ggregory $\\n * @see <a href=\\\"http://en.wikipedia.org/wiki/Caverphone\\\">Wikipedia - Caverphone</a>\\n * @see <a href=\\\"http://caversham.otago.ac.nz/files/working/ctp150804.pdf\\\">Caverphone 2.0 specification</a>\\n * @since 1.5\\n *\\n * <p>This class is immutable and thread-safe.</p>\\n */\\npublic class Caverphone2 extends AbstractCaverphone {\\n\\n    private static final String TEN_1 = \\\"1111111111\\\";\\n\\n    /**\\n     * Encodes the given String into a Caverphone 2.0 value.\\n     *\\n     * @param source\\n     *            String the source string\\n     * @return A caverphone code for the given String\\n     */\\n    @Override\\n    public String encode(final String source) {\\n        String txt = source;\\n        if (txt == null || txt.length() == 0) {\\n            return TEN_1;\\n        }\\n\\n        // 1. Convert to lowercase\\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\\n\\n        // 2. Remove anything not A-Z\\n        txt = txt.replaceAll(\\\"[^a-z]\\\", \\\"\\\");\\n\\n        // 2.5. Remove final e\\n        txt = txt.replaceAll(\\\"e$\\\", \\\"\\\"); // 2.0 only\\n\\n        // 3. Handle various start options\\n        txt = txt.replaceAll(\\\"^cough\\\", \\\"cou2f\\\");\\n        txt = txt.replaceAll(\\\"^rough\\\", \\\"rou2f\\\");\\n        txt = txt.replaceAll(\\\"^tough\\\", \\\"tou2f\\\");\\n        txt = txt.replaceAll(\\\"^enough\\\", \\\"enou2f\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"^trough\\\", \\\"trou2f\\\"); // 2.0 only\\n                                                   // note the spec says ^enough here again, c+p error I assume\\n        txt = txt.replaceAll(\\\"^gn\\\", \\\"2n\\\");\\n\\n        // End\\n        txt = txt.replaceAll(\\\"mb$\\\", \\\"m2\\\");\\n\\n        // 4. Handle replacements\\n        txt = txt.replaceAll(\\\"cq\\\", \\\"2q\\\");\\n        txt = txt.replaceAll(\\\"ci\\\", \\\"si\\\");\\n        txt = txt.replaceAll(\\\"ce\\\", \\\"se\\\");\\n        txt = txt.replaceAll(\\\"cy\\\", \\\"sy\\\");\\n        txt = txt.replaceAll(\\\"tch\\\", \\\"2ch\\\");\\n        txt = txt.replaceAll(\\\"c\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"q\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"x\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"v\\\", \\\"f\\\");\\n        txt = txt.replaceAll(\\\"dg\\\", \\\"2g\\\");\\n        txt = txt.replaceAll(\\\"tio\\\", \\\"sio\\\");\\n        txt = txt.replaceAll(\\\"tia\\\", \\\"sia\\\");\\n        txt = txt.replaceAll(\\\"d\\\", \\\"t\\\");\\n        txt = txt.replaceAll(\\\"ph\\\", \\\"fh\\\");\\n        txt = txt.replaceAll(\\\"b\\\", \\\"p\\\");\\n        txt = txt.replaceAll(\\\"sh\\\", \\\"s2\\\");\\n        txt = txt.replaceAll(\\\"z\\\", \\\"s\\\");\\n        txt = txt.replaceAll(\\\"^[aeiou]\\\", \\\"A\\\");\\n        txt = txt.replaceAll(\\\"[aeiou]\\\", \\\"3\\\");\\n        txt = txt.replaceAll(\\\"j\\\", \\\"y\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"^y3\\\", \\\"Y3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"^y\\\", \\\"A\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"y\\\", \\\"3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"3gh3\\\", \\\"3kh3\\\");\\n        txt = txt.replaceAll(\\\"gh\\\", \\\"22\\\");\\n        txt = txt.replaceAll(\\\"g\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"s+\\\", \\\"S\\\");\\n        txt = txt.replaceAll(\\\"t+\\\", \\\"T\\\");\\n        txt = txt.replaceAll(\\\"p+\\\", \\\"P\\\");\\n        txt = txt.replaceAll(\\\"k+\\\", \\\"K\\\");\\n        txt = txt.replaceAll(\\\"f+\\\", \\\"F\\\");\\n        txt = txt.replaceAll(\\\"m+\\\", \\\"M\\\");\\n        txt = txt.replaceAll(\\\"n+\\\", \\\"N\\\");\\n        txt = txt.replaceAll(\\\"w3\\\", \\\"W3\\\");\\n        txt = txt.replaceAll(\\\"wh3\\\", \\\"Wh3\\\");\\n        txt = txt.replaceAll(\\\"w$\\\", \\\"3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"w\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"^h\\\", \\\"A\\\");\\n        txt = txt.replaceAll(\\\"h\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"r3\\\", \\\"R3\\\");\\n        txt = txt.replaceAll(\\\"r$\\\", \\\"3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"r\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"l3\\\", \\\"L3\\\");\\n        txt = txt.replaceAll(\\\"l$\\\", \\\"3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"l\\\", \\\"2\\\");\\n\\n        // 5. Handle removals\\n        txt = txt.replaceAll(\\\"2\\\", \\\"\\\");\\n        txt = txt.replaceAll(\\\"3$\\\", \\\"A\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"3\\\", \\\"\\\");\\n\\n        // 6. put ten 1s on the end\\n        txt = txt + TEN_1;\\n\\n        // 7. take the first ten characters as the code\\n        return txt.substring(0, TEN_1.length());\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Caverphone2\", \"position\": {\"start_line\": 33, \"end_line\": 131, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Caverphone2 extends AbstractCaverphone {\\n\\n    private static final String TEN_1 = \\\"1111111111\\\";\\n\\n    /**\\n     * Encodes the given String into a Caverphone 2.0 value.\\n     *\\n     * @param source\\n     *            String the source string\\n     * @return A caverphone code for the given String\\n     */\\n    @Override\\n    public String encode(final String source) {\\n        String txt = source;\\n        if (txt == null || txt.length() == 0) {\\n            return TEN_1;\\n        }\\n\\n        // 1. Convert to lowercase\\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\\n\\n        // 2. Remove anything not A-Z\\n        txt = txt.replaceAll(\\\"[^a-z]\\\", \\\"\\\");\\n\\n        // 2.5. Remove final e\\n        txt = txt.replaceAll(\\\"e$\\\", \\\"\\\"); // 2.0 only\\n\\n        // 3. Handle various start options\\n        txt = txt.replaceAll(\\\"^cough\\\", \\\"cou2f\\\");\\n        txt = txt.replaceAll(\\\"^rough\\\", \\\"rou2f\\\");\\n        txt = txt.replaceAll(\\\"^tough\\\", \\\"tou2f\\\");\\n        txt = txt.replaceAll(\\\"^enough\\\", \\\"enou2f\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"^trough\\\", \\\"trou2f\\\"); // 2.0 only\\n                                                   // note the spec says ^enough here again, c+p error I assume\\n        txt = txt.replaceAll(\\\"^gn\\\", \\\"2n\\\");\\n\\n        // End\\n        txt = txt.replaceAll(\\\"mb$\\\", \\\"m2\\\");\\n\\n        // 4. Handle replacements\\n        txt = txt.replaceAll(\\\"cq\\\", \\\"2q\\\");\\n        txt = txt.replaceAll(\\\"ci\\\", \\\"si\\\");\\n        txt = txt.replaceAll(\\\"ce\\\", \\\"se\\\");\\n        txt = txt.replaceAll(\\\"cy\\\", \\\"sy\\\");\\n        txt = txt.replaceAll(\\\"tch\\\", \\\"2ch\\\");\\n        txt = txt.replaceAll(\\\"c\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"q\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"x\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"v\\\", \\\"f\\\");\\n        txt = txt.replaceAll(\\\"dg\\\", \\\"2g\\\");\\n        txt = txt.replaceAll(\\\"tio\\\", \\\"sio\\\");\\n        txt = txt.replaceAll(\\\"tia\\\", \\\"sia\\\");\\n        txt = txt.replaceAll(\\\"d\\\", \\\"t\\\");\\n        txt = txt.replaceAll(\\\"ph\\\", \\\"fh\\\");\\n        txt = txt.replaceAll(\\\"b\\\", \\\"p\\\");\\n        txt = txt.replaceAll(\\\"sh\\\", \\\"s2\\\");\\n        txt = txt.replaceAll(\\\"z\\\", \\\"s\\\");\\n        txt = txt.replaceAll(\\\"^[aeiou]\\\", \\\"A\\\");\\n        txt = txt.replaceAll(\\\"[aeiou]\\\", \\\"3\\\");\\n        txt = txt.replaceAll(\\\"j\\\", \\\"y\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"^y3\\\", \\\"Y3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"^y\\\", \\\"A\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"y\\\", \\\"3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"3gh3\\\", \\\"3kh3\\\");\\n        txt = txt.replaceAll(\\\"gh\\\", \\\"22\\\");\\n        txt = txt.replaceAll(\\\"g\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"s+\\\", \\\"S\\\");\\n        txt = txt.replaceAll(\\\"t+\\\", \\\"T\\\");\\n        txt = txt.replaceAll(\\\"p+\\\", \\\"P\\\");\\n        txt = txt.replaceAll(\\\"k+\\\", \\\"K\\\");\\n        txt = txt.replaceAll(\\\"f+\\\", \\\"F\\\");\\n        txt = txt.replaceAll(\\\"m+\\\", \\\"M\\\");\\n        txt = txt.replaceAll(\\\"n+\\\", \\\"N\\\");\\n        txt = txt.replaceAll(\\\"w3\\\", \\\"W3\\\");\\n        txt = txt.replaceAll(\\\"wh3\\\", \\\"Wh3\\\");\\n        txt = txt.replaceAll(\\\"w$\\\", \\\"3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"w\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"^h\\\", \\\"A\\\");\\n        txt = txt.replaceAll(\\\"h\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"r3\\\", \\\"R3\\\");\\n        txt = txt.replaceAll(\\\"r$\\\", \\\"3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"r\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"l3\\\", \\\"L3\\\");\\n        txt = txt.replaceAll(\\\"l$\\\", \\\"3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"l\\\", \\\"2\\\");\\n\\n        // 5. Handle removals\\n        txt = txt.replaceAll(\\\"2\\\", \\\"\\\");\\n        txt = txt.replaceAll(\\\"3$\\\", \\\"A\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"3\\\", \\\"\\\");\\n\\n        // 6. put ten 1s on the end\\n        txt = txt + TEN_1;\\n\\n        // 7. take the first ten characters as the code\\n        return txt.substring(0, TEN_1.length());\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 45, \"end_line\": 129, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String source) {\\n        String txt = source;\\n        if (txt == null || txt.length() == 0) {\\n            return TEN_1;\\n        }\\n\\n        // 1. Convert to lowercase\\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\\n\\n        // 2. Remove anything not A-Z\\n        txt = txt.replaceAll(\\\"[^a-z]\\\", \\\"\\\");\\n\\n        // 2.5. Remove final e\\n        txt = txt.replaceAll(\\\"e$\\\", \\\"\\\"); // 2.0 only\\n\\n        // 3. Handle various start options\\n        txt = txt.replaceAll(\\\"^cough\\\", \\\"cou2f\\\");\\n        txt = txt.replaceAll(\\\"^rough\\\", \\\"rou2f\\\");\\n        txt = txt.replaceAll(\\\"^tough\\\", \\\"tou2f\\\");\\n        txt = txt.replaceAll(\\\"^enough\\\", \\\"enou2f\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"^trough\\\", \\\"trou2f\\\"); // 2.0 only\\n                                                   // note the spec says ^enough here again, c+p error I assume\\n        txt = txt.replaceAll(\\\"^gn\\\", \\\"2n\\\");\\n\\n        // End\\n        txt = txt.replaceAll(\\\"mb$\\\", \\\"m2\\\");\\n\\n        // 4. Handle replacements\\n        txt = txt.replaceAll(\\\"cq\\\", \\\"2q\\\");\\n        txt = txt.replaceAll(\\\"ci\\\", \\\"si\\\");\\n        txt = txt.replaceAll(\\\"ce\\\", \\\"se\\\");\\n        txt = txt.replaceAll(\\\"cy\\\", \\\"sy\\\");\\n        txt = txt.replaceAll(\\\"tch\\\", \\\"2ch\\\");\\n        txt = txt.replaceAll(\\\"c\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"q\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"x\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"v\\\", \\\"f\\\");\\n        txt = txt.replaceAll(\\\"dg\\\", \\\"2g\\\");\\n        txt = txt.replaceAll(\\\"tio\\\", \\\"sio\\\");\\n        txt = txt.replaceAll(\\\"tia\\\", \\\"sia\\\");\\n        txt = txt.replaceAll(\\\"d\\\", \\\"t\\\");\\n        txt = txt.replaceAll(\\\"ph\\\", \\\"fh\\\");\\n        txt = txt.replaceAll(\\\"b\\\", \\\"p\\\");\\n        txt = txt.replaceAll(\\\"sh\\\", \\\"s2\\\");\\n        txt = txt.replaceAll(\\\"z\\\", \\\"s\\\");\\n        txt = txt.replaceAll(\\\"^[aeiou]\\\", \\\"A\\\");\\n        txt = txt.replaceAll(\\\"[aeiou]\\\", \\\"3\\\");\\n        txt = txt.replaceAll(\\\"j\\\", \\\"y\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"^y3\\\", \\\"Y3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"^y\\\", \\\"A\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"y\\\", \\\"3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"3gh3\\\", \\\"3kh3\\\");\\n        txt = txt.replaceAll(\\\"gh\\\", \\\"22\\\");\\n        txt = txt.replaceAll(\\\"g\\\", \\\"k\\\");\\n        txt = txt.replaceAll(\\\"s+\\\", \\\"S\\\");\\n        txt = txt.replaceAll(\\\"t+\\\", \\\"T\\\");\\n        txt = txt.replaceAll(\\\"p+\\\", \\\"P\\\");\\n        txt = txt.replaceAll(\\\"k+\\\", \\\"K\\\");\\n        txt = txt.replaceAll(\\\"f+\\\", \\\"F\\\");\\n        txt = txt.replaceAll(\\\"m+\\\", \\\"M\\\");\\n        txt = txt.replaceAll(\\\"n+\\\", \\\"N\\\");\\n        txt = txt.replaceAll(\\\"w3\\\", \\\"W3\\\");\\n        txt = txt.replaceAll(\\\"wh3\\\", \\\"Wh3\\\");\\n        txt = txt.replaceAll(\\\"w$\\\", \\\"3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"w\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"^h\\\", \\\"A\\\");\\n        txt = txt.replaceAll(\\\"h\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"r3\\\", \\\"R3\\\");\\n        txt = txt.replaceAll(\\\"r$\\\", \\\"3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"r\\\", \\\"2\\\");\\n        txt = txt.replaceAll(\\\"l3\\\", \\\"L3\\\");\\n        txt = txt.replaceAll(\\\"l$\\\", \\\"3\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"l\\\", \\\"2\\\");\\n\\n        // 5. Handle removals\\n        txt = txt.replaceAll(\\\"2\\\", \\\"\\\");\\n        txt = txt.replaceAll(\\\"3$\\\", \\\"A\\\"); // 2.0 only\\n        txt = txt.replaceAll(\\\"3\\\", \\\"\\\");\\n\\n        // 6. put ten 1s on the end\\n        txt = txt + TEN_1;\\n\\n        // 7. take the first ten characters as the code\\n        return txt.substring(0, TEN_1.length());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/ColognePhonetic.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language;\\n\\nimport java.util.Locale;\\n\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringEncoder;\\n\\n/**\\n * Encodes a string into a Cologne Phonetic value.\\n * <p>\\n * Implements the <a href=\\\"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik\\\">K&ouml;lner Phonetik</a> (Cologne\\n * Phonetic) algorithm issued by Hans Joachim Postel in 1969.\\n * </p>\\n * <p>\\n * The <i>K&ouml;lner Phonetik</i> is a phonetic algorithm which is optimized for the German language. It is related to\\n * the well-known soundex algorithm.\\n * </p>\\n *\\n * <h2>Algorithm</h2>\\n *\\n * <ul>\\n *\\n * <li>\\n * <h3>Step 1:</h3>\\n * After preprocessing (conversion to upper case, transcription of <a\\n * href=\\\"http://en.wikipedia.org/wiki/Germanic_umlaut\\\">germanic umlauts</a>, removal of non alphabetical characters) the\\n * letters of the supplied text are replaced by their phonetic code according to the following table.\\n * <table border=\\\"1\\\">\\n * <caption style=\\\"caption-side: bottom\\\"><small><i>(Source: <a\\n * href=\\\"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik#Buchstabencodes\\\">Wikipedia (de): K&ouml;lner Phonetik --\\n * Buchstabencodes</a>)</i></small></caption> <tbody>\\n * <tr>\\n * <th>Letter</th>\\n * <th>Context</th>\\n * <th align=\\\"center\\\">Code</th>\\n * </tr>\\n * <tr>\\n * <td>A, E, I, J, O, U, Y</td>\\n * <td></td>\\n * <td align=\\\"center\\\">0</td>\\n * </tr>\\n * <tr>\\n *\\n * <td>H</td>\\n * <td></td>\\n * <td align=\\\"center\\\">-</td>\\n * </tr>\\n * <tr>\\n * <td>B</td>\\n * <td></td>\\n * <td rowspan=\\\"2\\\" align=\\\"center\\\">1</td>\\n * </tr>\\n * <tr>\\n * <td>P</td>\\n * <td>not before H</td>\\n *\\n * </tr>\\n * <tr>\\n * <td>D, T</td>\\n * <td>not before C, S, Z</td>\\n * <td align=\\\"center\\\">2</td>\\n * </tr>\\n * <tr>\\n * <td>F, V, W</td>\\n * <td></td>\\n * <td rowspan=\\\"2\\\" align=\\\"center\\\">3</td>\\n * </tr>\\n * <tr>\\n *\\n * <td>P</td>\\n * <td>before H</td>\\n * </tr>\\n * <tr>\\n * <td>G, K, Q</td>\\n * <td></td>\\n * <td rowspan=\\\"3\\\" align=\\\"center\\\">4</td>\\n * </tr>\\n * <tr>\\n * <td rowspan=\\\"2\\\">C</td>\\n * <td>at onset before A, H, K, L, O, Q, R, U, X</td>\\n *\\n * </tr>\\n * <tr>\\n * <td>before A, H, K, O, Q, U, X except after S, Z</td>\\n * </tr>\\n * <tr>\\n * <td>X</td>\\n * <td>not after C, K, Q</td>\\n * <td align=\\\"center\\\">48</td>\\n * </tr>\\n * <tr>\\n * <td>L</td>\\n * <td></td>\\n *\\n * <td align=\\\"center\\\">5</td>\\n * </tr>\\n * <tr>\\n * <td>M, N</td>\\n * <td></td>\\n * <td align=\\\"center\\\">6</td>\\n * </tr>\\n * <tr>\\n * <td>R</td>\\n * <td></td>\\n * <td align=\\\"center\\\">7</td>\\n * </tr>\\n *\\n * <tr>\\n * <td>S, Z</td>\\n * <td></td>\\n * <td rowspan=\\\"6\\\" align=\\\"center\\\">8</td>\\n * </tr>\\n * <tr>\\n * <td rowspan=\\\"3\\\">C</td>\\n * <td>after S, Z</td>\\n * </tr>\\n * <tr>\\n * <td>at onset except before A, H, K, L, O, Q, R, U, X</td>\\n * </tr>\\n *\\n * <tr>\\n * <td>not before A, H, K, O, Q, U, X</td>\\n * </tr>\\n * <tr>\\n * <td>D, T</td>\\n * <td>before C, S, Z</td>\\n * </tr>\\n * <tr>\\n * <td>X</td>\\n * <td>after C, K, Q</td>\\n * </tr>\\n * </tbody>\\n * </table>\\n *\\n * <h4>Example:</h4>\\n *\\n * <code>\\\"M</code>&uuml;<code>ller-L</code>&uuml;\\n * <code>denscheidt\\\" =&gt; \\\"MULLERLUDENSCHEIDT\\\" =&gt; \\\"6005507500206880022\\\"</code>\\n *\\n * </li>\\n *\\n * <li>\\n * <h3>Step 2:</h3>\\n * Collapse of all multiple consecutive code digits.\\n * <h4>Example:</h4>\\n * <code>\\\"6005507500206880022\\\" =&gt; \\\"6050750206802\\\"</code></li>\\n *\\n * <li>\\n * <h3>Step 3:</h3>\\n * Removal of all codes \\\"0\\\" except at the beginning. This means that two or more identical consecutive digits can occur\\n * if they occur after removing the \\\"0\\\" digits.\\n *\\n * <h4>Example:</h4>\\n * <code>\\\"6050750206802\\\" =&gt; \\\"65752682\\\"</code></li>\\n *\\n * </ul>\\n *\\n * <p>\\n * This class is thread-safe.\\n * </p>\\n *\\n * @see <a href=\\\"http://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik\\\">Wikipedia (de): K&ouml;lner Phonetik (in German)</a>\\n * @since 1.5\\n */\\npublic class ColognePhonetic implements StringEncoder {\\n\\n    // Predefined char arrays for better performance and less GC load\\n    private static final char[] AEIJOUY = new char[] { 'A', 'E', 'I', 'J', 'O', 'U', 'Y' };\\n    private static final char[] SCZ = new char[] { 'S', 'C', 'Z' };\\n    private static final char[] WFPV = new char[] { 'W', 'F', 'P', 'V' };\\n    private static final char[] GKQ = new char[] { 'G', 'K', 'Q' };\\n    private static final char[] CKQ = new char[] { 'C', 'K', 'Q' };\\n    private static final char[] AHKLOQRUX = new char[] { 'A', 'H', 'K', 'L', 'O', 'Q', 'R', 'U', 'X' };\\n    private static final char[] SZ = new char[] { 'S', 'Z' };\\n    private static final char[] AHOUKQX = new char[] { 'A', 'H', 'O', 'U', 'K', 'Q', 'X' };\\n    private static final char[] TDX = new char[] { 'T', 'D', 'X' };\\n\\n    /**\\n     * This class is not thread-safe; the field {@link #length} is mutable.\\n     * However, it is not shared between threads, as it is constructed on demand\\n     * by the method {@link ColognePhonetic#colognePhonetic(String)}\\n     */\\n    private abstract class CologneBuffer {\\n\\n        protected final char[] data;\\n\\n        protected int length = 0;\\n\\n        public CologneBuffer(final char[] data) {\\n            this.data = data;\\n            this.length = data.length;\\n        }\\n\\n        public CologneBuffer(final int buffSize) {\\n            this.data = new char[buffSize];\\n            this.length = 0;\\n        }\\n\\n        protected abstract char[] copyData(int start, final int length);\\n\\n        public int length() {\\n            return length;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return new String(copyData(0, length));\\n        }\\n    }\\n\\n    private class CologneOutputBuffer extends CologneBuffer {\\n\\n        public CologneOutputBuffer(final int buffSize) {\\n            super(buffSize);\\n        }\\n\\n        public void addRight(final char chr) {\\n            data[length] = chr;\\n            length++;\\n        }\\n\\n        @Override\\n        protected char[] copyData(final int start, final int length) {\\n            final char[] newData = new char[length];\\n            System.arraycopy(data, start, newData, 0, length);\\n            return newData;\\n        }\\n    }\\n\\n    private class CologneInputBuffer extends CologneBuffer {\\n\\n        public CologneInputBuffer(final char[] data) {\\n            super(data);\\n        }\\n\\n        public void addLeft(final char ch) {\\n            length++;\\n            data[getNextPos()] = ch;\\n        }\\n\\n        @Override\\n        protected char[] copyData(final int start, final int length) {\\n            final char[] newData = new char[length];\\n            System.arraycopy(data, data.length - this.length + start, newData, 0, length);\\n            return newData;\\n        }\\n\\n        public char getNextChar() {\\n            return data[getNextPos()];\\n        }\\n\\n        protected int getNextPos() {\\n            return data.length - length;\\n        }\\n\\n        public char removeNext() {\\n            final char ch = getNextChar();\\n            length--;\\n            return ch;\\n        }\\n    }\\n\\n    /**\\n     * Maps some Germanic characters to plain for internal processing. The following characters are mapped:\\n     * <ul>\\n     * <li>capital a, umlaut mark</li>\\n     * <li>capital u, umlaut mark</li>\\n     * <li>capital o, umlaut mark</li>\\n     * <li>small sharp s, German</li>\\n     * </ul>\\n     */\\n    private static final char[][] PREPROCESS_MAP = new char[][]{\\n        {'\\\\u00C4', 'A'}, // capital a, umlaut mark\\n        {'\\\\u00DC', 'U'}, // capital u, umlaut mark\\n        {'\\\\u00D6', 'O'}, // capital o, umlaut mark\\n        {'\\\\u00DF', 'S'} // small sharp s, German\\n    };\\n\\n    /*\\n     * Returns whether the array contains the key, or not.\\n     */\\n    private static boolean arrayContains(final char[] arr, final char key) {\\n        for (final char element : arr) {\\n            if (element == key) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * <p>\\n     * Implements the <i>K&ouml;lner Phonetik</i> algorithm.\\n     * </p>\\n     * <p>\\n     * In contrast to the initial description of the algorithm, this implementation does the encoding in one pass.\\n     * </p>\\n     *\\n     * @param text The source text to encode\\n     * @return the corresponding encoding according to the <i>K&ouml;lner Phonetik</i> algorithm\\n     */\\n    public String colognePhonetic(String text) {\\n        if (text == null) {\\n            return null;\\n        }\\n\\n        text = preprocess(text);\\n\\n        final CologneOutputBuffer output = new CologneOutputBuffer(text.length() * 2);\\n        final CologneInputBuffer input = new CologneInputBuffer(text.toCharArray());\\n\\n        char nextChar;\\n\\n        char lastChar = '-';\\n        char lastCode = '/';\\n        char code;\\n        char chr;\\n\\n        int rightLength = input.length();\\n\\n        while (rightLength > 0) {\\n            chr = input.removeNext();\\n\\n            if ((rightLength = input.length()) > 0) {\\n                nextChar = input.getNextChar();\\n            } else {\\n                nextChar = '-';\\n            }\\n\\n            if (arrayContains(AEIJOUY, chr)) {\\n                code = '0';\\n            } else if (chr == 'H' || chr < 'A' || chr > 'Z') {\\n                if (lastCode == '/') {\\n                    continue;\\n                }\\n                code = '-';\\n            } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {\\n                code = '1';\\n            } else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) {\\n                code = '2';\\n            } else if (arrayContains(WFPV, chr)) {\\n                code = '3';\\n            } else if (arrayContains(GKQ, chr)) {\\n                code = '4';\\n            } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) {\\n                code = '4';\\n                input.addLeft('S');\\n                rightLength++;\\n            } else if (chr == 'S' || chr == 'Z') {\\n                code = '8';\\n            } else if (chr == 'C') {\\n                if (lastCode == '/') {\\n                    if (arrayContains(AHKLOQRUX, nextChar)) {\\n                        code = '4';\\n                    } else {\\n                        code = '8';\\n                    }\\n                } else {\\n                    if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) {\\n                        code = '8';\\n                    } else {\\n                        code = '4';\\n                    }\\n                }\\n            } else if (arrayContains(TDX, chr)) {\\n                code = '8';\\n            } else if (chr == 'R') {\\n                code = '7';\\n            } else if (chr == 'L') {\\n                code = '5';\\n            } else if (chr == 'M' || chr == 'N') {\\n                code = '6';\\n            } else {\\n                code = chr;\\n            }\\n\\n            if (code != '-' && (lastCode != code && (code != '0' || lastCode == '/') || code < '0' || code > '8')) {\\n                output.addRight(code);\\n            }\\n\\n            lastChar = chr;\\n            lastCode = code;\\n        }\\n        return output.toString();\\n    }\\n\\n    @Override\\n    public Object encode(final Object object) throws EncoderException {\\n        if (!(object instanceof String)) {\\n            throw new EncoderException(\\\"This method's parameter was expected to be of the type \\\" +\\n                String.class.getName() +\\n                \\\". But actually it was of the type \\\" +\\n                object.getClass().getName() +\\n                \\\".\\\");\\n        }\\n        return encode((String) object);\\n    }\\n\\n    @Override\\n    public String encode(final String text) {\\n        return colognePhonetic(text);\\n    }\\n\\n    public boolean isEncodeEqual(final String text1, final String text2) {\\n        return colognePhonetic(text1).equals(colognePhonetic(text2));\\n    }\\n\\n    /**\\n     * Converts the string to upper case and replaces germanic characters as defined in {@link #PREPROCESS_MAP}.\\n     */\\n    private String preprocess(String text) {\\n        text = text.toUpperCase(Locale.GERMAN);\\n\\n        final char[] chrs = text.toCharArray();\\n\\n        for (int index = 0; index < chrs.length; index++) {\\n            if (chrs[index] > 'Z') {\\n                for (final char[] element : PREPROCESS_MAP) {\\n                    if (chrs[index] == element[0]) {\\n                        chrs[index] = element[1];\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return new String(chrs);\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"ColognePhonetic\", \"position\": {\"start_line\": 182, \"end_line\": 445, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class ColognePhonetic implements StringEncoder {\\n\\n    // Predefined char arrays for better performance and less GC load\\n    private static final char[] AEIJOUY = new char[] { 'A', 'E', 'I', 'J', 'O', 'U', 'Y' };\\n    private static final char[] SCZ = new char[] { 'S', 'C', 'Z' };\\n    private static final char[] WFPV = new char[] { 'W', 'F', 'P', 'V' };\\n    private static final char[] GKQ = new char[] { 'G', 'K', 'Q' };\\n    private static final char[] CKQ = new char[] { 'C', 'K', 'Q' };\\n    private static final char[] AHKLOQRUX = new char[] { 'A', 'H', 'K', 'L', 'O', 'Q', 'R', 'U', 'X' };\\n    private static final char[] SZ = new char[] { 'S', 'Z' };\\n    private static final char[] AHOUKQX = new char[] { 'A', 'H', 'O', 'U', 'K', 'Q', 'X' };\\n    private static final char[] TDX = new char[] { 'T', 'D', 'X' };\\n\\n    /**\\n     * This class is not thread-safe; the field {@link #length} is mutable.\\n     * However, it is not shared between threads, as it is constructed on demand\\n     * by the method {@link ColognePhonetic#colognePhonetic(String)}\\n     */\\n    private abstract class CologneBuffer {\\n\\n        protected final char[] data;\\n\\n        protected int length = 0;\\n\\n        public CologneBuffer(final char[] data) {\\n            this.data = data;\\n            this.length = data.length;\\n        }\\n\\n        public CologneBuffer(final int buffSize) {\\n            this.data = new char[buffSize];\\n            this.length = 0;\\n        }\\n\\n        protected abstract char[] copyData(int start, final int length);\\n\\n        public int length() {\\n            return length;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return new String(copyData(0, length));\\n        }\\n    }\\n\\n    private class CologneOutputBuffer extends CologneBuffer {\\n\\n        public CologneOutputBuffer(final int buffSize) {\\n            super(buffSize);\\n        }\\n\\n        public void addRight(final char chr) {\\n            data[length] = chr;\\n            length++;\\n        }\\n\\n        @Override\\n        protected char[] copyData(final int start, final int length) {\\n            final char[] newData = new char[length];\\n            System.arraycopy(data, start, newData, 0, length);\\n            return newData;\\n        }\\n    }\\n\\n    private class CologneInputBuffer extends CologneBuffer {\\n\\n        public CologneInputBuffer(final char[] data) {\\n            super(data);\\n        }\\n\\n        public void addLeft(final char ch) {\\n            length++;\\n            data[getNextPos()] = ch;\\n        }\\n\\n        @Override\\n        protected char[] copyData(final int start, final int length) {\\n            final char[] newData = new char[length];\\n            System.arraycopy(data, data.length - this.length + start, newData, 0, length);\\n            return newData;\\n        }\\n\\n        public char getNextChar() {\\n            return data[getNextPos()];\\n        }\\n\\n        protected int getNextPos() {\\n            return data.length - length;\\n        }\\n\\n        public char removeNext() {\\n            final char ch = getNextChar();\\n            length--;\\n            return ch;\\n        }\\n    }\\n\\n    /**\\n     * Maps some Germanic characters to plain for internal processing. The following characters are mapped:\\n     * <ul>\\n     * <li>capital a, umlaut mark</li>\\n     * <li>capital u, umlaut mark</li>\\n     * <li>capital o, umlaut mark</li>\\n     * <li>small sharp s, German</li>\\n     * </ul>\\n     */\\n    private static final char[][] PREPROCESS_MAP = new char[][]{\\n        {'\\\\u00C4', 'A'}, // capital a, umlaut mark\\n        {'\\\\u00DC', 'U'}, // capital u, umlaut mark\\n        {'\\\\u00D6', 'O'}, // capital o, umlaut mark\\n        {'\\\\u00DF', 'S'} // small sharp s, German\\n    };\\n\\n    /*\\n     * Returns whether the array contains the key, or not.\\n     */\\n    private static boolean arrayContains(final char[] arr, final char key) {\\n        for (final char element : arr) {\\n            if (element == key) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * <p>\\n     * Implements the <i>K&ouml;lner Phonetik</i> algorithm.\\n     * </p>\\n     * <p>\\n     * In contrast to the initial description of the algorithm, this implementation does the encoding in one pass.\\n     * </p>\\n     *\\n     * @param text The source text to encode\\n     * @return the corresponding encoding according to the <i>K&ouml;lner Phonetik</i> algorithm\\n     */\\n    public String colognePhonetic(String text) {\\n        if (text == null) {\\n            return null;\\n        }\\n\\n        text = preprocess(text);\\n\\n        final CologneOutputBuffer output = new CologneOutputBuffer(text.length() * 2);\\n        final CologneInputBuffer input = new CologneInputBuffer(text.toCharArray());\\n\\n        char nextChar;\\n\\n        char lastChar = '-';\\n        char lastCode = '/';\\n        char code;\\n        char chr;\\n\\n        int rightLength = input.length();\\n\\n        while (rightLength > 0) {\\n            chr = input.removeNext();\\n\\n            if ((rightLength = input.length()) > 0) {\\n                nextChar = input.getNextChar();\\n            } else {\\n                nextChar = '-';\\n            }\\n\\n            if (arrayContains(AEIJOUY, chr)) {\\n                code = '0';\\n            } else if (chr == 'H' || chr < 'A' || chr > 'Z') {\\n                if (lastCode == '/') {\\n                    continue;\\n                }\\n                code = '-';\\n            } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {\\n                code = '1';\\n            } else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) {\\n                code = '2';\\n            } else if (arrayContains(WFPV, chr)) {\\n                code = '3';\\n            } else if (arrayContains(GKQ, chr)) {\\n                code = '4';\\n            } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) {\\n                code = '4';\\n                input.addLeft('S');\\n                rightLength++;\\n            } else if (chr == 'S' || chr == 'Z') {\\n                code = '8';\\n            } else if (chr == 'C') {\\n                if (lastCode == '/') {\\n                    if (arrayContains(AHKLOQRUX, nextChar)) {\\n                        code = '4';\\n                    } else {\\n                        code = '8';\\n                    }\\n                } else {\\n                    if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) {\\n                        code = '8';\\n                    } else {\\n                        code = '4';\\n                    }\\n                }\\n            } else if (arrayContains(TDX, chr)) {\\n                code = '8';\\n            } else if (chr == 'R') {\\n                code = '7';\\n            } else if (chr == 'L') {\\n                code = '5';\\n            } else if (chr == 'M' || chr == 'N') {\\n                code = '6';\\n            } else {\\n                code = chr;\\n            }\\n\\n            if (code != '-' && (lastCode != code && (code != '0' || lastCode == '/') || code < '0' || code > '8')) {\\n                output.addRight(code);\\n            }\\n\\n            lastChar = chr;\\n            lastCode = code;\\n        }\\n        return output.toString();\\n    }\\n\\n    @Override\\n    public Object encode(final Object object) throws EncoderException {\\n        if (!(object instanceof String)) {\\n            throw new EncoderException(\\\"This method's parameter was expected to be of the type \\\" +\\n                String.class.getName() +\\n                \\\". But actually it was of the type \\\" +\\n                object.getClass().getName() +\\n                \\\".\\\");\\n        }\\n        return encode((String) object);\\n    }\\n\\n    @Override\\n    public String encode(final String text) {\\n        return colognePhonetic(text);\\n    }\\n\\n    public boolean isEncodeEqual(final String text1, final String text2) {\\n        return colognePhonetic(text1).equals(colognePhonetic(text2));\\n    }\\n\\n    /**\\n     * Converts the string to upper case and replaces germanic characters as defined in {@link #PREPROCESS_MAP}.\\n     */\\n    private String preprocess(String text) {\\n        text = text.toUpperCase(Locale.GERMAN);\\n\\n        final char[] chrs = text.toCharArray();\\n\\n        for (int index = 0; index < chrs.length; index++) {\\n            if (chrs[index] > 'Z') {\\n                for (final char[] element : PREPROCESS_MAP) {\\n                    if (chrs[index] == element[0]) {\\n                        chrs[index] = element[1];\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return new String(chrs);\\n    }\\n}\", \"summary\": \"\", \"methods\": []}, {\"parent_file\": null, \"name\": \"CologneBuffer\", \"position\": {\"start_line\": 200, \"end_line\": 226, \"start_column\": 22, \"end_column\": 5}, \"code\": \"class CologneBuffer {\\n\\n        protected final char[] data;\\n\\n        protected int length = 0;\\n\\n        public CologneBuffer(final char[] data) {\\n            this.data = data;\\n            this.length = data.length;\\n        }\\n\\n        public CologneBuffer(final int buffSize) {\\n            this.data = new char[buffSize];\\n            this.length = 0;\\n        }\\n\\n        protected abstract char[] copyData(int start, final int length);\\n\\n        public int length() {\\n            return length;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return new String(copyData(0, length));\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"copyData\", \"return_type\": \"char\", \"position\": {\"start_line\": 216, \"end_line\": 216, \"start_column\": 28, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"start\", \"type\": \"int\"}, {\"name\": \"length\", \"type\": \"int\"}]}, {\"name\": \"length\", \"return_type\": \"int\", \"position\": {\"start_line\": 218, \"end_line\": 220, \"start_column\": 16, \"end_column\": 9}, \"code\": \"int length() {\\n            return length;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 223, \"end_line\": 225, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String toString() {\\n            return new String(copyData(0, length));\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}, {\"parent_file\": null, \"name\": \"CologneOutputBuffer\", \"position\": {\"start_line\": 228, \"end_line\": 245, \"start_column\": 13, \"end_column\": 5}, \"code\": \"class CologneOutputBuffer extends CologneBuffer {\\n\\n        public CologneOutputBuffer(final int buffSize) {\\n            super(buffSize);\\n        }\\n\\n        public void addRight(final char chr) {\\n            data[length] = chr;\\n            length++;\\n        }\\n\\n        @Override\\n        protected char[] copyData(final int start, final int length) {\\n            final char[] newData = new char[length];\\n            System.arraycopy(data, start, newData, 0, length);\\n            return newData;\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"addRight\", \"return_type\": \"void\", \"position\": {\"start_line\": 234, \"end_line\": 237, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void addRight(final char chr) {\\n            data[length] = chr;\\n            length++;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"chr\", \"type\": \"char\"}]}, {\"name\": \"copyData\", \"return_type\": \"char\", \"position\": {\"start_line\": 240, \"end_line\": 244, \"start_column\": 19, \"end_column\": 9}, \"code\": \"char[] copyData(final int start, final int length) {\\n            final char[] newData = new char[length];\\n            System.arraycopy(data, start, newData, 0, length);\\n            return newData;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"start\", \"type\": \"int\"}, {\"name\": \"length\", \"type\": \"int\"}]}]}, {\"parent_file\": null, \"name\": \"CologneInputBuffer\", \"position\": {\"start_line\": 247, \"end_line\": 278, \"start_column\": 13, \"end_column\": 5}, \"code\": \"class CologneInputBuffer extends CologneBuffer {\\n\\n        public CologneInputBuffer(final char[] data) {\\n            super(data);\\n        }\\n\\n        public void addLeft(final char ch) {\\n            length++;\\n            data[getNextPos()] = ch;\\n        }\\n\\n        @Override\\n        protected char[] copyData(final int start, final int length) {\\n            final char[] newData = new char[length];\\n            System.arraycopy(data, data.length - this.length + start, newData, 0, length);\\n            return newData;\\n        }\\n\\n        public char getNextChar() {\\n            return data[getNextPos()];\\n        }\\n\\n        protected int getNextPos() {\\n            return data.length - length;\\n        }\\n\\n        public char removeNext() {\\n            final char ch = getNextChar();\\n            length--;\\n            return ch;\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"addLeft\", \"return_type\": \"void\", \"position\": {\"start_line\": 253, \"end_line\": 256, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void addLeft(final char ch) {\\n            length++;\\n            data[getNextPos()] = ch;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ch\", \"type\": \"char\"}]}, {\"name\": \"copyData\", \"return_type\": \"char\", \"position\": {\"start_line\": 259, \"end_line\": 263, \"start_column\": 19, \"end_column\": 9}, \"code\": \"char[] copyData(final int start, final int length) {\\n            final char[] newData = new char[length];\\n            System.arraycopy(data, data.length - this.length + start, newData, 0, length);\\n            return newData;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"start\", \"type\": \"int\"}, {\"name\": \"length\", \"type\": \"int\"}]}, {\"name\": \"getNextChar\", \"return_type\": \"char\", \"position\": {\"start_line\": 265, \"end_line\": 267, \"start_column\": 16, \"end_column\": 9}, \"code\": \"char getNextChar() {\\n            return data[getNextPos()];\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getNextPos\", \"return_type\": \"int\", \"position\": {\"start_line\": 269, \"end_line\": 271, \"start_column\": 19, \"end_column\": 9}, \"code\": \"int getNextPos() {\\n            return data.length - length;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"removeNext\", \"return_type\": \"char\", \"position\": {\"start_line\": 273, \"end_line\": 277, \"start_column\": 16, \"end_column\": 9}, \"code\": \"char removeNext() {\\n            final char ch = getNextChar();\\n            length--;\\n            return ch;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"arrayContains\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 299, \"end_line\": 306, \"start_column\": 20, \"end_column\": 5}, \"code\": \"boolean arrayContains(final char[] arr, final char key) {\\n        for (final char element : arr) {\\n            if (element == key) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"arr\", \"type\": \"char\"}, {\"name\": \"key\", \"type\": \"char\"}]}, {\"name\": \"colognePhonetic\", \"return_type\": \"String\", \"position\": {\"start_line\": 319, \"end_line\": 402, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String colognePhonetic(String text) {\\n        if (text == null) {\\n            return null;\\n        }\\n\\n        text = preprocess(text);\\n\\n        final CologneOutputBuffer output = new CologneOutputBuffer(text.length() * 2);\\n        final CologneInputBuffer input = new CologneInputBuffer(text.toCharArray());\\n\\n        char nextChar;\\n\\n        char lastChar = '-';\\n        char lastCode = '/';\\n        char code;\\n        char chr;\\n\\n        int rightLength = input.length();\\n\\n        while (rightLength > 0) {\\n            chr = input.removeNext();\\n\\n            if ((rightLength = input.length()) > 0) {\\n                nextChar = input.getNextChar();\\n            } else {\\n                nextChar = '-';\\n            }\\n\\n            if (arrayContains(AEIJOUY, chr)) {\\n                code = '0';\\n            } else if (chr == 'H' || chr < 'A' || chr > 'Z') {\\n                if (lastCode == '/') {\\n                    continue;\\n                }\\n                code = '-';\\n            } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {\\n                code = '1';\\n            } else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) {\\n                code = '2';\\n            } else if (arrayContains(WFPV, chr)) {\\n                code = '3';\\n            } else if (arrayContains(GKQ, chr)) {\\n                code = '4';\\n            } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) {\\n                code = '4';\\n                input.addLeft('S');\\n                rightLength++;\\n            } else if (chr == 'S' || chr == 'Z') {\\n                code = '8';\\n            } else if (chr == 'C') {\\n                if (lastCode == '/') {\\n                    if (arrayContains(AHKLOQRUX, nextChar)) {\\n                        code = '4';\\n                    } else {\\n                        code = '8';\\n                    }\\n                } else {\\n                    if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) {\\n                        code = '8';\\n                    } else {\\n                        code = '4';\\n                    }\\n                }\\n            } else if (arrayContains(TDX, chr)) {\\n                code = '8';\\n            } else if (chr == 'R') {\\n                code = '7';\\n            } else if (chr == 'L') {\\n                code = '5';\\n            } else if (chr == 'M' || chr == 'N') {\\n                code = '6';\\n            } else {\\n                code = chr;\\n            }\\n\\n            if (code != '-' && (lastCode != code && (code != '0' || lastCode == '/') || code < '0' || code > '8')) {\\n                output.addRight(code);\\n            }\\n\\n            lastChar = chr;\\n            lastCode = code;\\n        }\\n        return output.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"text\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 405, \"end_line\": 414, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object object) throws EncoderException {\\n        if (!(object instanceof String)) {\\n            throw new EncoderException(\\\"This method's parameter was expected to be of the type \\\" +\\n                String.class.getName() +\\n                \\\". But actually it was of the type \\\" +\\n                object.getClass().getName() +\\n                \\\".\\\");\\n        }\\n        return encode((String) object);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"object\", \"type\": \"Object\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 417, \"end_line\": 419, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String text) {\\n        return colognePhonetic(text);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"text\", \"type\": \"String\"}]}, {\"name\": \"isEncodeEqual\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 421, \"end_line\": 423, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isEncodeEqual(final String text1, final String text2) {\\n        return colognePhonetic(text1).equals(colognePhonetic(text2));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"text1\", \"type\": \"String\"}, {\"name\": \"text2\", \"type\": \"String\"}]}, {\"name\": \"preprocess\", \"return_type\": \"String\", \"position\": {\"start_line\": 428, \"end_line\": 444, \"start_column\": 13, \"end_column\": 5}, \"code\": \"String preprocess(String text) {\\n        text = text.toUpperCase(Locale.GERMAN);\\n\\n        final char[] chrs = text.toCharArray();\\n\\n        for (int index = 0; index < chrs.length; index++) {\\n            if (chrs[index] > 'Z') {\\n                for (final char[] element : PREPROCESS_MAP) {\\n                    if (chrs[index] == element[0]) {\\n                        chrs[index] = element[1];\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return new String(chrs);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"text\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npackage org.apache.commons.codec.language;\\n\\nimport java.io.InputStream;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.Comparator;\\nimport java.util.HashMap;\\nimport java.util.LinkedHashSet;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Scanner;\\nimport java.util.Set;\\n\\nimport org.apache.commons.codec.CharEncoding;\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringEncoder;\\n\\n/**\\n * Encodes a string into a Daitch-Mokotoff Soundex value.\\n * <p>\\n * The Daitch-Mokotoff Soundex algorithm is a refinement of the Russel and American Soundex algorithms, yielding greater\\n * accuracy in matching especially Slavish and Yiddish surnames with similar pronunciation but differences in spelling.\\n * </p>\\n * <p>\\n * The main differences compared to the other soundex variants are:\\n * </p>\\n * <ul>\\n * <li>coded names are 6 digits long\\n * <li>the initial character of the name is coded\\n * <li>rules to encoded multi-character n-grams\\n * <li>multiple possible encodings for the same name (branching)\\n * </ul>\\n * <p>\\n * This implementation supports branching, depending on the used method:\\n * <ul>\\n * <li>{@link #encode(String)} - branching disabled, only the first code will be returned\\n * <li>{@link #soundex(String)} - branching enabled, all codes will be returned, separated by '|'\\n * </ul>\\n * <p>\\n * Note: this implementation has additional branching rules compared to the original description of the algorithm. The\\n * rules can be customized by overriding the default rules contained in the resource file\\n * {@code org/apache/commons/codec/language/dmrules.txt}.\\n * </p>\\n * <p>\\n * This class is thread-safe.\\n * </p>\\n *\\n * @see Soundex\\n * @see <a href=\\\"http://en.wikipedia.org/wiki/Daitch%E2%80%93Mokotoff_Soundex\\\"> Wikipedia - Daitch-Mokotoff Soundex</a>\\n * @see <a href=\\\"http://www.avotaynu.com/soundex.htm\\\">Avotaynu - Soundexing and Genealogy</a>\\n *\\n * @version $Id: DaitchMokotoffSoundex.java 1760691 2016-09-14 12:14:26Z jochen $\\n * @since 1.10\\n */\\npublic class DaitchMokotoffSoundex implements StringEncoder {\\n\\n    /**\\n     * Inner class representing a branch during DM soundex encoding.\\n     */\\n    private static final class Branch {\\n        private final StringBuilder builder;\\n        private String cachedString;\\n        private String lastReplacement;\\n\\n        private Branch() {\\n            builder = new StringBuilder();\\n            lastReplacement = null;\\n            cachedString = null;\\n        }\\n\\n        /**\\n         * Creates a new branch, identical to this branch.\\n         *\\n         * @return a new, identical branch\\n         */\\n        public Branch createBranch() {\\n            final Branch branch = new Branch();\\n            branch.builder.append(toString());\\n            branch.lastReplacement = this.lastReplacement;\\n            return branch;\\n        }\\n\\n        @Override\\n        public boolean equals(final Object other) {\\n            if (this == other) {\\n                return true;\\n            }\\n            if (!(other instanceof Branch)) {\\n                return false;\\n            }\\n\\n            return toString().equals(((Branch) other).toString());\\n        }\\n\\n        /**\\n         * Finish this branch by appending '0's until the maximum code length has been reached.\\n         */\\n        public void finish() {\\n            while (builder.length() < MAX_LENGTH) {\\n                builder.append('0');\\n                cachedString = null;\\n            }\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return toString().hashCode();\\n        }\\n\\n        /**\\n         * Process the next replacement to be added to this branch.\\n         *\\n         * @param replacement\\n         *            the next replacement to append\\n         * @param forceAppend\\n         *            indicates if the default processing shall be overridden\\n         */\\n        public void processNextReplacement(final String replacement, final boolean forceAppend) {\\n            final boolean append = lastReplacement == null || !lastReplacement.endsWith(replacement) || forceAppend;\\n\\n            if (append && builder.length() < MAX_LENGTH) {\\n                builder.append(replacement);\\n                // remove all characters after the maximum length\\n                if (builder.length() > MAX_LENGTH) {\\n                    builder.delete(MAX_LENGTH, builder.length());\\n                }\\n                cachedString = null;\\n            }\\n\\n            lastReplacement = replacement;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            if (cachedString == null) {\\n                cachedString = builder.toString();\\n            }\\n            return cachedString;\\n        }\\n    }\\n\\n    /**\\n     * Inner class for storing rules.\\n     */\\n    private static final class Rule {\\n        private final String pattern;\\n        private final String[] replacementAtStart;\\n        private final String[] replacementBeforeVowel;\\n        private final String[] replacementDefault;\\n\\n        protected Rule(final String pattern, final String replacementAtStart, final String replacementBeforeVowel,\\n                final String replacementDefault) {\\n            this.pattern = pattern;\\n            this.replacementAtStart = replacementAtStart.split(\\\"\\\\\\\\|\\\");\\n            this.replacementBeforeVowel = replacementBeforeVowel.split(\\\"\\\\\\\\|\\\");\\n            this.replacementDefault = replacementDefault.split(\\\"\\\\\\\\|\\\");\\n        }\\n\\n        public int getPatternLength() {\\n            return pattern.length();\\n        }\\n\\n        public String[] getReplacements(final String context, final boolean atStart) {\\n            if (atStart) {\\n                return replacementAtStart;\\n            }\\n\\n            final int nextIndex = getPatternLength();\\n            final boolean nextCharIsVowel = nextIndex < context.length() ? isVowel(context.charAt(nextIndex)) : false;\\n            if (nextCharIsVowel) {\\n                return replacementBeforeVowel;\\n            }\\n\\n            return replacementDefault;\\n        }\\n\\n        private boolean isVowel(final char ch) {\\n            return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';\\n        }\\n\\n        public boolean matches(final String context) {\\n            return context.startsWith(pattern);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return String.format(\\\"%s=(%s,%s,%s)\\\", pattern, Arrays.asList(replacementAtStart),\\n                    Arrays.asList(replacementBeforeVowel), Arrays.asList(replacementDefault));\\n        }\\n    }\\n\\n    private static final String COMMENT = \\\"//\\\";\\n    private static final String DOUBLE_QUOTE = \\\"\\\\\\\"\\\";\\n\\n    private static final String MULTILINE_COMMENT_END = \\\"*/\\\";\\n\\n    private static final String MULTILINE_COMMENT_START = \\\"/*\\\";\\n\\n    /** The resource file containing the replacement and folding rules */\\n    private static final String RESOURCE_FILE = \\\"org/apache/commons/codec/language/dmrules.txt\\\";\\n\\n    /** The code length of a DM soundex value. */\\n    private static final int MAX_LENGTH = 6;\\n\\n    /** Transformation rules indexed by the first character of their pattern. */\\n    private static final Map<Character, List<Rule>> RULES = new HashMap<Character, List<Rule>>();\\n\\n    /** Folding rules. */\\n    private static final Map<Character, Character> FOLDINGS = new HashMap<Character, Character>();\\n\\n    static {\\n        final InputStream rulesIS = DaitchMokotoffSoundex.class.getClassLoader().getResourceAsStream(RESOURCE_FILE);\\n        if (rulesIS == null) {\\n            throw new IllegalArgumentException(\\\"Unable to load resource: \\\" + RESOURCE_FILE);\\n        }\\n\\n        final Scanner scanner = new Scanner(rulesIS, CharEncoding.UTF_8);\\n        try {\\n            parseRules(scanner, RESOURCE_FILE, RULES, FOLDINGS);\\n        } finally {\\n            scanner.close();\\n        }\\n\\n        // sort RULES by pattern length in descending order\\n        for (final Map.Entry<Character, List<Rule>> rule : RULES.entrySet()) {\\n            final List<Rule> ruleList = rule.getValue();\\n            Collections.sort(ruleList, new Comparator<Rule>() {\\n                @Override\\n                public int compare(final Rule rule1, final Rule rule2) {\\n                    return rule2.getPatternLength() - rule1.getPatternLength();\\n                }\\n            });\\n        }\\n    }\\n\\n    private static void parseRules(final Scanner scanner, final String location,\\n            final Map<Character, List<Rule>> ruleMapping, final Map<Character, Character> asciiFoldings) {\\n        int currentLine = 0;\\n        boolean inMultilineComment = false;\\n\\n        while (scanner.hasNextLine()) {\\n            currentLine++;\\n            final String rawLine = scanner.nextLine();\\n            String line = rawLine;\\n\\n            if (inMultilineComment) {\\n                if (line.endsWith(MULTILINE_COMMENT_END)) {\\n                    inMultilineComment = false;\\n                }\\n                continue;\\n            }\\n\\n            if (line.startsWith(MULTILINE_COMMENT_START)) {\\n                inMultilineComment = true;\\n            } else {\\n                // discard comments\\n                final int cmtI = line.indexOf(COMMENT);\\n                if (cmtI >= 0) {\\n                    line = line.substring(0, cmtI);\\n                }\\n\\n                // trim leading-trailing whitespace\\n                line = line.trim();\\n\\n                if (line.length() == 0) {\\n                    continue; // empty lines can be safely skipped\\n                }\\n\\n                if (line.contains(\\\"=\\\")) {\\n                    // folding\\n                    final String[] parts = line.split(\\\"=\\\");\\n                    if (parts.length != 2) {\\n                        throw new IllegalArgumentException(\\\"Malformed folding statement split into \\\" + parts.length +\\n                                \\\" parts: \\\" + rawLine + \\\" in \\\" + location);\\n                    }\\n                    final String leftCharacter = parts[0];\\n                    final String rightCharacter = parts[1];\\n\\n                    if (leftCharacter.length() != 1 || rightCharacter.length() != 1) {\\n                        throw new IllegalArgumentException(\\\"Malformed folding statement - \\\" +\\n                                \\\"patterns are not single characters: \\\" + rawLine + \\\" in \\\" + location);\\n                    }\\n\\n                    asciiFoldings.put(leftCharacter.charAt(0), rightCharacter.charAt(0));\\n                } else {\\n                    // rule\\n                    final String[] parts = line.split(\\\"\\\\\\\\s+\\\");\\n                    if (parts.length != 4) {\\n                        throw new IllegalArgumentException(\\\"Malformed rule statement split into \\\" + parts.length +\\n                                \\\" parts: \\\" + rawLine + \\\" in \\\" + location);\\n                    }\\n                    try {\\n                        final String pattern = stripQuotes(parts[0]);\\n                        final String replacement1 = stripQuotes(parts[1]);\\n                        final String replacement2 = stripQuotes(parts[2]);\\n                        final String replacement3 = stripQuotes(parts[3]);\\n\\n                        final Rule r = new Rule(pattern, replacement1, replacement2, replacement3);\\n                        final char patternKey = r.pattern.charAt(0);\\n                        List<Rule> rules = ruleMapping.get(patternKey);\\n                        if (rules == null) {\\n                            rules = new ArrayList<Rule>();\\n                            ruleMapping.put(patternKey, rules);\\n                        }\\n                        rules.add(r);\\n                    } catch (final IllegalArgumentException e) {\\n                        throw new IllegalStateException(\\n                                \\\"Problem parsing line '\\\" + currentLine + \\\"' in \\\" + location, e);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    private static String stripQuotes(String str) {\\n        if (str.startsWith(DOUBLE_QUOTE)) {\\n            str = str.substring(1);\\n        }\\n\\n        if (str.endsWith(DOUBLE_QUOTE)) {\\n            str = str.substring(0, str.length() - 1);\\n        }\\n\\n        return str;\\n    }\\n\\n    /** Whether to use ASCII folding prior to encoding. */\\n    private final boolean folding;\\n\\n    /**\\n     * Creates a new instance with ASCII-folding enabled.\\n     */\\n    public DaitchMokotoffSoundex() {\\n        this(true);\\n    }\\n\\n    /**\\n     * Creates a new instance.\\n     * <p>\\n     * With ASCII-folding enabled, certain accented characters will be transformed to equivalent ASCII characters, e.g.\\n     * \\u00e8 -&gt; e.\\n     * </p>\\n     *\\n     * @param folding\\n     *            if ASCII-folding shall be performed before encoding\\n     */\\n    public DaitchMokotoffSoundex(final boolean folding) {\\n        this.folding = folding;\\n    }\\n\\n    /**\\n     * Performs a cleanup of the input string before the actual soundex transformation.\\n     * <p>\\n     * Removes all whitespace characters and performs ASCII folding if enabled.\\n     * </p>\\n     *\\n     * @param input\\n     *            the input string to cleanup\\n     * @return a cleaned up string\\n     */\\n    private String cleanup(final String input) {\\n        final StringBuilder sb = new StringBuilder();\\n        for (char ch : input.toCharArray()) {\\n            if (Character.isWhitespace(ch)) {\\n                continue;\\n            }\\n\\n            ch = Character.toLowerCase(ch);\\n            if (folding && FOLDINGS.containsKey(ch)) {\\n                ch = FOLDINGS.get(ch);\\n            }\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\\n\\n    /**\\n     * Encodes an Object using the Daitch-Mokotoff soundex algorithm without branching.\\n     * <p>\\n     * This method is provided in order to satisfy the requirements of the Encoder interface, and will throw an\\n     * EncoderException if the supplied object is not of type java.lang.String.\\n     * </p>\\n     *\\n     * @see #soundex(String)\\n     *\\n     * @param obj\\n     *            Object to encode\\n     * @return An object (of type java.lang.String) containing the DM soundex code, which corresponds to the String\\n     *         supplied.\\n     * @throws EncoderException\\n     *             if the parameter supplied is not of type java.lang.String\\n     * @throws IllegalArgumentException\\n     *             if a character is not mapped\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\n                    \\\"Parameter supplied to DaitchMokotoffSoundex encode is not of type java.lang.String\\\");\\n        }\\n        return encode((String) obj);\\n    }\\n\\n    /**\\n     * Encodes a String using the Daitch-Mokotoff soundex algorithm without branching.\\n     *\\n     * @see #soundex(String)\\n     *\\n     * @param source\\n     *            A String object to encode\\n     * @return A DM Soundex code corresponding to the String supplied\\n     * @throws IllegalArgumentException\\n     *             if a character is not mapped\\n     */\\n    @Override\\n    public String encode(final String source) {\\n        if (source == null) {\\n            return null;\\n        }\\n        return soundex(source, false)[0];\\n    }\\n\\n    /**\\n     * Encodes a String using the Daitch-Mokotoff soundex algorithm with branching.\\n     * <p>\\n     * In case a string is encoded into multiple codes (see branching rules), the result will contain all codes,\\n     * separated by '|'.\\n     * </p>\\n     * <p>\\n     * Example: the name \\\"AUERBACH\\\" is encoded as both\\n     * </p>\\n     * <ul>\\n     * <li>097400</li>\\n     * <li>097500</li>\\n     * </ul>\\n     * <p>\\n     * Thus the result will be \\\"097400|097500\\\".\\n     * </p>\\n     *\\n     * @param source\\n     *            A String object to encode\\n     * @return A string containing a set of DM Soundex codes corresponding to the String supplied\\n     * @throws IllegalArgumentException\\n     *             if a character is not mapped\\n     */\\n    public String soundex(final String source) {\\n        final String[] branches = soundex(source, true);\\n        final StringBuilder sb = new StringBuilder();\\n        int index = 0;\\n        for (final String branch : branches) {\\n            sb.append(branch);\\n            if (++index < branches.length) {\\n                sb.append('|');\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    /**\\n     * Perform the actual DM Soundex algorithm on the input string.\\n     *\\n     * @param source\\n     *            A String object to encode\\n     * @param branching\\n     *            If branching shall be performed\\n     * @return A string array containing all DM Soundex codes corresponding to the String supplied depending on the\\n     *         selected branching mode\\n     */\\n    private String[] soundex(final String source, final boolean branching) {\\n        if (source == null) {\\n            return null;\\n        }\\n\\n        final String input = cleanup(source);\\n\\n        final Set<Branch> currentBranches = new LinkedHashSet<Branch>();\\n        currentBranches.add(new Branch());\\n\\n        char lastChar = '\\\\0';\\n        for (int index = 0; index < input.length(); index++) {\\n            final char ch = input.charAt(index);\\n\\n            // ignore whitespace inside a name\\n            if (Character.isWhitespace(ch)) {\\n                continue;\\n            }\\n\\n            final String inputContext = input.substring(index);\\n            final List<Rule> rules = RULES.get(ch);\\n            if (rules == null) {\\n                continue;\\n            }\\n\\n            // use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access\\n            @SuppressWarnings(\\\"unchecked\\\")\\n            final List<Branch> nextBranches = branching ? new ArrayList<Branch>() : Collections.EMPTY_LIST;\\n\\n            for (final Rule rule : rules) {\\n                if (rule.matches(inputContext)) {\\n                    if (branching) {\\n                        nextBranches.clear();\\n                    }\\n                    final String[] replacements = rule.getReplacements(inputContext, lastChar == '\\\\0');\\n                    final boolean branchingRequired = replacements.length > 1 && branching;\\n\\n                    for (final Branch branch : currentBranches) {\\n                        for (final String nextReplacement : replacements) {\\n                            // if we have multiple replacements, always create a new branch\\n                            final Branch nextBranch = branchingRequired ? branch.createBranch() : branch;\\n\\n                            // special rule: occurrences of mn or nm are treated differently\\n                            final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm');\\n\\n                            nextBranch.processNextReplacement(nextReplacement, force);\\n\\n                            if (branching) {\\n                                nextBranches.add(nextBranch);\\n                            } else {\\n                                break;\\n                            }\\n                        }\\n                    }\\n\\n                    if (branching) {\\n                        currentBranches.clear();\\n                        currentBranches.addAll(nextBranches);\\n                    }\\n                    index += rule.getPatternLength() - 1;\\n                    break;\\n                }\\n            }\\n\\n            lastChar = ch;\\n        }\\n\\n        final String[] result = new String[currentBranches.size()];\\n        int index = 0;\\n        for (final Branch branch : currentBranches) {\\n            branch.finish();\\n            result[index++] = branch.toString();\\n        }\\n\\n        return result;\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"DaitchMokotoffSoundex\", \"position\": {\"start_line\": 72, \"end_line\": 562, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class DaitchMokotoffSoundex implements StringEncoder {\\n\\n    /**\\n     * Inner class representing a branch during DM soundex encoding.\\n     */\\n    private static final class Branch {\\n        private final StringBuilder builder;\\n        private String cachedString;\\n        private String lastReplacement;\\n\\n        private Branch() {\\n            builder = new StringBuilder();\\n            lastReplacement = null;\\n            cachedString = null;\\n        }\\n\\n        /**\\n         * Creates a new branch, identical to this branch.\\n         *\\n         * @return a new, identical branch\\n         */\\n        public Branch createBranch() {\\n            final Branch branch = new Branch();\\n            branch.builder.append(toString());\\n            branch.lastReplacement = this.lastReplacement;\\n            return branch;\\n        }\\n\\n        @Override\\n        public boolean equals(final Object other) {\\n            if (this == other) {\\n                return true;\\n            }\\n            if (!(other instanceof Branch)) {\\n                return false;\\n            }\\n\\n            return toString().equals(((Branch) other).toString());\\n        }\\n\\n        /**\\n         * Finish this branch by appending '0's until the maximum code length has been reached.\\n         */\\n        public void finish() {\\n            while (builder.length() < MAX_LENGTH) {\\n                builder.append('0');\\n                cachedString = null;\\n            }\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return toString().hashCode();\\n        }\\n\\n        /**\\n         * Process the next replacement to be added to this branch.\\n         *\\n         * @param replacement\\n         *            the next replacement to append\\n         * @param forceAppend\\n         *            indicates if the default processing shall be overridden\\n         */\\n        public void processNextReplacement(final String replacement, final boolean forceAppend) {\\n            final boolean append = lastReplacement == null || !lastReplacement.endsWith(replacement) || forceAppend;\\n\\n            if (append && builder.length() < MAX_LENGTH) {\\n                builder.append(replacement);\\n                // remove all characters after the maximum length\\n                if (builder.length() > MAX_LENGTH) {\\n                    builder.delete(MAX_LENGTH, builder.length());\\n                }\\n                cachedString = null;\\n            }\\n\\n            lastReplacement = replacement;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            if (cachedString == null) {\\n                cachedString = builder.toString();\\n            }\\n            return cachedString;\\n        }\\n    }\\n\\n    /**\\n     * Inner class for storing rules.\\n     */\\n    private static final class Rule {\\n        private final String pattern;\\n        private final String[] replacementAtStart;\\n        private final String[] replacementBeforeVowel;\\n        private final String[] replacementDefault;\\n\\n        protected Rule(final String pattern, final String replacementAtStart, final String replacementBeforeVowel,\\n                final String replacementDefault) {\\n            this.pattern = pattern;\\n            this.replacementAtStart = replacementAtStart.split(\\\"\\\\\\\\|\\\");\\n            this.replacementBeforeVowel = replacementBeforeVowel.split(\\\"\\\\\\\\|\\\");\\n            this.replacementDefault = replacementDefault.split(\\\"\\\\\\\\|\\\");\\n        }\\n\\n        public int getPatternLength() {\\n            return pattern.length();\\n        }\\n\\n        public String[] getReplacements(final String context, final boolean atStart) {\\n            if (atStart) {\\n                return replacementAtStart;\\n            }\\n\\n            final int nextIndex = getPatternLength();\\n            final boolean nextCharIsVowel = nextIndex < context.length() ? isVowel(context.charAt(nextIndex)) : false;\\n            if (nextCharIsVowel) {\\n                return replacementBeforeVowel;\\n            }\\n\\n            return replacementDefault;\\n        }\\n\\n        private boolean isVowel(final char ch) {\\n            return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';\\n        }\\n\\n        public boolean matches(final String context) {\\n            return context.startsWith(pattern);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return String.format(\\\"%s=(%s,%s,%s)\\\", pattern, Arrays.asList(replacementAtStart),\\n                    Arrays.asList(replacementBeforeVowel), Arrays.asList(replacementDefault));\\n        }\\n    }\\n\\n    private static final String COMMENT = \\\"//\\\";\\n    private static final String DOUBLE_QUOTE = \\\"\\\\\\\"\\\";\\n\\n    private static final String MULTILINE_COMMENT_END = \\\"*/\\\";\\n\\n    private static final String MULTILINE_COMMENT_START = \\\"/*\\\";\\n\\n    /** The resource file containing the replacement and folding rules */\\n    private static final String RESOURCE_FILE = \\\"org/apache/commons/codec/language/dmrules.txt\\\";\\n\\n    /** The code length of a DM soundex value. */\\n    private static final int MAX_LENGTH = 6;\\n\\n    /** Transformation rules indexed by the first character of their pattern. */\\n    private static final Map<Character, List<Rule>> RULES = new HashMap<Character, List<Rule>>();\\n\\n    /** Folding rules. */\\n    private static final Map<Character, Character> FOLDINGS = new HashMap<Character, Character>();\\n\\n    static {\\n        final InputStream rulesIS = DaitchMokotoffSoundex.class.getClassLoader().getResourceAsStream(RESOURCE_FILE);\\n        if (rulesIS == null) {\\n            throw new IllegalArgumentException(\\\"Unable to load resource: \\\" + RESOURCE_FILE);\\n        }\\n\\n        final Scanner scanner = new Scanner(rulesIS, CharEncoding.UTF_8);\\n        try {\\n            parseRules(scanner, RESOURCE_FILE, RULES, FOLDINGS);\\n        } finally {\\n            scanner.close();\\n        }\\n\\n        // sort RULES by pattern length in descending order\\n        for (final Map.Entry<Character, List<Rule>> rule : RULES.entrySet()) {\\n            final List<Rule> ruleList = rule.getValue();\\n            Collections.sort(ruleList, new Comparator<Rule>() {\\n                @Override\\n                public int compare(final Rule rule1, final Rule rule2) {\\n                    return rule2.getPatternLength() - rule1.getPatternLength();\\n                }\\n            });\\n        }\\n    }\\n\\n    private static void parseRules(final Scanner scanner, final String location,\\n            final Map<Character, List<Rule>> ruleMapping, final Map<Character, Character> asciiFoldings) {\\n        int currentLine = 0;\\n        boolean inMultilineComment = false;\\n\\n        while (scanner.hasNextLine()) {\\n            currentLine++;\\n            final String rawLine = scanner.nextLine();\\n            String line = rawLine;\\n\\n            if (inMultilineComment) {\\n                if (line.endsWith(MULTILINE_COMMENT_END)) {\\n                    inMultilineComment = false;\\n                }\\n                continue;\\n            }\\n\\n            if (line.startsWith(MULTILINE_COMMENT_START)) {\\n                inMultilineComment = true;\\n            } else {\\n                // discard comments\\n                final int cmtI = line.indexOf(COMMENT);\\n                if (cmtI >= 0) {\\n                    line = line.substring(0, cmtI);\\n                }\\n\\n                // trim leading-trailing whitespace\\n                line = line.trim();\\n\\n                if (line.length() == 0) {\\n                    continue; // empty lines can be safely skipped\\n                }\\n\\n                if (line.contains(\\\"=\\\")) {\\n                    // folding\\n                    final String[] parts = line.split(\\\"=\\\");\\n                    if (parts.length != 2) {\\n                        throw new IllegalArgumentException(\\\"Malformed folding statement split into \\\" + parts.length +\\n                                \\\" parts: \\\" + rawLine + \\\" in \\\" + location);\\n                    }\\n                    final String leftCharacter = parts[0];\\n                    final String rightCharacter = parts[1];\\n\\n                    if (leftCharacter.length() != 1 || rightCharacter.length() != 1) {\\n                        throw new IllegalArgumentException(\\\"Malformed folding statement - \\\" +\\n                                \\\"patterns are not single characters: \\\" + rawLine + \\\" in \\\" + location);\\n                    }\\n\\n                    asciiFoldings.put(leftCharacter.charAt(0), rightCharacter.charAt(0));\\n                } else {\\n                    // rule\\n                    final String[] parts = line.split(\\\"\\\\\\\\s+\\\");\\n                    if (parts.length != 4) {\\n                        throw new IllegalArgumentException(\\\"Malformed rule statement split into \\\" + parts.length +\\n                                \\\" parts: \\\" + rawLine + \\\" in \\\" + location);\\n                    }\\n                    try {\\n                        final String pattern = stripQuotes(parts[0]);\\n                        final String replacement1 = stripQuotes(parts[1]);\\n                        final String replacement2 = stripQuotes(parts[2]);\\n                        final String replacement3 = stripQuotes(parts[3]);\\n\\n                        final Rule r = new Rule(pattern, replacement1, replacement2, replacement3);\\n                        final char patternKey = r.pattern.charAt(0);\\n                        List<Rule> rules = ruleMapping.get(patternKey);\\n                        if (rules == null) {\\n                            rules = new ArrayList<Rule>();\\n                            ruleMapping.put(patternKey, rules);\\n                        }\\n                        rules.add(r);\\n                    } catch (final IllegalArgumentException e) {\\n                        throw new IllegalStateException(\\n                                \\\"Problem parsing line '\\\" + currentLine + \\\"' in \\\" + location, e);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    private static String stripQuotes(String str) {\\n        if (str.startsWith(DOUBLE_QUOTE)) {\\n            str = str.substring(1);\\n        }\\n\\n        if (str.endsWith(DOUBLE_QUOTE)) {\\n            str = str.substring(0, str.length() - 1);\\n        }\\n\\n        return str;\\n    }\\n\\n    /** Whether to use ASCII folding prior to encoding. */\\n    private final boolean folding;\\n\\n    /**\\n     * Creates a new instance with ASCII-folding enabled.\\n     */\\n    public DaitchMokotoffSoundex() {\\n        this(true);\\n    }\\n\\n    /**\\n     * Creates a new instance.\\n     * <p>\\n     * With ASCII-folding enabled, certain accented characters will be transformed to equivalent ASCII characters, e.g.\\n     * \\u00e8 -&gt; e.\\n     * </p>\\n     *\\n     * @param folding\\n     *            if ASCII-folding shall be performed before encoding\\n     */\\n    public DaitchMokotoffSoundex(final boolean folding) {\\n        this.folding = folding;\\n    }\\n\\n    /**\\n     * Performs a cleanup of the input string before the actual soundex transformation.\\n     * <p>\\n     * Removes all whitespace characters and performs ASCII folding if enabled.\\n     * </p>\\n     *\\n     * @param input\\n     *            the input string to cleanup\\n     * @return a cleaned up string\\n     */\\n    private String cleanup(final String input) {\\n        final StringBuilder sb = new StringBuilder();\\n        for (char ch : input.toCharArray()) {\\n            if (Character.isWhitespace(ch)) {\\n                continue;\\n            }\\n\\n            ch = Character.toLowerCase(ch);\\n            if (folding && FOLDINGS.containsKey(ch)) {\\n                ch = FOLDINGS.get(ch);\\n            }\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\\n\\n    /**\\n     * Encodes an Object using the Daitch-Mokotoff soundex algorithm without branching.\\n     * <p>\\n     * This method is provided in order to satisfy the requirements of the Encoder interface, and will throw an\\n     * EncoderException if the supplied object is not of type java.lang.String.\\n     * </p>\\n     *\\n     * @see #soundex(String)\\n     *\\n     * @param obj\\n     *            Object to encode\\n     * @return An object (of type java.lang.String) containing the DM soundex code, which corresponds to the String\\n     *         supplied.\\n     * @throws EncoderException\\n     *             if the parameter supplied is not of type java.lang.String\\n     * @throws IllegalArgumentException\\n     *             if a character is not mapped\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\n                    \\\"Parameter supplied to DaitchMokotoffSoundex encode is not of type java.lang.String\\\");\\n        }\\n        return encode((String) obj);\\n    }\\n\\n    /**\\n     * Encodes a String using the Daitch-Mokotoff soundex algorithm without branching.\\n     *\\n     * @see #soundex(String)\\n     *\\n     * @param source\\n     *            A String object to encode\\n     * @return A DM Soundex code corresponding to the String supplied\\n     * @throws IllegalArgumentException\\n     *             if a character is not mapped\\n     */\\n    @Override\\n    public String encode(final String source) {\\n        if (source == null) {\\n            return null;\\n        }\\n        return soundex(source, false)[0];\\n    }\\n\\n    /**\\n     * Encodes a String using the Daitch-Mokotoff soundex algorithm with branching.\\n     * <p>\\n     * In case a string is encoded into multiple codes (see branching rules), the result will contain all codes,\\n     * separated by '|'.\\n     * </p>\\n     * <p>\\n     * Example: the name \\\"AUERBACH\\\" is encoded as both\\n     * </p>\\n     * <ul>\\n     * <li>097400</li>\\n     * <li>097500</li>\\n     * </ul>\\n     * <p>\\n     * Thus the result will be \\\"097400|097500\\\".\\n     * </p>\\n     *\\n     * @param source\\n     *            A String object to encode\\n     * @return A string containing a set of DM Soundex codes corresponding to the String supplied\\n     * @throws IllegalArgumentException\\n     *             if a character is not mapped\\n     */\\n    public String soundex(final String source) {\\n        final String[] branches = soundex(source, true);\\n        final StringBuilder sb = new StringBuilder();\\n        int index = 0;\\n        for (final String branch : branches) {\\n            sb.append(branch);\\n            if (++index < branches.length) {\\n                sb.append('|');\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    /**\\n     * Perform the actual DM Soundex algorithm on the input string.\\n     *\\n     * @param source\\n     *            A String object to encode\\n     * @param branching\\n     *            If branching shall be performed\\n     * @return A string array containing all DM Soundex codes corresponding to the String supplied depending on the\\n     *         selected branching mode\\n     */\\n    private String[] soundex(final String source, final boolean branching) {\\n        if (source == null) {\\n            return null;\\n        }\\n\\n        final String input = cleanup(source);\\n\\n        final Set<Branch> currentBranches = new LinkedHashSet<Branch>();\\n        currentBranches.add(new Branch());\\n\\n        char lastChar = '\\\\0';\\n        for (int index = 0; index < input.length(); index++) {\\n            final char ch = input.charAt(index);\\n\\n            // ignore whitespace inside a name\\n            if (Character.isWhitespace(ch)) {\\n                continue;\\n            }\\n\\n            final String inputContext = input.substring(index);\\n            final List<Rule> rules = RULES.get(ch);\\n            if (rules == null) {\\n                continue;\\n            }\\n\\n            // use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access\\n            @SuppressWarnings(\\\"unchecked\\\")\\n            final List<Branch> nextBranches = branching ? new ArrayList<Branch>() : Collections.EMPTY_LIST;\\n\\n            for (final Rule rule : rules) {\\n                if (rule.matches(inputContext)) {\\n                    if (branching) {\\n                        nextBranches.clear();\\n                    }\\n                    final String[] replacements = rule.getReplacements(inputContext, lastChar == '\\\\0');\\n                    final boolean branchingRequired = replacements.length > 1 && branching;\\n\\n                    for (final Branch branch : currentBranches) {\\n                        for (final String nextReplacement : replacements) {\\n                            // if we have multiple replacements, always create a new branch\\n                            final Branch nextBranch = branchingRequired ? branch.createBranch() : branch;\\n\\n                            // special rule: occurrences of mn or nm are treated differently\\n                            final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm');\\n\\n                            nextBranch.processNextReplacement(nextReplacement, force);\\n\\n                            if (branching) {\\n                                nextBranches.add(nextBranch);\\n                            } else {\\n                                break;\\n                            }\\n                        }\\n                    }\\n\\n                    if (branching) {\\n                        currentBranches.clear();\\n                        currentBranches.addAll(nextBranches);\\n                    }\\n                    index += rule.getPatternLength() - 1;\\n                    break;\\n                }\\n            }\\n\\n            lastChar = ch;\\n        }\\n\\n        final String[] result = new String[currentBranches.size()];\\n        int index = 0;\\n        for (final Branch branch : currentBranches) {\\n            branch.finish();\\n            result[index++] = branch.toString();\\n        }\\n\\n        return result;\\n    }\\n}\", \"summary\": \"\", \"methods\": []}, {\"parent_file\": null, \"name\": \"Branch\", \"position\": {\"start_line\": 77, \"end_line\": 157, \"start_column\": 26, \"end_column\": 5}, \"code\": \"class Branch {\\n        private final StringBuilder builder;\\n        private String cachedString;\\n        private String lastReplacement;\\n\\n        private Branch() {\\n            builder = new StringBuilder();\\n            lastReplacement = null;\\n            cachedString = null;\\n        }\\n\\n        /**\\n         * Creates a new branch, identical to this branch.\\n         *\\n         * @return a new, identical branch\\n         */\\n        public Branch createBranch() {\\n            final Branch branch = new Branch();\\n            branch.builder.append(toString());\\n            branch.lastReplacement = this.lastReplacement;\\n            return branch;\\n        }\\n\\n        @Override\\n        public boolean equals(final Object other) {\\n            if (this == other) {\\n                return true;\\n            }\\n            if (!(other instanceof Branch)) {\\n                return false;\\n            }\\n\\n            return toString().equals(((Branch) other).toString());\\n        }\\n\\n        /**\\n         * Finish this branch by appending '0's until the maximum code length has been reached.\\n         */\\n        public void finish() {\\n            while (builder.length() < MAX_LENGTH) {\\n                builder.append('0');\\n                cachedString = null;\\n            }\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return toString().hashCode();\\n        }\\n\\n        /**\\n         * Process the next replacement to be added to this branch.\\n         *\\n         * @param replacement\\n         *            the next replacement to append\\n         * @param forceAppend\\n         *            indicates if the default processing shall be overridden\\n         */\\n        public void processNextReplacement(final String replacement, final boolean forceAppend) {\\n            final boolean append = lastReplacement == null || !lastReplacement.endsWith(replacement) || forceAppend;\\n\\n            if (append && builder.length() < MAX_LENGTH) {\\n                builder.append(replacement);\\n                // remove all characters after the maximum length\\n                if (builder.length() > MAX_LENGTH) {\\n                    builder.delete(MAX_LENGTH, builder.length());\\n                }\\n                cachedString = null;\\n            }\\n\\n            lastReplacement = replacement;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            if (cachedString == null) {\\n                cachedString = builder.toString();\\n            }\\n            return cachedString;\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"createBranch\", \"return_type\": \"Branch\", \"position\": {\"start_line\": 93, \"end_line\": 98, \"start_column\": 16, \"end_column\": 9}, \"code\": \"Branch createBranch() {\\n            final Branch branch = new Branch();\\n            branch.builder.append(toString());\\n            branch.lastReplacement = this.lastReplacement;\\n            return branch;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"equals\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 101, \"end_line\": 110, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean equals(final Object other) {\\n            if (this == other) {\\n                return true;\\n            }\\n            if (!(other instanceof Branch)) {\\n                return false;\\n            }\\n\\n            return toString().equals(((Branch) other).toString());\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"other\", \"type\": \"Object\"}]}, {\"name\": \"finish\", \"return_type\": \"void\", \"position\": {\"start_line\": 115, \"end_line\": 120, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void finish() {\\n            while (builder.length() < MAX_LENGTH) {\\n                builder.append('0');\\n                cachedString = null;\\n            }\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"hashCode\", \"return_type\": \"int\", \"position\": {\"start_line\": 123, \"end_line\": 125, \"start_column\": 16, \"end_column\": 9}, \"code\": \"int hashCode() {\\n            return toString().hashCode();\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"processNextReplacement\", \"return_type\": \"void\", \"position\": {\"start_line\": 135, \"end_line\": 148, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void processNextReplacement(final String replacement, final boolean forceAppend) {\\n            final boolean append = lastReplacement == null || !lastReplacement.endsWith(replacement) || forceAppend;\\n\\n            if (append && builder.length() < MAX_LENGTH) {\\n                builder.append(replacement);\\n                // remove all characters after the maximum length\\n                if (builder.length() > MAX_LENGTH) {\\n                    builder.delete(MAX_LENGTH, builder.length());\\n                }\\n                cachedString = null;\\n            }\\n\\n            lastReplacement = replacement;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"replacement\", \"type\": \"String\"}, {\"name\": \"forceAppend\", \"type\": \"boolean\"}]}, {\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 151, \"end_line\": 156, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String toString() {\\n            if (cachedString == null) {\\n                cachedString = builder.toString();\\n            }\\n            return cachedString;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}, {\"parent_file\": null, \"name\": \"Rule\", \"position\": {\"start_line\": 162, \"end_line\": 207, \"start_column\": 26, \"end_column\": 5}, \"code\": \"class Rule {\\n        private final String pattern;\\n        private final String[] replacementAtStart;\\n        private final String[] replacementBeforeVowel;\\n        private final String[] replacementDefault;\\n\\n        protected Rule(final String pattern, final String replacementAtStart, final String replacementBeforeVowel,\\n                final String replacementDefault) {\\n            this.pattern = pattern;\\n            this.replacementAtStart = replacementAtStart.split(\\\"\\\\\\\\|\\\");\\n            this.replacementBeforeVowel = replacementBeforeVowel.split(\\\"\\\\\\\\|\\\");\\n            this.replacementDefault = replacementDefault.split(\\\"\\\\\\\\|\\\");\\n        }\\n\\n        public int getPatternLength() {\\n            return pattern.length();\\n        }\\n\\n        public String[] getReplacements(final String context, final boolean atStart) {\\n            if (atStart) {\\n                return replacementAtStart;\\n            }\\n\\n            final int nextIndex = getPatternLength();\\n            final boolean nextCharIsVowel = nextIndex < context.length() ? isVowel(context.charAt(nextIndex)) : false;\\n            if (nextCharIsVowel) {\\n                return replacementBeforeVowel;\\n            }\\n\\n            return replacementDefault;\\n        }\\n\\n        private boolean isVowel(final char ch) {\\n            return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';\\n        }\\n\\n        public boolean matches(final String context) {\\n            return context.startsWith(pattern);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return String.format(\\\"%s=(%s,%s,%s)\\\", pattern, Arrays.asList(replacementAtStart),\\n                    Arrays.asList(replacementBeforeVowel), Arrays.asList(replacementDefault));\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"getPatternLength\", \"return_type\": \"int\", \"position\": {\"start_line\": 176, \"end_line\": 178, \"start_column\": 16, \"end_column\": 9}, \"code\": \"int getPatternLength() {\\n            return pattern.length();\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getReplacements\", \"return_type\": \"String\", \"position\": {\"start_line\": 180, \"end_line\": 192, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String[] getReplacements(final String context, final boolean atStart) {\\n            if (atStart) {\\n                return replacementAtStart;\\n            }\\n\\n            final int nextIndex = getPatternLength();\\n            final boolean nextCharIsVowel = nextIndex < context.length() ? isVowel(context.charAt(nextIndex)) : false;\\n            if (nextCharIsVowel) {\\n                return replacementBeforeVowel;\\n            }\\n\\n            return replacementDefault;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"context\", \"type\": \"String\"}, {\"name\": \"atStart\", \"type\": \"boolean\"}]}, {\"name\": \"isVowel\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 194, \"end_line\": 196, \"start_column\": 17, \"end_column\": 9}, \"code\": \"boolean isVowel(final char ch) {\\n            return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ch\", \"type\": \"char\"}]}, {\"name\": \"matches\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 198, \"end_line\": 200, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean matches(final String context) {\\n            return context.startsWith(pattern);\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"context\", \"type\": \"String\"}]}, {\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 203, \"end_line\": 206, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String toString() {\\n            return String.format(\\\"%s=(%s,%s,%s)\\\", pattern, Arrays.asList(replacementAtStart),\\n                    Arrays.asList(replacementBeforeVowel), Arrays.asList(replacementDefault));\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"compare\", \"return_type\": \"int\", \"position\": {\"start_line\": 246, \"end_line\": 248, \"start_column\": 24, \"end_column\": 17}, \"code\": \"int compare(final Rule rule1, final Rule rule2) {\\n                    return rule2.getPatternLength() - rule1.getPatternLength();\\n                }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"rule1\", \"type\": \"Rule\"}, {\"name\": \"rule2\", \"type\": \"Rule\"}]}, {\"name\": \"parseRules\", \"return_type\": \"void\", \"position\": {\"start_line\": 253, \"end_line\": 330, \"start_column\": 20, \"end_column\": 5}, \"code\": \"void parseRules(final Scanner scanner, final String location,\\n            final Map<Character, List<Rule>> ruleMapping, final Map<Character, Character> asciiFoldings) {\\n        int currentLine = 0;\\n        boolean inMultilineComment = false;\\n\\n        while (scanner.hasNextLine()) {\\n            currentLine++;\\n            final String rawLine = scanner.nextLine();\\n            String line = rawLine;\\n\\n            if (inMultilineComment) {\\n                if (line.endsWith(MULTILINE_COMMENT_END)) {\\n                    inMultilineComment = false;\\n                }\\n                continue;\\n            }\\n\\n            if (line.startsWith(MULTILINE_COMMENT_START)) {\\n                inMultilineComment = true;\\n            } else {\\n                // discard comments\\n                final int cmtI = line.indexOf(COMMENT);\\n                if (cmtI >= 0) {\\n                    line = line.substring(0, cmtI);\\n                }\\n\\n                // trim leading-trailing whitespace\\n                line = line.trim();\\n\\n                if (line.length() == 0) {\\n                    continue; // empty lines can be safely skipped\\n                }\\n\\n                if (line.contains(\\\"=\\\")) {\\n                    // folding\\n                    final String[] parts = line.split(\\\"=\\\");\\n                    if (parts.length != 2) {\\n                        throw new IllegalArgumentException(\\\"Malformed folding statement split into \\\" + parts.length +\\n                                \\\" parts: \\\" + rawLine + \\\" in \\\" + location);\\n                    }\\n                    final String leftCharacter = parts[0];\\n                    final String rightCharacter = parts[1];\\n\\n                    if (leftCharacter.length() != 1 || rightCharacter.length() != 1) {\\n                        throw new IllegalArgumentException(\\\"Malformed folding statement - \\\" +\\n                                \\\"patterns are not single characters: \\\" + rawLine + \\\" in \\\" + location);\\n                    }\\n\\n                    asciiFoldings.put(leftCharacter.charAt(0), rightCharacter.charAt(0));\\n                } else {\\n                    // rule\\n                    final String[] parts = line.split(\\\"\\\\\\\\s+\\\");\\n                    if (parts.length != 4) {\\n                        throw new IllegalArgumentException(\\\"Malformed rule statement split into \\\" + parts.length +\\n                                \\\" parts: \\\" + rawLine + \\\" in \\\" + location);\\n                    }\\n                    try {\\n                        final String pattern = stripQuotes(parts[0]);\\n                        final String replacement1 = stripQuotes(parts[1]);\\n                        final String replacement2 = stripQuotes(parts[2]);\\n                        final String replacement3 = stripQuotes(parts[3]);\\n\\n                        final Rule r = new Rule(pattern, replacement1, replacement2, replacement3);\\n                        final char patternKey = r.pattern.charAt(0);\\n                        List<Rule> rules = ruleMapping.get(patternKey);\\n                        if (rules == null) {\\n                            rules = new ArrayList<Rule>();\\n                            ruleMapping.put(patternKey, rules);\\n                        }\\n                        rules.add(r);\\n                    } catch (final IllegalArgumentException e) {\\n                        throw new IllegalStateException(\\n                                \\\"Problem parsing line '\\\" + currentLine + \\\"' in \\\" + location, e);\\n                    }\\n                }\\n            }\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"scanner\", \"type\": \"Scanner\"}, {\"name\": \"location\", \"type\": \"String\"}, {\"name\": \"ruleMapping\", \"type\": \"Map\"}, {\"name\": \"asciiFoldings\", \"type\": \"Map\"}]}, {\"name\": \"stripQuotes\", \"return_type\": \"String\", \"position\": {\"start_line\": 332, \"end_line\": 342, \"start_column\": 20, \"end_column\": 5}, \"code\": \"String stripQuotes(String str) {\\n        if (str.startsWith(DOUBLE_QUOTE)) {\\n            str = str.substring(1);\\n        }\\n\\n        if (str.endsWith(DOUBLE_QUOTE)) {\\n            str = str.substring(0, str.length() - 1);\\n        }\\n\\n        return str;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"cleanup\", \"return_type\": \"String\", \"position\": {\"start_line\": 378, \"end_line\": 392, \"start_column\": 13, \"end_column\": 5}, \"code\": \"String cleanup(final String input) {\\n        final StringBuilder sb = new StringBuilder();\\n        for (char ch : input.toCharArray()) {\\n            if (Character.isWhitespace(ch)) {\\n                continue;\\n            }\\n\\n            ch = Character.toLowerCase(ch);\\n            if (folding && FOLDINGS.containsKey(ch)) {\\n                ch = FOLDINGS.get(ch);\\n            }\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 413, \"end_line\": 419, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\n                    \\\"Parameter supplied to DaitchMokotoffSoundex encode is not of type java.lang.String\\\");\\n        }\\n        return encode((String) obj);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 433, \"end_line\": 438, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String source) {\\n        if (source == null) {\\n            return null;\\n        }\\n        return soundex(source, false)[0];\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"String\"}]}, {\"name\": \"soundex\", \"return_type\": \"String\", \"position\": {\"start_line\": 463, \"end_line\": 474, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String soundex(final String source) {\\n        final String[] branches = soundex(source, true);\\n        final StringBuilder sb = new StringBuilder();\\n        int index = 0;\\n        for (final String branch : branches) {\\n            sb.append(branch);\\n            if (++index < branches.length) {\\n                sb.append('|');\\n            }\\n        }\\n        return sb.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"String\"}]}, {\"name\": \"soundex\", \"return_type\": \"String\", \"position\": {\"start_line\": 486, \"end_line\": 561, \"start_column\": 13, \"end_column\": 5}, \"code\": \"String[] soundex(final String source, final boolean branching) {\\n        if (source == null) {\\n            return null;\\n        }\\n\\n        final String input = cleanup(source);\\n\\n        final Set<Branch> currentBranches = new LinkedHashSet<Branch>();\\n        currentBranches.add(new Branch());\\n\\n        char lastChar = '\\\\0';\\n        for (int index = 0; index < input.length(); index++) {\\n            final char ch = input.charAt(index);\\n\\n            // ignore whitespace inside a name\\n            if (Character.isWhitespace(ch)) {\\n                continue;\\n            }\\n\\n            final String inputContext = input.substring(index);\\n            final List<Rule> rules = RULES.get(ch);\\n            if (rules == null) {\\n                continue;\\n            }\\n\\n            // use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access\\n            @SuppressWarnings(\\\"unchecked\\\")\\n            final List<Branch> nextBranches = branching ? new ArrayList<Branch>() : Collections.EMPTY_LIST;\\n\\n            for (final Rule rule : rules) {\\n                if (rule.matches(inputContext)) {\\n                    if (branching) {\\n                        nextBranches.clear();\\n                    }\\n                    final String[] replacements = rule.getReplacements(inputContext, lastChar == '\\\\0');\\n                    final boolean branchingRequired = replacements.length > 1 && branching;\\n\\n                    for (final Branch branch : currentBranches) {\\n                        for (final String nextReplacement : replacements) {\\n                            // if we have multiple replacements, always create a new branch\\n                            final Branch nextBranch = branchingRequired ? branch.createBranch() : branch;\\n\\n                            // special rule: occurrences of mn or nm are treated differently\\n                            final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm');\\n\\n                            nextBranch.processNextReplacement(nextReplacement, force);\\n\\n                            if (branching) {\\n                                nextBranches.add(nextBranch);\\n                            } else {\\n                                break;\\n                            }\\n                        }\\n                    }\\n\\n                    if (branching) {\\n                        currentBranches.clear();\\n                        currentBranches.addAll(nextBranches);\\n                    }\\n                    index += rule.getPatternLength() - 1;\\n                    break;\\n                }\\n            }\\n\\n            lastChar = ch;\\n        }\\n\\n        final String[] result = new String[currentBranches.size()];\\n        int index = 0;\\n        for (final Branch branch : currentBranches) {\\n            branch.finish();\\n            result[index++] = branch.toString();\\n        }\\n\\n        return result;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"String\"}, {\"name\": \"branching\", \"type\": \"boolean\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language;\\n\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringEncoder;\\nimport org.apache.commons.codec.binary.StringUtils;\\n\\n/**\\n * Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence\\n * Philips</CITE>.\\n * <p>\\n * This class is conditionally thread-safe. The instance field {@link #maxCodeLen} is mutable\\n * {@link #setMaxCodeLen(int)} but is not volatile, and accesses are not synchronized. If an instance of the class is\\n * shared between threads, the caller needs to ensure that suitable synchronization is used to ensure safe publication\\n * of the value between threads, and must not invoke {@link #setMaxCodeLen(int)} after initial setup.\\n *\\n * @see <a href=\\\"http://drdobbs.com/184401251?pgno=2\\\">Original Article</a>\\n * @see <a href=\\\"http://en.wikipedia.org/wiki/Metaphone\\\">http://en.wikipedia.org/wiki/Metaphone</a>\\n *\\n * @version $Id: DoubleMetaphone.java 1634417 2014-10-27 00:42:28Z ggregory $\\n */\\npublic class DoubleMetaphone implements StringEncoder {\\n\\n    /**\\n     * \\\"Vowels\\\" to test for\\n     */\\n    private static final String VOWELS = \\\"AEIOUY\\\";\\n\\n    /**\\n     * Prefixes when present which are not pronounced\\n     */\\n    private static final String[] SILENT_START =\\n        { \\\"GN\\\", \\\"KN\\\", \\\"PN\\\", \\\"WR\\\", \\\"PS\\\" };\\n    private static final String[] L_R_N_M_B_H_F_V_W_SPACE =\\n        { \\\"L\\\", \\\"R\\\", \\\"N\\\", \\\"M\\\", \\\"B\\\", \\\"H\\\", \\\"F\\\", \\\"V\\\", \\\"W\\\", \\\" \\\" };\\n    private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER =\\n        { \\\"ES\\\", \\\"EP\\\", \\\"EB\\\", \\\"EL\\\", \\\"EY\\\", \\\"IB\\\", \\\"IL\\\", \\\"IN\\\", \\\"IE\\\", \\\"EI\\\", \\\"ER\\\" };\\n    private static final String[] L_T_K_S_N_M_B_Z =\\n        { \\\"L\\\", \\\"T\\\", \\\"K\\\", \\\"S\\\", \\\"N\\\", \\\"M\\\", \\\"B\\\", \\\"Z\\\" };\\n\\n    /**\\n     * Maximum length of an encoding, default is 4\\n     */\\n    private int maxCodeLen = 4;\\n\\n    /**\\n     * Creates an instance of this DoubleMetaphone encoder\\n     */\\n    public DoubleMetaphone() {\\n        super();\\n    }\\n\\n    /**\\n     * Encode a value with Double Metaphone.\\n     *\\n     * @param value String to encode\\n     * @return an encoded string\\n     */\\n    public String doubleMetaphone(final String value) {\\n        return doubleMetaphone(value, false);\\n    }\\n\\n    /**\\n     * Encode a value with Double Metaphone, optionally using the alternate encoding.\\n     *\\n     * @param value String to encode\\n     * @param alternate use alternate encode\\n     * @return an encoded string\\n     */\\n    public String doubleMetaphone(String value, final boolean alternate) {\\n        value = cleanInput(value);\\n        if (value == null) {\\n            return null;\\n        }\\n\\n        final boolean slavoGermanic = isSlavoGermanic(value);\\n        int index = isSilentStart(value) ? 1 : 0;\\n\\n        final DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\\n\\n        while (!result.isComplete() && index <= value.length() - 1) {\\n            switch (value.charAt(index)) {\\n            case 'A':\\n            case 'E':\\n            case 'I':\\n            case 'O':\\n            case 'U':\\n            case 'Y':\\n                index = handleAEIOUY(result, index);\\n                break;\\n            case 'B':\\n                result.append('P');\\n                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\\n                break;\\n            case '\\\\u00C7':\\n                // A C with a Cedilla\\n                result.append('S');\\n                index++;\\n                break;\\n            case 'C':\\n                index = handleC(value, result, index);\\n                break;\\n            case 'D':\\n                index = handleD(value, result, index);\\n                break;\\n            case 'F':\\n                result.append('F');\\n                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\\n                break;\\n            case 'G':\\n                index = handleG(value, result, index, slavoGermanic);\\n                break;\\n            case 'H':\\n                index = handleH(value, result, index);\\n                break;\\n            case 'J':\\n                index = handleJ(value, result, index, slavoGermanic);\\n                break;\\n            case 'K':\\n                result.append('K');\\n                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\\n                break;\\n            case 'L':\\n                index = handleL(value, result, index);\\n                break;\\n            case 'M':\\n                result.append('M');\\n                index = conditionM0(value, index) ? index + 2 : index + 1;\\n                break;\\n            case 'N':\\n                result.append('N');\\n                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\\n                break;\\n            case '\\\\u00D1':\\n                // N with a tilde (spanish ene)\\n                result.append('N');\\n                index++;\\n                break;\\n            case 'P':\\n                index = handleP(value, result, index);\\n                break;\\n            case 'Q':\\n                result.append('K');\\n                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\\n                break;\\n            case 'R':\\n                index = handleR(value, result, index, slavoGermanic);\\n                break;\\n            case 'S':\\n                index = handleS(value, result, index, slavoGermanic);\\n                break;\\n            case 'T':\\n                index = handleT(value, result, index);\\n                break;\\n            case 'V':\\n                result.append('F');\\n                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\\n                break;\\n            case 'W':\\n                index = handleW(value, result, index);\\n                break;\\n            case 'X':\\n                index = handleX(value, result, index);\\n                break;\\n            case 'Z':\\n                index = handleZ(value, result, index, slavoGermanic);\\n                break;\\n            default:\\n                index++;\\n                break;\\n            }\\n        }\\n\\n        return alternate ? result.getAlternate() : result.getPrimary();\\n    }\\n\\n    /**\\n     * Encode the value using DoubleMetaphone.  It will only work if\\n     * <code>obj</code> is a <code>String</code> (like <code>Metaphone</code>).\\n     *\\n     * @param obj Object to encode (should be of type String)\\n     * @return An encoded Object (will be of type String)\\n     * @throws EncoderException encode parameter is not of type String\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"DoubleMetaphone encode parameter is not of type String\\\");\\n        }\\n        return doubleMetaphone((String) obj);\\n    }\\n\\n    /**\\n     * Encode the value using DoubleMetaphone.\\n     *\\n     * @param value String to encode\\n     * @return An encoded String\\n     */\\n    @Override\\n    public String encode(final String value) {\\n        return doubleMetaphone(value);\\n    }\\n\\n    /**\\n     * Check if the Double Metaphone values of two <code>String</code> values\\n     * are equal.\\n     *\\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\\n     * @return <code>true</code> if the encoded <code>String</code>s are equal;\\n     *          <code>false</code> otherwise.\\n     * @see #isDoubleMetaphoneEqual(String,String,boolean)\\n     */\\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2) {\\n        return isDoubleMetaphoneEqual(value1, value2, false);\\n    }\\n\\n    /**\\n     * Check if the Double Metaphone values of two <code>String</code> values\\n     * are equal, optionally using the alternate value.\\n     *\\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\\n     * @param alternate use the alternate value if <code>true</code>.\\n     * @return <code>true</code> if the encoded <code>String</code>s are equal;\\n     *          <code>false</code> otherwise.\\n     */\\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\\n        return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate));\\n    }\\n\\n    /**\\n     * Returns the maxCodeLen.\\n     * @return int\\n     */\\n    public int getMaxCodeLen() {\\n        return this.maxCodeLen;\\n    }\\n\\n    /**\\n     * Sets the maxCodeLen.\\n     * @param maxCodeLen The maxCodeLen to set\\n     */\\n    public void setMaxCodeLen(final int maxCodeLen) {\\n        this.maxCodeLen = maxCodeLen;\\n    }\\n\\n    //-- BEGIN HANDLERS --//\\n\\n    /**\\n     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases.\\n     */\\n    private int handleAEIOUY(final DoubleMetaphoneResult result, final int index) {\\n        if (index == 0) {\\n            result.append('A');\\n        }\\n        return index + 1;\\n    }\\n\\n    /**\\n     * Handles 'C' cases.\\n     */\\n    private int handleC(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (conditionC0(value, index)) {  // very confusing, moved out\\n            result.append('K');\\n            index += 2;\\n        } else if (index == 0 && contains(value, index, 6, \\\"CAESAR\\\")) {\\n            result.append('S');\\n            index += 2;\\n        } else if (contains(value, index, 2, \\\"CH\\\")) {\\n            index = handleCH(value, result, index);\\n        } else if (contains(value, index, 2, \\\"CZ\\\") &&\\n                   !contains(value, index - 2, 4, \\\"WICZ\\\")) {\\n            //-- \\\"Czerny\\\" --//\\n            result.append('S', 'X');\\n            index += 2;\\n        } else if (contains(value, index + 1, 3, \\\"CIA\\\")) {\\n            //-- \\\"focaccia\\\" --//\\n            result.append('X');\\n            index += 3;\\n        } else if (contains(value, index, 2, \\\"CC\\\") &&\\n                   !(index == 1 && charAt(value, 0) == 'M')) {\\n            //-- double \\\"cc\\\" but not \\\"McClelland\\\" --//\\n            return handleCC(value, result, index);\\n        } else if (contains(value, index, 2, \\\"CK\\\", \\\"CG\\\", \\\"CQ\\\")) {\\n            result.append('K');\\n            index += 2;\\n        } else if (contains(value, index, 2, \\\"CI\\\", \\\"CE\\\", \\\"CY\\\")) {\\n            //-- Italian vs. English --//\\n            if (contains(value, index, 3, \\\"CIO\\\", \\\"CIE\\\", \\\"CIA\\\")) {\\n                result.append('S', 'X');\\n            } else {\\n                result.append('S');\\n            }\\n            index += 2;\\n        } else {\\n            result.append('K');\\n            if (contains(value, index + 1, 2, \\\" C\\\", \\\" Q\\\", \\\" G\\\")) {\\n                //-- Mac Caffrey, Mac Gregor --//\\n                index += 3;\\n            } else if (contains(value, index + 1, 1, \\\"C\\\", \\\"K\\\", \\\"Q\\\") &&\\n                       !contains(value, index + 1, 2, \\\"CE\\\", \\\"CI\\\")) {\\n                index += 2;\\n            } else {\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'CC' cases.\\n     */\\n    private int handleCC(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (contains(value, index + 2, 1, \\\"I\\\", \\\"E\\\", \\\"H\\\") &&\\n            !contains(value, index + 2, 2, \\\"HU\\\")) {\\n            //-- \\\"bellocchio\\\" but not \\\"bacchus\\\" --//\\n            if ((index == 1 && charAt(value, index - 1) == 'A') ||\\n                contains(value, index - 1, 5, \\\"UCCEE\\\", \\\"UCCES\\\")) {\\n                //-- \\\"accident\\\", \\\"accede\\\", \\\"succeed\\\" --//\\n                result.append(\\\"KS\\\");\\n            } else {\\n                //-- \\\"bacci\\\", \\\"bertucci\\\", other Italian --//\\n                result.append('X');\\n            }\\n            index += 3;\\n        } else {    // Pierce's rule\\n            result.append('K');\\n            index += 2;\\n        }\\n\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'CH' cases.\\n     */\\n    private int handleCH(final String value, final DoubleMetaphoneResult result, final int index) {\\n        if (index > 0 && contains(value, index, 4, \\\"CHAE\\\")) {   // Michael\\n            result.append('K', 'X');\\n            return index + 2;\\n        } else if (conditionCH0(value, index)) {\\n            //-- Greek roots (\\\"chemistry\\\", \\\"chorus\\\", etc.) --//\\n            result.append('K');\\n            return index + 2;\\n        } else if (conditionCH1(value, index)) {\\n            //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//\\n            result.append('K');\\n            return index + 2;\\n        } else {\\n            if (index > 0) {\\n                if (contains(value, 0, 2, \\\"MC\\\")) {\\n                    result.append('K');\\n                } else {\\n                    result.append('X', 'K');\\n                }\\n            } else {\\n                result.append('X');\\n            }\\n            return index + 2;\\n        }\\n    }\\n\\n    /**\\n     * Handles 'D' cases.\\n     */\\n    private int handleD(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (contains(value, index, 2, \\\"DG\\\")) {\\n            //-- \\\"Edge\\\" --//\\n            if (contains(value, index + 2, 1, \\\"I\\\", \\\"E\\\", \\\"Y\\\")) {\\n                result.append('J');\\n                index += 3;\\n                //-- \\\"Edgar\\\" --//\\n            } else {\\n                result.append(\\\"TK\\\");\\n                index += 2;\\n            }\\n        } else if (contains(value, index, 2, \\\"DT\\\", \\\"DD\\\")) {\\n            result.append('T');\\n            index += 2;\\n        } else {\\n            result.append('T');\\n            index++;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'G' cases.\\n     */\\n    private int handleG(final String value, final DoubleMetaphoneResult result, int index,\\n                        final boolean slavoGermanic) {\\n        if (charAt(value, index + 1) == 'H') {\\n            index = handleGH(value, result, index);\\n        } else if (charAt(value, index + 1) == 'N') {\\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\\n                result.append(\\\"KN\\\", \\\"N\\\");\\n            } else if (!contains(value, index + 2, 2, \\\"EY\\\") &&\\n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\\n                result.append(\\\"N\\\", \\\"KN\\\");\\n            } else {\\n                result.append(\\\"KN\\\");\\n            }\\n            index = index + 2;\\n        } else if (contains(value, index + 1, 2, \\\"LI\\\") && !slavoGermanic) {\\n            result.append(\\\"KL\\\", \\\"L\\\");\\n            index += 2;\\n        } else if (index == 0 &&\\n                   (charAt(value, index + 1) == 'Y' ||\\n                    contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\\n            result.append('K', 'J');\\n            index += 2;\\n        } else if ((contains(value, index + 1, 2, \\\"ER\\\") ||\\n                    charAt(value, index + 1) == 'Y') &&\\n                   !contains(value, 0, 6, \\\"DANGER\\\", \\\"RANGER\\\", \\\"MANGER\\\") &&\\n                   !contains(value, index - 1, 1, \\\"E\\\", \\\"I\\\") &&\\n                   !contains(value, index - 1, 3, \\\"RGY\\\", \\\"OGY\\\")) {\\n            //-- -ger-, -gy- --//\\n            result.append('K', 'J');\\n            index += 2;\\n        } else if (contains(value, index + 1, 1, \\\"E\\\", \\\"I\\\", \\\"Y\\\") ||\\n                   contains(value, index - 1, 4, \\\"AGGI\\\", \\\"OGGI\\\")) {\\n            //-- Italian \\\"biaggi\\\" --//\\n            if (contains(value, 0 ,4, \\\"VAN \\\", \\\"VON \\\") ||\\n                contains(value, 0, 3, \\\"SCH\\\") ||\\n                contains(value, index + 1, 2, \\\"ET\\\")) {\\n                //-- obvious germanic --//\\n                result.append('K');\\n            } else if (contains(value, index + 1, 3, \\\"IER\\\")) {\\n                result.append('J');\\n            } else {\\n                result.append('J', 'K');\\n            }\\n            index += 2;\\n        } else if (charAt(value, index + 1) == 'G') {\\n            index += 2;\\n            result.append('K');\\n        } else {\\n            index++;\\n            result.append('K');\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'GH' cases.\\n     */\\n    private int handleGH(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (index > 0 && !isVowel(charAt(value, index - 1))) {\\n            result.append('K');\\n            index += 2;\\n        } else if (index == 0) {\\n            if (charAt(value, index + 2) == 'I') {\\n                result.append('J');\\n            } else {\\n                result.append('K');\\n            }\\n            index += 2;\\n        } else if ((index > 1 && contains(value, index - 2, 1, \\\"B\\\", \\\"H\\\", \\\"D\\\")) ||\\n                   (index > 2 && contains(value, index - 3, 1, \\\"B\\\", \\\"H\\\", \\\"D\\\")) ||\\n                   (index > 3 && contains(value, index - 4, 1, \\\"B\\\", \\\"H\\\"))) {\\n            //-- Parker's rule (with some further refinements) - \\\"hugh\\\"\\n            index += 2;\\n        } else {\\n            if (index > 2 && charAt(value, index - 1) == 'U' &&\\n                contains(value, index - 3, 1, \\\"C\\\", \\\"G\\\", \\\"L\\\", \\\"R\\\", \\\"T\\\")) {\\n                //-- \\\"laugh\\\", \\\"McLaughlin\\\", \\\"cough\\\", \\\"gough\\\", \\\"rough\\\", \\\"tough\\\"\\n                result.append('F');\\n            } else if (index > 0 && charAt(value, index - 1) != 'I') {\\n                result.append('K');\\n            }\\n            index += 2;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'H' cases.\\n     */\\n    private int handleH(final String value, final DoubleMetaphoneResult result, int index) {\\n        //-- only keep if first & before vowel or between 2 vowels --//\\n        if ((index == 0 || isVowel(charAt(value, index - 1))) &&\\n            isVowel(charAt(value, index + 1))) {\\n            result.append('H');\\n            index += 2;\\n            //-- also takes car of \\\"HH\\\" --//\\n        } else {\\n            index++;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'J' cases.\\n     */\\n    private int handleJ(final String value, final DoubleMetaphoneResult result, int index,\\n                        final boolean slavoGermanic) {\\n        if (contains(value, index, 4, \\\"JOSE\\\") || contains(value, 0, 4, \\\"SAN \\\")) {\\n                //-- obvious Spanish, \\\"Jose\\\", \\\"San Jacinto\\\" --//\\n                if ((index == 0 && (charAt(value, index + 4) == ' ') ||\\n                     value.length() == 4) || contains(value, 0, 4, \\\"SAN \\\")) {\\n                    result.append('H');\\n                } else {\\n                    result.append('J', 'H');\\n                }\\n                index++;\\n            } else {\\n                if (index == 0 && !contains(value, index, 4, \\\"JOSE\\\")) {\\n                    result.append('J', 'A');\\n                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic &&\\n                           (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) {\\n                    result.append('J', 'H');\\n                } else if (index == value.length() - 1) {\\n                    result.append('J', ' ');\\n                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) &&\\n                           !contains(value, index - 1, 1, \\\"S\\\", \\\"K\\\", \\\"L\\\")) {\\n                    result.append('J');\\n                }\\n\\n                if (charAt(value, index + 1) == 'J') {\\n                    index += 2;\\n                } else {\\n                    index++;\\n                }\\n            }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'L' cases.\\n     */\\n    private int handleL(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (charAt(value, index + 1) == 'L') {\\n            if (conditionL0(value, index)) {\\n                result.appendPrimary('L');\\n            } else {\\n                result.append('L');\\n            }\\n            index += 2;\\n        } else {\\n            index++;\\n            result.append('L');\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'P' cases.\\n     */\\n    private int handleP(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (charAt(value, index + 1) == 'H') {\\n            result.append('F');\\n            index += 2;\\n        } else {\\n            result.append('P');\\n            index = contains(value, index + 1, 1, \\\"P\\\", \\\"B\\\") ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'R' cases.\\n     */\\n    private int handleR(final String value, final DoubleMetaphoneResult result, final int index,\\n                        final boolean slavoGermanic) {\\n        if (index == value.length() - 1 && !slavoGermanic &&\\n            contains(value, index - 2, 2, \\\"IE\\\") &&\\n            !contains(value, index - 4, 2, \\\"ME\\\", \\\"MA\\\")) {\\n            result.appendAlternate('R');\\n        } else {\\n            result.append('R');\\n        }\\n        return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\\n    }\\n\\n    /**\\n     * Handles 'S' cases.\\n     */\\n    private int handleS(final String value, final DoubleMetaphoneResult result, int index,\\n                        final boolean slavoGermanic) {\\n        if (contains(value, index - 1, 3, \\\"ISL\\\", \\\"YSL\\\")) {\\n            //-- special cases \\\"island\\\", \\\"isle\\\", \\\"carlisle\\\", \\\"carlysle\\\" --//\\n            index++;\\n        } else if (index == 0 && contains(value, index, 5, \\\"SUGAR\\\")) {\\n            //-- special case \\\"sugar-\\\" --//\\n            result.append('X', 'S');\\n            index++;\\n        } else if (contains(value, index, 2, \\\"SH\\\")) {\\n            if (contains(value, index + 1, 4, \\\"HEIM\\\", \\\"HOEK\\\", \\\"HOLM\\\", \\\"HOLZ\\\")) {\\n                //-- germanic --//\\n                result.append('S');\\n            } else {\\n                result.append('X');\\n            }\\n            index += 2;\\n        } else if (contains(value, index, 3, \\\"SIO\\\", \\\"SIA\\\") || contains(value, index, 4, \\\"SIAN\\\")) {\\n            //-- Italian and Armenian --//\\n            if (slavoGermanic) {\\n                result.append('S');\\n            } else {\\n                result.append('S', 'X');\\n            }\\n            index += 3;\\n        } else if ((index == 0 && contains(value, index + 1, 1, \\\"M\\\", \\\"N\\\", \\\"L\\\", \\\"W\\\")) ||\\n                   contains(value, index + 1, 1, \\\"Z\\\")) {\\n            //-- german & anglicisations, e.g. \\\"smith\\\" match \\\"schmidt\\\" //\\n            // \\\"snider\\\" match \\\"schneider\\\" --//\\n            //-- also, -sz- in slavic language although in hungarian it //\\n            //   is pronounced \\\"s\\\" --//\\n            result.append('S', 'X');\\n            index = contains(value, index + 1, 1, \\\"Z\\\") ? index + 2 : index + 1;\\n        } else if (contains(value, index, 2, \\\"SC\\\")) {\\n            index = handleSC(value, result, index);\\n        } else {\\n            if (index == value.length() - 1 && contains(value, index - 2, 2, \\\"AI\\\", \\\"OI\\\")) {\\n                //-- french e.g. \\\"resnais\\\", \\\"artois\\\" --//\\n                result.appendAlternate('S');\\n            } else {\\n                result.append('S');\\n            }\\n            index = contains(value, index + 1, 1, \\\"S\\\", \\\"Z\\\") ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'SC' cases.\\n     */\\n    private int handleSC(final String value, final DoubleMetaphoneResult result, final int index) {\\n        if (charAt(value, index + 2) == 'H') {\\n            //-- Schlesinger's rule --//\\n            if (contains(value, index + 3, 2, \\\"OO\\\", \\\"ER\\\", \\\"EN\\\", \\\"UY\\\", \\\"ED\\\", \\\"EM\\\")) {\\n                //-- Dutch origin, e.g. \\\"school\\\", \\\"schooner\\\" --//\\n                if (contains(value, index + 3, 2, \\\"ER\\\", \\\"EN\\\")) {\\n                    //-- \\\"schermerhorn\\\", \\\"schenker\\\" --//\\n                    result.append(\\\"X\\\", \\\"SK\\\");\\n                } else {\\n                    result.append(\\\"SK\\\");\\n                }\\n            } else {\\n                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') {\\n                    result.append('X', 'S');\\n                } else {\\n                    result.append('X');\\n                }\\n            }\\n        } else if (contains(value, index + 2, 1, \\\"I\\\", \\\"E\\\", \\\"Y\\\")) {\\n            result.append('S');\\n        } else {\\n            result.append(\\\"SK\\\");\\n        }\\n        return index + 3;\\n    }\\n\\n    /**\\n     * Handles 'T' cases.\\n     */\\n    private int handleT(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (contains(value, index, 4, \\\"TION\\\")) {\\n            result.append('X');\\n            index += 3;\\n        } else if (contains(value, index, 3, \\\"TIA\\\", \\\"TCH\\\")) {\\n            result.append('X');\\n            index += 3;\\n        } else if (contains(value, index, 2, \\\"TH\\\") || contains(value, index, 3, \\\"TTH\\\")) {\\n            if (contains(value, index + 2, 2, \\\"OM\\\", \\\"AM\\\") ||\\n                //-- special case \\\"thomas\\\", \\\"thames\\\" or germanic --//\\n                contains(value, 0, 4, \\\"VAN \\\", \\\"VON \\\") ||\\n                contains(value, 0, 3, \\\"SCH\\\")) {\\n                result.append('T');\\n            } else {\\n                result.append('0', 'T');\\n            }\\n            index += 2;\\n        } else {\\n            result.append('T');\\n            index = contains(value, index + 1, 1, \\\"T\\\", \\\"D\\\") ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'W' cases.\\n     */\\n    private int handleW(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (contains(value, index, 2, \\\"WR\\\")) {\\n            //-- can also be in middle of word --//\\n            result.append('R');\\n            index += 2;\\n        } else {\\n            if (index == 0 && (isVowel(charAt(value, index + 1)) ||\\n                               contains(value, index, 2, \\\"WH\\\"))) {\\n                if (isVowel(charAt(value, index + 1))) {\\n                    //-- Wasserman should match Vasserman --//\\n                    result.append('A', 'F');\\n                } else {\\n                    //-- need Uomo to match Womo --//\\n                    result.append('A');\\n                }\\n                index++;\\n            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\\n                       contains(value, index - 1, 5, \\\"EWSKI\\\", \\\"EWSKY\\\", \\\"OWSKI\\\", \\\"OWSKY\\\") ||\\n                       contains(value, 0, 3, \\\"SCH\\\")) {\\n                //-- Arnow should match Arnoff --//\\n                result.appendAlternate('F');\\n                index++;\\n            } else if (contains(value, index, 4, \\\"WICZ\\\", \\\"WITZ\\\")) {\\n                //-- Polish e.g. \\\"filipowicz\\\" --//\\n                result.append(\\\"TS\\\", \\\"FX\\\");\\n                index += 4;\\n            } else {\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'X' cases.\\n     */\\n    private int handleX(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (index == 0) {\\n            result.append('S');\\n            index++;\\n        } else {\\n            if (!((index == value.length() - 1) &&\\n                  (contains(value, index - 3, 3, \\\"IAU\\\", \\\"EAU\\\") ||\\n                   contains(value, index - 2, 2, \\\"AU\\\", \\\"OU\\\")))) {\\n                //-- French e.g. breaux --//\\n                result.append(\\\"KS\\\");\\n            }\\n            index = contains(value, index + 1, 1, \\\"C\\\", \\\"X\\\") ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'Z' cases.\\n     */\\n    private int handleZ(final String value, final DoubleMetaphoneResult result, int index,\\n                        final boolean slavoGermanic) {\\n        if (charAt(value, index + 1) == 'H') {\\n            //-- Chinese pinyin e.g. \\\"zhao\\\" or Angelina \\\"Zhang\\\" --//\\n            result.append('J');\\n            index += 2;\\n        } else {\\n            if (contains(value, index + 1, 2, \\\"ZO\\\", \\\"ZI\\\", \\\"ZA\\\") ||\\n                (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) {\\n                result.append(\\\"S\\\", \\\"TS\\\");\\n            } else {\\n                result.append('S');\\n            }\\n            index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\\n\\n    //-- BEGIN CONDITIONS --//\\n\\n    /**\\n     * Complex condition 0 for 'C'.\\n     */\\n    private boolean conditionC0(final String value, final int index) {\\n        if (contains(value, index, 4, \\\"CHIA\\\")) {\\n            return true;\\n        } else if (index <= 1) {\\n            return false;\\n        } else if (isVowel(charAt(value, index - 2))) {\\n            return false;\\n        } else if (!contains(value, index - 1, 3, \\\"ACH\\\")) {\\n            return false;\\n        } else {\\n            final char c = charAt(value, index + 2);\\n            return (c != 'I' && c != 'E') ||\\n                    contains(value, index - 2, 6, \\\"BACHER\\\", \\\"MACHER\\\");\\n        }\\n    }\\n\\n    /**\\n     * Complex condition 0 for 'CH'.\\n     */\\n    private boolean conditionCH0(final String value, final int index) {\\n        if (index != 0) {\\n            return false;\\n        } else if (!contains(value, index + 1, 5, \\\"HARAC\\\", \\\"HARIS\\\") &&\\n                   !contains(value, index + 1, 3, \\\"HOR\\\", \\\"HYM\\\", \\\"HIA\\\", \\\"HEM\\\")) {\\n            return false;\\n        } else if (contains(value, 0, 5, \\\"CHORE\\\")) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * Complex condition 1 for 'CH'.\\n     */\\n    private boolean conditionCH1(final String value, final int index) {\\n        return ((contains(value, 0, 4, \\\"VAN \\\", \\\"VON \\\") || contains(value, 0, 3, \\\"SCH\\\")) ||\\n                contains(value, index - 2, 6, \\\"ORCHES\\\", \\\"ARCHIT\\\", \\\"ORCHID\\\") ||\\n                contains(value, index + 2, 1, \\\"T\\\", \\\"S\\\") ||\\n                ((contains(value, index - 1, 1, \\\"A\\\", \\\"O\\\", \\\"U\\\", \\\"E\\\") || index == 0) &&\\n                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\\n    }\\n\\n    /**\\n     * Complex condition 0 for 'L'.\\n     */\\n    private boolean conditionL0(final String value, final int index) {\\n        if (index == value.length() - 3 &&\\n            contains(value, index - 1, 4, \\\"ILLO\\\", \\\"ILLA\\\", \\\"ALLE\\\")) {\\n            return true;\\n        } else if ((contains(value, value.length() - 2, 2, \\\"AS\\\", \\\"OS\\\") ||\\n                    contains(value, value.length() - 1, 1, \\\"A\\\", \\\"O\\\")) &&\\n                   contains(value, index - 1, 4, \\\"ALLE\\\")) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * Complex condition 0 for 'M'.\\n     */\\n    private boolean conditionM0(final String value, final int index) {\\n        if (charAt(value, index + 1) == 'M') {\\n            return true;\\n        }\\n        return contains(value, index - 1, 3, \\\"UMB\\\") &&\\n               ((index + 1) == value.length() - 1 || contains(value, index + 2, 2, \\\"ER\\\"));\\n    }\\n\\n    //-- BEGIN HELPER FUNCTIONS --//\\n\\n    /**\\n     * Determines whether or not a value is of slavo-germanic origin. A value is\\n     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\\n     */\\n    private boolean isSlavoGermanic(final String value) {\\n        return value.indexOf('W') > -1 || value.indexOf('K') > -1 ||\\n            value.indexOf(\\\"CZ\\\") > -1 || value.indexOf(\\\"WITZ\\\") > -1;\\n    }\\n\\n    /**\\n     * Determines whether or not a character is a vowel or not\\n     */\\n    private boolean isVowel(final char ch) {\\n        return VOWELS.indexOf(ch) != -1;\\n    }\\n\\n    /**\\n     * Determines whether or not the value starts with a silent letter.  It will\\n     * return <code>true</code> if the value starts with any of 'GN', 'KN',\\n     * 'PN', 'WR' or 'PS'.\\n     */\\n    private boolean isSilentStart(final String value) {\\n        boolean result = false;\\n        for (final String element : SILENT_START) {\\n            if (value.startsWith(element)) {\\n                result = true;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * Cleans the input.\\n     */\\n    private String cleanInput(String input) {\\n        if (input == null) {\\n            return null;\\n        }\\n        input = input.trim();\\n        if (input.length() == 0) {\\n            return null;\\n        }\\n        return input.toUpperCase(java.util.Locale.ENGLISH);\\n    }\\n\\n    /*\\n     * Gets the character at index <code>index</code> if available, otherwise\\n     * it returns <code>Character.MIN_VALUE</code> so that there is some sort\\n     * of a default.\\n     */\\n    protected char charAt(final String value, final int index) {\\n        if (index < 0 || index >= value.length()) {\\n            return Character.MIN_VALUE;\\n        }\\n        return value.charAt(index);\\n    }\\n\\n    /*\\n     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\\n     * matching up to length <code>length</code>.\\n     */\\n    protected static boolean contains(final String value, final int start, final int length,\\n                                      final String... criteria) {\\n        boolean result = false;\\n        if (start >= 0 && start + length <= value.length()) {\\n            final String target = value.substring(start, start + length);\\n\\n            for (final String element : criteria) {\\n                if (target.equals(element)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    //-- BEGIN INNER CLASSES --//\\n\\n    /**\\n     * Inner class for storing results, since there is the optional alternate encoding.\\n     */\\n    public class DoubleMetaphoneResult {\\n\\n        private final StringBuilder primary = new StringBuilder(getMaxCodeLen());\\n        private final StringBuilder alternate = new StringBuilder(getMaxCodeLen());\\n        private final int maxLength;\\n\\n        public DoubleMetaphoneResult(final int maxLength) {\\n            this.maxLength = maxLength;\\n        }\\n\\n        public void append(final char value) {\\n            appendPrimary(value);\\n            appendAlternate(value);\\n        }\\n\\n        public void append(final char primary, final char alternate) {\\n            appendPrimary(primary);\\n            appendAlternate(alternate);\\n        }\\n\\n        public void appendPrimary(final char value) {\\n            if (this.primary.length() < this.maxLength) {\\n                this.primary.append(value);\\n            }\\n        }\\n\\n        public void appendAlternate(final char value) {\\n            if (this.alternate.length() < this.maxLength) {\\n                this.alternate.append(value);\\n            }\\n        }\\n\\n        public void append(final String value) {\\n            appendPrimary(value);\\n            appendAlternate(value);\\n        }\\n\\n        public void append(final String primary, final String alternate) {\\n            appendPrimary(primary);\\n            appendAlternate(alternate);\\n        }\\n\\n        public void appendPrimary(final String value) {\\n            final int addChars = this.maxLength - this.primary.length();\\n            if (value.length() <= addChars) {\\n                this.primary.append(value);\\n            } else {\\n                this.primary.append(value.substring(0, addChars));\\n            }\\n        }\\n\\n        public void appendAlternate(final String value) {\\n            final int addChars = this.maxLength - this.alternate.length();\\n            if (value.length() <= addChars) {\\n                this.alternate.append(value);\\n            } else {\\n                this.alternate.append(value.substring(0, addChars));\\n            }\\n        }\\n\\n        public String getPrimary() {\\n            return this.primary.toString();\\n        }\\n\\n        public String getAlternate() {\\n            return this.alternate.toString();\\n        }\\n\\n        public boolean isComplete() {\\n            return this.primary.length() >= this.maxLength &&\\n                   this.alternate.length() >= this.maxLength;\\n        }\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"DoubleMetaphone\", \"position\": {\"start_line\": 38, \"end_line\": 1009, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class DoubleMetaphone implements StringEncoder {\\n\\n    /**\\n     * \\\"Vowels\\\" to test for\\n     */\\n    private static final String VOWELS = \\\"AEIOUY\\\";\\n\\n    /**\\n     * Prefixes when present which are not pronounced\\n     */\\n    private static final String[] SILENT_START =\\n        { \\\"GN\\\", \\\"KN\\\", \\\"PN\\\", \\\"WR\\\", \\\"PS\\\" };\\n    private static final String[] L_R_N_M_B_H_F_V_W_SPACE =\\n        { \\\"L\\\", \\\"R\\\", \\\"N\\\", \\\"M\\\", \\\"B\\\", \\\"H\\\", \\\"F\\\", \\\"V\\\", \\\"W\\\", \\\" \\\" };\\n    private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER =\\n        { \\\"ES\\\", \\\"EP\\\", \\\"EB\\\", \\\"EL\\\", \\\"EY\\\", \\\"IB\\\", \\\"IL\\\", \\\"IN\\\", \\\"IE\\\", \\\"EI\\\", \\\"ER\\\" };\\n    private static final String[] L_T_K_S_N_M_B_Z =\\n        { \\\"L\\\", \\\"T\\\", \\\"K\\\", \\\"S\\\", \\\"N\\\", \\\"M\\\", \\\"B\\\", \\\"Z\\\" };\\n\\n    /**\\n     * Maximum length of an encoding, default is 4\\n     */\\n    private int maxCodeLen = 4;\\n\\n    /**\\n     * Creates an instance of this DoubleMetaphone encoder\\n     */\\n    public DoubleMetaphone() {\\n        super();\\n    }\\n\\n    /**\\n     * Encode a value with Double Metaphone.\\n     *\\n     * @param value String to encode\\n     * @return an encoded string\\n     */\\n    public String doubleMetaphone(final String value) {\\n        return doubleMetaphone(value, false);\\n    }\\n\\n    /**\\n     * Encode a value with Double Metaphone, optionally using the alternate encoding.\\n     *\\n     * @param value String to encode\\n     * @param alternate use alternate encode\\n     * @return an encoded string\\n     */\\n    public String doubleMetaphone(String value, final boolean alternate) {\\n        value = cleanInput(value);\\n        if (value == null) {\\n            return null;\\n        }\\n\\n        final boolean slavoGermanic = isSlavoGermanic(value);\\n        int index = isSilentStart(value) ? 1 : 0;\\n\\n        final DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\\n\\n        while (!result.isComplete() && index <= value.length() - 1) {\\n            switch (value.charAt(index)) {\\n            case 'A':\\n            case 'E':\\n            case 'I':\\n            case 'O':\\n            case 'U':\\n            case 'Y':\\n                index = handleAEIOUY(result, index);\\n                break;\\n            case 'B':\\n                result.append('P');\\n                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\\n                break;\\n            case '\\\\u00C7':\\n                // A C with a Cedilla\\n                result.append('S');\\n                index++;\\n                break;\\n            case 'C':\\n                index = handleC(value, result, index);\\n                break;\\n            case 'D':\\n                index = handleD(value, result, index);\\n                break;\\n            case 'F':\\n                result.append('F');\\n                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\\n                break;\\n            case 'G':\\n                index = handleG(value, result, index, slavoGermanic);\\n                break;\\n            case 'H':\\n                index = handleH(value, result, index);\\n                break;\\n            case 'J':\\n                index = handleJ(value, result, index, slavoGermanic);\\n                break;\\n            case 'K':\\n                result.append('K');\\n                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\\n                break;\\n            case 'L':\\n                index = handleL(value, result, index);\\n                break;\\n            case 'M':\\n                result.append('M');\\n                index = conditionM0(value, index) ? index + 2 : index + 1;\\n                break;\\n            case 'N':\\n                result.append('N');\\n                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\\n                break;\\n            case '\\\\u00D1':\\n                // N with a tilde (spanish ene)\\n                result.append('N');\\n                index++;\\n                break;\\n            case 'P':\\n                index = handleP(value, result, index);\\n                break;\\n            case 'Q':\\n                result.append('K');\\n                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\\n                break;\\n            case 'R':\\n                index = handleR(value, result, index, slavoGermanic);\\n                break;\\n            case 'S':\\n                index = handleS(value, result, index, slavoGermanic);\\n                break;\\n            case 'T':\\n                index = handleT(value, result, index);\\n                break;\\n            case 'V':\\n                result.append('F');\\n                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\\n                break;\\n            case 'W':\\n                index = handleW(value, result, index);\\n                break;\\n            case 'X':\\n                index = handleX(value, result, index);\\n                break;\\n            case 'Z':\\n                index = handleZ(value, result, index, slavoGermanic);\\n                break;\\n            default:\\n                index++;\\n                break;\\n            }\\n        }\\n\\n        return alternate ? result.getAlternate() : result.getPrimary();\\n    }\\n\\n    /**\\n     * Encode the value using DoubleMetaphone.  It will only work if\\n     * <code>obj</code> is a <code>String</code> (like <code>Metaphone</code>).\\n     *\\n     * @param obj Object to encode (should be of type String)\\n     * @return An encoded Object (will be of type String)\\n     * @throws EncoderException encode parameter is not of type String\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"DoubleMetaphone encode parameter is not of type String\\\");\\n        }\\n        return doubleMetaphone((String) obj);\\n    }\\n\\n    /**\\n     * Encode the value using DoubleMetaphone.\\n     *\\n     * @param value String to encode\\n     * @return An encoded String\\n     */\\n    @Override\\n    public String encode(final String value) {\\n        return doubleMetaphone(value);\\n    }\\n\\n    /**\\n     * Check if the Double Metaphone values of two <code>String</code> values\\n     * are equal.\\n     *\\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\\n     * @return <code>true</code> if the encoded <code>String</code>s are equal;\\n     *          <code>false</code> otherwise.\\n     * @see #isDoubleMetaphoneEqual(String,String,boolean)\\n     */\\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2) {\\n        return isDoubleMetaphoneEqual(value1, value2, false);\\n    }\\n\\n    /**\\n     * Check if the Double Metaphone values of two <code>String</code> values\\n     * are equal, optionally using the alternate value.\\n     *\\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\\n     * @param alternate use the alternate value if <code>true</code>.\\n     * @return <code>true</code> if the encoded <code>String</code>s are equal;\\n     *          <code>false</code> otherwise.\\n     */\\n    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\\n        return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate));\\n    }\\n\\n    /**\\n     * Returns the maxCodeLen.\\n     * @return int\\n     */\\n    public int getMaxCodeLen() {\\n        return this.maxCodeLen;\\n    }\\n\\n    /**\\n     * Sets the maxCodeLen.\\n     * @param maxCodeLen The maxCodeLen to set\\n     */\\n    public void setMaxCodeLen(final int maxCodeLen) {\\n        this.maxCodeLen = maxCodeLen;\\n    }\\n\\n    //-- BEGIN HANDLERS --//\\n\\n    /**\\n     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases.\\n     */\\n    private int handleAEIOUY(final DoubleMetaphoneResult result, final int index) {\\n        if (index == 0) {\\n            result.append('A');\\n        }\\n        return index + 1;\\n    }\\n\\n    /**\\n     * Handles 'C' cases.\\n     */\\n    private int handleC(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (conditionC0(value, index)) {  // very confusing, moved out\\n            result.append('K');\\n            index += 2;\\n        } else if (index == 0 && contains(value, index, 6, \\\"CAESAR\\\")) {\\n            result.append('S');\\n            index += 2;\\n        } else if (contains(value, index, 2, \\\"CH\\\")) {\\n            index = handleCH(value, result, index);\\n        } else if (contains(value, index, 2, \\\"CZ\\\") &&\\n                   !contains(value, index - 2, 4, \\\"WICZ\\\")) {\\n            //-- \\\"Czerny\\\" --//\\n            result.append('S', 'X');\\n            index += 2;\\n        } else if (contains(value, index + 1, 3, \\\"CIA\\\")) {\\n            //-- \\\"focaccia\\\" --//\\n            result.append('X');\\n            index += 3;\\n        } else if (contains(value, index, 2, \\\"CC\\\") &&\\n                   !(index == 1 && charAt(value, 0) == 'M')) {\\n            //-- double \\\"cc\\\" but not \\\"McClelland\\\" --//\\n            return handleCC(value, result, index);\\n        } else if (contains(value, index, 2, \\\"CK\\\", \\\"CG\\\", \\\"CQ\\\")) {\\n            result.append('K');\\n            index += 2;\\n        } else if (contains(value, index, 2, \\\"CI\\\", \\\"CE\\\", \\\"CY\\\")) {\\n            //-- Italian vs. English --//\\n            if (contains(value, index, 3, \\\"CIO\\\", \\\"CIE\\\", \\\"CIA\\\")) {\\n                result.append('S', 'X');\\n            } else {\\n                result.append('S');\\n            }\\n            index += 2;\\n        } else {\\n            result.append('K');\\n            if (contains(value, index + 1, 2, \\\" C\\\", \\\" Q\\\", \\\" G\\\")) {\\n                //-- Mac Caffrey, Mac Gregor --//\\n                index += 3;\\n            } else if (contains(value, index + 1, 1, \\\"C\\\", \\\"K\\\", \\\"Q\\\") &&\\n                       !contains(value, index + 1, 2, \\\"CE\\\", \\\"CI\\\")) {\\n                index += 2;\\n            } else {\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'CC' cases.\\n     */\\n    private int handleCC(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (contains(value, index + 2, 1, \\\"I\\\", \\\"E\\\", \\\"H\\\") &&\\n            !contains(value, index + 2, 2, \\\"HU\\\")) {\\n            //-- \\\"bellocchio\\\" but not \\\"bacchus\\\" --//\\n            if ((index == 1 && charAt(value, index - 1) == 'A') ||\\n                contains(value, index - 1, 5, \\\"UCCEE\\\", \\\"UCCES\\\")) {\\n                //-- \\\"accident\\\", \\\"accede\\\", \\\"succeed\\\" --//\\n                result.append(\\\"KS\\\");\\n            } else {\\n                //-- \\\"bacci\\\", \\\"bertucci\\\", other Italian --//\\n                result.append('X');\\n            }\\n            index += 3;\\n        } else {    // Pierce's rule\\n            result.append('K');\\n            index += 2;\\n        }\\n\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'CH' cases.\\n     */\\n    private int handleCH(final String value, final DoubleMetaphoneResult result, final int index) {\\n        if (index > 0 && contains(value, index, 4, \\\"CHAE\\\")) {   // Michael\\n            result.append('K', 'X');\\n            return index + 2;\\n        } else if (conditionCH0(value, index)) {\\n            //-- Greek roots (\\\"chemistry\\\", \\\"chorus\\\", etc.) --//\\n            result.append('K');\\n            return index + 2;\\n        } else if (conditionCH1(value, index)) {\\n            //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//\\n            result.append('K');\\n            return index + 2;\\n        } else {\\n            if (index > 0) {\\n                if (contains(value, 0, 2, \\\"MC\\\")) {\\n                    result.append('K');\\n                } else {\\n                    result.append('X', 'K');\\n                }\\n            } else {\\n                result.append('X');\\n            }\\n            return index + 2;\\n        }\\n    }\\n\\n    /**\\n     * Handles 'D' cases.\\n     */\\n    private int handleD(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (contains(value, index, 2, \\\"DG\\\")) {\\n            //-- \\\"Edge\\\" --//\\n            if (contains(value, index + 2, 1, \\\"I\\\", \\\"E\\\", \\\"Y\\\")) {\\n                result.append('J');\\n                index += 3;\\n                //-- \\\"Edgar\\\" --//\\n            } else {\\n                result.append(\\\"TK\\\");\\n                index += 2;\\n            }\\n        } else if (contains(value, index, 2, \\\"DT\\\", \\\"DD\\\")) {\\n            result.append('T');\\n            index += 2;\\n        } else {\\n            result.append('T');\\n            index++;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'G' cases.\\n     */\\n    private int handleG(final String value, final DoubleMetaphoneResult result, int index,\\n                        final boolean slavoGermanic) {\\n        if (charAt(value, index + 1) == 'H') {\\n            index = handleGH(value, result, index);\\n        } else if (charAt(value, index + 1) == 'N') {\\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\\n                result.append(\\\"KN\\\", \\\"N\\\");\\n            } else if (!contains(value, index + 2, 2, \\\"EY\\\") &&\\n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\\n                result.append(\\\"N\\\", \\\"KN\\\");\\n            } else {\\n                result.append(\\\"KN\\\");\\n            }\\n            index = index + 2;\\n        } else if (contains(value, index + 1, 2, \\\"LI\\\") && !slavoGermanic) {\\n            result.append(\\\"KL\\\", \\\"L\\\");\\n            index += 2;\\n        } else if (index == 0 &&\\n                   (charAt(value, index + 1) == 'Y' ||\\n                    contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\\n            result.append('K', 'J');\\n            index += 2;\\n        } else if ((contains(value, index + 1, 2, \\\"ER\\\") ||\\n                    charAt(value, index + 1) == 'Y') &&\\n                   !contains(value, 0, 6, \\\"DANGER\\\", \\\"RANGER\\\", \\\"MANGER\\\") &&\\n                   !contains(value, index - 1, 1, \\\"E\\\", \\\"I\\\") &&\\n                   !contains(value, index - 1, 3, \\\"RGY\\\", \\\"OGY\\\")) {\\n            //-- -ger-, -gy- --//\\n            result.append('K', 'J');\\n            index += 2;\\n        } else if (contains(value, index + 1, 1, \\\"E\\\", \\\"I\\\", \\\"Y\\\") ||\\n                   contains(value, index - 1, 4, \\\"AGGI\\\", \\\"OGGI\\\")) {\\n            //-- Italian \\\"biaggi\\\" --//\\n            if (contains(value, 0 ,4, \\\"VAN \\\", \\\"VON \\\") ||\\n                contains(value, 0, 3, \\\"SCH\\\") ||\\n                contains(value, index + 1, 2, \\\"ET\\\")) {\\n                //-- obvious germanic --//\\n                result.append('K');\\n            } else if (contains(value, index + 1, 3, \\\"IER\\\")) {\\n                result.append('J');\\n            } else {\\n                result.append('J', 'K');\\n            }\\n            index += 2;\\n        } else if (charAt(value, index + 1) == 'G') {\\n            index += 2;\\n            result.append('K');\\n        } else {\\n            index++;\\n            result.append('K');\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'GH' cases.\\n     */\\n    private int handleGH(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (index > 0 && !isVowel(charAt(value, index - 1))) {\\n            result.append('K');\\n            index += 2;\\n        } else if (index == 0) {\\n            if (charAt(value, index + 2) == 'I') {\\n                result.append('J');\\n            } else {\\n                result.append('K');\\n            }\\n            index += 2;\\n        } else if ((index > 1 && contains(value, index - 2, 1, \\\"B\\\", \\\"H\\\", \\\"D\\\")) ||\\n                   (index > 2 && contains(value, index - 3, 1, \\\"B\\\", \\\"H\\\", \\\"D\\\")) ||\\n                   (index > 3 && contains(value, index - 4, 1, \\\"B\\\", \\\"H\\\"))) {\\n            //-- Parker's rule (with some further refinements) - \\\"hugh\\\"\\n            index += 2;\\n        } else {\\n            if (index > 2 && charAt(value, index - 1) == 'U' &&\\n                contains(value, index - 3, 1, \\\"C\\\", \\\"G\\\", \\\"L\\\", \\\"R\\\", \\\"T\\\")) {\\n                //-- \\\"laugh\\\", \\\"McLaughlin\\\", \\\"cough\\\", \\\"gough\\\", \\\"rough\\\", \\\"tough\\\"\\n                result.append('F');\\n            } else if (index > 0 && charAt(value, index - 1) != 'I') {\\n                result.append('K');\\n            }\\n            index += 2;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'H' cases.\\n     */\\n    private int handleH(final String value, final DoubleMetaphoneResult result, int index) {\\n        //-- only keep if first & before vowel or between 2 vowels --//\\n        if ((index == 0 || isVowel(charAt(value, index - 1))) &&\\n            isVowel(charAt(value, index + 1))) {\\n            result.append('H');\\n            index += 2;\\n            //-- also takes car of \\\"HH\\\" --//\\n        } else {\\n            index++;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'J' cases.\\n     */\\n    private int handleJ(final String value, final DoubleMetaphoneResult result, int index,\\n                        final boolean slavoGermanic) {\\n        if (contains(value, index, 4, \\\"JOSE\\\") || contains(value, 0, 4, \\\"SAN \\\")) {\\n                //-- obvious Spanish, \\\"Jose\\\", \\\"San Jacinto\\\" --//\\n                if ((index == 0 && (charAt(value, index + 4) == ' ') ||\\n                     value.length() == 4) || contains(value, 0, 4, \\\"SAN \\\")) {\\n                    result.append('H');\\n                } else {\\n                    result.append('J', 'H');\\n                }\\n                index++;\\n            } else {\\n                if (index == 0 && !contains(value, index, 4, \\\"JOSE\\\")) {\\n                    result.append('J', 'A');\\n                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic &&\\n                           (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) {\\n                    result.append('J', 'H');\\n                } else if (index == value.length() - 1) {\\n                    result.append('J', ' ');\\n                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) &&\\n                           !contains(value, index - 1, 1, \\\"S\\\", \\\"K\\\", \\\"L\\\")) {\\n                    result.append('J');\\n                }\\n\\n                if (charAt(value, index + 1) == 'J') {\\n                    index += 2;\\n                } else {\\n                    index++;\\n                }\\n            }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'L' cases.\\n     */\\n    private int handleL(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (charAt(value, index + 1) == 'L') {\\n            if (conditionL0(value, index)) {\\n                result.appendPrimary('L');\\n            } else {\\n                result.append('L');\\n            }\\n            index += 2;\\n        } else {\\n            index++;\\n            result.append('L');\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'P' cases.\\n     */\\n    private int handleP(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (charAt(value, index + 1) == 'H') {\\n            result.append('F');\\n            index += 2;\\n        } else {\\n            result.append('P');\\n            index = contains(value, index + 1, 1, \\\"P\\\", \\\"B\\\") ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'R' cases.\\n     */\\n    private int handleR(final String value, final DoubleMetaphoneResult result, final int index,\\n                        final boolean slavoGermanic) {\\n        if (index == value.length() - 1 && !slavoGermanic &&\\n            contains(value, index - 2, 2, \\\"IE\\\") &&\\n            !contains(value, index - 4, 2, \\\"ME\\\", \\\"MA\\\")) {\\n            result.appendAlternate('R');\\n        } else {\\n            result.append('R');\\n        }\\n        return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\\n    }\\n\\n    /**\\n     * Handles 'S' cases.\\n     */\\n    private int handleS(final String value, final DoubleMetaphoneResult result, int index,\\n                        final boolean slavoGermanic) {\\n        if (contains(value, index - 1, 3, \\\"ISL\\\", \\\"YSL\\\")) {\\n            //-- special cases \\\"island\\\", \\\"isle\\\", \\\"carlisle\\\", \\\"carlysle\\\" --//\\n            index++;\\n        } else if (index == 0 && contains(value, index, 5, \\\"SUGAR\\\")) {\\n            //-- special case \\\"sugar-\\\" --//\\n            result.append('X', 'S');\\n            index++;\\n        } else if (contains(value, index, 2, \\\"SH\\\")) {\\n            if (contains(value, index + 1, 4, \\\"HEIM\\\", \\\"HOEK\\\", \\\"HOLM\\\", \\\"HOLZ\\\")) {\\n                //-- germanic --//\\n                result.append('S');\\n            } else {\\n                result.append('X');\\n            }\\n            index += 2;\\n        } else if (contains(value, index, 3, \\\"SIO\\\", \\\"SIA\\\") || contains(value, index, 4, \\\"SIAN\\\")) {\\n            //-- Italian and Armenian --//\\n            if (slavoGermanic) {\\n                result.append('S');\\n            } else {\\n                result.append('S', 'X');\\n            }\\n            index += 3;\\n        } else if ((index == 0 && contains(value, index + 1, 1, \\\"M\\\", \\\"N\\\", \\\"L\\\", \\\"W\\\")) ||\\n                   contains(value, index + 1, 1, \\\"Z\\\")) {\\n            //-- german & anglicisations, e.g. \\\"smith\\\" match \\\"schmidt\\\" //\\n            // \\\"snider\\\" match \\\"schneider\\\" --//\\n            //-- also, -sz- in slavic language although in hungarian it //\\n            //   is pronounced \\\"s\\\" --//\\n            result.append('S', 'X');\\n            index = contains(value, index + 1, 1, \\\"Z\\\") ? index + 2 : index + 1;\\n        } else if (contains(value, index, 2, \\\"SC\\\")) {\\n            index = handleSC(value, result, index);\\n        } else {\\n            if (index == value.length() - 1 && contains(value, index - 2, 2, \\\"AI\\\", \\\"OI\\\")) {\\n                //-- french e.g. \\\"resnais\\\", \\\"artois\\\" --//\\n                result.appendAlternate('S');\\n            } else {\\n                result.append('S');\\n            }\\n            index = contains(value, index + 1, 1, \\\"S\\\", \\\"Z\\\") ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'SC' cases.\\n     */\\n    private int handleSC(final String value, final DoubleMetaphoneResult result, final int index) {\\n        if (charAt(value, index + 2) == 'H') {\\n            //-- Schlesinger's rule --//\\n            if (contains(value, index + 3, 2, \\\"OO\\\", \\\"ER\\\", \\\"EN\\\", \\\"UY\\\", \\\"ED\\\", \\\"EM\\\")) {\\n                //-- Dutch origin, e.g. \\\"school\\\", \\\"schooner\\\" --//\\n                if (contains(value, index + 3, 2, \\\"ER\\\", \\\"EN\\\")) {\\n                    //-- \\\"schermerhorn\\\", \\\"schenker\\\" --//\\n                    result.append(\\\"X\\\", \\\"SK\\\");\\n                } else {\\n                    result.append(\\\"SK\\\");\\n                }\\n            } else {\\n                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') {\\n                    result.append('X', 'S');\\n                } else {\\n                    result.append('X');\\n                }\\n            }\\n        } else if (contains(value, index + 2, 1, \\\"I\\\", \\\"E\\\", \\\"Y\\\")) {\\n            result.append('S');\\n        } else {\\n            result.append(\\\"SK\\\");\\n        }\\n        return index + 3;\\n    }\\n\\n    /**\\n     * Handles 'T' cases.\\n     */\\n    private int handleT(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (contains(value, index, 4, \\\"TION\\\")) {\\n            result.append('X');\\n            index += 3;\\n        } else if (contains(value, index, 3, \\\"TIA\\\", \\\"TCH\\\")) {\\n            result.append('X');\\n            index += 3;\\n        } else if (contains(value, index, 2, \\\"TH\\\") || contains(value, index, 3, \\\"TTH\\\")) {\\n            if (contains(value, index + 2, 2, \\\"OM\\\", \\\"AM\\\") ||\\n                //-- special case \\\"thomas\\\", \\\"thames\\\" or germanic --//\\n                contains(value, 0, 4, \\\"VAN \\\", \\\"VON \\\") ||\\n                contains(value, 0, 3, \\\"SCH\\\")) {\\n                result.append('T');\\n            } else {\\n                result.append('0', 'T');\\n            }\\n            index += 2;\\n        } else {\\n            result.append('T');\\n            index = contains(value, index + 1, 1, \\\"T\\\", \\\"D\\\") ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'W' cases.\\n     */\\n    private int handleW(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (contains(value, index, 2, \\\"WR\\\")) {\\n            //-- can also be in middle of word --//\\n            result.append('R');\\n            index += 2;\\n        } else {\\n            if (index == 0 && (isVowel(charAt(value, index + 1)) ||\\n                               contains(value, index, 2, \\\"WH\\\"))) {\\n                if (isVowel(charAt(value, index + 1))) {\\n                    //-- Wasserman should match Vasserman --//\\n                    result.append('A', 'F');\\n                } else {\\n                    //-- need Uomo to match Womo --//\\n                    result.append('A');\\n                }\\n                index++;\\n            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\\n                       contains(value, index - 1, 5, \\\"EWSKI\\\", \\\"EWSKY\\\", \\\"OWSKI\\\", \\\"OWSKY\\\") ||\\n                       contains(value, 0, 3, \\\"SCH\\\")) {\\n                //-- Arnow should match Arnoff --//\\n                result.appendAlternate('F');\\n                index++;\\n            } else if (contains(value, index, 4, \\\"WICZ\\\", \\\"WITZ\\\")) {\\n                //-- Polish e.g. \\\"filipowicz\\\" --//\\n                result.append(\\\"TS\\\", \\\"FX\\\");\\n                index += 4;\\n            } else {\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'X' cases.\\n     */\\n    private int handleX(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (index == 0) {\\n            result.append('S');\\n            index++;\\n        } else {\\n            if (!((index == value.length() - 1) &&\\n                  (contains(value, index - 3, 3, \\\"IAU\\\", \\\"EAU\\\") ||\\n                   contains(value, index - 2, 2, \\\"AU\\\", \\\"OU\\\")))) {\\n                //-- French e.g. breaux --//\\n                result.append(\\\"KS\\\");\\n            }\\n            index = contains(value, index + 1, 1, \\\"C\\\", \\\"X\\\") ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Handles 'Z' cases.\\n     */\\n    private int handleZ(final String value, final DoubleMetaphoneResult result, int index,\\n                        final boolean slavoGermanic) {\\n        if (charAt(value, index + 1) == 'H') {\\n            //-- Chinese pinyin e.g. \\\"zhao\\\" or Angelina \\\"Zhang\\\" --//\\n            result.append('J');\\n            index += 2;\\n        } else {\\n            if (contains(value, index + 1, 2, \\\"ZO\\\", \\\"ZI\\\", \\\"ZA\\\") ||\\n                (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) {\\n                result.append(\\\"S\\\", \\\"TS\\\");\\n            } else {\\n                result.append('S');\\n            }\\n            index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\\n\\n    //-- BEGIN CONDITIONS --//\\n\\n    /**\\n     * Complex condition 0 for 'C'.\\n     */\\n    private boolean conditionC0(final String value, final int index) {\\n        if (contains(value, index, 4, \\\"CHIA\\\")) {\\n            return true;\\n        } else if (index <= 1) {\\n            return false;\\n        } else if (isVowel(charAt(value, index - 2))) {\\n            return false;\\n        } else if (!contains(value, index - 1, 3, \\\"ACH\\\")) {\\n            return false;\\n        } else {\\n            final char c = charAt(value, index + 2);\\n            return (c != 'I' && c != 'E') ||\\n                    contains(value, index - 2, 6, \\\"BACHER\\\", \\\"MACHER\\\");\\n        }\\n    }\\n\\n    /**\\n     * Complex condition 0 for 'CH'.\\n     */\\n    private boolean conditionCH0(final String value, final int index) {\\n        if (index != 0) {\\n            return false;\\n        } else if (!contains(value, index + 1, 5, \\\"HARAC\\\", \\\"HARIS\\\") &&\\n                   !contains(value, index + 1, 3, \\\"HOR\\\", \\\"HYM\\\", \\\"HIA\\\", \\\"HEM\\\")) {\\n            return false;\\n        } else if (contains(value, 0, 5, \\\"CHORE\\\")) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * Complex condition 1 for 'CH'.\\n     */\\n    private boolean conditionCH1(final String value, final int index) {\\n        return ((contains(value, 0, 4, \\\"VAN \\\", \\\"VON \\\") || contains(value, 0, 3, \\\"SCH\\\")) ||\\n                contains(value, index - 2, 6, \\\"ORCHES\\\", \\\"ARCHIT\\\", \\\"ORCHID\\\") ||\\n                contains(value, index + 2, 1, \\\"T\\\", \\\"S\\\") ||\\n                ((contains(value, index - 1, 1, \\\"A\\\", \\\"O\\\", \\\"U\\\", \\\"E\\\") || index == 0) &&\\n                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\\n    }\\n\\n    /**\\n     * Complex condition 0 for 'L'.\\n     */\\n    private boolean conditionL0(final String value, final int index) {\\n        if (index == value.length() - 3 &&\\n            contains(value, index - 1, 4, \\\"ILLO\\\", \\\"ILLA\\\", \\\"ALLE\\\")) {\\n            return true;\\n        } else if ((contains(value, value.length() - 2, 2, \\\"AS\\\", \\\"OS\\\") ||\\n                    contains(value, value.length() - 1, 1, \\\"A\\\", \\\"O\\\")) &&\\n                   contains(value, index - 1, 4, \\\"ALLE\\\")) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * Complex condition 0 for 'M'.\\n     */\\n    private boolean conditionM0(final String value, final int index) {\\n        if (charAt(value, index + 1) == 'M') {\\n            return true;\\n        }\\n        return contains(value, index - 1, 3, \\\"UMB\\\") &&\\n               ((index + 1) == value.length() - 1 || contains(value, index + 2, 2, \\\"ER\\\"));\\n    }\\n\\n    //-- BEGIN HELPER FUNCTIONS --//\\n\\n    /**\\n     * Determines whether or not a value is of slavo-germanic origin. A value is\\n     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.\\n     */\\n    private boolean isSlavoGermanic(final String value) {\\n        return value.indexOf('W') > -1 || value.indexOf('K') > -1 ||\\n            value.indexOf(\\\"CZ\\\") > -1 || value.indexOf(\\\"WITZ\\\") > -1;\\n    }\\n\\n    /**\\n     * Determines whether or not a character is a vowel or not\\n     */\\n    private boolean isVowel(final char ch) {\\n        return VOWELS.indexOf(ch) != -1;\\n    }\\n\\n    /**\\n     * Determines whether or not the value starts with a silent letter.  It will\\n     * return <code>true</code> if the value starts with any of 'GN', 'KN',\\n     * 'PN', 'WR' or 'PS'.\\n     */\\n    private boolean isSilentStart(final String value) {\\n        boolean result = false;\\n        for (final String element : SILENT_START) {\\n            if (value.startsWith(element)) {\\n                result = true;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * Cleans the input.\\n     */\\n    private String cleanInput(String input) {\\n        if (input == null) {\\n            return null;\\n        }\\n        input = input.trim();\\n        if (input.length() == 0) {\\n            return null;\\n        }\\n        return input.toUpperCase(java.util.Locale.ENGLISH);\\n    }\\n\\n    /*\\n     * Gets the character at index <code>index</code> if available, otherwise\\n     * it returns <code>Character.MIN_VALUE</code> so that there is some sort\\n     * of a default.\\n     */\\n    protected char charAt(final String value, final int index) {\\n        if (index < 0 || index >= value.length()) {\\n            return Character.MIN_VALUE;\\n        }\\n        return value.charAt(index);\\n    }\\n\\n    /*\\n     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and\\n     * matching up to length <code>length</code>.\\n     */\\n    protected static boolean contains(final String value, final int start, final int length,\\n                                      final String... criteria) {\\n        boolean result = false;\\n        if (start >= 0 && start + length <= value.length()) {\\n            final String target = value.substring(start, start + length);\\n\\n            for (final String element : criteria) {\\n                if (target.equals(element)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    //-- BEGIN INNER CLASSES --//\\n\\n    /**\\n     * Inner class for storing results, since there is the optional alternate encoding.\\n     */\\n    public class DoubleMetaphoneResult {\\n\\n        private final StringBuilder primary = new StringBuilder(getMaxCodeLen());\\n        private final StringBuilder alternate = new StringBuilder(getMaxCodeLen());\\n        private final int maxLength;\\n\\n        public DoubleMetaphoneResult(final int maxLength) {\\n            this.maxLength = maxLength;\\n        }\\n\\n        public void append(final char value) {\\n            appendPrimary(value);\\n            appendAlternate(value);\\n        }\\n\\n        public void append(final char primary, final char alternate) {\\n            appendPrimary(primary);\\n            appendAlternate(alternate);\\n        }\\n\\n        public void appendPrimary(final char value) {\\n            if (this.primary.length() < this.maxLength) {\\n                this.primary.append(value);\\n            }\\n        }\\n\\n        public void appendAlternate(final char value) {\\n            if (this.alternate.length() < this.maxLength) {\\n                this.alternate.append(value);\\n            }\\n        }\\n\\n        public void append(final String value) {\\n            appendPrimary(value);\\n            appendAlternate(value);\\n        }\\n\\n        public void append(final String primary, final String alternate) {\\n            appendPrimary(primary);\\n            appendAlternate(alternate);\\n        }\\n\\n        public void appendPrimary(final String value) {\\n            final int addChars = this.maxLength - this.primary.length();\\n            if (value.length() <= addChars) {\\n                this.primary.append(value);\\n            } else {\\n                this.primary.append(value.substring(0, addChars));\\n            }\\n        }\\n\\n        public void appendAlternate(final String value) {\\n            final int addChars = this.maxLength - this.alternate.length();\\n            if (value.length() <= addChars) {\\n                this.alternate.append(value);\\n            } else {\\n                this.alternate.append(value.substring(0, addChars));\\n            }\\n        }\\n\\n        public String getPrimary() {\\n            return this.primary.toString();\\n        }\\n\\n        public String getAlternate() {\\n            return this.alternate.toString();\\n        }\\n\\n        public boolean isComplete() {\\n            return this.primary.length() >= this.maxLength &&\\n                   this.alternate.length() >= this.maxLength;\\n        }\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"doubleMetaphone\", \"return_type\": \"String\", \"position\": {\"start_line\": 75, \"end_line\": 77, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String doubleMetaphone(final String value) {\\n        return doubleMetaphone(value, false);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}]}, {\"name\": \"doubleMetaphone\", \"return_type\": \"String\", \"position\": {\"start_line\": 86, \"end_line\": 191, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String doubleMetaphone(String value, final boolean alternate) {\\n        value = cleanInput(value);\\n        if (value == null) {\\n            return null;\\n        }\\n\\n        final boolean slavoGermanic = isSlavoGermanic(value);\\n        int index = isSilentStart(value) ? 1 : 0;\\n\\n        final DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\\n\\n        while (!result.isComplete() && index <= value.length() - 1) {\\n            switch (value.charAt(index)) {\\n            case 'A':\\n            case 'E':\\n            case 'I':\\n            case 'O':\\n            case 'U':\\n            case 'Y':\\n                index = handleAEIOUY(result, index);\\n                break;\\n            case 'B':\\n                result.append('P');\\n                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\\n                break;\\n            case '\\\\u00C7':\\n                // A C with a Cedilla\\n                result.append('S');\\n                index++;\\n                break;\\n            case 'C':\\n                index = handleC(value, result, index);\\n                break;\\n            case 'D':\\n                index = handleD(value, result, index);\\n                break;\\n            case 'F':\\n                result.append('F');\\n                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\\n                break;\\n            case 'G':\\n                index = handleG(value, result, index, slavoGermanic);\\n                break;\\n            case 'H':\\n                index = handleH(value, result, index);\\n                break;\\n            case 'J':\\n                index = handleJ(value, result, index, slavoGermanic);\\n                break;\\n            case 'K':\\n                result.append('K');\\n                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\\n                break;\\n            case 'L':\\n                index = handleL(value, result, index);\\n                break;\\n            case 'M':\\n                result.append('M');\\n                index = conditionM0(value, index) ? index + 2 : index + 1;\\n                break;\\n            case 'N':\\n                result.append('N');\\n                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\\n                break;\\n            case '\\\\u00D1':\\n                // N with a tilde (spanish ene)\\n                result.append('N');\\n                index++;\\n                break;\\n            case 'P':\\n                index = handleP(value, result, index);\\n                break;\\n            case 'Q':\\n                result.append('K');\\n                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\\n                break;\\n            case 'R':\\n                index = handleR(value, result, index, slavoGermanic);\\n                break;\\n            case 'S':\\n                index = handleS(value, result, index, slavoGermanic);\\n                break;\\n            case 'T':\\n                index = handleT(value, result, index);\\n                break;\\n            case 'V':\\n                result.append('F');\\n                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\\n                break;\\n            case 'W':\\n                index = handleW(value, result, index);\\n                break;\\n            case 'X':\\n                index = handleX(value, result, index);\\n                break;\\n            case 'Z':\\n                index = handleZ(value, result, index, slavoGermanic);\\n                break;\\n            default:\\n                index++;\\n                break;\\n            }\\n        }\\n\\n        return alternate ? result.getAlternate() : result.getPrimary();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"alternate\", \"type\": \"boolean\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 202, \"end_line\": 207, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"DoubleMetaphone encode parameter is not of type String\\\");\\n        }\\n        return doubleMetaphone((String) obj);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 216, \"end_line\": 218, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String value) {\\n        return doubleMetaphone(value);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}]}, {\"name\": \"isDoubleMetaphoneEqual\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 230, \"end_line\": 232, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isDoubleMetaphoneEqual(final String value1, final String value2) {\\n        return isDoubleMetaphoneEqual(value1, value2, false);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value1\", \"type\": \"String\"}, {\"name\": \"value2\", \"type\": \"String\"}]}, {\"name\": \"isDoubleMetaphoneEqual\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 244, \"end_line\": 246, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\\n        return StringUtils.equals(doubleMetaphone(value1, alternate), doubleMetaphone(value2, alternate));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value1\", \"type\": \"String\"}, {\"name\": \"value2\", \"type\": \"String\"}, {\"name\": \"alternate\", \"type\": \"boolean\"}]}, {\"name\": \"getMaxCodeLen\", \"return_type\": \"int\", \"position\": {\"start_line\": 252, \"end_line\": 254, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int getMaxCodeLen() {\\n        return this.maxCodeLen;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"setMaxCodeLen\", \"return_type\": \"void\", \"position\": {\"start_line\": 260, \"end_line\": 262, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setMaxCodeLen(final int maxCodeLen) {\\n        this.maxCodeLen = maxCodeLen;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"maxCodeLen\", \"type\": \"int\"}]}, {\"name\": \"handleAEIOUY\", \"return_type\": \"int\", \"position\": {\"start_line\": 269, \"end_line\": 274, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleAEIOUY(final DoubleMetaphoneResult result, final int index) {\\n        if (index == 0) {\\n            result.append('A');\\n        }\\n        return index + 1;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleC\", \"return_type\": \"int\", \"position\": {\"start_line\": 279, \"end_line\": 326, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleC(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (conditionC0(value, index)) {  // very confusing, moved out\\n            result.append('K');\\n            index += 2;\\n        } else if (index == 0 && contains(value, index, 6, \\\"CAESAR\\\")) {\\n            result.append('S');\\n            index += 2;\\n        } else if (contains(value, index, 2, \\\"CH\\\")) {\\n            index = handleCH(value, result, index);\\n        } else if (contains(value, index, 2, \\\"CZ\\\") &&\\n                   !contains(value, index - 2, 4, \\\"WICZ\\\")) {\\n            //-- \\\"Czerny\\\" --//\\n            result.append('S', 'X');\\n            index += 2;\\n        } else if (contains(value, index + 1, 3, \\\"CIA\\\")) {\\n            //-- \\\"focaccia\\\" --//\\n            result.append('X');\\n            index += 3;\\n        } else if (contains(value, index, 2, \\\"CC\\\") &&\\n                   !(index == 1 && charAt(value, 0) == 'M')) {\\n            //-- double \\\"cc\\\" but not \\\"McClelland\\\" --//\\n            return handleCC(value, result, index);\\n        } else if (contains(value, index, 2, \\\"CK\\\", \\\"CG\\\", \\\"CQ\\\")) {\\n            result.append('K');\\n            index += 2;\\n        } else if (contains(value, index, 2, \\\"CI\\\", \\\"CE\\\", \\\"CY\\\")) {\\n            //-- Italian vs. English --//\\n            if (contains(value, index, 3, \\\"CIO\\\", \\\"CIE\\\", \\\"CIA\\\")) {\\n                result.append('S', 'X');\\n            } else {\\n                result.append('S');\\n            }\\n            index += 2;\\n        } else {\\n            result.append('K');\\n            if (contains(value, index + 1, 2, \\\" C\\\", \\\" Q\\\", \\\" G\\\")) {\\n                //-- Mac Caffrey, Mac Gregor --//\\n                index += 3;\\n            } else if (contains(value, index + 1, 1, \\\"C\\\", \\\"K\\\", \\\"Q\\\") &&\\n                       !contains(value, index + 1, 2, \\\"CE\\\", \\\"CI\\\")) {\\n                index += 2;\\n            } else {\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleCC\", \"return_type\": \"int\", \"position\": {\"start_line\": 331, \"end_line\": 350, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleCC(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (contains(value, index + 2, 1, \\\"I\\\", \\\"E\\\", \\\"H\\\") &&\\n            !contains(value, index + 2, 2, \\\"HU\\\")) {\\n            //-- \\\"bellocchio\\\" but not \\\"bacchus\\\" --//\\n            if ((index == 1 && charAt(value, index - 1) == 'A') ||\\n                contains(value, index - 1, 5, \\\"UCCEE\\\", \\\"UCCES\\\")) {\\n                //-- \\\"accident\\\", \\\"accede\\\", \\\"succeed\\\" --//\\n                result.append(\\\"KS\\\");\\n            } else {\\n                //-- \\\"bacci\\\", \\\"bertucci\\\", other Italian --//\\n                result.append('X');\\n            }\\n            index += 3;\\n        } else {    // Pierce's rule\\n            result.append('K');\\n            index += 2;\\n        }\\n\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleCH\", \"return_type\": \"int\", \"position\": {\"start_line\": 355, \"end_line\": 379, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleCH(final String value, final DoubleMetaphoneResult result, final int index) {\\n        if (index > 0 && contains(value, index, 4, \\\"CHAE\\\")) {   // Michael\\n            result.append('K', 'X');\\n            return index + 2;\\n        } else if (conditionCH0(value, index)) {\\n            //-- Greek roots (\\\"chemistry\\\", \\\"chorus\\\", etc.) --//\\n            result.append('K');\\n            return index + 2;\\n        } else if (conditionCH1(value, index)) {\\n            //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//\\n            result.append('K');\\n            return index + 2;\\n        } else {\\n            if (index > 0) {\\n                if (contains(value, 0, 2, \\\"MC\\\")) {\\n                    result.append('K');\\n                } else {\\n                    result.append('X', 'K');\\n                }\\n            } else {\\n                result.append('X');\\n            }\\n            return index + 2;\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleD\", \"return_type\": \"int\", \"position\": {\"start_line\": 384, \"end_line\": 403, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleD(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (contains(value, index, 2, \\\"DG\\\")) {\\n            //-- \\\"Edge\\\" --//\\n            if (contains(value, index + 2, 1, \\\"I\\\", \\\"E\\\", \\\"Y\\\")) {\\n                result.append('J');\\n                index += 3;\\n                //-- \\\"Edgar\\\" --//\\n            } else {\\n                result.append(\\\"TK\\\");\\n                index += 2;\\n            }\\n        } else if (contains(value, index, 2, \\\"DT\\\", \\\"DD\\\")) {\\n            result.append('T');\\n            index += 2;\\n        } else {\\n            result.append('T');\\n            index++;\\n        }\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleG\", \"return_type\": \"int\", \"position\": {\"start_line\": 408, \"end_line\": 461, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleG(final String value, final DoubleMetaphoneResult result, int index,\\n                        final boolean slavoGermanic) {\\n        if (charAt(value, index + 1) == 'H') {\\n            index = handleGH(value, result, index);\\n        } else if (charAt(value, index + 1) == 'N') {\\n            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\\n                result.append(\\\"KN\\\", \\\"N\\\");\\n            } else if (!contains(value, index + 2, 2, \\\"EY\\\") &&\\n                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {\\n                result.append(\\\"N\\\", \\\"KN\\\");\\n            } else {\\n                result.append(\\\"KN\\\");\\n            }\\n            index = index + 2;\\n        } else if (contains(value, index + 1, 2, \\\"LI\\\") && !slavoGermanic) {\\n            result.append(\\\"KL\\\", \\\"L\\\");\\n            index += 2;\\n        } else if (index == 0 &&\\n                   (charAt(value, index + 1) == 'Y' ||\\n                    contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\\n            result.append('K', 'J');\\n            index += 2;\\n        } else if ((contains(value, index + 1, 2, \\\"ER\\\") ||\\n                    charAt(value, index + 1) == 'Y') &&\\n                   !contains(value, 0, 6, \\\"DANGER\\\", \\\"RANGER\\\", \\\"MANGER\\\") &&\\n                   !contains(value, index - 1, 1, \\\"E\\\", \\\"I\\\") &&\\n                   !contains(value, index - 1, 3, \\\"RGY\\\", \\\"OGY\\\")) {\\n            //-- -ger-, -gy- --//\\n            result.append('K', 'J');\\n            index += 2;\\n        } else if (contains(value, index + 1, 1, \\\"E\\\", \\\"I\\\", \\\"Y\\\") ||\\n                   contains(value, index - 1, 4, \\\"AGGI\\\", \\\"OGGI\\\")) {\\n            //-- Italian \\\"biaggi\\\" --//\\n            if (contains(value, 0 ,4, \\\"VAN \\\", \\\"VON \\\") ||\\n                contains(value, 0, 3, \\\"SCH\\\") ||\\n                contains(value, index + 1, 2, \\\"ET\\\")) {\\n                //-- obvious germanic --//\\n                result.append('K');\\n            } else if (contains(value, index + 1, 3, \\\"IER\\\")) {\\n                result.append('J');\\n            } else {\\n                result.append('J', 'K');\\n            }\\n            index += 2;\\n        } else if (charAt(value, index + 1) == 'G') {\\n            index += 2;\\n            result.append('K');\\n        } else {\\n            index++;\\n            result.append('K');\\n        }\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}, {\"name\": \"slavoGermanic\", \"type\": \"boolean\"}]}, {\"name\": \"handleGH\", \"return_type\": \"int\", \"position\": {\"start_line\": 466, \"end_line\": 493, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleGH(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (index > 0 && !isVowel(charAt(value, index - 1))) {\\n            result.append('K');\\n            index += 2;\\n        } else if (index == 0) {\\n            if (charAt(value, index + 2) == 'I') {\\n                result.append('J');\\n            } else {\\n                result.append('K');\\n            }\\n            index += 2;\\n        } else if ((index > 1 && contains(value, index - 2, 1, \\\"B\\\", \\\"H\\\", \\\"D\\\")) ||\\n                   (index > 2 && contains(value, index - 3, 1, \\\"B\\\", \\\"H\\\", \\\"D\\\")) ||\\n                   (index > 3 && contains(value, index - 4, 1, \\\"B\\\", \\\"H\\\"))) {\\n            //-- Parker's rule (with some further refinements) - \\\"hugh\\\"\\n            index += 2;\\n        } else {\\n            if (index > 2 && charAt(value, index - 1) == 'U' &&\\n                contains(value, index - 3, 1, \\\"C\\\", \\\"G\\\", \\\"L\\\", \\\"R\\\", \\\"T\\\")) {\\n                //-- \\\"laugh\\\", \\\"McLaughlin\\\", \\\"cough\\\", \\\"gough\\\", \\\"rough\\\", \\\"tough\\\"\\n                result.append('F');\\n            } else if (index > 0 && charAt(value, index - 1) != 'I') {\\n                result.append('K');\\n            }\\n            index += 2;\\n        }\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleH\", \"return_type\": \"int\", \"position\": {\"start_line\": 498, \"end_line\": 509, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleH(final String value, final DoubleMetaphoneResult result, int index) {\\n        //-- only keep if first & before vowel or between 2 vowels --//\\n        if ((index == 0 || isVowel(charAt(value, index - 1))) &&\\n            isVowel(charAt(value, index + 1))) {\\n            result.append('H');\\n            index += 2;\\n            //-- also takes car of \\\"HH\\\" --//\\n        } else {\\n            index++;\\n        }\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleJ\", \"return_type\": \"int\", \"position\": {\"start_line\": 514, \"end_line\": 545, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleJ(final String value, final DoubleMetaphoneResult result, int index,\\n                        final boolean slavoGermanic) {\\n        if (contains(value, index, 4, \\\"JOSE\\\") || contains(value, 0, 4, \\\"SAN \\\")) {\\n                //-- obvious Spanish, \\\"Jose\\\", \\\"San Jacinto\\\" --//\\n                if ((index == 0 && (charAt(value, index + 4) == ' ') ||\\n                     value.length() == 4) || contains(value, 0, 4, \\\"SAN \\\")) {\\n                    result.append('H');\\n                } else {\\n                    result.append('J', 'H');\\n                }\\n                index++;\\n            } else {\\n                if (index == 0 && !contains(value, index, 4, \\\"JOSE\\\")) {\\n                    result.append('J', 'A');\\n                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic &&\\n                           (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) {\\n                    result.append('J', 'H');\\n                } else if (index == value.length() - 1) {\\n                    result.append('J', ' ');\\n                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) &&\\n                           !contains(value, index - 1, 1, \\\"S\\\", \\\"K\\\", \\\"L\\\")) {\\n                    result.append('J');\\n                }\\n\\n                if (charAt(value, index + 1) == 'J') {\\n                    index += 2;\\n                } else {\\n                    index++;\\n                }\\n            }\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}, {\"name\": \"slavoGermanic\", \"type\": \"boolean\"}]}, {\"name\": \"handleL\", \"return_type\": \"int\", \"position\": {\"start_line\": 550, \"end_line\": 563, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleL(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (charAt(value, index + 1) == 'L') {\\n            if (conditionL0(value, index)) {\\n                result.appendPrimary('L');\\n            } else {\\n                result.append('L');\\n            }\\n            index += 2;\\n        } else {\\n            index++;\\n            result.append('L');\\n        }\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleP\", \"return_type\": \"int\", \"position\": {\"start_line\": 568, \"end_line\": 577, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleP(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (charAt(value, index + 1) == 'H') {\\n            result.append('F');\\n            index += 2;\\n        } else {\\n            result.append('P');\\n            index = contains(value, index + 1, 1, \\\"P\\\", \\\"B\\\") ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleR\", \"return_type\": \"int\", \"position\": {\"start_line\": 582, \"end_line\": 592, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleR(final String value, final DoubleMetaphoneResult result, final int index,\\n                        final boolean slavoGermanic) {\\n        if (index == value.length() - 1 && !slavoGermanic &&\\n            contains(value, index - 2, 2, \\\"IE\\\") &&\\n            !contains(value, index - 4, 2, \\\"ME\\\", \\\"MA\\\")) {\\n            result.appendAlternate('R');\\n        } else {\\n            result.append('R');\\n        }\\n        return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}, {\"name\": \"slavoGermanic\", \"type\": \"boolean\"}]}, {\"name\": \"handleS\", \"return_type\": \"int\", \"position\": {\"start_line\": 597, \"end_line\": 642, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleS(final String value, final DoubleMetaphoneResult result, int index,\\n                        final boolean slavoGermanic) {\\n        if (contains(value, index - 1, 3, \\\"ISL\\\", \\\"YSL\\\")) {\\n            //-- special cases \\\"island\\\", \\\"isle\\\", \\\"carlisle\\\", \\\"carlysle\\\" --//\\n            index++;\\n        } else if (index == 0 && contains(value, index, 5, \\\"SUGAR\\\")) {\\n            //-- special case \\\"sugar-\\\" --//\\n            result.append('X', 'S');\\n            index++;\\n        } else if (contains(value, index, 2, \\\"SH\\\")) {\\n            if (contains(value, index + 1, 4, \\\"HEIM\\\", \\\"HOEK\\\", \\\"HOLM\\\", \\\"HOLZ\\\")) {\\n                //-- germanic --//\\n                result.append('S');\\n            } else {\\n                result.append('X');\\n            }\\n            index += 2;\\n        } else if (contains(value, index, 3, \\\"SIO\\\", \\\"SIA\\\") || contains(value, index, 4, \\\"SIAN\\\")) {\\n            //-- Italian and Armenian --//\\n            if (slavoGermanic) {\\n                result.append('S');\\n            } else {\\n                result.append('S', 'X');\\n            }\\n            index += 3;\\n        } else if ((index == 0 && contains(value, index + 1, 1, \\\"M\\\", \\\"N\\\", \\\"L\\\", \\\"W\\\")) ||\\n                   contains(value, index + 1, 1, \\\"Z\\\")) {\\n            //-- german & anglicisations, e.g. \\\"smith\\\" match \\\"schmidt\\\" //\\n            // \\\"snider\\\" match \\\"schneider\\\" --//\\n            //-- also, -sz- in slavic language although in hungarian it //\\n            //   is pronounced \\\"s\\\" --//\\n            result.append('S', 'X');\\n            index = contains(value, index + 1, 1, \\\"Z\\\") ? index + 2 : index + 1;\\n        } else if (contains(value, index, 2, \\\"SC\\\")) {\\n            index = handleSC(value, result, index);\\n        } else {\\n            if (index == value.length() - 1 && contains(value, index - 2, 2, \\\"AI\\\", \\\"OI\\\")) {\\n                //-- french e.g. \\\"resnais\\\", \\\"artois\\\" --//\\n                result.appendAlternate('S');\\n            } else {\\n                result.append('S');\\n            }\\n            index = contains(value, index + 1, 1, \\\"S\\\", \\\"Z\\\") ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}, {\"name\": \"slavoGermanic\", \"type\": \"boolean\"}]}, {\"name\": \"handleSC\", \"return_type\": \"int\", \"position\": {\"start_line\": 647, \"end_line\": 671, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleSC(final String value, final DoubleMetaphoneResult result, final int index) {\\n        if (charAt(value, index + 2) == 'H') {\\n            //-- Schlesinger's rule --//\\n            if (contains(value, index + 3, 2, \\\"OO\\\", \\\"ER\\\", \\\"EN\\\", \\\"UY\\\", \\\"ED\\\", \\\"EM\\\")) {\\n                //-- Dutch origin, e.g. \\\"school\\\", \\\"schooner\\\" --//\\n                if (contains(value, index + 3, 2, \\\"ER\\\", \\\"EN\\\")) {\\n                    //-- \\\"schermerhorn\\\", \\\"schenker\\\" --//\\n                    result.append(\\\"X\\\", \\\"SK\\\");\\n                } else {\\n                    result.append(\\\"SK\\\");\\n                }\\n            } else {\\n                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') {\\n                    result.append('X', 'S');\\n                } else {\\n                    result.append('X');\\n                }\\n            }\\n        } else if (contains(value, index + 2, 1, \\\"I\\\", \\\"E\\\", \\\"Y\\\")) {\\n            result.append('S');\\n        } else {\\n            result.append(\\\"SK\\\");\\n        }\\n        return index + 3;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleT\", \"return_type\": \"int\", \"position\": {\"start_line\": 676, \"end_line\": 698, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleT(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (contains(value, index, 4, \\\"TION\\\")) {\\n            result.append('X');\\n            index += 3;\\n        } else if (contains(value, index, 3, \\\"TIA\\\", \\\"TCH\\\")) {\\n            result.append('X');\\n            index += 3;\\n        } else if (contains(value, index, 2, \\\"TH\\\") || contains(value, index, 3, \\\"TTH\\\")) {\\n            if (contains(value, index + 2, 2, \\\"OM\\\", \\\"AM\\\") ||\\n                //-- special case \\\"thomas\\\", \\\"thames\\\" or germanic --//\\n                contains(value, 0, 4, \\\"VAN \\\", \\\"VON \\\") ||\\n                contains(value, 0, 3, \\\"SCH\\\")) {\\n                result.append('T');\\n            } else {\\n                result.append('0', 'T');\\n            }\\n            index += 2;\\n        } else {\\n            result.append('T');\\n            index = contains(value, index + 1, 1, \\\"T\\\", \\\"D\\\") ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleW\", \"return_type\": \"int\", \"position\": {\"start_line\": 703, \"end_line\": 734, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleW(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (contains(value, index, 2, \\\"WR\\\")) {\\n            //-- can also be in middle of word --//\\n            result.append('R');\\n            index += 2;\\n        } else {\\n            if (index == 0 && (isVowel(charAt(value, index + 1)) ||\\n                               contains(value, index, 2, \\\"WH\\\"))) {\\n                if (isVowel(charAt(value, index + 1))) {\\n                    //-- Wasserman should match Vasserman --//\\n                    result.append('A', 'F');\\n                } else {\\n                    //-- need Uomo to match Womo --//\\n                    result.append('A');\\n                }\\n                index++;\\n            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||\\n                       contains(value, index - 1, 5, \\\"EWSKI\\\", \\\"EWSKY\\\", \\\"OWSKI\\\", \\\"OWSKY\\\") ||\\n                       contains(value, 0, 3, \\\"SCH\\\")) {\\n                //-- Arnow should match Arnoff --//\\n                result.appendAlternate('F');\\n                index++;\\n            } else if (contains(value, index, 4, \\\"WICZ\\\", \\\"WITZ\\\")) {\\n                //-- Polish e.g. \\\"filipowicz\\\" --//\\n                result.append(\\\"TS\\\", \\\"FX\\\");\\n                index += 4;\\n            } else {\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleX\", \"return_type\": \"int\", \"position\": {\"start_line\": 739, \"end_line\": 753, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleX(final String value, final DoubleMetaphoneResult result, int index) {\\n        if (index == 0) {\\n            result.append('S');\\n            index++;\\n        } else {\\n            if (!((index == value.length() - 1) &&\\n                  (contains(value, index - 3, 3, \\\"IAU\\\", \\\"EAU\\\") ||\\n                   contains(value, index - 2, 2, \\\"AU\\\", \\\"OU\\\")))) {\\n                //-- French e.g. breaux --//\\n                result.append(\\\"KS\\\");\\n            }\\n            index = contains(value, index + 1, 1, \\\"C\\\", \\\"X\\\") ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"handleZ\", \"return_type\": \"int\", \"position\": {\"start_line\": 758, \"end_line\": 774, \"start_column\": 13, \"end_column\": 5}, \"code\": \"int handleZ(final String value, final DoubleMetaphoneResult result, int index,\\n                        final boolean slavoGermanic) {\\n        if (charAt(value, index + 1) == 'H') {\\n            //-- Chinese pinyin e.g. \\\"zhao\\\" or Angelina \\\"Zhang\\\" --//\\n            result.append('J');\\n            index += 2;\\n        } else {\\n            if (contains(value, index + 1, 2, \\\"ZO\\\", \\\"ZI\\\", \\\"ZA\\\") ||\\n                (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) {\\n                result.append(\\\"S\\\", \\\"TS\\\");\\n            } else {\\n                result.append('S');\\n            }\\n            index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;\\n        }\\n        return index;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"result\", \"type\": \"DoubleMetaphoneResult\"}, {\"name\": \"index\", \"type\": \"int\"}, {\"name\": \"slavoGermanic\", \"type\": \"boolean\"}]}, {\"name\": \"conditionC0\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 781, \"end_line\": 795, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean conditionC0(final String value, final int index) {\\n        if (contains(value, index, 4, \\\"CHIA\\\")) {\\n            return true;\\n        } else if (index <= 1) {\\n            return false;\\n        } else if (isVowel(charAt(value, index - 2))) {\\n            return false;\\n        } else if (!contains(value, index - 1, 3, \\\"ACH\\\")) {\\n            return false;\\n        } else {\\n            final char c = charAt(value, index + 2);\\n            return (c != 'I' && c != 'E') ||\\n                    contains(value, index - 2, 6, \\\"BACHER\\\", \\\"MACHER\\\");\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"conditionCH0\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 800, \"end_line\": 811, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean conditionCH0(final String value, final int index) {\\n        if (index != 0) {\\n            return false;\\n        } else if (!contains(value, index + 1, 5, \\\"HARAC\\\", \\\"HARIS\\\") &&\\n                   !contains(value, index + 1, 3, \\\"HOR\\\", \\\"HYM\\\", \\\"HIA\\\", \\\"HEM\\\")) {\\n            return false;\\n        } else if (contains(value, 0, 5, \\\"CHORE\\\")) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"conditionCH1\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 816, \"end_line\": 822, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean conditionCH1(final String value, final int index) {\\n        return ((contains(value, 0, 4, \\\"VAN \\\", \\\"VON \\\") || contains(value, 0, 3, \\\"SCH\\\")) ||\\n                contains(value, index - 2, 6, \\\"ORCHES\\\", \\\"ARCHIT\\\", \\\"ORCHID\\\") ||\\n                contains(value, index + 2, 1, \\\"T\\\", \\\"S\\\") ||\\n                ((contains(value, index - 1, 1, \\\"A\\\", \\\"O\\\", \\\"U\\\", \\\"E\\\") || index == 0) &&\\n                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"conditionL0\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 827, \"end_line\": 838, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean conditionL0(final String value, final int index) {\\n        if (index == value.length() - 3 &&\\n            contains(value, index - 1, 4, \\\"ILLO\\\", \\\"ILLA\\\", \\\"ALLE\\\")) {\\n            return true;\\n        } else if ((contains(value, value.length() - 2, 2, \\\"AS\\\", \\\"OS\\\") ||\\n                    contains(value, value.length() - 1, 1, \\\"A\\\", \\\"O\\\")) &&\\n                   contains(value, index - 1, 4, \\\"ALLE\\\")) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"conditionM0\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 843, \"end_line\": 849, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean conditionM0(final String value, final int index) {\\n        if (charAt(value, index + 1) == 'M') {\\n            return true;\\n        }\\n        return contains(value, index - 1, 3, \\\"UMB\\\") &&\\n               ((index + 1) == value.length() - 1 || contains(value, index + 2, 2, \\\"ER\\\"));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"isSlavoGermanic\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 857, \"end_line\": 860, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean isSlavoGermanic(final String value) {\\n        return value.indexOf('W') > -1 || value.indexOf('K') > -1 ||\\n            value.indexOf(\\\"CZ\\\") > -1 || value.indexOf(\\\"WITZ\\\") > -1;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}]}, {\"name\": \"isVowel\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 865, \"end_line\": 867, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean isVowel(final char ch) {\\n        return VOWELS.indexOf(ch) != -1;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ch\", \"type\": \"char\"}]}, {\"name\": \"isSilentStart\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 874, \"end_line\": 883, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean isSilentStart(final String value) {\\n        boolean result = false;\\n        for (final String element : SILENT_START) {\\n            if (value.startsWith(element)) {\\n                result = true;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}]}, {\"name\": \"cleanInput\", \"return_type\": \"String\", \"position\": {\"start_line\": 888, \"end_line\": 897, \"start_column\": 13, \"end_column\": 5}, \"code\": \"String cleanInput(String input) {\\n        if (input == null) {\\n            return null;\\n        }\\n        input = input.trim();\\n        if (input.length() == 0) {\\n            return null;\\n        }\\n        return input.toUpperCase(java.util.Locale.ENGLISH);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"String\"}]}, {\"name\": \"charAt\", \"return_type\": \"char\", \"position\": {\"start_line\": 904, \"end_line\": 909, \"start_column\": 15, \"end_column\": 5}, \"code\": \"char charAt(final String value, final int index) {\\n        if (index < 0 || index >= value.length()) {\\n            return Character.MIN_VALUE;\\n        }\\n        return value.charAt(index);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"contains\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 915, \"end_line\": 929, \"start_column\": 22, \"end_column\": 5}, \"code\": \"boolean contains(final String value, final int start, final int length,\\n                                      final String... criteria) {\\n        boolean result = false;\\n        if (start >= 0 && start + length <= value.length()) {\\n            final String target = value.substring(start, start + length);\\n\\n            for (final String element : criteria) {\\n                if (target.equals(element)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"start\", \"type\": \"int\"}, {\"name\": \"length\", \"type\": \"int\"}, {\"name\": \"criteria\", \"type\": \"String\"}]}]}, {\"parent_file\": null, \"name\": \"DoubleMetaphoneResult\", \"position\": {\"start_line\": 936, \"end_line\": 1008, \"start_column\": 12, \"end_column\": 5}, \"code\": \"class DoubleMetaphoneResult {\\n\\n        private final StringBuilder primary = new StringBuilder(getMaxCodeLen());\\n        private final StringBuilder alternate = new StringBuilder(getMaxCodeLen());\\n        private final int maxLength;\\n\\n        public DoubleMetaphoneResult(final int maxLength) {\\n            this.maxLength = maxLength;\\n        }\\n\\n        public void append(final char value) {\\n            appendPrimary(value);\\n            appendAlternate(value);\\n        }\\n\\n        public void append(final char primary, final char alternate) {\\n            appendPrimary(primary);\\n            appendAlternate(alternate);\\n        }\\n\\n        public void appendPrimary(final char value) {\\n            if (this.primary.length() < this.maxLength) {\\n                this.primary.append(value);\\n            }\\n        }\\n\\n        public void appendAlternate(final char value) {\\n            if (this.alternate.length() < this.maxLength) {\\n                this.alternate.append(value);\\n            }\\n        }\\n\\n        public void append(final String value) {\\n            appendPrimary(value);\\n            appendAlternate(value);\\n        }\\n\\n        public void append(final String primary, final String alternate) {\\n            appendPrimary(primary);\\n            appendAlternate(alternate);\\n        }\\n\\n        public void appendPrimary(final String value) {\\n            final int addChars = this.maxLength - this.primary.length();\\n            if (value.length() <= addChars) {\\n                this.primary.append(value);\\n            } else {\\n                this.primary.append(value.substring(0, addChars));\\n            }\\n        }\\n\\n        public void appendAlternate(final String value) {\\n            final int addChars = this.maxLength - this.alternate.length();\\n            if (value.length() <= addChars) {\\n                this.alternate.append(value);\\n            } else {\\n                this.alternate.append(value.substring(0, addChars));\\n            }\\n        }\\n\\n        public String getPrimary() {\\n            return this.primary.toString();\\n        }\\n\\n        public String getAlternate() {\\n            return this.alternate.toString();\\n        }\\n\\n        public boolean isComplete() {\\n            return this.primary.length() >= this.maxLength &&\\n                   this.alternate.length() >= this.maxLength;\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"append\", \"return_type\": \"void\", \"position\": {\"start_line\": 946, \"end_line\": 949, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void append(final char value) {\\n            appendPrimary(value);\\n            appendAlternate(value);\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"char\"}]}, {\"name\": \"append\", \"return_type\": \"void\", \"position\": {\"start_line\": 951, \"end_line\": 954, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void append(final char primary, final char alternate) {\\n            appendPrimary(primary);\\n            appendAlternate(alternate);\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"primary\", \"type\": \"char\"}, {\"name\": \"alternate\", \"type\": \"char\"}]}, {\"name\": \"appendPrimary\", \"return_type\": \"void\", \"position\": {\"start_line\": 956, \"end_line\": 960, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void appendPrimary(final char value) {\\n            if (this.primary.length() < this.maxLength) {\\n                this.primary.append(value);\\n            }\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"char\"}]}, {\"name\": \"appendAlternate\", \"return_type\": \"void\", \"position\": {\"start_line\": 962, \"end_line\": 966, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void appendAlternate(final char value) {\\n            if (this.alternate.length() < this.maxLength) {\\n                this.alternate.append(value);\\n            }\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"char\"}]}, {\"name\": \"append\", \"return_type\": \"void\", \"position\": {\"start_line\": 968, \"end_line\": 971, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void append(final String value) {\\n            appendPrimary(value);\\n            appendAlternate(value);\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}]}, {\"name\": \"append\", \"return_type\": \"void\", \"position\": {\"start_line\": 973, \"end_line\": 976, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void append(final String primary, final String alternate) {\\n            appendPrimary(primary);\\n            appendAlternate(alternate);\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"primary\", \"type\": \"String\"}, {\"name\": \"alternate\", \"type\": \"String\"}]}, {\"name\": \"appendPrimary\", \"return_type\": \"void\", \"position\": {\"start_line\": 978, \"end_line\": 985, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void appendPrimary(final String value) {\\n            final int addChars = this.maxLength - this.primary.length();\\n            if (value.length() <= addChars) {\\n                this.primary.append(value);\\n            } else {\\n                this.primary.append(value.substring(0, addChars));\\n            }\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}]}, {\"name\": \"appendAlternate\", \"return_type\": \"void\", \"position\": {\"start_line\": 987, \"end_line\": 994, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void appendAlternate(final String value) {\\n            final int addChars = this.maxLength - this.alternate.length();\\n            if (value.length() <= addChars) {\\n                this.alternate.append(value);\\n            } else {\\n                this.alternate.append(value.substring(0, addChars));\\n            }\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}]}, {\"name\": \"getPrimary\", \"return_type\": \"String\", \"position\": {\"start_line\": 996, \"end_line\": 998, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String getPrimary() {\\n            return this.primary.toString();\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getAlternate\", \"return_type\": \"String\", \"position\": {\"start_line\": 1000, \"end_line\": 1002, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String getAlternate() {\\n            return this.alternate.toString();\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isComplete\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 1004, \"end_line\": 1007, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean isComplete() {\\n            return this.primary.length() >= this.maxLength &&\\n                   this.alternate.length() >= this.maxLength;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/MatchRatingApproachEncoder.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npackage org.apache.commons.codec.language;\\n\\nimport java.util.Locale;\\n\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringEncoder;\\n\\n/**\\n * Match Rating Approach Phonetic Algorithm Developed by <CITE>Western Airlines</CITE> in 1977.\\n *\\n * This class is immutable and thread-safe.\\n *\\n * @see <a href=\\\"http://en.wikipedia.org/wiki/Match_rating_approach\\\">Wikipedia - Match Rating Approach</a>\\n * @since 1.8\\n */\\npublic class MatchRatingApproachEncoder implements StringEncoder {\\n\\n    private static final String SPACE = \\\" \\\";\\n\\n    private static final String EMPTY = \\\"\\\";\\n\\n    /**\\n     * Constants used mainly for the min rating value.\\n     */\\n    private static final int ONE = 1, TWO = 2, THREE = 3, FOUR = 4, FIVE = 5, SIX = 6, SEVEN = 7,\\n                             ELEVEN = 11, TWELVE = 12;\\n\\n    /**\\n     * The plain letter equivalent of the accented letters.\\n     */\\n    private static final String PLAIN_ASCII = \\\"AaEeIiOoUu\\\" + // grave\\n            \\\"AaEeIiOoUuYy\\\" + // acute\\n            \\\"AaEeIiOoUuYy\\\" + // circumflex\\n            \\\"AaOoNn\\\" + // tilde\\n            \\\"AaEeIiOoUuYy\\\" + // umlaut\\n            \\\"Aa\\\" + // ring\\n            \\\"Cc\\\" + // cedilla\\n            \\\"OoUu\\\"; // double acute\\n\\n    /**\\n     * Unicode characters corresponding to various accented letters. For example: \\\\u00DA is U acute etc...\\n     */\\n    private static final String UNICODE = \\\"\\\\u00C0\\\\u00E0\\\\u00C8\\\\u00E8\\\\u00CC\\\\u00EC\\\\u00D2\\\\u00F2\\\\u00D9\\\\u00F9\\\" +\\n            \\\"\\\\u00C1\\\\u00E1\\\\u00C9\\\\u00E9\\\\u00CD\\\\u00ED\\\\u00D3\\\\u00F3\\\\u00DA\\\\u00FA\\\\u00DD\\\\u00FD\\\" +\\n            \\\"\\\\u00C2\\\\u00E2\\\\u00CA\\\\u00EA\\\\u00CE\\\\u00EE\\\\u00D4\\\\u00F4\\\\u00DB\\\\u00FB\\\\u0176\\\\u0177\\\" +\\n            \\\"\\\\u00C3\\\\u00E3\\\\u00D5\\\\u00F5\\\\u00D1\\\\u00F1\\\" +\\n            \\\"\\\\u00C4\\\\u00E4\\\\u00CB\\\\u00EB\\\\u00CF\\\\u00EF\\\\u00D6\\\\u00F6\\\\u00DC\\\\u00FC\\\\u0178\\\\u00FF\\\" +\\n            \\\"\\\\u00C5\\\\u00E5\\\" + \\\"\\\\u00C7\\\\u00E7\\\" + \\\"\\\\u0150\\\\u0151\\\\u0170\\\\u0171\\\";\\n\\n    private static final String[] DOUBLE_CONSONANT =\\n            new String[] { \\\"BB\\\", \\\"CC\\\", \\\"DD\\\", \\\"FF\\\", \\\"GG\\\", \\\"HH\\\", \\\"JJ\\\", \\\"KK\\\", \\\"LL\\\", \\\"MM\\\", \\\"NN\\\", \\\"PP\\\", \\\"QQ\\\", \\\"RR\\\", \\\"SS\\\",\\n                           \\\"TT\\\", \\\"VV\\\", \\\"WW\\\", \\\"XX\\\", \\\"YY\\\", \\\"ZZ\\\" };\\n\\n    /**\\n     * Cleans up a name: 1. Upper-cases everything 2. Removes some common punctuation 3. Removes accents 4. Removes any\\n     * spaces.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param name\\n     *            The name to be cleaned\\n     * @return The cleaned name\\n     */\\n    String cleanName(final String name) {\\n        String upperName = name.toUpperCase(Locale.ENGLISH);\\n\\n        final String[] charsToTrim = { \\\"\\\\\\\\-\\\", \\\"[&]\\\", \\\"\\\\\\\\'\\\", \\\"\\\\\\\\.\\\", \\\"[\\\\\\\\,]\\\" };\\n        for (final String str : charsToTrim) {\\n            upperName = upperName.replaceAll(str, EMPTY);\\n        }\\n\\n        upperName = removeAccents(upperName);\\n        upperName = upperName.replaceAll(\\\"\\\\\\\\s+\\\", EMPTY);\\n\\n        return upperName;\\n    }\\n\\n    /**\\n     * Encodes an Object using the Match Rating Approach algorithm. Method is here to satisfy the requirements of the\\n     * Encoder interface Throws an EncoderException if input object is not of type java.lang.String.\\n     *\\n     * @param pObject\\n     *            Object to encode\\n     * @return An object (or type java.lang.String) containing the Match Rating Approach code which corresponds to the\\n     *         String supplied.\\n     * @throws EncoderException\\n     *             if the parameter supplied is not of type java.lang.String\\n     */\\n    @Override\\n    public final Object encode(final Object pObject) throws EncoderException {\\n        if (!(pObject instanceof String)) {\\n            throw new EncoderException(\\n                    \\\"Parameter supplied to Match Rating Approach encoder is not of type java.lang.String\\\");\\n        }\\n        return encode((String) pObject);\\n    }\\n\\n    /**\\n     * Encodes a String using the Match Rating Approach (MRA) algorithm.\\n     *\\n     * @param name\\n     *            String object to encode\\n     * @return The MRA code corresponding to the String supplied\\n     */\\n    @Override\\n    public final String encode(String name) {\\n        // Bulletproof for trivial input - NINO\\n        if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) {\\n            return EMPTY;\\n        }\\n\\n        // Preprocessing\\n        name = cleanName(name);\\n\\n        // BEGIN: Actual encoding part of the algorithm...\\n        // 1. Delete all vowels unless the vowel begins the word\\n        name = removeVowels(name);\\n\\n        // 2. Remove second consonant from any double consonant\\n        name = removeDoubleConsonants(name);\\n\\n        // 3. Reduce codex to 6 letters by joining the first 3 and last 3 letters\\n        name = getFirst3Last3(name);\\n\\n        return name;\\n    }\\n\\n    /**\\n     * Gets the first and last 3 letters of a name (if &gt; 6 characters) Else just returns the name.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param name\\n     *            The string to get the substrings from\\n     * @return Annexed first and last 3 letters of input word.\\n     */\\n    String getFirst3Last3(final String name) {\\n        final int nameLength = name.length();\\n\\n        if (nameLength > SIX) {\\n            final String firstThree = name.substring(0, THREE);\\n            final String lastThree = name.substring(nameLength - THREE, nameLength);\\n            return firstThree + lastThree;\\n        }\\n        return name;\\n    }\\n\\n    /**\\n     * Obtains the min rating of the length sum of the 2 names. In essence the larger the sum length the smaller the\\n     * min rating. Values strictly from documentation.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param sumLength\\n     *            The length of 2 strings sent down\\n     * @return The min rating value\\n     */\\n    int getMinRating(final int sumLength) {\\n        int minRating = 0;\\n\\n        if (sumLength <= FOUR) {\\n            minRating = FIVE;\\n        } else if (sumLength <= SEVEN) { // aready know it is at least 5\\n            minRating = FOUR;\\n        } else if (sumLength <= ELEVEN) { // aready know it is at least 8\\n            minRating = THREE;\\n        } else if (sumLength == TWELVE) {\\n            minRating = TWO;\\n        } else {\\n            minRating = ONE; // docs said little here.\\n        }\\n\\n        return minRating;\\n    }\\n\\n    /**\\n     * Determines if two names are homophonous via Match Rating Approach (MRA) algorithm. It should be noted that the\\n     * strings are cleaned in the same way as {@link #encode(String)}.\\n     *\\n     * @param name1\\n     *            First of the 2 strings (names) to compare\\n     * @param name2\\n     *            Second of the 2 names to compare\\n     * @return <code>true</code> if the encodings are identical <code>false</code> otherwise.\\n     */\\n    public boolean isEncodeEquals(String name1, String name2) {\\n        // Bulletproof for trivial input - NINO\\n        if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) {\\n            return false;\\n        } else if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) {\\n            return false;\\n        } else if (name1.length() == 1 || name2.length() == 1) {\\n            return false;\\n        } else if (name1.equalsIgnoreCase(name2)) {\\n            return true;\\n        }\\n\\n        // Preprocessing\\n        name1 = cleanName(name1);\\n        name2 = cleanName(name2);\\n\\n        // Actual MRA Algorithm\\n\\n        // 1. Remove vowels\\n        name1 = removeVowels(name1);\\n        name2 = removeVowels(name2);\\n\\n        // 2. Remove double consonants\\n        name1 = removeDoubleConsonants(name1);\\n        name2 = removeDoubleConsonants(name2);\\n\\n        // 3. Reduce down to 3 letters\\n        name1 = getFirst3Last3(name1);\\n        name2 = getFirst3Last3(name2);\\n\\n        // 4. Check for length difference - if 3 or greater then no similarity\\n        // comparison is done\\n        if (Math.abs(name1.length() - name2.length()) >= THREE) {\\n            return false;\\n        }\\n\\n        // 5. Obtain the minimum rating value by calculating the length sum of the\\n        // encoded Strings and sending it down.\\n        final int sumLength = Math.abs(name1.length() + name2.length());\\n        int minRating = 0;\\n        minRating = getMinRating(sumLength);\\n\\n        // 6. Process the encoded Strings from left to right and remove any\\n        // identical characters found from both Strings respectively.\\n        final int count = leftToRightThenRightToLeftProcessing(name1, name2);\\n\\n        // 7. Each PNI item that has a similarity rating equal to or greater than\\n        // the min is considered to be a good candidate match\\n        return count >= minRating;\\n\\n    }\\n\\n    /**\\n     * Determines if a letter is a vowel.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param letter\\n     *            The letter under investiagtion\\n     * @return True if a vowel, else false\\n     */\\n    boolean isVowel(final String letter) {\\n        return letter.equalsIgnoreCase(\\\"E\\\") || letter.equalsIgnoreCase(\\\"A\\\") || letter.equalsIgnoreCase(\\\"O\\\") ||\\n               letter.equalsIgnoreCase(\\\"I\\\") || letter.equalsIgnoreCase(\\\"U\\\");\\n    }\\n\\n    /**\\n     * Processes the names from left to right (first) then right to left removing identical letters in same positions.\\n     * Then subtracts the longer string that remains from 6 and returns this.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param name1\\n     *            name2\\n     * @return the length as above\\n     */\\n    int leftToRightThenRightToLeftProcessing(final String name1, final String name2) {\\n        final char[] name1Char = name1.toCharArray();\\n        final char[] name2Char = name2.toCharArray();\\n\\n        final int name1Size = name1.length() - 1;\\n        final int name2Size = name2.length() - 1;\\n\\n        String name1LtRStart = EMPTY;\\n        String name1LtREnd = EMPTY;\\n\\n        String name2RtLStart = EMPTY;\\n        String name2RtLEnd = EMPTY;\\n\\n        for (int i = 0; i < name1Char.length; i++) {\\n            if (i > name2Size) {\\n                break;\\n            }\\n\\n            name1LtRStart = name1.substring(i, i + 1);\\n            name1LtREnd = name1.substring(name1Size - i, name1Size - i + 1);\\n\\n            name2RtLStart = name2.substring(i, i + 1);\\n            name2RtLEnd = name2.substring(name2Size - i, name2Size - i + 1);\\n\\n            // Left to right...\\n            if (name1LtRStart.equals(name2RtLStart)) {\\n                name1Char[i] = ' ';\\n                name2Char[i] = ' ';\\n            }\\n\\n            // Right to left...\\n            if (name1LtREnd.equals(name2RtLEnd)) {\\n                name1Char[name1Size - i] = ' ';\\n                name2Char[name2Size - i] = ' ';\\n            }\\n        }\\n\\n        // Char arrays -> string & remove extraneous space\\n        final String strA = new String(name1Char).replaceAll(\\\"\\\\\\\\s+\\\", EMPTY);\\n        final String strB = new String(name2Char).replaceAll(\\\"\\\\\\\\s+\\\", EMPTY);\\n\\n        // Final bit - subtract longest string from 6 and return this int value\\n        if (strA.length() > strB.length()) {\\n            return Math.abs(SIX - strA.length());\\n        }\\n        return Math.abs(SIX - strB.length());\\n    }\\n\\n    /**\\n     * Removes accented letters and replaces with non-accented ascii equivalent Case is preserved.\\n     * http://www.codecodex.com/wiki/Remove_accent_from_letters_%28ex_.%C3%A9_to_e%29\\n     *\\n     * @param accentedWord\\n     *            The word that may have accents in it.\\n     * @return De-accented word\\n     */\\n    String removeAccents(final String accentedWord) {\\n        if (accentedWord == null) {\\n            return null;\\n        }\\n\\n        final StringBuilder sb = new StringBuilder();\\n        final int n = accentedWord.length();\\n\\n        for (int i = 0; i < n; i++) {\\n            final char c = accentedWord.charAt(i);\\n            final int pos = UNICODE.indexOf(c);\\n            if (pos > -1) {\\n                sb.append(PLAIN_ASCII.charAt(pos));\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    /**\\n     * Replaces any double consonant pair with the single letter equivalent.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param name\\n     *            String to have double consonants removed\\n     * @return Single consonant word\\n     */\\n    String removeDoubleConsonants(final String name) {\\n        String replacedName = name.toUpperCase(Locale.ENGLISH);\\n        for (final String dc : DOUBLE_CONSONANT) {\\n            if (replacedName.contains(dc)) {\\n                final String singleLetter = dc.substring(0, 1);\\n                replacedName = replacedName.replace(dc, singleLetter);\\n            }\\n        }\\n        return replacedName;\\n    }\\n\\n    /**\\n     * Deletes all vowels unless the vowel begins the word.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param name\\n     *            The name to have vowels removed\\n     * @return De-voweled word\\n     */\\n    String removeVowels(String name) {\\n        // Extract first letter\\n        final String firstLetter = name.substring(0, 1);\\n\\n        name = name.replaceAll(\\\"A\\\", EMPTY);\\n        name = name.replaceAll(\\\"E\\\", EMPTY);\\n        name = name.replaceAll(\\\"I\\\", EMPTY);\\n        name = name.replaceAll(\\\"O\\\", EMPTY);\\n        name = name.replaceAll(\\\"U\\\", EMPTY);\\n\\n        name = name.replaceAll(\\\"\\\\\\\\s{2,}\\\\\\\\b\\\", SPACE);\\n\\n        // return isVowel(firstLetter) ? (firstLetter + name) : name;\\n        if (isVowel(firstLetter)) {\\n            return firstLetter + name;\\n        }\\n        return name;\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"MatchRatingApproachEncoder\", \"position\": {\"start_line\": 32, \"end_line\": 423, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class MatchRatingApproachEncoder implements StringEncoder {\\n\\n    private static final String SPACE = \\\" \\\";\\n\\n    private static final String EMPTY = \\\"\\\";\\n\\n    /**\\n     * Constants used mainly for the min rating value.\\n     */\\n    private static final int ONE = 1, TWO = 2, THREE = 3, FOUR = 4, FIVE = 5, SIX = 6, SEVEN = 7,\\n                             ELEVEN = 11, TWELVE = 12;\\n\\n    /**\\n     * The plain letter equivalent of the accented letters.\\n     */\\n    private static final String PLAIN_ASCII = \\\"AaEeIiOoUu\\\" + // grave\\n            \\\"AaEeIiOoUuYy\\\" + // acute\\n            \\\"AaEeIiOoUuYy\\\" + // circumflex\\n            \\\"AaOoNn\\\" + // tilde\\n            \\\"AaEeIiOoUuYy\\\" + // umlaut\\n            \\\"Aa\\\" + // ring\\n            \\\"Cc\\\" + // cedilla\\n            \\\"OoUu\\\"; // double acute\\n\\n    /**\\n     * Unicode characters corresponding to various accented letters. For example: \\\\u00DA is U acute etc...\\n     */\\n    private static final String UNICODE = \\\"\\\\u00C0\\\\u00E0\\\\u00C8\\\\u00E8\\\\u00CC\\\\u00EC\\\\u00D2\\\\u00F2\\\\u00D9\\\\u00F9\\\" +\\n            \\\"\\\\u00C1\\\\u00E1\\\\u00C9\\\\u00E9\\\\u00CD\\\\u00ED\\\\u00D3\\\\u00F3\\\\u00DA\\\\u00FA\\\\u00DD\\\\u00FD\\\" +\\n            \\\"\\\\u00C2\\\\u00E2\\\\u00CA\\\\u00EA\\\\u00CE\\\\u00EE\\\\u00D4\\\\u00F4\\\\u00DB\\\\u00FB\\\\u0176\\\\u0177\\\" +\\n            \\\"\\\\u00C3\\\\u00E3\\\\u00D5\\\\u00F5\\\\u00D1\\\\u00F1\\\" +\\n            \\\"\\\\u00C4\\\\u00E4\\\\u00CB\\\\u00EB\\\\u00CF\\\\u00EF\\\\u00D6\\\\u00F6\\\\u00DC\\\\u00FC\\\\u0178\\\\u00FF\\\" +\\n            \\\"\\\\u00C5\\\\u00E5\\\" + \\\"\\\\u00C7\\\\u00E7\\\" + \\\"\\\\u0150\\\\u0151\\\\u0170\\\\u0171\\\";\\n\\n    private static final String[] DOUBLE_CONSONANT =\\n            new String[] { \\\"BB\\\", \\\"CC\\\", \\\"DD\\\", \\\"FF\\\", \\\"GG\\\", \\\"HH\\\", \\\"JJ\\\", \\\"KK\\\", \\\"LL\\\", \\\"MM\\\", \\\"NN\\\", \\\"PP\\\", \\\"QQ\\\", \\\"RR\\\", \\\"SS\\\",\\n                           \\\"TT\\\", \\\"VV\\\", \\\"WW\\\", \\\"XX\\\", \\\"YY\\\", \\\"ZZ\\\" };\\n\\n    /**\\n     * Cleans up a name: 1. Upper-cases everything 2. Removes some common punctuation 3. Removes accents 4. Removes any\\n     * spaces.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param name\\n     *            The name to be cleaned\\n     * @return The cleaned name\\n     */\\n    String cleanName(final String name) {\\n        String upperName = name.toUpperCase(Locale.ENGLISH);\\n\\n        final String[] charsToTrim = { \\\"\\\\\\\\-\\\", \\\"[&]\\\", \\\"\\\\\\\\'\\\", \\\"\\\\\\\\.\\\", \\\"[\\\\\\\\,]\\\" };\\n        for (final String str : charsToTrim) {\\n            upperName = upperName.replaceAll(str, EMPTY);\\n        }\\n\\n        upperName = removeAccents(upperName);\\n        upperName = upperName.replaceAll(\\\"\\\\\\\\s+\\\", EMPTY);\\n\\n        return upperName;\\n    }\\n\\n    /**\\n     * Encodes an Object using the Match Rating Approach algorithm. Method is here to satisfy the requirements of the\\n     * Encoder interface Throws an EncoderException if input object is not of type java.lang.String.\\n     *\\n     * @param pObject\\n     *            Object to encode\\n     * @return An object (or type java.lang.String) containing the Match Rating Approach code which corresponds to the\\n     *         String supplied.\\n     * @throws EncoderException\\n     *             if the parameter supplied is not of type java.lang.String\\n     */\\n    @Override\\n    public final Object encode(final Object pObject) throws EncoderException {\\n        if (!(pObject instanceof String)) {\\n            throw new EncoderException(\\n                    \\\"Parameter supplied to Match Rating Approach encoder is not of type java.lang.String\\\");\\n        }\\n        return encode((String) pObject);\\n    }\\n\\n    /**\\n     * Encodes a String using the Match Rating Approach (MRA) algorithm.\\n     *\\n     * @param name\\n     *            String object to encode\\n     * @return The MRA code corresponding to the String supplied\\n     */\\n    @Override\\n    public final String encode(String name) {\\n        // Bulletproof for trivial input - NINO\\n        if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) {\\n            return EMPTY;\\n        }\\n\\n        // Preprocessing\\n        name = cleanName(name);\\n\\n        // BEGIN: Actual encoding part of the algorithm...\\n        // 1. Delete all vowels unless the vowel begins the word\\n        name = removeVowels(name);\\n\\n        // 2. Remove second consonant from any double consonant\\n        name = removeDoubleConsonants(name);\\n\\n        // 3. Reduce codex to 6 letters by joining the first 3 and last 3 letters\\n        name = getFirst3Last3(name);\\n\\n        return name;\\n    }\\n\\n    /**\\n     * Gets the first and last 3 letters of a name (if &gt; 6 characters) Else just returns the name.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param name\\n     *            The string to get the substrings from\\n     * @return Annexed first and last 3 letters of input word.\\n     */\\n    String getFirst3Last3(final String name) {\\n        final int nameLength = name.length();\\n\\n        if (nameLength > SIX) {\\n            final String firstThree = name.substring(0, THREE);\\n            final String lastThree = name.substring(nameLength - THREE, nameLength);\\n            return firstThree + lastThree;\\n        }\\n        return name;\\n    }\\n\\n    /**\\n     * Obtains the min rating of the length sum of the 2 names. In essence the larger the sum length the smaller the\\n     * min rating. Values strictly from documentation.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param sumLength\\n     *            The length of 2 strings sent down\\n     * @return The min rating value\\n     */\\n    int getMinRating(final int sumLength) {\\n        int minRating = 0;\\n\\n        if (sumLength <= FOUR) {\\n            minRating = FIVE;\\n        } else if (sumLength <= SEVEN) { // aready know it is at least 5\\n            minRating = FOUR;\\n        } else if (sumLength <= ELEVEN) { // aready know it is at least 8\\n            minRating = THREE;\\n        } else if (sumLength == TWELVE) {\\n            minRating = TWO;\\n        } else {\\n            minRating = ONE; // docs said little here.\\n        }\\n\\n        return minRating;\\n    }\\n\\n    /**\\n     * Determines if two names are homophonous via Match Rating Approach (MRA) algorithm. It should be noted that the\\n     * strings are cleaned in the same way as {@link #encode(String)}.\\n     *\\n     * @param name1\\n     *            First of the 2 strings (names) to compare\\n     * @param name2\\n     *            Second of the 2 names to compare\\n     * @return <code>true</code> if the encodings are identical <code>false</code> otherwise.\\n     */\\n    public boolean isEncodeEquals(String name1, String name2) {\\n        // Bulletproof for trivial input - NINO\\n        if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) {\\n            return false;\\n        } else if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) {\\n            return false;\\n        } else if (name1.length() == 1 || name2.length() == 1) {\\n            return false;\\n        } else if (name1.equalsIgnoreCase(name2)) {\\n            return true;\\n        }\\n\\n        // Preprocessing\\n        name1 = cleanName(name1);\\n        name2 = cleanName(name2);\\n\\n        // Actual MRA Algorithm\\n\\n        // 1. Remove vowels\\n        name1 = removeVowels(name1);\\n        name2 = removeVowels(name2);\\n\\n        // 2. Remove double consonants\\n        name1 = removeDoubleConsonants(name1);\\n        name2 = removeDoubleConsonants(name2);\\n\\n        // 3. Reduce down to 3 letters\\n        name1 = getFirst3Last3(name1);\\n        name2 = getFirst3Last3(name2);\\n\\n        // 4. Check for length difference - if 3 or greater then no similarity\\n        // comparison is done\\n        if (Math.abs(name1.length() - name2.length()) >= THREE) {\\n            return false;\\n        }\\n\\n        // 5. Obtain the minimum rating value by calculating the length sum of the\\n        // encoded Strings and sending it down.\\n        final int sumLength = Math.abs(name1.length() + name2.length());\\n        int minRating = 0;\\n        minRating = getMinRating(sumLength);\\n\\n        // 6. Process the encoded Strings from left to right and remove any\\n        // identical characters found from both Strings respectively.\\n        final int count = leftToRightThenRightToLeftProcessing(name1, name2);\\n\\n        // 7. Each PNI item that has a similarity rating equal to or greater than\\n        // the min is considered to be a good candidate match\\n        return count >= minRating;\\n\\n    }\\n\\n    /**\\n     * Determines if a letter is a vowel.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param letter\\n     *            The letter under investiagtion\\n     * @return True if a vowel, else false\\n     */\\n    boolean isVowel(final String letter) {\\n        return letter.equalsIgnoreCase(\\\"E\\\") || letter.equalsIgnoreCase(\\\"A\\\") || letter.equalsIgnoreCase(\\\"O\\\") ||\\n               letter.equalsIgnoreCase(\\\"I\\\") || letter.equalsIgnoreCase(\\\"U\\\");\\n    }\\n\\n    /**\\n     * Processes the names from left to right (first) then right to left removing identical letters in same positions.\\n     * Then subtracts the longer string that remains from 6 and returns this.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param name1\\n     *            name2\\n     * @return the length as above\\n     */\\n    int leftToRightThenRightToLeftProcessing(final String name1, final String name2) {\\n        final char[] name1Char = name1.toCharArray();\\n        final char[] name2Char = name2.toCharArray();\\n\\n        final int name1Size = name1.length() - 1;\\n        final int name2Size = name2.length() - 1;\\n\\n        String name1LtRStart = EMPTY;\\n        String name1LtREnd = EMPTY;\\n\\n        String name2RtLStart = EMPTY;\\n        String name2RtLEnd = EMPTY;\\n\\n        for (int i = 0; i < name1Char.length; i++) {\\n            if (i > name2Size) {\\n                break;\\n            }\\n\\n            name1LtRStart = name1.substring(i, i + 1);\\n            name1LtREnd = name1.substring(name1Size - i, name1Size - i + 1);\\n\\n            name2RtLStart = name2.substring(i, i + 1);\\n            name2RtLEnd = name2.substring(name2Size - i, name2Size - i + 1);\\n\\n            // Left to right...\\n            if (name1LtRStart.equals(name2RtLStart)) {\\n                name1Char[i] = ' ';\\n                name2Char[i] = ' ';\\n            }\\n\\n            // Right to left...\\n            if (name1LtREnd.equals(name2RtLEnd)) {\\n                name1Char[name1Size - i] = ' ';\\n                name2Char[name2Size - i] = ' ';\\n            }\\n        }\\n\\n        // Char arrays -> string & remove extraneous space\\n        final String strA = new String(name1Char).replaceAll(\\\"\\\\\\\\s+\\\", EMPTY);\\n        final String strB = new String(name2Char).replaceAll(\\\"\\\\\\\\s+\\\", EMPTY);\\n\\n        // Final bit - subtract longest string from 6 and return this int value\\n        if (strA.length() > strB.length()) {\\n            return Math.abs(SIX - strA.length());\\n        }\\n        return Math.abs(SIX - strB.length());\\n    }\\n\\n    /**\\n     * Removes accented letters and replaces with non-accented ascii equivalent Case is preserved.\\n     * http://www.codecodex.com/wiki/Remove_accent_from_letters_%28ex_.%C3%A9_to_e%29\\n     *\\n     * @param accentedWord\\n     *            The word that may have accents in it.\\n     * @return De-accented word\\n     */\\n    String removeAccents(final String accentedWord) {\\n        if (accentedWord == null) {\\n            return null;\\n        }\\n\\n        final StringBuilder sb = new StringBuilder();\\n        final int n = accentedWord.length();\\n\\n        for (int i = 0; i < n; i++) {\\n            final char c = accentedWord.charAt(i);\\n            final int pos = UNICODE.indexOf(c);\\n            if (pos > -1) {\\n                sb.append(PLAIN_ASCII.charAt(pos));\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    /**\\n     * Replaces any double consonant pair with the single letter equivalent.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param name\\n     *            String to have double consonants removed\\n     * @return Single consonant word\\n     */\\n    String removeDoubleConsonants(final String name) {\\n        String replacedName = name.toUpperCase(Locale.ENGLISH);\\n        for (final String dc : DOUBLE_CONSONANT) {\\n            if (replacedName.contains(dc)) {\\n                final String singleLetter = dc.substring(0, 1);\\n                replacedName = replacedName.replace(dc, singleLetter);\\n            }\\n        }\\n        return replacedName;\\n    }\\n\\n    /**\\n     * Deletes all vowels unless the vowel begins the word.\\n     *\\n     * <h2>API Usage</h2>\\n     * <p>\\n     * Consider this method private, it is package protected for unit testing only.\\n     * </p>\\n     *\\n     * @param name\\n     *            The name to have vowels removed\\n     * @return De-voweled word\\n     */\\n    String removeVowels(String name) {\\n        // Extract first letter\\n        final String firstLetter = name.substring(0, 1);\\n\\n        name = name.replaceAll(\\\"A\\\", EMPTY);\\n        name = name.replaceAll(\\\"E\\\", EMPTY);\\n        name = name.replaceAll(\\\"I\\\", EMPTY);\\n        name = name.replaceAll(\\\"O\\\", EMPTY);\\n        name = name.replaceAll(\\\"U\\\", EMPTY);\\n\\n        name = name.replaceAll(\\\"\\\\\\\\s{2,}\\\\\\\\b\\\", SPACE);\\n\\n        // return isVowel(firstLetter) ? (firstLetter + name) : name;\\n        if (isVowel(firstLetter)) {\\n            return firstLetter + name;\\n        }\\n        return name;\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"cleanName\", \"return_type\": \"String\", \"position\": {\"start_line\": 83, \"end_line\": 95, \"start_column\": 5, \"end_column\": 5}, \"code\": \"String cleanName(final String name) {\\n        String upperName = name.toUpperCase(Locale.ENGLISH);\\n\\n        final String[] charsToTrim = { \\\"\\\\\\\\-\\\", \\\"[&]\\\", \\\"\\\\\\\\'\\\", \\\"\\\\\\\\.\\\", \\\"[\\\\\\\\,]\\\" };\\n        for (final String str : charsToTrim) {\\n            upperName = upperName.replaceAll(str, EMPTY);\\n        }\\n\\n        upperName = removeAccents(upperName);\\n        upperName = upperName.replaceAll(\\\"\\\\\\\\s+\\\", EMPTY);\\n\\n        return upperName;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"name\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 109, \"end_line\": 115, \"start_column\": 18, \"end_column\": 5}, \"code\": \"Object encode(final Object pObject) throws EncoderException {\\n        if (!(pObject instanceof String)) {\\n            throw new EncoderException(\\n                    \\\"Parameter supplied to Match Rating Approach encoder is not of type java.lang.String\\\");\\n        }\\n        return encode((String) pObject);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"pObject\", \"type\": \"Object\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 125, \"end_line\": 145, \"start_column\": 18, \"end_column\": 5}, \"code\": \"String encode(String name) {\\n        // Bulletproof for trivial input - NINO\\n        if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) {\\n            return EMPTY;\\n        }\\n\\n        // Preprocessing\\n        name = cleanName(name);\\n\\n        // BEGIN: Actual encoding part of the algorithm...\\n        // 1. Delete all vowels unless the vowel begins the word\\n        name = removeVowels(name);\\n\\n        // 2. Remove second consonant from any double consonant\\n        name = removeDoubleConsonants(name);\\n\\n        // 3. Reduce codex to 6 letters by joining the first 3 and last 3 letters\\n        name = getFirst3Last3(name);\\n\\n        return name;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"name\", \"type\": \"String\"}]}, {\"name\": \"getFirst3Last3\", \"return_type\": \"String\", \"position\": {\"start_line\": 159, \"end_line\": 168, \"start_column\": 5, \"end_column\": 5}, \"code\": \"String getFirst3Last3(final String name) {\\n        final int nameLength = name.length();\\n\\n        if (nameLength > SIX) {\\n            final String firstThree = name.substring(0, THREE);\\n            final String lastThree = name.substring(nameLength - THREE, nameLength);\\n            return firstThree + lastThree;\\n        }\\n        return name;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"name\", \"type\": \"String\"}]}, {\"name\": \"getMinRating\", \"return_type\": \"int\", \"position\": {\"start_line\": 183, \"end_line\": 199, \"start_column\": 5, \"end_column\": 5}, \"code\": \"int getMinRating(final int sumLength) {\\n        int minRating = 0;\\n\\n        if (sumLength <= FOUR) {\\n            minRating = FIVE;\\n        } else if (sumLength <= SEVEN) { // aready know it is at least 5\\n            minRating = FOUR;\\n        } else if (sumLength <= ELEVEN) { // aready know it is at least 8\\n            minRating = THREE;\\n        } else if (sumLength == TWELVE) {\\n            minRating = TWO;\\n        } else {\\n            minRating = ONE; // docs said little here.\\n        }\\n\\n        return minRating;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"sumLength\", \"type\": \"int\"}]}, {\"name\": \"isEncodeEquals\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 211, \"end_line\": 261, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isEncodeEquals(String name1, String name2) {\\n        // Bulletproof for trivial input - NINO\\n        if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) {\\n            return false;\\n        } else if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) {\\n            return false;\\n        } else if (name1.length() == 1 || name2.length() == 1) {\\n            return false;\\n        } else if (name1.equalsIgnoreCase(name2)) {\\n            return true;\\n        }\\n\\n        // Preprocessing\\n        name1 = cleanName(name1);\\n        name2 = cleanName(name2);\\n\\n        // Actual MRA Algorithm\\n\\n        // 1. Remove vowels\\n        name1 = removeVowels(name1);\\n        name2 = removeVowels(name2);\\n\\n        // 2. Remove double consonants\\n        name1 = removeDoubleConsonants(name1);\\n        name2 = removeDoubleConsonants(name2);\\n\\n        // 3. Reduce down to 3 letters\\n        name1 = getFirst3Last3(name1);\\n        name2 = getFirst3Last3(name2);\\n\\n        // 4. Check for length difference - if 3 or greater then no similarity\\n        // comparison is done\\n        if (Math.abs(name1.length() - name2.length()) >= THREE) {\\n            return false;\\n        }\\n\\n        // 5. Obtain the minimum rating value by calculating the length sum of the\\n        // encoded Strings and sending it down.\\n        final int sumLength = Math.abs(name1.length() + name2.length());\\n        int minRating = 0;\\n        minRating = getMinRating(sumLength);\\n\\n        // 6. Process the encoded Strings from left to right and remove any\\n        // identical characters found from both Strings respectively.\\n        final int count = leftToRightThenRightToLeftProcessing(name1, name2);\\n\\n        // 7. Each PNI item that has a similarity rating equal to or greater than\\n        // the min is considered to be a good candidate match\\n        return count >= minRating;\\n\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"name1\", \"type\": \"String\"}, {\"name\": \"name2\", \"type\": \"String\"}]}, {\"name\": \"isVowel\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 275, \"end_line\": 278, \"start_column\": 5, \"end_column\": 5}, \"code\": \"boolean isVowel(final String letter) {\\n        return letter.equalsIgnoreCase(\\\"E\\\") || letter.equalsIgnoreCase(\\\"A\\\") || letter.equalsIgnoreCase(\\\"O\\\") ||\\n               letter.equalsIgnoreCase(\\\"I\\\") || letter.equalsIgnoreCase(\\\"U\\\");\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"letter\", \"type\": \"String\"}]}, {\"name\": \"leftToRightThenRightToLeftProcessing\", \"return_type\": \"int\", \"position\": {\"start_line\": 293, \"end_line\": 339, \"start_column\": 5, \"end_column\": 5}, \"code\": \"int leftToRightThenRightToLeftProcessing(final String name1, final String name2) {\\n        final char[] name1Char = name1.toCharArray();\\n        final char[] name2Char = name2.toCharArray();\\n\\n        final int name1Size = name1.length() - 1;\\n        final int name2Size = name2.length() - 1;\\n\\n        String name1LtRStart = EMPTY;\\n        String name1LtREnd = EMPTY;\\n\\n        String name2RtLStart = EMPTY;\\n        String name2RtLEnd = EMPTY;\\n\\n        for (int i = 0; i < name1Char.length; i++) {\\n            if (i > name2Size) {\\n                break;\\n            }\\n\\n            name1LtRStart = name1.substring(i, i + 1);\\n            name1LtREnd = name1.substring(name1Size - i, name1Size - i + 1);\\n\\n            name2RtLStart = name2.substring(i, i + 1);\\n            name2RtLEnd = name2.substring(name2Size - i, name2Size - i + 1);\\n\\n            // Left to right...\\n            if (name1LtRStart.equals(name2RtLStart)) {\\n                name1Char[i] = ' ';\\n                name2Char[i] = ' ';\\n            }\\n\\n            // Right to left...\\n            if (name1LtREnd.equals(name2RtLEnd)) {\\n                name1Char[name1Size - i] = ' ';\\n                name2Char[name2Size - i] = ' ';\\n            }\\n        }\\n\\n        // Char arrays -> string & remove extraneous space\\n        final String strA = new String(name1Char).replaceAll(\\\"\\\\\\\\s+\\\", EMPTY);\\n        final String strB = new String(name2Char).replaceAll(\\\"\\\\\\\\s+\\\", EMPTY);\\n\\n        // Final bit - subtract longest string from 6 and return this int value\\n        if (strA.length() > strB.length()) {\\n            return Math.abs(SIX - strA.length());\\n        }\\n        return Math.abs(SIX - strB.length());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"name1\", \"type\": \"String\"}, {\"name\": \"name2\", \"type\": \"String\"}]}, {\"name\": \"removeAccents\", \"return_type\": \"String\", \"position\": {\"start_line\": 349, \"end_line\": 368, \"start_column\": 5, \"end_column\": 5}, \"code\": \"String removeAccents(final String accentedWord) {\\n        if (accentedWord == null) {\\n            return null;\\n        }\\n\\n        final StringBuilder sb = new StringBuilder();\\n        final int n = accentedWord.length();\\n\\n        for (int i = 0; i < n; i++) {\\n            final char c = accentedWord.charAt(i);\\n            final int pos = UNICODE.indexOf(c);\\n            if (pos > -1) {\\n                sb.append(PLAIN_ASCII.charAt(pos));\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"accentedWord\", \"type\": \"String\"}]}, {\"name\": \"removeDoubleConsonants\", \"return_type\": \"String\", \"position\": {\"start_line\": 382, \"end_line\": 391, \"start_column\": 5, \"end_column\": 5}, \"code\": \"String removeDoubleConsonants(final String name) {\\n        String replacedName = name.toUpperCase(Locale.ENGLISH);\\n        for (final String dc : DOUBLE_CONSONANT) {\\n            if (replacedName.contains(dc)) {\\n                final String singleLetter = dc.substring(0, 1);\\n                replacedName = replacedName.replace(dc, singleLetter);\\n            }\\n        }\\n        return replacedName;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"name\", \"type\": \"String\"}]}, {\"name\": \"removeVowels\", \"return_type\": \"String\", \"position\": {\"start_line\": 405, \"end_line\": 422, \"start_column\": 5, \"end_column\": 5}, \"code\": \"String removeVowels(String name) {\\n        // Extract first letter\\n        final String firstLetter = name.substring(0, 1);\\n\\n        name = name.replaceAll(\\\"A\\\", EMPTY);\\n        name = name.replaceAll(\\\"E\\\", EMPTY);\\n        name = name.replaceAll(\\\"I\\\", EMPTY);\\n        name = name.replaceAll(\\\"O\\\", EMPTY);\\n        name = name.replaceAll(\\\"U\\\", EMPTY);\\n\\n        name = name.replaceAll(\\\"\\\\\\\\s{2,}\\\\\\\\b\\\", SPACE);\\n\\n        // return isVowel(firstLetter) ? (firstLetter + name) : name;\\n        if (isVowel(firstLetter)) {\\n            return firstLetter + name;\\n        }\\n        return name;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"name\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/Metaphone.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language;\\n\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringEncoder;\\n\\n/**\\n * Encodes a string into a Metaphone value.\\n * <p>\\n * Initial Java implementation by <CITE>William B. Brogden. December, 1997</CITE>.\\n * Permission given by <CITE>wbrogden</CITE> for code to be used anywhere.\\n * <p>\\n * <CITE>Hanging on the Metaphone</CITE> by <CITE>Lawrence Philips</CITE> in <CITE>Computer Language of Dec. 1990,\\n * p 39.</CITE>\\n * <p>\\n * Note, that this does not match the algorithm that ships with PHP, or the algorithm found in the Perl implementations:\\n * </p>\\n * <ul>\\n * <li><a href=\\\"http://search.cpan.org/~mschwern/Text-Metaphone-1.96/Metaphone.pm\\\">Text:Metaphone-1.96</a>\\n *  (broken link 4/30/2013) </li>\\n * <li><a href=\\\"https://metacpan.org/source/MSCHWERN/Text-Metaphone-1.96//Metaphone.pm\\\">Text:Metaphone-1.96</a>\\n *  (link checked 4/30/2013) </li>\\n * </ul>\\n * <p>\\n * They have had undocumented changes from the originally published algorithm.\\n * For more information, see <a href=\\\"https://issues.apache.org/jira/browse/CODEC-57\\\">CODEC-57</a>.\\n * <p>\\n * This class is conditionally thread-safe.\\n * The instance field {@link #maxCodeLen} is mutable {@link #setMaxCodeLen(int)}\\n * but is not volatile, and accesses are not synchronized.\\n * If an instance of the class is shared between threads, the caller needs to ensure that suitable synchronization\\n * is used to ensure safe publication of the value between threads, and must not invoke {@link #setMaxCodeLen(int)}\\n * after initial setup.\\n *\\n * @version $Id: Metaphone.java 1619948 2014-08-22 22:53:55Z ggregory $\\n */\\npublic class Metaphone implements StringEncoder {\\n\\n    /**\\n     * Five values in the English language\\n     */\\n    private static final String VOWELS = \\\"AEIOU\\\";\\n\\n    /**\\n     * Variable used in Metaphone algorithm\\n     */\\n    private static final String FRONTV = \\\"EIY\\\";\\n\\n    /**\\n     * Variable used in Metaphone algorithm\\n     */\\n    private static final String VARSON = \\\"CSPTG\\\";\\n\\n    /**\\n     * The max code length for metaphone is 4\\n     */\\n    private int maxCodeLen = 4;\\n\\n    /**\\n     * Creates an instance of the Metaphone encoder\\n     */\\n    public Metaphone() {\\n        super();\\n    }\\n\\n    /**\\n     * Find the metaphone value of a String. This is similar to the\\n     * soundex algorithm, but better at finding similar sounding words.\\n     * All input is converted to upper case.\\n     * Limitations: Input format is expected to be a single ASCII word\\n     * with only characters in the A - Z range, no punctuation or numbers.\\n     *\\n     * @param txt String to find the metaphone code for\\n     * @return A metaphone code corresponding to the String supplied\\n     */\\n    public String metaphone(final String txt) {\\n        boolean hard = false;\\n        int txtLength;\\n        if (txt == null || (txtLength = txt.length()) == 0) {\\n            return \\\"\\\";\\n        }\\n        // single character is itself\\n        if (txtLength == 1) {\\n            return txt.toUpperCase(java.util.Locale.ENGLISH);\\n        }\\n\\n        final char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\\n\\n        final StringBuilder local = new StringBuilder(40); // manipulate\\n        final StringBuilder code = new StringBuilder(10); //   output\\n        // handle initial 2 characters exceptions\\n        switch(inwd[0]) {\\n        case 'K':\\n        case 'G':\\n        case 'P': /* looking for KN, etc*/\\n            if (inwd[1] == 'N') {\\n                local.append(inwd, 1, inwd.length - 1);\\n            } else {\\n                local.append(inwd);\\n            }\\n            break;\\n        case 'A': /* looking for AE */\\n            if (inwd[1] == 'E') {\\n                local.append(inwd, 1, inwd.length - 1);\\n            } else {\\n                local.append(inwd);\\n            }\\n            break;\\n        case 'W': /* looking for WR or WH */\\n            if (inwd[1] == 'R') {   // WR -> R\\n                local.append(inwd, 1, inwd.length - 1);\\n                break;\\n            }\\n            if (inwd[1] == 'H') {\\n                local.append(inwd, 1, inwd.length - 1);\\n                local.setCharAt(0, 'W'); // WH -> W\\n            } else {\\n                local.append(inwd);\\n            }\\n            break;\\n        case 'X': /* initial X becomes S */\\n            inwd[0] = 'S';\\n            local.append(inwd);\\n            break;\\n        default:\\n            local.append(inwd);\\n        } // now local has working string with initials fixed\\n\\n        final int wdsz = local.length();\\n        int n = 0;\\n\\n        while (code.length() < this.getMaxCodeLen() &&\\n               n < wdsz ) { // max code size of 4 works well\\n            final char symb = local.charAt(n);\\n            // remove duplicate letters except C\\n            if (symb != 'C' && isPreviousChar( local, n, symb ) ) {\\n                n++;\\n            } else { // not dup\\n                switch(symb) {\\n                case 'A':\\n                case 'E':\\n                case 'I':\\n                case 'O':\\n                case 'U':\\n                    if (n == 0) {\\n                        code.append(symb);\\n                    }\\n                    break; // only use vowel if leading char\\n                case 'B':\\n                    if ( isPreviousChar(local, n, 'M') &&\\n                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB\\n                        break;\\n                    }\\n                    code.append(symb);\\n                    break;\\n                case 'C': // lots of C special cases\\n                    /* discard if SCI, SCE or SCY */\\n                    if ( isPreviousChar(local, n, 'S') &&\\n                         !isLastChar(wdsz, n) &&\\n                         FRONTV.indexOf(local.charAt(n + 1)) >= 0 ) {\\n                        break;\\n                    }\\n                    if (regionMatch(local, n, \\\"CIA\\\")) { // \\\"CIA\\\" -> X\\n                        code.append('X');\\n                        break;\\n                    }\\n                    if (!isLastChar(wdsz, n) &&\\n                        FRONTV.indexOf(local.charAt(n + 1)) >= 0) {\\n                        code.append('S');\\n                        break; // CI,CE,CY -> S\\n                    }\\n                    if (isPreviousChar(local, n, 'S') &&\\n                        isNextChar(local, n, 'H') ) { // SCH->sk\\n                        code.append('K');\\n                        break;\\n                    }\\n                    if (isNextChar(local, n, 'H')) { // detect CH\\n                        if (n == 0 &&\\n                            wdsz >= 3 &&\\n                            isVowel(local,2) ) { // CH consonant -> K consonant\\n                            code.append('K');\\n                        } else {\\n                            code.append('X'); // CHvowel -> X\\n                        }\\n                    } else {\\n                        code.append('K');\\n                    }\\n                    break;\\n                case 'D':\\n                    if (!isLastChar(wdsz, n + 1) &&\\n                        isNextChar(local, n, 'G') &&\\n                        FRONTV.indexOf(local.charAt(n + 2)) >= 0) { // DGE DGI DGY -> J\\n                        code.append('J'); n += 2;\\n                    } else {\\n                        code.append('T');\\n                    }\\n                    break;\\n                case 'G': // GH silent at end or before consonant\\n                    if (isLastChar(wdsz, n + 1) &&\\n                        isNextChar(local, n, 'H')) {\\n                        break;\\n                    }\\n                    if (!isLastChar(wdsz, n + 1) &&\\n                        isNextChar(local,n,'H') &&\\n                        !isVowel(local,n+2)) {\\n                        break;\\n                    }\\n                    if (n > 0 &&\\n                        ( regionMatch(local, n, \\\"GN\\\") ||\\n                          regionMatch(local, n, \\\"GNED\\\") ) ) {\\n                        break; // silent G\\n                    }\\n                    if (isPreviousChar(local, n, 'G')) {\\n                        // NOTE: Given that duplicated chars are removed, I don't see how this can ever be true\\n                        hard = true;\\n                    } else {\\n                        hard = false;\\n                    }\\n                    if (!isLastChar(wdsz, n) &&\\n                        FRONTV.indexOf(local.charAt(n + 1)) >= 0 &&\\n                        !hard) {\\n                        code.append('J');\\n                    } else {\\n                        code.append('K');\\n                    }\\n                    break;\\n                case 'H':\\n                    if (isLastChar(wdsz, n)) {\\n                        break; // terminal H\\n                    }\\n                    if (n > 0 &&\\n                        VARSON.indexOf(local.charAt(n - 1)) >= 0) {\\n                        break;\\n                    }\\n                    if (isVowel(local,n+1)) {\\n                        code.append('H'); // Hvowel\\n                    }\\n                    break;\\n                case 'F':\\n                case 'J':\\n                case 'L':\\n                case 'M':\\n                case 'N':\\n                case 'R':\\n                    code.append(symb);\\n                    break;\\n                case 'K':\\n                    if (n > 0) { // not initial\\n                        if (!isPreviousChar(local, n, 'C')) {\\n                            code.append(symb);\\n                        }\\n                    } else {\\n                        code.append(symb); // initial K\\n                    }\\n                    break;\\n                case 'P':\\n                    if (isNextChar(local,n,'H')) {\\n                        // PH -> F\\n                        code.append('F');\\n                    } else {\\n                        code.append(symb);\\n                    }\\n                    break;\\n                case 'Q':\\n                    code.append('K');\\n                    break;\\n                case 'S':\\n                    if (regionMatch(local,n,\\\"SH\\\") ||\\n                        regionMatch(local,n,\\\"SIO\\\") ||\\n                        regionMatch(local,n,\\\"SIA\\\")) {\\n                        code.append('X');\\n                    } else {\\n                        code.append('S');\\n                    }\\n                    break;\\n                case 'T':\\n                    if (regionMatch(local,n,\\\"TIA\\\") ||\\n                        regionMatch(local,n,\\\"TIO\\\")) {\\n                        code.append('X');\\n                        break;\\n                    }\\n                    if (regionMatch(local,n,\\\"TCH\\\")) {\\n                        // Silent if in \\\"TCH\\\"\\n                        break;\\n                    }\\n                    // substitute numeral 0 for TH (resembles theta after all)\\n                    if (regionMatch(local,n,\\\"TH\\\")) {\\n                        code.append('0');\\n                    } else {\\n                        code.append('T');\\n                    }\\n                    break;\\n                case 'V':\\n                    code.append('F'); break;\\n                case 'W':\\n                case 'Y': // silent if not followed by vowel\\n                    if (!isLastChar(wdsz,n) &&\\n                        isVowel(local,n+1)) {\\n                        code.append(symb);\\n                    }\\n                    break;\\n                case 'X':\\n                    code.append('K');\\n                    code.append('S');\\n                    break;\\n                case 'Z':\\n                    code.append('S');\\n                    break;\\n                default:\\n                    // do nothing\\n                    break;\\n                } // end switch\\n                n++;\\n            } // end else from symb != 'C'\\n            if (code.length() > this.getMaxCodeLen()) {\\n                code.setLength(this.getMaxCodeLen());\\n            }\\n        }\\n        return code.toString();\\n    }\\n\\n    private boolean isVowel(final StringBuilder string, final int index) {\\n        return VOWELS.indexOf(string.charAt(index)) >= 0;\\n    }\\n\\n    private boolean isPreviousChar(final StringBuilder string, final int index, final char c) {\\n        boolean matches = false;\\n        if( index > 0 &&\\n            index < string.length() ) {\\n            matches = string.charAt(index - 1) == c;\\n        }\\n        return matches;\\n    }\\n\\n    private boolean isNextChar(final StringBuilder string, final int index, final char c) {\\n        boolean matches = false;\\n        if( index >= 0 &&\\n            index < string.length() - 1 ) {\\n            matches = string.charAt(index + 1) == c;\\n        }\\n        return matches;\\n    }\\n\\n    private boolean regionMatch(final StringBuilder string, final int index, final String test) {\\n        boolean matches = false;\\n        if( index >= 0 &&\\n            index + test.length() - 1 < string.length() ) {\\n            final String substring = string.substring( index, index + test.length());\\n            matches = substring.equals( test );\\n        }\\n        return matches;\\n    }\\n\\n    private boolean isLastChar(final int wdsz, final int n) {\\n        return n + 1 == wdsz;\\n    }\\n\\n\\n    /**\\n     * Encodes an Object using the metaphone algorithm.  This method\\n     * is provided in order to satisfy the requirements of the\\n     * Encoder interface, and will throw an EncoderException if the\\n     * supplied object is not of type java.lang.String.\\n     *\\n     * @param obj Object to encode\\n     * @return An object (or type java.lang.String) containing the\\n     *         metaphone code which corresponds to the String supplied.\\n     * @throws EncoderException if the parameter supplied is not\\n     *                          of type java.lang.String\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Metaphone encode is not of type java.lang.String\\\");\\n        }\\n        return metaphone((String) obj);\\n    }\\n\\n    /**\\n     * Encodes a String using the Metaphone algorithm.\\n     *\\n     * @param str String object to encode\\n     * @return The metaphone code corresponding to the String supplied\\n     */\\n    @Override\\n    public String encode(final String str) {\\n        return metaphone(str);\\n    }\\n\\n    /**\\n     * Tests is the metaphones of two strings are identical.\\n     *\\n     * @param str1 First of two strings to compare\\n     * @param str2 Second of two strings to compare\\n     * @return <code>true</code> if the metaphones of these strings are identical,\\n     *        <code>false</code> otherwise.\\n     */\\n    public boolean isMetaphoneEqual(final String str1, final String str2) {\\n        return metaphone(str1).equals(metaphone(str2));\\n    }\\n\\n    /**\\n     * Returns the maxCodeLen.\\n     * @return int\\n     */\\n    public int getMaxCodeLen() { return this.maxCodeLen; }\\n\\n    /**\\n     * Sets the maxCodeLen.\\n     * @param maxCodeLen The maxCodeLen to set\\n     */\\n    public void setMaxCodeLen(final int maxCodeLen) { this.maxCodeLen = maxCodeLen; }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Metaphone\", \"position\": {\"start_line\": 53, \"end_line\": 430, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Metaphone implements StringEncoder {\\n\\n    /**\\n     * Five values in the English language\\n     */\\n    private static final String VOWELS = \\\"AEIOU\\\";\\n\\n    /**\\n     * Variable used in Metaphone algorithm\\n     */\\n    private static final String FRONTV = \\\"EIY\\\";\\n\\n    /**\\n     * Variable used in Metaphone algorithm\\n     */\\n    private static final String VARSON = \\\"CSPTG\\\";\\n\\n    /**\\n     * The max code length for metaphone is 4\\n     */\\n    private int maxCodeLen = 4;\\n\\n    /**\\n     * Creates an instance of the Metaphone encoder\\n     */\\n    public Metaphone() {\\n        super();\\n    }\\n\\n    /**\\n     * Find the metaphone value of a String. This is similar to the\\n     * soundex algorithm, but better at finding similar sounding words.\\n     * All input is converted to upper case.\\n     * Limitations: Input format is expected to be a single ASCII word\\n     * with only characters in the A - Z range, no punctuation or numbers.\\n     *\\n     * @param txt String to find the metaphone code for\\n     * @return A metaphone code corresponding to the String supplied\\n     */\\n    public String metaphone(final String txt) {\\n        boolean hard = false;\\n        int txtLength;\\n        if (txt == null || (txtLength = txt.length()) == 0) {\\n            return \\\"\\\";\\n        }\\n        // single character is itself\\n        if (txtLength == 1) {\\n            return txt.toUpperCase(java.util.Locale.ENGLISH);\\n        }\\n\\n        final char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\\n\\n        final StringBuilder local = new StringBuilder(40); // manipulate\\n        final StringBuilder code = new StringBuilder(10); //   output\\n        // handle initial 2 characters exceptions\\n        switch(inwd[0]) {\\n        case 'K':\\n        case 'G':\\n        case 'P': /* looking for KN, etc*/\\n            if (inwd[1] == 'N') {\\n                local.append(inwd, 1, inwd.length - 1);\\n            } else {\\n                local.append(inwd);\\n            }\\n            break;\\n        case 'A': /* looking for AE */\\n            if (inwd[1] == 'E') {\\n                local.append(inwd, 1, inwd.length - 1);\\n            } else {\\n                local.append(inwd);\\n            }\\n            break;\\n        case 'W': /* looking for WR or WH */\\n            if (inwd[1] == 'R') {   // WR -> R\\n                local.append(inwd, 1, inwd.length - 1);\\n                break;\\n            }\\n            if (inwd[1] == 'H') {\\n                local.append(inwd, 1, inwd.length - 1);\\n                local.setCharAt(0, 'W'); // WH -> W\\n            } else {\\n                local.append(inwd);\\n            }\\n            break;\\n        case 'X': /* initial X becomes S */\\n            inwd[0] = 'S';\\n            local.append(inwd);\\n            break;\\n        default:\\n            local.append(inwd);\\n        } // now local has working string with initials fixed\\n\\n        final int wdsz = local.length();\\n        int n = 0;\\n\\n        while (code.length() < this.getMaxCodeLen() &&\\n               n < wdsz ) { // max code size of 4 works well\\n            final char symb = local.charAt(n);\\n            // remove duplicate letters except C\\n            if (symb != 'C' && isPreviousChar( local, n, symb ) ) {\\n                n++;\\n            } else { // not dup\\n                switch(symb) {\\n                case 'A':\\n                case 'E':\\n                case 'I':\\n                case 'O':\\n                case 'U':\\n                    if (n == 0) {\\n                        code.append(symb);\\n                    }\\n                    break; // only use vowel if leading char\\n                case 'B':\\n                    if ( isPreviousChar(local, n, 'M') &&\\n                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB\\n                        break;\\n                    }\\n                    code.append(symb);\\n                    break;\\n                case 'C': // lots of C special cases\\n                    /* discard if SCI, SCE or SCY */\\n                    if ( isPreviousChar(local, n, 'S') &&\\n                         !isLastChar(wdsz, n) &&\\n                         FRONTV.indexOf(local.charAt(n + 1)) >= 0 ) {\\n                        break;\\n                    }\\n                    if (regionMatch(local, n, \\\"CIA\\\")) { // \\\"CIA\\\" -> X\\n                        code.append('X');\\n                        break;\\n                    }\\n                    if (!isLastChar(wdsz, n) &&\\n                        FRONTV.indexOf(local.charAt(n + 1)) >= 0) {\\n                        code.append('S');\\n                        break; // CI,CE,CY -> S\\n                    }\\n                    if (isPreviousChar(local, n, 'S') &&\\n                        isNextChar(local, n, 'H') ) { // SCH->sk\\n                        code.append('K');\\n                        break;\\n                    }\\n                    if (isNextChar(local, n, 'H')) { // detect CH\\n                        if (n == 0 &&\\n                            wdsz >= 3 &&\\n                            isVowel(local,2) ) { // CH consonant -> K consonant\\n                            code.append('K');\\n                        } else {\\n                            code.append('X'); // CHvowel -> X\\n                        }\\n                    } else {\\n                        code.append('K');\\n                    }\\n                    break;\\n                case 'D':\\n                    if (!isLastChar(wdsz, n + 1) &&\\n                        isNextChar(local, n, 'G') &&\\n                        FRONTV.indexOf(local.charAt(n + 2)) >= 0) { // DGE DGI DGY -> J\\n                        code.append('J'); n += 2;\\n                    } else {\\n                        code.append('T');\\n                    }\\n                    break;\\n                case 'G': // GH silent at end or before consonant\\n                    if (isLastChar(wdsz, n + 1) &&\\n                        isNextChar(local, n, 'H')) {\\n                        break;\\n                    }\\n                    if (!isLastChar(wdsz, n + 1) &&\\n                        isNextChar(local,n,'H') &&\\n                        !isVowel(local,n+2)) {\\n                        break;\\n                    }\\n                    if (n > 0 &&\\n                        ( regionMatch(local, n, \\\"GN\\\") ||\\n                          regionMatch(local, n, \\\"GNED\\\") ) ) {\\n                        break; // silent G\\n                    }\\n                    if (isPreviousChar(local, n, 'G')) {\\n                        // NOTE: Given that duplicated chars are removed, I don't see how this can ever be true\\n                        hard = true;\\n                    } else {\\n                        hard = false;\\n                    }\\n                    if (!isLastChar(wdsz, n) &&\\n                        FRONTV.indexOf(local.charAt(n + 1)) >= 0 &&\\n                        !hard) {\\n                        code.append('J');\\n                    } else {\\n                        code.append('K');\\n                    }\\n                    break;\\n                case 'H':\\n                    if (isLastChar(wdsz, n)) {\\n                        break; // terminal H\\n                    }\\n                    if (n > 0 &&\\n                        VARSON.indexOf(local.charAt(n - 1)) >= 0) {\\n                        break;\\n                    }\\n                    if (isVowel(local,n+1)) {\\n                        code.append('H'); // Hvowel\\n                    }\\n                    break;\\n                case 'F':\\n                case 'J':\\n                case 'L':\\n                case 'M':\\n                case 'N':\\n                case 'R':\\n                    code.append(symb);\\n                    break;\\n                case 'K':\\n                    if (n > 0) { // not initial\\n                        if (!isPreviousChar(local, n, 'C')) {\\n                            code.append(symb);\\n                        }\\n                    } else {\\n                        code.append(symb); // initial K\\n                    }\\n                    break;\\n                case 'P':\\n                    if (isNextChar(local,n,'H')) {\\n                        // PH -> F\\n                        code.append('F');\\n                    } else {\\n                        code.append(symb);\\n                    }\\n                    break;\\n                case 'Q':\\n                    code.append('K');\\n                    break;\\n                case 'S':\\n                    if (regionMatch(local,n,\\\"SH\\\") ||\\n                        regionMatch(local,n,\\\"SIO\\\") ||\\n                        regionMatch(local,n,\\\"SIA\\\")) {\\n                        code.append('X');\\n                    } else {\\n                        code.append('S');\\n                    }\\n                    break;\\n                case 'T':\\n                    if (regionMatch(local,n,\\\"TIA\\\") ||\\n                        regionMatch(local,n,\\\"TIO\\\")) {\\n                        code.append('X');\\n                        break;\\n                    }\\n                    if (regionMatch(local,n,\\\"TCH\\\")) {\\n                        // Silent if in \\\"TCH\\\"\\n                        break;\\n                    }\\n                    // substitute numeral 0 for TH (resembles theta after all)\\n                    if (regionMatch(local,n,\\\"TH\\\")) {\\n                        code.append('0');\\n                    } else {\\n                        code.append('T');\\n                    }\\n                    break;\\n                case 'V':\\n                    code.append('F'); break;\\n                case 'W':\\n                case 'Y': // silent if not followed by vowel\\n                    if (!isLastChar(wdsz,n) &&\\n                        isVowel(local,n+1)) {\\n                        code.append(symb);\\n                    }\\n                    break;\\n                case 'X':\\n                    code.append('K');\\n                    code.append('S');\\n                    break;\\n                case 'Z':\\n                    code.append('S');\\n                    break;\\n                default:\\n                    // do nothing\\n                    break;\\n                } // end switch\\n                n++;\\n            } // end else from symb != 'C'\\n            if (code.length() > this.getMaxCodeLen()) {\\n                code.setLength(this.getMaxCodeLen());\\n            }\\n        }\\n        return code.toString();\\n    }\\n\\n    private boolean isVowel(final StringBuilder string, final int index) {\\n        return VOWELS.indexOf(string.charAt(index)) >= 0;\\n    }\\n\\n    private boolean isPreviousChar(final StringBuilder string, final int index, final char c) {\\n        boolean matches = false;\\n        if( index > 0 &&\\n            index < string.length() ) {\\n            matches = string.charAt(index - 1) == c;\\n        }\\n        return matches;\\n    }\\n\\n    private boolean isNextChar(final StringBuilder string, final int index, final char c) {\\n        boolean matches = false;\\n        if( index >= 0 &&\\n            index < string.length() - 1 ) {\\n            matches = string.charAt(index + 1) == c;\\n        }\\n        return matches;\\n    }\\n\\n    private boolean regionMatch(final StringBuilder string, final int index, final String test) {\\n        boolean matches = false;\\n        if( index >= 0 &&\\n            index + test.length() - 1 < string.length() ) {\\n            final String substring = string.substring( index, index + test.length());\\n            matches = substring.equals( test );\\n        }\\n        return matches;\\n    }\\n\\n    private boolean isLastChar(final int wdsz, final int n) {\\n        return n + 1 == wdsz;\\n    }\\n\\n\\n    /**\\n     * Encodes an Object using the metaphone algorithm.  This method\\n     * is provided in order to satisfy the requirements of the\\n     * Encoder interface, and will throw an EncoderException if the\\n     * supplied object is not of type java.lang.String.\\n     *\\n     * @param obj Object to encode\\n     * @return An object (or type java.lang.String) containing the\\n     *         metaphone code which corresponds to the String supplied.\\n     * @throws EncoderException if the parameter supplied is not\\n     *                          of type java.lang.String\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Metaphone encode is not of type java.lang.String\\\");\\n        }\\n        return metaphone((String) obj);\\n    }\\n\\n    /**\\n     * Encodes a String using the Metaphone algorithm.\\n     *\\n     * @param str String object to encode\\n     * @return The metaphone code corresponding to the String supplied\\n     */\\n    @Override\\n    public String encode(final String str) {\\n        return metaphone(str);\\n    }\\n\\n    /**\\n     * Tests is the metaphones of two strings are identical.\\n     *\\n     * @param str1 First of two strings to compare\\n     * @param str2 Second of two strings to compare\\n     * @return <code>true</code> if the metaphones of these strings are identical,\\n     *        <code>false</code> otherwise.\\n     */\\n    public boolean isMetaphoneEqual(final String str1, final String str2) {\\n        return metaphone(str1).equals(metaphone(str2));\\n    }\\n\\n    /**\\n     * Returns the maxCodeLen.\\n     * @return int\\n     */\\n    public int getMaxCodeLen() { return this.maxCodeLen; }\\n\\n    /**\\n     * Sets the maxCodeLen.\\n     * @param maxCodeLen The maxCodeLen to set\\n     */\\n    public void setMaxCodeLen(final int maxCodeLen) { this.maxCodeLen = maxCodeLen; }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"metaphone\", \"return_type\": \"String\", \"position\": {\"start_line\": 92, \"end_line\": 336, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String metaphone(final String txt) {\\n        boolean hard = false;\\n        int txtLength;\\n        if (txt == null || (txtLength = txt.length()) == 0) {\\n            return \\\"\\\";\\n        }\\n        // single character is itself\\n        if (txtLength == 1) {\\n            return txt.toUpperCase(java.util.Locale.ENGLISH);\\n        }\\n\\n        final char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\\n\\n        final StringBuilder local = new StringBuilder(40); // manipulate\\n        final StringBuilder code = new StringBuilder(10); //   output\\n        // handle initial 2 characters exceptions\\n        switch(inwd[0]) {\\n        case 'K':\\n        case 'G':\\n        case 'P': /* looking for KN, etc*/\\n            if (inwd[1] == 'N') {\\n                local.append(inwd, 1, inwd.length - 1);\\n            } else {\\n                local.append(inwd);\\n            }\\n            break;\\n        case 'A': /* looking for AE */\\n            if (inwd[1] == 'E') {\\n                local.append(inwd, 1, inwd.length - 1);\\n            } else {\\n                local.append(inwd);\\n            }\\n            break;\\n        case 'W': /* looking for WR or WH */\\n            if (inwd[1] == 'R') {   // WR -> R\\n                local.append(inwd, 1, inwd.length - 1);\\n                break;\\n            }\\n            if (inwd[1] == 'H') {\\n                local.append(inwd, 1, inwd.length - 1);\\n                local.setCharAt(0, 'W'); // WH -> W\\n            } else {\\n                local.append(inwd);\\n            }\\n            break;\\n        case 'X': /* initial X becomes S */\\n            inwd[0] = 'S';\\n            local.append(inwd);\\n            break;\\n        default:\\n            local.append(inwd);\\n        } // now local has working string with initials fixed\\n\\n        final int wdsz = local.length();\\n        int n = 0;\\n\\n        while (code.length() < this.getMaxCodeLen() &&\\n               n < wdsz ) { // max code size of 4 works well\\n            final char symb = local.charAt(n);\\n            // remove duplicate letters except C\\n            if (symb != 'C' && isPreviousChar( local, n, symb ) ) {\\n                n++;\\n            } else { // not dup\\n                switch(symb) {\\n                case 'A':\\n                case 'E':\\n                case 'I':\\n                case 'O':\\n                case 'U':\\n                    if (n == 0) {\\n                        code.append(symb);\\n                    }\\n                    break; // only use vowel if leading char\\n                case 'B':\\n                    if ( isPreviousChar(local, n, 'M') &&\\n                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB\\n                        break;\\n                    }\\n                    code.append(symb);\\n                    break;\\n                case 'C': // lots of C special cases\\n                    /* discard if SCI, SCE or SCY */\\n                    if ( isPreviousChar(local, n, 'S') &&\\n                         !isLastChar(wdsz, n) &&\\n                         FRONTV.indexOf(local.charAt(n + 1)) >= 0 ) {\\n                        break;\\n                    }\\n                    if (regionMatch(local, n, \\\"CIA\\\")) { // \\\"CIA\\\" -> X\\n                        code.append('X');\\n                        break;\\n                    }\\n                    if (!isLastChar(wdsz, n) &&\\n                        FRONTV.indexOf(local.charAt(n + 1)) >= 0) {\\n                        code.append('S');\\n                        break; // CI,CE,CY -> S\\n                    }\\n                    if (isPreviousChar(local, n, 'S') &&\\n                        isNextChar(local, n, 'H') ) { // SCH->sk\\n                        code.append('K');\\n                        break;\\n                    }\\n                    if (isNextChar(local, n, 'H')) { // detect CH\\n                        if (n == 0 &&\\n                            wdsz >= 3 &&\\n                            isVowel(local,2) ) { // CH consonant -> K consonant\\n                            code.append('K');\\n                        } else {\\n                            code.append('X'); // CHvowel -> X\\n                        }\\n                    } else {\\n                        code.append('K');\\n                    }\\n                    break;\\n                case 'D':\\n                    if (!isLastChar(wdsz, n + 1) &&\\n                        isNextChar(local, n, 'G') &&\\n                        FRONTV.indexOf(local.charAt(n + 2)) >= 0) { // DGE DGI DGY -> J\\n                        code.append('J'); n += 2;\\n                    } else {\\n                        code.append('T');\\n                    }\\n                    break;\\n                case 'G': // GH silent at end or before consonant\\n                    if (isLastChar(wdsz, n + 1) &&\\n                        isNextChar(local, n, 'H')) {\\n                        break;\\n                    }\\n                    if (!isLastChar(wdsz, n + 1) &&\\n                        isNextChar(local,n,'H') &&\\n                        !isVowel(local,n+2)) {\\n                        break;\\n                    }\\n                    if (n > 0 &&\\n                        ( regionMatch(local, n, \\\"GN\\\") ||\\n                          regionMatch(local, n, \\\"GNED\\\") ) ) {\\n                        break; // silent G\\n                    }\\n                    if (isPreviousChar(local, n, 'G')) {\\n                        // NOTE: Given that duplicated chars are removed, I don't see how this can ever be true\\n                        hard = true;\\n                    } else {\\n                        hard = false;\\n                    }\\n                    if (!isLastChar(wdsz, n) &&\\n                        FRONTV.indexOf(local.charAt(n + 1)) >= 0 &&\\n                        !hard) {\\n                        code.append('J');\\n                    } else {\\n                        code.append('K');\\n                    }\\n                    break;\\n                case 'H':\\n                    if (isLastChar(wdsz, n)) {\\n                        break; // terminal H\\n                    }\\n                    if (n > 0 &&\\n                        VARSON.indexOf(local.charAt(n - 1)) >= 0) {\\n                        break;\\n                    }\\n                    if (isVowel(local,n+1)) {\\n                        code.append('H'); // Hvowel\\n                    }\\n                    break;\\n                case 'F':\\n                case 'J':\\n                case 'L':\\n                case 'M':\\n                case 'N':\\n                case 'R':\\n                    code.append(symb);\\n                    break;\\n                case 'K':\\n                    if (n > 0) { // not initial\\n                        if (!isPreviousChar(local, n, 'C')) {\\n                            code.append(symb);\\n                        }\\n                    } else {\\n                        code.append(symb); // initial K\\n                    }\\n                    break;\\n                case 'P':\\n                    if (isNextChar(local,n,'H')) {\\n                        // PH -> F\\n                        code.append('F');\\n                    } else {\\n                        code.append(symb);\\n                    }\\n                    break;\\n                case 'Q':\\n                    code.append('K');\\n                    break;\\n                case 'S':\\n                    if (regionMatch(local,n,\\\"SH\\\") ||\\n                        regionMatch(local,n,\\\"SIO\\\") ||\\n                        regionMatch(local,n,\\\"SIA\\\")) {\\n                        code.append('X');\\n                    } else {\\n                        code.append('S');\\n                    }\\n                    break;\\n                case 'T':\\n                    if (regionMatch(local,n,\\\"TIA\\\") ||\\n                        regionMatch(local,n,\\\"TIO\\\")) {\\n                        code.append('X');\\n                        break;\\n                    }\\n                    if (regionMatch(local,n,\\\"TCH\\\")) {\\n                        // Silent if in \\\"TCH\\\"\\n                        break;\\n                    }\\n                    // substitute numeral 0 for TH (resembles theta after all)\\n                    if (regionMatch(local,n,\\\"TH\\\")) {\\n                        code.append('0');\\n                    } else {\\n                        code.append('T');\\n                    }\\n                    break;\\n                case 'V':\\n                    code.append('F'); break;\\n                case 'W':\\n                case 'Y': // silent if not followed by vowel\\n                    if (!isLastChar(wdsz,n) &&\\n                        isVowel(local,n+1)) {\\n                        code.append(symb);\\n                    }\\n                    break;\\n                case 'X':\\n                    code.append('K');\\n                    code.append('S');\\n                    break;\\n                case 'Z':\\n                    code.append('S');\\n                    break;\\n                default:\\n                    // do nothing\\n                    break;\\n                } // end switch\\n                n++;\\n            } // end else from symb != 'C'\\n            if (code.length() > this.getMaxCodeLen()) {\\n                code.setLength(this.getMaxCodeLen());\\n            }\\n        }\\n        return code.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"txt\", \"type\": \"String\"}]}, {\"name\": \"isVowel\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 338, \"end_line\": 340, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean isVowel(final StringBuilder string, final int index) {\\n        return VOWELS.indexOf(string.charAt(index)) >= 0;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"StringBuilder\"}, {\"name\": \"index\", \"type\": \"int\"}]}, {\"name\": \"isPreviousChar\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 342, \"end_line\": 349, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean isPreviousChar(final StringBuilder string, final int index, final char c) {\\n        boolean matches = false;\\n        if( index > 0 &&\\n            index < string.length() ) {\\n            matches = string.charAt(index - 1) == c;\\n        }\\n        return matches;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"StringBuilder\"}, {\"name\": \"index\", \"type\": \"int\"}, {\"name\": \"c\", \"type\": \"char\"}]}, {\"name\": \"isNextChar\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 351, \"end_line\": 358, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean isNextChar(final StringBuilder string, final int index, final char c) {\\n        boolean matches = false;\\n        if( index >= 0 &&\\n            index < string.length() - 1 ) {\\n            matches = string.charAt(index + 1) == c;\\n        }\\n        return matches;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"StringBuilder\"}, {\"name\": \"index\", \"type\": \"int\"}, {\"name\": \"c\", \"type\": \"char\"}]}, {\"name\": \"regionMatch\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 360, \"end_line\": 368, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean regionMatch(final StringBuilder string, final int index, final String test) {\\n        boolean matches = false;\\n        if( index >= 0 &&\\n            index + test.length() - 1 < string.length() ) {\\n            final String substring = string.substring( index, index + test.length());\\n            matches = substring.equals( test );\\n        }\\n        return matches;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"string\", \"type\": \"StringBuilder\"}, {\"name\": \"index\", \"type\": \"int\"}, {\"name\": \"test\", \"type\": \"String\"}]}, {\"name\": \"isLastChar\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 370, \"end_line\": 372, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean isLastChar(final int wdsz, final int n) {\\n        return n + 1 == wdsz;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"wdsz\", \"type\": \"int\"}, {\"name\": \"n\", \"type\": \"int\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 388, \"end_line\": 393, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Metaphone encode is not of type java.lang.String\\\");\\n        }\\n        return metaphone((String) obj);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 402, \"end_line\": 404, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str) {\\n        return metaphone(str);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"isMetaphoneEqual\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 414, \"end_line\": 416, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isMetaphoneEqual(final String str1, final String str2) {\\n        return metaphone(str1).equals(metaphone(str2));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str1\", \"type\": \"String\"}, {\"name\": \"str2\", \"type\": \"String\"}]}, {\"name\": \"getMaxCodeLen\", \"return_type\": \"int\", \"position\": {\"start_line\": 422, \"end_line\": 422, \"start_column\": 12, \"end_column\": 47}, \"code\": \"int getMaxCodeLen() { return this.maxCodeLen; }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"setMaxCodeLen\", \"return_type\": \"void\", \"position\": {\"start_line\": 428, \"end_line\": 428, \"start_column\": 12, \"end_column\": 74}, \"code\": \"void setMaxCodeLen(final int maxCodeLen) { this.maxCodeLen = maxCodeLen; }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"maxCodeLen\", \"type\": \"int\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/Nysiis.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language;\\n\\nimport java.util.regex.Pattern;\\n\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringEncoder;\\n\\n/**\\n * Encodes a string into a NYSIIS value. NYSIIS is an encoding used to relate similar names, but can also be used as a\\n * general purpose scheme to find word with similar phonemes.\\n * <p>\\n * NYSIIS features an accuracy increase of 2.7% over the traditional Soundex algorithm.\\n * <p>\\n * Algorithm description:\\n * <pre>\\n * 1. Transcode first characters of name\\n *   1a. MAC -&gt;   MCC\\n *   1b. KN  -&gt;   NN\\n *   1c. K   -&gt;   C\\n *   1d. PH  -&gt;   FF\\n *   1e. PF  -&gt;   FF\\n *   1f. SCH -&gt;   SSS\\n * 2. Transcode last characters of name\\n *   2a. EE, IE          -&gt;   Y\\n *   2b. DT,RT,RD,NT,ND  -&gt;   D\\n * 3. First character of key = first character of name\\n * 4. Transcode remaining characters by following these rules, incrementing by one character each time\\n *   4a. EV  -&gt;   AF  else A,E,I,O,U -&gt; A\\n *   4b. Q   -&gt;   G\\n *   4c. Z   -&gt;   S\\n *   4d. M   -&gt;   N\\n *   4e. KN  -&gt;   N   else K -&gt; C\\n *   4f. SCH -&gt;   SSS\\n *   4g. PH  -&gt;   FF\\n *   4h. H   -&gt;   If previous or next is nonvowel, previous\\n *   4i. W   -&gt;   If previous is vowel, previous\\n *   4j. Add current to key if current != last key character\\n * 5. If last character is S, remove it\\n * 6. If last characters are AY, replace with Y\\n * 7. If last character is A, remove it\\n * 8. Collapse all strings of repeated characters\\n * 9. Add original first character of name as first character of key\\n * </pre>\\n * <p>\\n * This class is immutable and thread-safe.\\n *\\n * @see <a href=\\\"http://en.wikipedia.org/wiki/NYSIIS\\\">NYSIIS on Wikipedia</a>\\n * @see <a href=\\\"http://www.dropby.com/NYSIIS.html\\\">NYSIIS on dropby.com</a>\\n * @see Soundex\\n * @since 1.7\\n * @version $Id: Nysiis.java 1725161 2016-01-18 01:08:56Z ggregory $\\n */\\npublic class Nysiis implements StringEncoder {\\n\\n    private static final char[] CHARS_A   = new char[] { 'A' };\\n    private static final char[] CHARS_AF  = new char[] { 'A', 'F' };\\n    private static final char[] CHARS_C   = new char[] { 'C' };\\n    private static final char[] CHARS_FF  = new char[] { 'F', 'F' };\\n    private static final char[] CHARS_G   = new char[] { 'G' };\\n    private static final char[] CHARS_N   = new char[] { 'N' };\\n    private static final char[] CHARS_NN  = new char[] { 'N', 'N' };\\n    private static final char[] CHARS_S   = new char[] { 'S' };\\n    private static final char[] CHARS_SSS = new char[] { 'S', 'S', 'S' };\\n\\n    private static final Pattern PAT_MAC    = Pattern.compile(\\\"^MAC\\\");\\n    private static final Pattern PAT_KN     = Pattern.compile(\\\"^KN\\\");\\n    private static final Pattern PAT_K      = Pattern.compile(\\\"^K\\\");\\n    private static final Pattern PAT_PH_PF  = Pattern.compile(\\\"^(PH|PF)\\\");\\n    private static final Pattern PAT_SCH    = Pattern.compile(\\\"^SCH\\\");\\n    private static final Pattern PAT_EE_IE  = Pattern.compile(\\\"(EE|IE)$\\\");\\n    private static final Pattern PAT_DT_ETC = Pattern.compile(\\\"(DT|RT|RD|NT|ND)$\\\");\\n\\n    private static final char SPACE = ' ';\\n    private static final int TRUE_LENGTH = 6;\\n\\n    /**\\n     * Tests if the given character is a vowel.\\n     *\\n     * @param c\\n     *            the character to test\\n     * @return <code>true</code> if the character is a vowel, <code>false</code> otherwise\\n     */\\n    private static boolean isVowel(final char c) {\\n        return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\\n    }\\n\\n    /**\\n     * Transcodes the remaining parts of the String. The method operates on a sliding window, looking at 4 characters at\\n     * a time: [i-1, i, i+1, i+2].\\n     *\\n     * @param prev\\n     *            the previous character\\n     * @param curr\\n     *            the current character\\n     * @param next\\n     *            the next character\\n     * @param aNext\\n     *            the after next character\\n     * @return a transcoded array of characters, starting from the current position\\n     */\\n    private static char[] transcodeRemaining(final char prev, final char curr, final char next, final char aNext) {\\n        // 1. EV -> AF\\n        if (curr == 'E' && next == 'V') {\\n            return CHARS_AF;\\n        }\\n\\n        // A, E, I, O, U -> A\\n        if (isVowel(curr)) {\\n            return CHARS_A;\\n        }\\n\\n        // 2. Q -> G, Z -> S, M -> N\\n        if (curr == 'Q') {\\n            return CHARS_G;\\n        } else if (curr == 'Z') {\\n            return CHARS_S;\\n        } else if (curr == 'M') {\\n            return CHARS_N;\\n        }\\n\\n        // 3. KN -> NN else K -> C\\n        if (curr == 'K') {\\n            if (next == 'N') {\\n                return CHARS_NN;\\n            }\\n            return CHARS_C;\\n        }\\n\\n        // 4. SCH -> SSS\\n        if (curr == 'S' && next == 'C' && aNext == 'H') {\\n            return CHARS_SSS;\\n        }\\n\\n        // PH -> FF\\n        if (curr == 'P' && next == 'H') {\\n            return CHARS_FF;\\n        }\\n\\n        // 5. H -> If previous or next is a non vowel, previous.\\n        if (curr == 'H' && (!isVowel(prev) || !isVowel(next))) {\\n            return new char[] { prev };\\n        }\\n\\n        // 6. W -> If previous is vowel, previous.\\n        if (curr == 'W' && isVowel(prev)) {\\n            return new char[] { prev };\\n        }\\n\\n        return new char[] { curr };\\n    }\\n\\n    /** Indicates the strict mode. */\\n    private final boolean strict;\\n\\n    /**\\n     * Creates an instance of the {@link Nysiis} encoder with strict mode (original form),\\n     * i.e. encoded strings have a maximum length of 6.\\n     */\\n    public Nysiis() {\\n        this(true);\\n    }\\n\\n    /**\\n     * Create an instance of the {@link Nysiis} encoder with the specified strict mode:\\n     *\\n     * <ul>\\n     *  <li><code>true</code>: encoded strings have a maximum length of 6</li>\\n     *  <li><code>false</code>: encoded strings may have arbitrary length</li>\\n     * </ul>\\n     *\\n     * @param strict\\n     *            the strict mode\\n     */\\n    public Nysiis(final boolean strict) {\\n        this.strict = strict;\\n    }\\n\\n    /**\\n     * Encodes an Object using the NYSIIS algorithm. This method is provided in order to satisfy the requirements of the\\n     * Encoder interface, and will throw an {@link EncoderException} if the supplied object is not of type\\n     * {@link String}.\\n     *\\n     * @param obj\\n     *            Object to encode\\n     * @return An object (or a {@link String}) containing the NYSIIS code which corresponds to the given String.\\n     * @throws EncoderException\\n     *            if the parameter supplied is not of a {@link String}\\n     * @throws IllegalArgumentException\\n     *            if a character is not mapped\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Nysiis encode is not of type java.lang.String\\\");\\n        }\\n        return this.nysiis((String) obj);\\n    }\\n\\n    /**\\n     * Encodes a String using the NYSIIS algorithm.\\n     *\\n     * @param str\\n     *            A String object to encode\\n     * @return A Nysiis code corresponding to the String supplied\\n     * @throws IllegalArgumentException\\n     *            if a character is not mapped\\n     */\\n    @Override\\n    public String encode(final String str) {\\n        return this.nysiis(str);\\n    }\\n\\n    /**\\n     * Indicates the strict mode for this {@link Nysiis} encoder.\\n     *\\n     * @return <code>true</code> if the encoder is configured for strict mode, <code>false</code> otherwise\\n     */\\n    public boolean isStrict() {\\n        return this.strict;\\n    }\\n\\n    /**\\n     * Retrieves the NYSIIS code for a given String object.\\n     *\\n     * @param str\\n     *            String to encode using the NYSIIS algorithm\\n     * @return A NYSIIS code for the String supplied\\n     */\\n    public String nysiis(String str) {\\n        if (str == null) {\\n            return null;\\n        }\\n\\n        // Use the same clean rules as Soundex\\n        str = SoundexUtils.clean(str);\\n\\n        if (str.length() == 0) {\\n            return str;\\n        }\\n\\n        // Translate first characters of name:\\n        // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS\\n        str = PAT_MAC.matcher(str).replaceFirst(\\\"MCC\\\");\\n        str = PAT_KN.matcher(str).replaceFirst(\\\"NN\\\");\\n        str = PAT_K.matcher(str).replaceFirst(\\\"C\\\");\\n        str = PAT_PH_PF.matcher(str).replaceFirst(\\\"FF\\\");\\n        str = PAT_SCH.matcher(str).replaceFirst(\\\"SSS\\\");\\n\\n        // Translate last characters of name:\\n        // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D\\n        str = PAT_EE_IE.matcher(str).replaceFirst(\\\"Y\\\");\\n        str = PAT_DT_ETC.matcher(str).replaceFirst(\\\"D\\\");\\n\\n        // First character of key = first character of name.\\n        final StringBuilder key = new StringBuilder(str.length());\\n        key.append(str.charAt(0));\\n\\n        // Transcode remaining characters, incrementing by one character each time\\n        final char[] chars = str.toCharArray();\\n        final int len = chars.length;\\n\\n        for (int i = 1; i < len; i++) {\\n            final char next = i < len - 1 ? chars[i + 1] : SPACE;\\n            final char aNext = i < len - 2 ? chars[i + 2] : SPACE;\\n            final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext);\\n            System.arraycopy(transcoded, 0, chars, i, transcoded.length);\\n\\n            // only append the current char to the key if it is different from the last one\\n            if (chars[i] != chars[i - 1]) {\\n                key.append(chars[i]);\\n            }\\n        }\\n\\n        if (key.length() > 1) {\\n            char lastChar = key.charAt(key.length() - 1);\\n\\n            // If last character is S, remove it.\\n            if (lastChar == 'S') {\\n                key.deleteCharAt(key.length() - 1);\\n                lastChar = key.charAt(key.length() - 1);\\n            }\\n\\n            if (key.length() > 2) {\\n                final char last2Char = key.charAt(key.length() - 2);\\n                // If last characters are AY, replace with Y.\\n                if (last2Char == 'A' && lastChar == 'Y') {\\n                    key.deleteCharAt(key.length() - 2);\\n                }\\n            }\\n\\n            // If last character is A, remove it.\\n            if (lastChar == 'A') {\\n                key.deleteCharAt(key.length() - 1);\\n            }\\n        }\\n\\n        final String string = key.toString();\\n        return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string;\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Nysiis\", \"position\": {\"start_line\": 70, \"end_line\": 318, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Nysiis implements StringEncoder {\\n\\n    private static final char[] CHARS_A   = new char[] { 'A' };\\n    private static final char[] CHARS_AF  = new char[] { 'A', 'F' };\\n    private static final char[] CHARS_C   = new char[] { 'C' };\\n    private static final char[] CHARS_FF  = new char[] { 'F', 'F' };\\n    private static final char[] CHARS_G   = new char[] { 'G' };\\n    private static final char[] CHARS_N   = new char[] { 'N' };\\n    private static final char[] CHARS_NN  = new char[] { 'N', 'N' };\\n    private static final char[] CHARS_S   = new char[] { 'S' };\\n    private static final char[] CHARS_SSS = new char[] { 'S', 'S', 'S' };\\n\\n    private static final Pattern PAT_MAC    = Pattern.compile(\\\"^MAC\\\");\\n    private static final Pattern PAT_KN     = Pattern.compile(\\\"^KN\\\");\\n    private static final Pattern PAT_K      = Pattern.compile(\\\"^K\\\");\\n    private static final Pattern PAT_PH_PF  = Pattern.compile(\\\"^(PH|PF)\\\");\\n    private static final Pattern PAT_SCH    = Pattern.compile(\\\"^SCH\\\");\\n    private static final Pattern PAT_EE_IE  = Pattern.compile(\\\"(EE|IE)$\\\");\\n    private static final Pattern PAT_DT_ETC = Pattern.compile(\\\"(DT|RT|RD|NT|ND)$\\\");\\n\\n    private static final char SPACE = ' ';\\n    private static final int TRUE_LENGTH = 6;\\n\\n    /**\\n     * Tests if the given character is a vowel.\\n     *\\n     * @param c\\n     *            the character to test\\n     * @return <code>true</code> if the character is a vowel, <code>false</code> otherwise\\n     */\\n    private static boolean isVowel(final char c) {\\n        return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\\n    }\\n\\n    /**\\n     * Transcodes the remaining parts of the String. The method operates on a sliding window, looking at 4 characters at\\n     * a time: [i-1, i, i+1, i+2].\\n     *\\n     * @param prev\\n     *            the previous character\\n     * @param curr\\n     *            the current character\\n     * @param next\\n     *            the next character\\n     * @param aNext\\n     *            the after next character\\n     * @return a transcoded array of characters, starting from the current position\\n     */\\n    private static char[] transcodeRemaining(final char prev, final char curr, final char next, final char aNext) {\\n        // 1. EV -> AF\\n        if (curr == 'E' && next == 'V') {\\n            return CHARS_AF;\\n        }\\n\\n        // A, E, I, O, U -> A\\n        if (isVowel(curr)) {\\n            return CHARS_A;\\n        }\\n\\n        // 2. Q -> G, Z -> S, M -> N\\n        if (curr == 'Q') {\\n            return CHARS_G;\\n        } else if (curr == 'Z') {\\n            return CHARS_S;\\n        } else if (curr == 'M') {\\n            return CHARS_N;\\n        }\\n\\n        // 3. KN -> NN else K -> C\\n        if (curr == 'K') {\\n            if (next == 'N') {\\n                return CHARS_NN;\\n            }\\n            return CHARS_C;\\n        }\\n\\n        // 4. SCH -> SSS\\n        if (curr == 'S' && next == 'C' && aNext == 'H') {\\n            return CHARS_SSS;\\n        }\\n\\n        // PH -> FF\\n        if (curr == 'P' && next == 'H') {\\n            return CHARS_FF;\\n        }\\n\\n        // 5. H -> If previous or next is a non vowel, previous.\\n        if (curr == 'H' && (!isVowel(prev) || !isVowel(next))) {\\n            return new char[] { prev };\\n        }\\n\\n        // 6. W -> If previous is vowel, previous.\\n        if (curr == 'W' && isVowel(prev)) {\\n            return new char[] { prev };\\n        }\\n\\n        return new char[] { curr };\\n    }\\n\\n    /** Indicates the strict mode. */\\n    private final boolean strict;\\n\\n    /**\\n     * Creates an instance of the {@link Nysiis} encoder with strict mode (original form),\\n     * i.e. encoded strings have a maximum length of 6.\\n     */\\n    public Nysiis() {\\n        this(true);\\n    }\\n\\n    /**\\n     * Create an instance of the {@link Nysiis} encoder with the specified strict mode:\\n     *\\n     * <ul>\\n     *  <li><code>true</code>: encoded strings have a maximum length of 6</li>\\n     *  <li><code>false</code>: encoded strings may have arbitrary length</li>\\n     * </ul>\\n     *\\n     * @param strict\\n     *            the strict mode\\n     */\\n    public Nysiis(final boolean strict) {\\n        this.strict = strict;\\n    }\\n\\n    /**\\n     * Encodes an Object using the NYSIIS algorithm. This method is provided in order to satisfy the requirements of the\\n     * Encoder interface, and will throw an {@link EncoderException} if the supplied object is not of type\\n     * {@link String}.\\n     *\\n     * @param obj\\n     *            Object to encode\\n     * @return An object (or a {@link String}) containing the NYSIIS code which corresponds to the given String.\\n     * @throws EncoderException\\n     *            if the parameter supplied is not of a {@link String}\\n     * @throws IllegalArgumentException\\n     *            if a character is not mapped\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Nysiis encode is not of type java.lang.String\\\");\\n        }\\n        return this.nysiis((String) obj);\\n    }\\n\\n    /**\\n     * Encodes a String using the NYSIIS algorithm.\\n     *\\n     * @param str\\n     *            A String object to encode\\n     * @return A Nysiis code corresponding to the String supplied\\n     * @throws IllegalArgumentException\\n     *            if a character is not mapped\\n     */\\n    @Override\\n    public String encode(final String str) {\\n        return this.nysiis(str);\\n    }\\n\\n    /**\\n     * Indicates the strict mode for this {@link Nysiis} encoder.\\n     *\\n     * @return <code>true</code> if the encoder is configured for strict mode, <code>false</code> otherwise\\n     */\\n    public boolean isStrict() {\\n        return this.strict;\\n    }\\n\\n    /**\\n     * Retrieves the NYSIIS code for a given String object.\\n     *\\n     * @param str\\n     *            String to encode using the NYSIIS algorithm\\n     * @return A NYSIIS code for the String supplied\\n     */\\n    public String nysiis(String str) {\\n        if (str == null) {\\n            return null;\\n        }\\n\\n        // Use the same clean rules as Soundex\\n        str = SoundexUtils.clean(str);\\n\\n        if (str.length() == 0) {\\n            return str;\\n        }\\n\\n        // Translate first characters of name:\\n        // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS\\n        str = PAT_MAC.matcher(str).replaceFirst(\\\"MCC\\\");\\n        str = PAT_KN.matcher(str).replaceFirst(\\\"NN\\\");\\n        str = PAT_K.matcher(str).replaceFirst(\\\"C\\\");\\n        str = PAT_PH_PF.matcher(str).replaceFirst(\\\"FF\\\");\\n        str = PAT_SCH.matcher(str).replaceFirst(\\\"SSS\\\");\\n\\n        // Translate last characters of name:\\n        // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D\\n        str = PAT_EE_IE.matcher(str).replaceFirst(\\\"Y\\\");\\n        str = PAT_DT_ETC.matcher(str).replaceFirst(\\\"D\\\");\\n\\n        // First character of key = first character of name.\\n        final StringBuilder key = new StringBuilder(str.length());\\n        key.append(str.charAt(0));\\n\\n        // Transcode remaining characters, incrementing by one character each time\\n        final char[] chars = str.toCharArray();\\n        final int len = chars.length;\\n\\n        for (int i = 1; i < len; i++) {\\n            final char next = i < len - 1 ? chars[i + 1] : SPACE;\\n            final char aNext = i < len - 2 ? chars[i + 2] : SPACE;\\n            final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext);\\n            System.arraycopy(transcoded, 0, chars, i, transcoded.length);\\n\\n            // only append the current char to the key if it is different from the last one\\n            if (chars[i] != chars[i - 1]) {\\n                key.append(chars[i]);\\n            }\\n        }\\n\\n        if (key.length() > 1) {\\n            char lastChar = key.charAt(key.length() - 1);\\n\\n            // If last character is S, remove it.\\n            if (lastChar == 'S') {\\n                key.deleteCharAt(key.length() - 1);\\n                lastChar = key.charAt(key.length() - 1);\\n            }\\n\\n            if (key.length() > 2) {\\n                final char last2Char = key.charAt(key.length() - 2);\\n                // If last characters are AY, replace with Y.\\n                if (last2Char == 'A' && lastChar == 'Y') {\\n                    key.deleteCharAt(key.length() - 2);\\n                }\\n            }\\n\\n            // If last character is A, remove it.\\n            if (lastChar == 'A') {\\n                key.deleteCharAt(key.length() - 1);\\n            }\\n        }\\n\\n        final String string = key.toString();\\n        return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string;\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"isVowel\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 100, \"end_line\": 102, \"start_column\": 20, \"end_column\": 5}, \"code\": \"boolean isVowel(final char c) {\\n        return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"c\", \"type\": \"char\"}]}, {\"name\": \"transcodeRemaining\", \"return_type\": \"char\", \"position\": {\"start_line\": 118, \"end_line\": 167, \"start_column\": 20, \"end_column\": 5}, \"code\": \"char[] transcodeRemaining(final char prev, final char curr, final char next, final char aNext) {\\n        // 1. EV -> AF\\n        if (curr == 'E' && next == 'V') {\\n            return CHARS_AF;\\n        }\\n\\n        // A, E, I, O, U -> A\\n        if (isVowel(curr)) {\\n            return CHARS_A;\\n        }\\n\\n        // 2. Q -> G, Z -> S, M -> N\\n        if (curr == 'Q') {\\n            return CHARS_G;\\n        } else if (curr == 'Z') {\\n            return CHARS_S;\\n        } else if (curr == 'M') {\\n            return CHARS_N;\\n        }\\n\\n        // 3. KN -> NN else K -> C\\n        if (curr == 'K') {\\n            if (next == 'N') {\\n                return CHARS_NN;\\n            }\\n            return CHARS_C;\\n        }\\n\\n        // 4. SCH -> SSS\\n        if (curr == 'S' && next == 'C' && aNext == 'H') {\\n            return CHARS_SSS;\\n        }\\n\\n        // PH -> FF\\n        if (curr == 'P' && next == 'H') {\\n            return CHARS_FF;\\n        }\\n\\n        // 5. H -> If previous or next is a non vowel, previous.\\n        if (curr == 'H' && (!isVowel(prev) || !isVowel(next))) {\\n            return new char[] { prev };\\n        }\\n\\n        // 6. W -> If previous is vowel, previous.\\n        if (curr == 'W' && isVowel(prev)) {\\n            return new char[] { prev };\\n        }\\n\\n        return new char[] { curr };\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"prev\", \"type\": \"char\"}, {\"name\": \"curr\", \"type\": \"char\"}, {\"name\": \"next\", \"type\": \"char\"}, {\"name\": \"aNext\", \"type\": \"char\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 209, \"end_line\": 214, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Nysiis encode is not of type java.lang.String\\\");\\n        }\\n        return this.nysiis((String) obj);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 226, \"end_line\": 228, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str) {\\n        return this.nysiis(str);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"isStrict\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 235, \"end_line\": 237, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isStrict() {\\n        return this.strict;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"nysiis\", \"return_type\": \"String\", \"position\": {\"start_line\": 246, \"end_line\": 316, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String nysiis(String str) {\\n        if (str == null) {\\n            return null;\\n        }\\n\\n        // Use the same clean rules as Soundex\\n        str = SoundexUtils.clean(str);\\n\\n        if (str.length() == 0) {\\n            return str;\\n        }\\n\\n        // Translate first characters of name:\\n        // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS\\n        str = PAT_MAC.matcher(str).replaceFirst(\\\"MCC\\\");\\n        str = PAT_KN.matcher(str).replaceFirst(\\\"NN\\\");\\n        str = PAT_K.matcher(str).replaceFirst(\\\"C\\\");\\n        str = PAT_PH_PF.matcher(str).replaceFirst(\\\"FF\\\");\\n        str = PAT_SCH.matcher(str).replaceFirst(\\\"SSS\\\");\\n\\n        // Translate last characters of name:\\n        // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D\\n        str = PAT_EE_IE.matcher(str).replaceFirst(\\\"Y\\\");\\n        str = PAT_DT_ETC.matcher(str).replaceFirst(\\\"D\\\");\\n\\n        // First character of key = first character of name.\\n        final StringBuilder key = new StringBuilder(str.length());\\n        key.append(str.charAt(0));\\n\\n        // Transcode remaining characters, incrementing by one character each time\\n        final char[] chars = str.toCharArray();\\n        final int len = chars.length;\\n\\n        for (int i = 1; i < len; i++) {\\n            final char next = i < len - 1 ? chars[i + 1] : SPACE;\\n            final char aNext = i < len - 2 ? chars[i + 2] : SPACE;\\n            final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext);\\n            System.arraycopy(transcoded, 0, chars, i, transcoded.length);\\n\\n            // only append the current char to the key if it is different from the last one\\n            if (chars[i] != chars[i - 1]) {\\n                key.append(chars[i]);\\n            }\\n        }\\n\\n        if (key.length() > 1) {\\n            char lastChar = key.charAt(key.length() - 1);\\n\\n            // If last character is S, remove it.\\n            if (lastChar == 'S') {\\n                key.deleteCharAt(key.length() - 1);\\n                lastChar = key.charAt(key.length() - 1);\\n            }\\n\\n            if (key.length() > 2) {\\n                final char last2Char = key.charAt(key.length() - 2);\\n                // If last characters are AY, replace with Y.\\n                if (last2Char == 'A' && lastChar == 'Y') {\\n                    key.deleteCharAt(key.length() - 2);\\n                }\\n            }\\n\\n            // If last character is A, remove it.\\n            if (lastChar == 'A') {\\n                key.deleteCharAt(key.length() - 1);\\n            }\\n        }\\n\\n        final String string = key.toString();\\n        return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/RefinedSoundex.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language;\\n\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringEncoder;\\n\\n/**\\n * Encodes a string into a Refined Soundex value. A refined soundex code is\\n * optimized for spell checking words. Soundex method originally developed by\\n * <CITE>Margaret Odell</CITE> and <CITE>Robert Russell</CITE>.\\n *\\n * <p>This class is immutable and thread-safe.</p>\\n *\\n * @version $Id: RefinedSoundex.java 1811347 2017-10-06 15:21:18Z ggregory $\\n */\\npublic class RefinedSoundex implements StringEncoder {\\n\\n    /**\\n     * Mapping:\\n     * <pre>\\n     * 0: A E I O U Y H W\\n     * 1: B P\\n     * 2: F V\\n     * 3: C K S\\n     * 4: G J\\n     * 5: Q X Z\\n     * 6: D T\\n     * 7: L\\n     * 8: M N\\n     * 9: R\\n     * </pre>\\n     * @since 1.4\\n     */\\n    //                                                      ABCDEFGHIJKLMNOPQRSTUVWXYZ\\n    public static final String US_ENGLISH_MAPPING_STRING = \\\"01360240043788015936020505\\\";\\n\\n   /**\\n     * RefinedSoundex is *refined* for a number of reasons one being that the\\n     * mappings have been altered. This implementation contains default\\n     * mappings for US English.\\n     */\\n    private static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\\n\\n    /**\\n     * Every letter of the alphabet is \\\"mapped\\\" to a numerical value. This char\\n     * array holds the values to which each letter is mapped. This\\n     * implementation contains a default map for US_ENGLISH\\n     */\\n    private final char[] soundexMapping;\\n\\n    /**\\n     * This static variable contains an instance of the RefinedSoundex using\\n     * the US_ENGLISH mapping.\\n     */\\n    public static final RefinedSoundex US_ENGLISH = new RefinedSoundex();\\n\\n     /**\\n     * Creates an instance of the RefinedSoundex object using the default US\\n     * English mapping.\\n     */\\n    public RefinedSoundex() {\\n        this.soundexMapping = US_ENGLISH_MAPPING;\\n    }\\n\\n    /**\\n     * Creates a refined soundex instance using a custom mapping. This\\n     * constructor can be used to customize the mapping, and/or possibly\\n     * provide an internationalized mapping for a non-Western character set.\\n     *\\n     * @param mapping\\n     *                  Mapping array to use when finding the corresponding code for\\n     *                  a given character\\n     */\\n    public RefinedSoundex(final char[] mapping) {\\n        this.soundexMapping = new char[mapping.length];\\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\\n    }\\n\\n    /**\\n     * Creates a refined Soundex instance using a custom mapping. This constructor can be used to customize the mapping,\\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\\n     *\\n     * @param mapping\\n     *            Mapping string to use when finding the corresponding code for a given character\\n     * @since 1.4\\n     */\\n    public RefinedSoundex(final String mapping) {\\n        this.soundexMapping = mapping.toCharArray();\\n    }\\n\\n    /**\\n     * Returns the number of characters in the two encoded Strings that are the\\n     * same. This return value ranges from 0 to the length of the shortest\\n     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for\\n     * example) indicates strong similarity or identical values. For refined\\n     * Soundex, the return value can be greater than 4.\\n     *\\n     * @param s1\\n     *                  A String that will be encoded and compared.\\n     * @param s2\\n     *                  A String that will be encoded and compared.\\n     * @return The number of characters in the two encoded Strings that are the\\n     *             same from 0 to to the length of the shortest encoded String.\\n     *\\n     * @see SoundexUtils#difference(StringEncoder,String,String)\\n     * @see <a href=\\\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\\\">\\n     *          MS T-SQL DIFFERENCE</a>\\n     *\\n     * @throws EncoderException\\n     *                  if an error occurs encoding one of the strings\\n     * @since 1.3\\n     */\\n    public int difference(final String s1, final String s2) throws EncoderException {\\n        return SoundexUtils.difference(this, s1, s2);\\n    }\\n\\n    /**\\n     * Encodes an Object using the refined soundex algorithm. This method is\\n     * provided in order to satisfy the requirements of the Encoder interface,\\n     * and will throw an EncoderException if the supplied object is not of type\\n     * java.lang.String.\\n     *\\n     * @param obj\\n     *                  Object to encode\\n     * @return An object (or type java.lang.String) containing the refined\\n     *             soundex code which corresponds to the String supplied.\\n     * @throws EncoderException\\n     *                  if the parameter supplied is not of type java.lang.String\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to RefinedSoundex encode is not of type java.lang.String\\\");\\n        }\\n        return soundex((String) obj);\\n    }\\n\\n    /**\\n     * Encodes a String using the refined soundex algorithm.\\n     *\\n     * @param str\\n     *                  A String object to encode\\n     * @return A Soundex code corresponding to the String supplied\\n     */\\n    @Override\\n    public String encode(final String str) {\\n        return soundex(str);\\n    }\\n\\n    /**\\n     * Returns the mapping code for a given character. The mapping codes are\\n     * maintained in an internal char array named soundexMapping, and the\\n     * default values of these mappings are US English.\\n     *\\n     * @param c\\n     *                  char to get mapping for\\n     * @return A character (really a numeral) to return for the given char\\n     */\\n    char getMappingCode(final char c) {\\n        if (!Character.isLetter(c)) {\\n            return 0;\\n        }\\n        return this.soundexMapping[Character.toUpperCase(c) - 'A'];\\n    }\\n\\n    /**\\n     * Retrieves the Refined Soundex code for a given String object.\\n     *\\n     * @param str\\n     *                  String to encode using the Refined Soundex algorithm\\n     * @return A soundex code for the String supplied\\n     */\\n    public String soundex(String str) {\\n        if (str == null) {\\n            return null;\\n        }\\n        str = SoundexUtils.clean(str);\\n        if (str.length() == 0) {\\n            return str;\\n        }\\n\\n        final StringBuilder sBuf = new StringBuilder();\\n        sBuf.append(str.charAt(0));\\n\\n        char last, current;\\n        last = '*';\\n\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            current = getMappingCode(str.charAt(i));\\n            if (current == last) {\\n                continue;\\n            } else if (current != 0) {\\n                sBuf.append(current);\\n            }\\n\\n            last = current;\\n\\n        }\\n\\n        return sBuf.toString();\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"RefinedSoundex\", \"position\": {\"start_line\": 32, \"end_line\": 219, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class RefinedSoundex implements StringEncoder {\\n\\n    /**\\n     * Mapping:\\n     * <pre>\\n     * 0: A E I O U Y H W\\n     * 1: B P\\n     * 2: F V\\n     * 3: C K S\\n     * 4: G J\\n     * 5: Q X Z\\n     * 6: D T\\n     * 7: L\\n     * 8: M N\\n     * 9: R\\n     * </pre>\\n     * @since 1.4\\n     */\\n    //                                                      ABCDEFGHIJKLMNOPQRSTUVWXYZ\\n    public static final String US_ENGLISH_MAPPING_STRING = \\\"01360240043788015936020505\\\";\\n\\n   /**\\n     * RefinedSoundex is *refined* for a number of reasons one being that the\\n     * mappings have been altered. This implementation contains default\\n     * mappings for US English.\\n     */\\n    private static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\\n\\n    /**\\n     * Every letter of the alphabet is \\\"mapped\\\" to a numerical value. This char\\n     * array holds the values to which each letter is mapped. This\\n     * implementation contains a default map for US_ENGLISH\\n     */\\n    private final char[] soundexMapping;\\n\\n    /**\\n     * This static variable contains an instance of the RefinedSoundex using\\n     * the US_ENGLISH mapping.\\n     */\\n    public static final RefinedSoundex US_ENGLISH = new RefinedSoundex();\\n\\n     /**\\n     * Creates an instance of the RefinedSoundex object using the default US\\n     * English mapping.\\n     */\\n    public RefinedSoundex() {\\n        this.soundexMapping = US_ENGLISH_MAPPING;\\n    }\\n\\n    /**\\n     * Creates a refined soundex instance using a custom mapping. This\\n     * constructor can be used to customize the mapping, and/or possibly\\n     * provide an internationalized mapping for a non-Western character set.\\n     *\\n     * @param mapping\\n     *                  Mapping array to use when finding the corresponding code for\\n     *                  a given character\\n     */\\n    public RefinedSoundex(final char[] mapping) {\\n        this.soundexMapping = new char[mapping.length];\\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\\n    }\\n\\n    /**\\n     * Creates a refined Soundex instance using a custom mapping. This constructor can be used to customize the mapping,\\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\\n     *\\n     * @param mapping\\n     *            Mapping string to use when finding the corresponding code for a given character\\n     * @since 1.4\\n     */\\n    public RefinedSoundex(final String mapping) {\\n        this.soundexMapping = mapping.toCharArray();\\n    }\\n\\n    /**\\n     * Returns the number of characters in the two encoded Strings that are the\\n     * same. This return value ranges from 0 to the length of the shortest\\n     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for\\n     * example) indicates strong similarity or identical values. For refined\\n     * Soundex, the return value can be greater than 4.\\n     *\\n     * @param s1\\n     *                  A String that will be encoded and compared.\\n     * @param s2\\n     *                  A String that will be encoded and compared.\\n     * @return The number of characters in the two encoded Strings that are the\\n     *             same from 0 to to the length of the shortest encoded String.\\n     *\\n     * @see SoundexUtils#difference(StringEncoder,String,String)\\n     * @see <a href=\\\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\\\">\\n     *          MS T-SQL DIFFERENCE</a>\\n     *\\n     * @throws EncoderException\\n     *                  if an error occurs encoding one of the strings\\n     * @since 1.3\\n     */\\n    public int difference(final String s1, final String s2) throws EncoderException {\\n        return SoundexUtils.difference(this, s1, s2);\\n    }\\n\\n    /**\\n     * Encodes an Object using the refined soundex algorithm. This method is\\n     * provided in order to satisfy the requirements of the Encoder interface,\\n     * and will throw an EncoderException if the supplied object is not of type\\n     * java.lang.String.\\n     *\\n     * @param obj\\n     *                  Object to encode\\n     * @return An object (or type java.lang.String) containing the refined\\n     *             soundex code which corresponds to the String supplied.\\n     * @throws EncoderException\\n     *                  if the parameter supplied is not of type java.lang.String\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to RefinedSoundex encode is not of type java.lang.String\\\");\\n        }\\n        return soundex((String) obj);\\n    }\\n\\n    /**\\n     * Encodes a String using the refined soundex algorithm.\\n     *\\n     * @param str\\n     *                  A String object to encode\\n     * @return A Soundex code corresponding to the String supplied\\n     */\\n    @Override\\n    public String encode(final String str) {\\n        return soundex(str);\\n    }\\n\\n    /**\\n     * Returns the mapping code for a given character. The mapping codes are\\n     * maintained in an internal char array named soundexMapping, and the\\n     * default values of these mappings are US English.\\n     *\\n     * @param c\\n     *                  char to get mapping for\\n     * @return A character (really a numeral) to return for the given char\\n     */\\n    char getMappingCode(final char c) {\\n        if (!Character.isLetter(c)) {\\n            return 0;\\n        }\\n        return this.soundexMapping[Character.toUpperCase(c) - 'A'];\\n    }\\n\\n    /**\\n     * Retrieves the Refined Soundex code for a given String object.\\n     *\\n     * @param str\\n     *                  String to encode using the Refined Soundex algorithm\\n     * @return A soundex code for the String supplied\\n     */\\n    public String soundex(String str) {\\n        if (str == null) {\\n            return null;\\n        }\\n        str = SoundexUtils.clean(str);\\n        if (str.length() == 0) {\\n            return str;\\n        }\\n\\n        final StringBuilder sBuf = new StringBuilder();\\n        sBuf.append(str.charAt(0));\\n\\n        char last, current;\\n        last = '*';\\n\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            current = getMappingCode(str.charAt(i));\\n            if (current == last) {\\n                continue;\\n            } else if (current != 0) {\\n                sBuf.append(current);\\n            }\\n\\n            last = current;\\n\\n        }\\n\\n        return sBuf.toString();\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"difference\", \"return_type\": \"int\", \"position\": {\"start_line\": 129, \"end_line\": 131, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int difference(final String s1, final String s2) throws EncoderException {\\n        return SoundexUtils.difference(this, s1, s2);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"s1\", \"type\": \"String\"}, {\"name\": \"s2\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 147, \"end_line\": 152, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to RefinedSoundex encode is not of type java.lang.String\\\");\\n        }\\n        return soundex((String) obj);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 162, \"end_line\": 164, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str) {\\n        return soundex(str);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"getMappingCode\", \"return_type\": \"char\", \"position\": {\"start_line\": 175, \"end_line\": 180, \"start_column\": 5, \"end_column\": 5}, \"code\": \"char getMappingCode(final char c) {\\n        if (!Character.isLetter(c)) {\\n            return 0;\\n        }\\n        return this.soundexMapping[Character.toUpperCase(c) - 'A'];\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"c\", \"type\": \"char\"}]}, {\"name\": \"soundex\", \"return_type\": \"String\", \"position\": {\"start_line\": 189, \"end_line\": 218, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String soundex(String str) {\\n        if (str == null) {\\n            return null;\\n        }\\n        str = SoundexUtils.clean(str);\\n        if (str.length() == 0) {\\n            return str;\\n        }\\n\\n        final StringBuilder sBuf = new StringBuilder();\\n        sBuf.append(str.charAt(0));\\n\\n        char last, current;\\n        last = '*';\\n\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            current = getMappingCode(str.charAt(i));\\n            if (current == last) {\\n                continue;\\n            } else if (current != 0) {\\n                sBuf.append(current);\\n            }\\n\\n            last = current;\\n\\n        }\\n\\n        return sBuf.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/Soundex.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language;\\n\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringEncoder;\\n\\n/**\\n * Encodes a string into a Soundex value. Soundex is an encoding used to relate similar names, but can also be used as a\\n * general purpose scheme to find word with similar phonemes.\\n *\\n * This class is thread-safe.\\n * Although not strictly immutable, the {@link #maxLength} field is not actually used.\\n *\\n * @version $Id: Soundex.java 1811347 2017-10-06 15:21:18Z ggregory $\\n */\\npublic class Soundex implements StringEncoder {\\n\\n    /**\\n     * The marker character used to indicate a silent (ignored) character.\\n     * These are ignored except when they appear as the first character.\\n     * <p>\\n     * Note: the {@link #US_ENGLISH_MAPPING_STRING} does not use this mechanism\\n     * because changing it might break existing code. Mappings that don't contain\\n     * a silent marker code are treated as though H and W are silent.\\n     * <p>\\n     * To override this, use the {@link #Soundex(String, boolean)} constructor.\\n     * @since 1.11\\n     */\\n    public static final char SILENT_MARKER = '-';\\n\\n    /**\\n     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\\n     * means do not encode, but treat as a separator when it occurs between consonants with the same code.\\n     * <p>\\n     * (This constant is provided as both an implementation convenience and to allow Javadoc to pick\\n     * up the value for the constant values page.)\\n     * <p>\\n     * <b>Note that letters H and W are treated specially.</b>\\n     * They are ignored (after the first letter) and don't act as separators\\n     * between consonants with the same code.\\n     * @see #US_ENGLISH_MAPPING\\n     */\\n    //                                                      ABCDEFGHIJKLMNOPQRSTUVWXYZ\\n    public static final String US_ENGLISH_MAPPING_STRING = \\\"01230120022455012623010202\\\";\\n\\n    /**\\n     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\\n     * means do not encode.\\n     *\\n     * @see Soundex#Soundex(char[])\\n     */\\n    private static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\\n\\n    /**\\n     * An instance of Soundex using the US_ENGLISH_MAPPING mapping.\\n     * This treats H and W as silent letters.\\n     * Apart from when they appear as the first letter, they are ignored.\\n     * They don't act as separators between duplicate codes.\\n     *\\n     * @see #US_ENGLISH_MAPPING\\n     * @see #US_ENGLISH_MAPPING_STRING\\n     */\\n    public static final Soundex US_ENGLISH = new Soundex();\\n\\n    /**\\n     * An instance of Soundex using the Simplified Soundex mapping, as described here:\\n     * http://west-penwith.org.uk/misc/soundex.htm\\n     * <p>\\n     * This treats H and W the same as vowels (AEIOUY).\\n     * Such letters aren't encoded (after the first), but they do\\n     * act as separators when dropping duplicate codes.\\n     * The mapping is otherwise the same as for {@link #US_ENGLISH}\\n     * <p>\\n     * @since 1.11\\n     */\\n    public static final Soundex US_ENGLISH_SIMPLIFIED = new Soundex(US_ENGLISH_MAPPING_STRING, false);\\n\\n    /**\\n     * An instance of Soundex using the mapping as per the Genealogy site:\\n     * http://www.genealogy.com/articles/research/00000060.html\\n     * <p>\\n     * This treats vowels (AEIOUY), H and W as silent letters.\\n     * Such letters are ignored (after the first) and do not\\n     * act as separators when dropping duplicate codes.\\n     * <p>\\n     * The codes for consonants are otherwise the same as for\\n     * {@link #US_ENGLISH_MAPPING_STRING} and {@link #US_ENGLISH_SIMPLIFIED}\\n     *\\n     * @since 1.11\\n     */\\n    public static final Soundex US_ENGLISH_GENEALOGY = new Soundex(\\\"-123-12--22455-12623-1-2-2\\\");\\n    //                                                              ABCDEFGHIJKLMNOPQRSTUVWXYZ\\n\\n    /**\\n     * The maximum length of a Soundex code - Soundex codes are only four characters by definition.\\n     *\\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\\n     */\\n    @Deprecated\\n    private int maxLength = 4;\\n\\n    /**\\n     * Every letter of the alphabet is \\\"mapped\\\" to a numerical value. This char array holds the values to which each\\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\\n     */\\n    private final char[] soundexMapping;\\n\\n    /**\\n     * Should H and W be treated specially?\\n     * <p>\\n     * In versions of the code prior to 1.11,\\n     * the code always treated H and W as silent (ignored) letters.\\n     * If this field is false, H and W are no longer special-cased.\\n     */\\n    private final boolean specialCaseHW;\\n\\n    /**\\n     * Creates an instance using US_ENGLISH_MAPPING\\n     *\\n     * @see Soundex#Soundex(char[])\\n     * @see Soundex#US_ENGLISH_MAPPING\\n     */\\n    public Soundex() {\\n        this.soundexMapping = US_ENGLISH_MAPPING;\\n        this.specialCaseHW = true;\\n    }\\n\\n    /**\\n     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized\\n     * mapping for a non-Western character set.\\n     *\\n     * Every letter of the alphabet is \\\"mapped\\\" to a numerical value. This char array holds the values to which each\\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\\n     * <p>\\n     * If the mapping contains an instance of {@link #SILENT_MARKER} then H and W are not given special treatment\\n     *\\n     * @param mapping\\n     *                  Mapping array to use when finding the corresponding code for a given character\\n     */\\n    public Soundex(final char[] mapping) {\\n        this.soundexMapping = new char[mapping.length];\\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\\n        this.specialCaseHW = !hasMarker(this.soundexMapping);\\n    }\\n\\n    private boolean hasMarker(final char[] mapping) {\\n        for(final char ch : mapping) {\\n            if (ch == SILENT_MARKER) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\\n     * <p>\\n     * If the mapping contains an instance of {@link #SILENT_MARKER} then H and W are not given special treatment\\n     *\\n     * @param mapping\\n     *            Mapping string to use when finding the corresponding code for a given character\\n     * @since 1.4\\n     */\\n    public Soundex(final String mapping) {\\n        this.soundexMapping = mapping.toCharArray();\\n        this.specialCaseHW = !hasMarker(this.soundexMapping);\\n    }\\n\\n    /**\\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\\n     *\\n     * @param mapping\\n     *            Mapping string to use when finding the corresponding code for a given character\\n     * @param specialCaseHW if true, then\\n     * @since 1.11\\n     */\\n    public Soundex(final String mapping, final boolean specialCaseHW) {\\n        this.soundexMapping = mapping.toCharArray();\\n        this.specialCaseHW = specialCaseHW;\\n    }\\n\\n    /**\\n     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\\n     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\\n     * identical values.\\n     *\\n     * @param s1\\n     *                  A String that will be encoded and compared.\\n     * @param s2\\n     *                  A String that will be encoded and compared.\\n     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\\n     *\\n     * @see SoundexUtils#difference(StringEncoder,String,String)\\n     * @see <a href=\\\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\\\"> MS\\n     *          T-SQL DIFFERENCE </a>\\n     *\\n     * @throws EncoderException\\n     *                  if an error occurs encoding one of the strings\\n     * @since 1.3\\n     */\\n    public int difference(final String s1, final String s2) throws EncoderException {\\n        return SoundexUtils.difference(this, s1, s2);\\n    }\\n\\n    /**\\n     * Encodes an Object using the soundex algorithm. This method is provided in order to satisfy the requirements of\\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\\n     *\\n     * @param obj\\n     *                  Object to encode\\n     * @return An object (or type java.lang.String) containing the soundex code which corresponds to the String\\n     *             supplied.\\n     * @throws EncoderException\\n     *                  if the parameter supplied is not of type java.lang.String\\n     * @throws IllegalArgumentException\\n     *                  if a character is not mapped\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Soundex encode is not of type java.lang.String\\\");\\n        }\\n        return soundex((String) obj);\\n    }\\n\\n    /**\\n     * Encodes a String using the soundex algorithm.\\n     *\\n     * @param str\\n     *                  A String object to encode\\n     * @return A Soundex code corresponding to the String supplied\\n     * @throws IllegalArgumentException\\n     *                  if a character is not mapped\\n     */\\n    @Override\\n    public String encode(final String str) {\\n        return soundex(str);\\n    }\\n\\n    /**\\n     * Returns the maxLength. Standard Soundex\\n     *\\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\\n     * @return int\\n     */\\n    @Deprecated\\n    public int getMaxLength() {\\n        return this.maxLength;\\n    }\\n\\n    /**\\n     * Maps the given upper-case character to its Soundex code.\\n     *\\n     * @param ch\\n     *                  An upper-case character.\\n     * @return A Soundex code.\\n     * @throws IllegalArgumentException\\n     *                  Thrown if <code>ch</code> is not mapped.\\n     */\\n    private char map(final char ch) {\\n        final int index = ch - 'A';\\n        if (index < 0 || index >= this.soundexMapping.length) {\\n            throw new IllegalArgumentException(\\\"The character is not mapped: \\\" + ch + \\\" (index=\\\" + index + \\\")\\\");\\n        }\\n        return this.soundexMapping[index];\\n    }\\n\\n    /**\\n     * Sets the maxLength.\\n     *\\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\\n     * @param maxLength\\n     *                  The maxLength to set\\n     */\\n    @Deprecated\\n    public void setMaxLength(final int maxLength) {\\n        this.maxLength = maxLength;\\n    }\\n\\n    /**\\n     * Retrieves the Soundex code for a given String object.\\n     *\\n     * @param str\\n     *                  String to encode using the Soundex algorithm\\n     * @return A soundex code for the String supplied\\n     * @throws IllegalArgumentException\\n     *                  if a character is not mapped\\n     */\\n    public String soundex(String str) {\\n        if (str == null) {\\n            return null;\\n        }\\n        str = SoundexUtils.clean(str);\\n        if (str.length() == 0) {\\n            return str;\\n        }\\n        final char out[] = {'0', '0', '0', '0'};\\n        int count = 0;\\n        final char first = str.charAt(0);\\n        out[count++] = first;\\n        char lastDigit = map(first); // previous digit\\n        for(int i = 1; i < str.length() && count < out.length ; i++) {\\n            final char ch = str.charAt(i);\\n            if ((this.specialCaseHW) && (ch == 'H' || ch == 'W')) { // these are ignored completely\\n                continue;\\n            }\\n            final char digit = map(ch);\\n            if (digit == SILENT_MARKER) {\\n                continue;\\n            }\\n            if (digit != '0' && digit != lastDigit) { // don't store vowels or repeats\\n                out[count++] = digit;\\n            }\\n            lastDigit = digit;\\n        }\\n        return new String(out);\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Soundex\", \"position\": {\"start_line\": 32, \"end_line\": 337, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Soundex implements StringEncoder {\\n\\n    /**\\n     * The marker character used to indicate a silent (ignored) character.\\n     * These are ignored except when they appear as the first character.\\n     * <p>\\n     * Note: the {@link #US_ENGLISH_MAPPING_STRING} does not use this mechanism\\n     * because changing it might break existing code. Mappings that don't contain\\n     * a silent marker code are treated as though H and W are silent.\\n     * <p>\\n     * To override this, use the {@link #Soundex(String, boolean)} constructor.\\n     * @since 1.11\\n     */\\n    public static final char SILENT_MARKER = '-';\\n\\n    /**\\n     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\\n     * means do not encode, but treat as a separator when it occurs between consonants with the same code.\\n     * <p>\\n     * (This constant is provided as both an implementation convenience and to allow Javadoc to pick\\n     * up the value for the constant values page.)\\n     * <p>\\n     * <b>Note that letters H and W are treated specially.</b>\\n     * They are ignored (after the first letter) and don't act as separators\\n     * between consonants with the same code.\\n     * @see #US_ENGLISH_MAPPING\\n     */\\n    //                                                      ABCDEFGHIJKLMNOPQRSTUVWXYZ\\n    public static final String US_ENGLISH_MAPPING_STRING = \\\"01230120022455012623010202\\\";\\n\\n    /**\\n     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position\\n     * means do not encode.\\n     *\\n     * @see Soundex#Soundex(char[])\\n     */\\n    private static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();\\n\\n    /**\\n     * An instance of Soundex using the US_ENGLISH_MAPPING mapping.\\n     * This treats H and W as silent letters.\\n     * Apart from when they appear as the first letter, they are ignored.\\n     * They don't act as separators between duplicate codes.\\n     *\\n     * @see #US_ENGLISH_MAPPING\\n     * @see #US_ENGLISH_MAPPING_STRING\\n     */\\n    public static final Soundex US_ENGLISH = new Soundex();\\n\\n    /**\\n     * An instance of Soundex using the Simplified Soundex mapping, as described here:\\n     * http://west-penwith.org.uk/misc/soundex.htm\\n     * <p>\\n     * This treats H and W the same as vowels (AEIOUY).\\n     * Such letters aren't encoded (after the first), but they do\\n     * act as separators when dropping duplicate codes.\\n     * The mapping is otherwise the same as for {@link #US_ENGLISH}\\n     * <p>\\n     * @since 1.11\\n     */\\n    public static final Soundex US_ENGLISH_SIMPLIFIED = new Soundex(US_ENGLISH_MAPPING_STRING, false);\\n\\n    /**\\n     * An instance of Soundex using the mapping as per the Genealogy site:\\n     * http://www.genealogy.com/articles/research/00000060.html\\n     * <p>\\n     * This treats vowels (AEIOUY), H and W as silent letters.\\n     * Such letters are ignored (after the first) and do not\\n     * act as separators when dropping duplicate codes.\\n     * <p>\\n     * The codes for consonants are otherwise the same as for\\n     * {@link #US_ENGLISH_MAPPING_STRING} and {@link #US_ENGLISH_SIMPLIFIED}\\n     *\\n     * @since 1.11\\n     */\\n    public static final Soundex US_ENGLISH_GENEALOGY = new Soundex(\\\"-123-12--22455-12623-1-2-2\\\");\\n    //                                                              ABCDEFGHIJKLMNOPQRSTUVWXYZ\\n\\n    /**\\n     * The maximum length of a Soundex code - Soundex codes are only four characters by definition.\\n     *\\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\\n     */\\n    @Deprecated\\n    private int maxLength = 4;\\n\\n    /**\\n     * Every letter of the alphabet is \\\"mapped\\\" to a numerical value. This char array holds the values to which each\\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\\n     */\\n    private final char[] soundexMapping;\\n\\n    /**\\n     * Should H and W be treated specially?\\n     * <p>\\n     * In versions of the code prior to 1.11,\\n     * the code always treated H and W as silent (ignored) letters.\\n     * If this field is false, H and W are no longer special-cased.\\n     */\\n    private final boolean specialCaseHW;\\n\\n    /**\\n     * Creates an instance using US_ENGLISH_MAPPING\\n     *\\n     * @see Soundex#Soundex(char[])\\n     * @see Soundex#US_ENGLISH_MAPPING\\n     */\\n    public Soundex() {\\n        this.soundexMapping = US_ENGLISH_MAPPING;\\n        this.specialCaseHW = true;\\n    }\\n\\n    /**\\n     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized\\n     * mapping for a non-Western character set.\\n     *\\n     * Every letter of the alphabet is \\\"mapped\\\" to a numerical value. This char array holds the values to which each\\n     * letter is mapped. This implementation contains a default map for US_ENGLISH\\n     * <p>\\n     * If the mapping contains an instance of {@link #SILENT_MARKER} then H and W are not given special treatment\\n     *\\n     * @param mapping\\n     *                  Mapping array to use when finding the corresponding code for a given character\\n     */\\n    public Soundex(final char[] mapping) {\\n        this.soundexMapping = new char[mapping.length];\\n        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);\\n        this.specialCaseHW = !hasMarker(this.soundexMapping);\\n    }\\n\\n    private boolean hasMarker(final char[] mapping) {\\n        for(final char ch : mapping) {\\n            if (ch == SILENT_MARKER) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\\n     * <p>\\n     * If the mapping contains an instance of {@link #SILENT_MARKER} then H and W are not given special treatment\\n     *\\n     * @param mapping\\n     *            Mapping string to use when finding the corresponding code for a given character\\n     * @since 1.4\\n     */\\n    public Soundex(final String mapping) {\\n        this.soundexMapping = mapping.toCharArray();\\n        this.specialCaseHW = !hasMarker(this.soundexMapping);\\n    }\\n\\n    /**\\n     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,\\n     * and/or possibly provide an internationalized mapping for a non-Western character set.\\n     *\\n     * @param mapping\\n     *            Mapping string to use when finding the corresponding code for a given character\\n     * @param specialCaseHW if true, then\\n     * @since 1.11\\n     */\\n    public Soundex(final String mapping, final boolean specialCaseHW) {\\n        this.soundexMapping = mapping.toCharArray();\\n        this.specialCaseHW = specialCaseHW;\\n    }\\n\\n    /**\\n     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\\n     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\\n     * identical values.\\n     *\\n     * @param s1\\n     *                  A String that will be encoded and compared.\\n     * @param s2\\n     *                  A String that will be encoded and compared.\\n     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\\n     *\\n     * @see SoundexUtils#difference(StringEncoder,String,String)\\n     * @see <a href=\\\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\\\"> MS\\n     *          T-SQL DIFFERENCE </a>\\n     *\\n     * @throws EncoderException\\n     *                  if an error occurs encoding one of the strings\\n     * @since 1.3\\n     */\\n    public int difference(final String s1, final String s2) throws EncoderException {\\n        return SoundexUtils.difference(this, s1, s2);\\n    }\\n\\n    /**\\n     * Encodes an Object using the soundex algorithm. This method is provided in order to satisfy the requirements of\\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.\\n     *\\n     * @param obj\\n     *                  Object to encode\\n     * @return An object (or type java.lang.String) containing the soundex code which corresponds to the String\\n     *             supplied.\\n     * @throws EncoderException\\n     *                  if the parameter supplied is not of type java.lang.String\\n     * @throws IllegalArgumentException\\n     *                  if a character is not mapped\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Soundex encode is not of type java.lang.String\\\");\\n        }\\n        return soundex((String) obj);\\n    }\\n\\n    /**\\n     * Encodes a String using the soundex algorithm.\\n     *\\n     * @param str\\n     *                  A String object to encode\\n     * @return A Soundex code corresponding to the String supplied\\n     * @throws IllegalArgumentException\\n     *                  if a character is not mapped\\n     */\\n    @Override\\n    public String encode(final String str) {\\n        return soundex(str);\\n    }\\n\\n    /**\\n     * Returns the maxLength. Standard Soundex\\n     *\\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\\n     * @return int\\n     */\\n    @Deprecated\\n    public int getMaxLength() {\\n        return this.maxLength;\\n    }\\n\\n    /**\\n     * Maps the given upper-case character to its Soundex code.\\n     *\\n     * @param ch\\n     *                  An upper-case character.\\n     * @return A Soundex code.\\n     * @throws IllegalArgumentException\\n     *                  Thrown if <code>ch</code> is not mapped.\\n     */\\n    private char map(final char ch) {\\n        final int index = ch - 'A';\\n        if (index < 0 || index >= this.soundexMapping.length) {\\n            throw new IllegalArgumentException(\\\"The character is not mapped: \\\" + ch + \\\" (index=\\\" + index + \\\")\\\");\\n        }\\n        return this.soundexMapping[index];\\n    }\\n\\n    /**\\n     * Sets the maxLength.\\n     *\\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\\n     * @param maxLength\\n     *                  The maxLength to set\\n     */\\n    @Deprecated\\n    public void setMaxLength(final int maxLength) {\\n        this.maxLength = maxLength;\\n    }\\n\\n    /**\\n     * Retrieves the Soundex code for a given String object.\\n     *\\n     * @param str\\n     *                  String to encode using the Soundex algorithm\\n     * @return A soundex code for the String supplied\\n     * @throws IllegalArgumentException\\n     *                  if a character is not mapped\\n     */\\n    public String soundex(String str) {\\n        if (str == null) {\\n            return null;\\n        }\\n        str = SoundexUtils.clean(str);\\n        if (str.length() == 0) {\\n            return str;\\n        }\\n        final char out[] = {'0', '0', '0', '0'};\\n        int count = 0;\\n        final char first = str.charAt(0);\\n        out[count++] = first;\\n        char lastDigit = map(first); // previous digit\\n        for(int i = 1; i < str.length() && count < out.length ; i++) {\\n            final char ch = str.charAt(i);\\n            if ((this.specialCaseHW) && (ch == 'H' || ch == 'W')) { // these are ignored completely\\n                continue;\\n            }\\n            final char digit = map(ch);\\n            if (digit == SILENT_MARKER) {\\n                continue;\\n            }\\n            if (digit != '0' && digit != lastDigit) { // don't store vowels or repeats\\n                out[count++] = digit;\\n            }\\n            lastDigit = digit;\\n        }\\n        return new String(out);\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"hasMarker\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 162, \"end_line\": 169, \"start_column\": 13, \"end_column\": 5}, \"code\": \"boolean hasMarker(final char[] mapping) {\\n        for(final char ch : mapping) {\\n            if (ch == SILENT_MARKER) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"mapping\", \"type\": \"char\"}]}, {\"name\": \"difference\", \"return_type\": \"int\", \"position\": {\"start_line\": 219, \"end_line\": 221, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int difference(final String s1, final String s2) throws EncoderException {\\n        return SoundexUtils.difference(this, s1, s2);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"s1\", \"type\": \"String\"}, {\"name\": \"s2\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 237, \"end_line\": 242, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object obj) throws EncoderException {\\n        if (!(obj instanceof String)) {\\n            throw new EncoderException(\\\"Parameter supplied to Soundex encode is not of type java.lang.String\\\");\\n        }\\n        return soundex((String) obj);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 254, \"end_line\": 256, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str) {\\n        return soundex(str);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"getMaxLength\", \"return_type\": \"int\", \"position\": {\"start_line\": 265, \"end_line\": 267, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int getMaxLength() {\\n        return this.maxLength;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"map\", \"return_type\": \"char\", \"position\": {\"start_line\": 278, \"end_line\": 284, \"start_column\": 13, \"end_column\": 5}, \"code\": \"char map(final char ch) {\\n        final int index = ch - 'A';\\n        if (index < 0 || index >= this.soundexMapping.length) {\\n            throw new IllegalArgumentException(\\\"The character is not mapped: \\\" + ch + \\\" (index=\\\" + index + \\\")\\\");\\n        }\\n        return this.soundexMapping[index];\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ch\", \"type\": \"char\"}]}, {\"name\": \"setMaxLength\", \"return_type\": \"void\", \"position\": {\"start_line\": 294, \"end_line\": 296, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setMaxLength(final int maxLength) {\\n        this.maxLength = maxLength;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"maxLength\", \"type\": \"int\"}]}, {\"name\": \"soundex\", \"return_type\": \"String\", \"position\": {\"start_line\": 307, \"end_line\": 335, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String soundex(String str) {\\n        if (str == null) {\\n            return null;\\n        }\\n        str = SoundexUtils.clean(str);\\n        if (str.length() == 0) {\\n            return str;\\n        }\\n        final char out[] = {'0', '0', '0', '0'};\\n        int count = 0;\\n        final char first = str.charAt(0);\\n        out[count++] = first;\\n        char lastDigit = map(first); // previous digit\\n        for(int i = 1; i < str.length() && count < out.length ; i++) {\\n            final char ch = str.charAt(i);\\n            if ((this.specialCaseHW) && (ch == 'H' || ch == 'W')) { // these are ignored completely\\n                continue;\\n            }\\n            final char digit = map(ch);\\n            if (digit == SILENT_MARKER) {\\n                continue;\\n            }\\n            if (digit != '0' && digit != lastDigit) { // don't store vowels or repeats\\n                out[count++] = digit;\\n            }\\n            lastDigit = digit;\\n        }\\n        return new String(out);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/SoundexUtils.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language;\\n\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringEncoder;\\n\\n/**\\n * Utility methods for {@link Soundex} and {@link RefinedSoundex} classes.\\n *\\n * <p>This class is immutable and thread-safe.</p>\\n *\\n * @version $Id: SoundexUtils.java 1429868 2013-01-07 16:08:05Z ggregory $\\n * @since 1.3\\n */\\nfinal class SoundexUtils {\\n\\n    /**\\n     * Cleans up the input string before Soundex processing by only returning\\n     * upper case letters.\\n     *\\n     * @param str\\n     *                  The String to clean.\\n     * @return A clean String.\\n     */\\n    static String clean(final String str) {\\n        if (str == null || str.length() == 0) {\\n            return str;\\n        }\\n        final int len = str.length();\\n        final char[] chars = new char[len];\\n        int count = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (Character.isLetter(str.charAt(i))) {\\n                chars[count++] = str.charAt(i);\\n            }\\n        }\\n        if (count == len) {\\n            return str.toUpperCase(java.util.Locale.ENGLISH);\\n        }\\n        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\\n    }\\n\\n    /**\\n     * Encodes the Strings and returns the number of characters in the two\\n     * encoded Strings that are the same.\\n     * <ul>\\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\\n     * little or no similarity, and 4 indicates strong similarity or identical\\n     * values.</li>\\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\\n     * </ul>\\n     *\\n     * @param encoder\\n     *                  The encoder to use to encode the Strings.\\n     * @param s1\\n     *                  A String that will be encoded and compared.\\n     * @param s2\\n     *                  A String that will be encoded and compared.\\n     * @return The number of characters in the two Soundex encoded Strings that\\n     *             are the same.\\n     *\\n     * @see #differenceEncoded(String,String)\\n     * @see <a href=\\\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\\\">\\n     *          MS T-SQL DIFFERENCE</a>\\n     *\\n     * @throws EncoderException\\n     *                  if an error occurs encoding one of the strings\\n     */\\n    static int difference(final StringEncoder encoder, final String s1, final String s2) throws EncoderException {\\n        return differenceEncoded(encoder.encode(s1), encoder.encode(s2));\\n    }\\n\\n    /**\\n     * Returns the number of characters in the two Soundex encoded Strings that\\n     * are the same.\\n     * <ul>\\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\\n     * little or no similarity, and 4 indicates strong similarity or identical\\n     * values.</li>\\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\\n     * </ul>\\n     *\\n     * @param es1\\n     *                  An encoded String.\\n     * @param es2\\n     *                  An encoded String.\\n     * @return The number of characters in the two Soundex encoded Strings that\\n     *             are the same.\\n     *\\n     * @see <a href=\\\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\\\">\\n     *          MS T-SQL DIFFERENCE</a>\\n     */\\n    static int differenceEncoded(final String es1, final String es2) {\\n\\n        if (es1 == null || es2 == null) {\\n            return 0;\\n        }\\n        final int lengthToMatch = Math.min(es1.length(), es2.length());\\n        int diff = 0;\\n        for (int i = 0; i < lengthToMatch; i++) {\\n            if (es1.charAt(i) == es2.charAt(i)) {\\n                diff++;\\n            }\\n        }\\n        return diff;\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"SoundexUtils\", \"position\": {\"start_line\": 31, \"end_line\": 124, \"start_column\": 7, \"end_column\": 1}, \"code\": \"class SoundexUtils {\\n\\n    /**\\n     * Cleans up the input string before Soundex processing by only returning\\n     * upper case letters.\\n     *\\n     * @param str\\n     *                  The String to clean.\\n     * @return A clean String.\\n     */\\n    static String clean(final String str) {\\n        if (str == null || str.length() == 0) {\\n            return str;\\n        }\\n        final int len = str.length();\\n        final char[] chars = new char[len];\\n        int count = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (Character.isLetter(str.charAt(i))) {\\n                chars[count++] = str.charAt(i);\\n            }\\n        }\\n        if (count == len) {\\n            return str.toUpperCase(java.util.Locale.ENGLISH);\\n        }\\n        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\\n    }\\n\\n    /**\\n     * Encodes the Strings and returns the number of characters in the two\\n     * encoded Strings that are the same.\\n     * <ul>\\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\\n     * little or no similarity, and 4 indicates strong similarity or identical\\n     * values.</li>\\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\\n     * </ul>\\n     *\\n     * @param encoder\\n     *                  The encoder to use to encode the Strings.\\n     * @param s1\\n     *                  A String that will be encoded and compared.\\n     * @param s2\\n     *                  A String that will be encoded and compared.\\n     * @return The number of characters in the two Soundex encoded Strings that\\n     *             are the same.\\n     *\\n     * @see #differenceEncoded(String,String)\\n     * @see <a href=\\\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\\\">\\n     *          MS T-SQL DIFFERENCE</a>\\n     *\\n     * @throws EncoderException\\n     *                  if an error occurs encoding one of the strings\\n     */\\n    static int difference(final StringEncoder encoder, final String s1, final String s2) throws EncoderException {\\n        return differenceEncoded(encoder.encode(s1), encoder.encode(s2));\\n    }\\n\\n    /**\\n     * Returns the number of characters in the two Soundex encoded Strings that\\n     * are the same.\\n     * <ul>\\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\\n     * little or no similarity, and 4 indicates strong similarity or identical\\n     * values.</li>\\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\\n     * </ul>\\n     *\\n     * @param es1\\n     *                  An encoded String.\\n     * @param es2\\n     *                  An encoded String.\\n     * @return The number of characters in the two Soundex encoded Strings that\\n     *             are the same.\\n     *\\n     * @see <a href=\\\"http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\\\">\\n     *          MS T-SQL DIFFERENCE</a>\\n     */\\n    static int differenceEncoded(final String es1, final String es2) {\\n\\n        if (es1 == null || es2 == null) {\\n            return 0;\\n        }\\n        final int lengthToMatch = Math.min(es1.length(), es2.length());\\n        int diff = 0;\\n        for (int i = 0; i < lengthToMatch; i++) {\\n            if (es1.charAt(i) == es2.charAt(i)) {\\n                diff++;\\n            }\\n        }\\n        return diff;\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"clean\", \"return_type\": \"String\", \"position\": {\"start_line\": 41, \"end_line\": 57, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String clean(final String str) {\\n        if (str == null || str.length() == 0) {\\n            return str;\\n        }\\n        final int len = str.length();\\n        final char[] chars = new char[len];\\n        int count = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (Character.isLetter(str.charAt(i))) {\\n                chars[count++] = str.charAt(i);\\n            }\\n        }\\n        if (count == len) {\\n            return str.toUpperCase(java.util.Locale.ENGLISH);\\n        }\\n        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"difference\", \"return_type\": \"int\", \"position\": {\"start_line\": 85, \"end_line\": 87, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int difference(final StringEncoder encoder, final String s1, final String s2) throws EncoderException {\\n        return differenceEncoded(encoder.encode(s1), encoder.encode(s2));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"encoder\", \"type\": \"StringEncoder\"}, {\"name\": \"s1\", \"type\": \"String\"}, {\"name\": \"s2\", \"type\": \"String\"}]}, {\"name\": \"differenceEncoded\", \"return_type\": \"int\", \"position\": {\"start_line\": 109, \"end_line\": 122, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int differenceEncoded(final String es1, final String es2) {\\n\\n        if (es1 == null || es2 == null) {\\n            return 0;\\n        }\\n        final int lengthToMatch = Math.min(es1.length(), es2.length());\\n        int diff = 0;\\n        for (int i = 0; i < lengthToMatch; i++) {\\n            if (es1.charAt(i) == es2.charAt(i)) {\\n                diff++;\\n            }\\n        }\\n        return diff;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"es1\", \"type\": \"String\"}, {\"name\": \"es2\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/bm/BeiderMorseEncoder.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language.bm;\\n\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringEncoder;\\n\\n/**\\n * Encodes strings into their Beider-Morse phonetic encoding.\\n * <p>\\n * Beider-Morse phonetic encodings are optimised for family names. However, they may be useful for a wide range of\\n * words.\\n * <p>\\n * This encoder is intentionally mutable to allow dynamic configuration through bean properties. As such, it is mutable,\\n * and may not be thread-safe. If you require a guaranteed thread-safe encoding then use {@link PhoneticEngine}\\n * directly.\\n * <p>\\n * <b>Encoding overview</b>\\n * <p>\\n * Beider-Morse phonetic encodings is a multi-step process. Firstly, a table of rules is consulted to guess what\\n * language the word comes from. For example, if it ends in \\\"<code>ault</code>\\\" then it infers that the word is French.\\n * Next, the word is translated into a phonetic representation using a language-specific phonetics table. Some runs of\\n * letters can be pronounced in multiple ways, and a single run of letters may be potentially broken up into phonemes at\\n * different places, so this stage results in a set of possible language-specific phonetic representations. Lastly, this\\n * language-specific phonetic representation is processed by a table of rules that re-writes it phonetically taking into\\n * account systematic pronunciation differences between languages, to move it towards a pan-indo-european phonetic\\n * representation. Again, sometimes there are multiple ways this could be done and sometimes things that can be\\n * pronounced in several ways in the source language have only one way to represent them in this average phonetic\\n * language, so the result is again a set of phonetic spellings.\\n * <p>\\n * Some names are treated as having multiple parts. This can be due to two things. Firstly, they may be hyphenated. In\\n * this case, each individual hyphenated word is encoded, and then these are combined end-to-end for the final encoding.\\n * Secondly, some names have standard prefixes, for example, \\\"<code>Mac/Mc</code>\\\" in Scottish (English) names. As\\n * sometimes it is ambiguous whether the prefix is intended or is an accident of the spelling, the word is encoded once\\n * with the prefix and once without it. The resulting encoding contains one and then the other result.\\n * <p>\\n * <b>Encoding format</b>\\n * <p>\\n * Individual phonetic spellings of an input word are represented in upper- and lower-case roman characters. Where there\\n * are multiple possible phonetic representations, these are joined with a pipe (<code>|</code>) character. If multiple\\n * hyphenated words where found, or if the word may contain a name prefix, each encoded word is placed in elipses and\\n * these blocks are then joined with hyphens. For example, \\\"<code>d'ortley</code>\\\" has a possible prefix. The form\\n * without prefix encodes to \\\"<code>ortlaj|ortlej</code>\\\", while the form with prefix encodes to \\\"\\n * <code>dortlaj|dortlej</code>\\\". Thus, the full, combined encoding is \\\"<code>(ortlaj|ortlej)-(dortlaj|dortlej)</code>\\\".\\n * <p>\\n * The encoded forms are often quite a bit longer than the input strings. This is because a single input may have many\\n * potential phonetic interpretations. For example, \\\"<code>Renault</code>\\\" encodes to \\\"\\n * <code>rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult</code>\\\". The <code>APPROX</code> rules will tend to produce larger\\n * encodings as they consider a wider range of possible, approximate phonetic interpretations of the original word.\\n * Down-stream applications may wish to further process the encoding for indexing or lookup purposes, for example, by\\n * splitting on pipe (<code>|</code>) and indexing under each of these alternatives.\\n * <p>\\n * <b>Note</b>: this version of the Beider-Morse encoding is equivalent with v3.4 of the reference implementation.\\n * </p>\\n * @see <a href=\\\"http://stevemorse.org/phonetics/bmpm.htm\\\">Beider-Morse Phonetic Matching</a>\\n * @see <a href=\\\"http://stevemorse.org/phoneticinfo.htm\\\">Reference implementation</a>\\n *\\n * <p>\\n * This class is Not ThreadSafe\\n * </p>\\n * @since 1.6\\n * @version $Id: BeiderMorseEncoder.java 1744724 2016-05-20 12:24:04Z sebb $\\n */\\npublic class BeiderMorseEncoder implements StringEncoder {\\n    // Implementation note: This class is a spring-friendly facade to PhoneticEngine. It allows read/write configuration\\n    // of an immutable PhoneticEngine instance that will be delegated to for the actual encoding.\\n\\n    // a cached object\\n    private PhoneticEngine engine = new PhoneticEngine(NameType.GENERIC, RuleType.APPROX, true);\\n\\n    @Override\\n    public Object encode(final Object source) throws EncoderException {\\n        if (!(source instanceof String)) {\\n            throw new EncoderException(\\\"BeiderMorseEncoder encode parameter is not of type String\\\");\\n        }\\n        return encode((String) source);\\n    }\\n\\n    @Override\\n    public String encode(final String source) throws EncoderException {\\n        if (source == null) {\\n            return null;\\n        }\\n        return this.engine.encode(source);\\n    }\\n\\n    /**\\n     * Gets the name type currently in operation.\\n     *\\n     * @return the NameType currently being used\\n     */\\n    public NameType getNameType() {\\n        return this.engine.getNameType();\\n    }\\n\\n    /**\\n     * Gets the rule type currently in operation.\\n     *\\n     * @return the RuleType currently being used\\n     */\\n    public RuleType getRuleType() {\\n        return this.engine.getRuleType();\\n    }\\n\\n    /**\\n     * Discovers if multiple possible encodings are concatenated.\\n     *\\n     * @return true if multiple encodings are concatenated, false if just the first one is returned\\n     */\\n    public boolean isConcat() {\\n        return this.engine.isConcat();\\n    }\\n\\n    /**\\n     * Sets how multiple possible phonetic encodings are combined.\\n     *\\n     * @param concat\\n     *            true if multiple encodings are to be combined with a '|', false if just the first one is\\n     *            to be considered\\n     */\\n    public void setConcat(final boolean concat) {\\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\\n                                         this.engine.getRuleType(),\\n                                         concat,\\n                                         this.engine.getMaxPhonemes());\\n    }\\n\\n    /**\\n     * Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phonetic encodings\\n     * optimized for Ashkenazi or Sephardic Jewish family names.\\n     *\\n     * @param nameType\\n     *            the NameType in use\\n     */\\n    public void setNameType(final NameType nameType) {\\n        this.engine = new PhoneticEngine(nameType,\\n                                         this.engine.getRuleType(),\\n                                         this.engine.isConcat(),\\n                                         this.engine.getMaxPhonemes());\\n    }\\n\\n    /**\\n     * Sets the rule type to apply. This will widen or narrow the range of phonetic encodings considered.\\n     *\\n     * @param ruleType\\n     *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches\\n     */\\n    public void setRuleType(final RuleType ruleType) {\\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\\n                                         ruleType,\\n                                         this.engine.isConcat(),\\n                                         this.engine.getMaxPhonemes());\\n    }\\n\\n    /**\\n     * Sets the number of maximum of phonemes that shall be considered by the engine.\\n     *\\n     * @param maxPhonemes\\n     *            the maximum number of phonemes returned by the engine\\n     * @since 1.7\\n     */\\n    public void setMaxPhonemes(final int maxPhonemes) {\\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\\n                                         this.engine.getRuleType(),\\n                                         this.engine.isConcat(),\\n                                         maxPhonemes);\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"BeiderMorseEncoder\", \"position\": {\"start_line\": 79, \"end_line\": 184, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class BeiderMorseEncoder implements StringEncoder {\\n    // Implementation note: This class is a spring-friendly facade to PhoneticEngine. It allows read/write configuration\\n    // of an immutable PhoneticEngine instance that will be delegated to for the actual encoding.\\n\\n    // a cached object\\n    private PhoneticEngine engine = new PhoneticEngine(NameType.GENERIC, RuleType.APPROX, true);\\n\\n    @Override\\n    public Object encode(final Object source) throws EncoderException {\\n        if (!(source instanceof String)) {\\n            throw new EncoderException(\\\"BeiderMorseEncoder encode parameter is not of type String\\\");\\n        }\\n        return encode((String) source);\\n    }\\n\\n    @Override\\n    public String encode(final String source) throws EncoderException {\\n        if (source == null) {\\n            return null;\\n        }\\n        return this.engine.encode(source);\\n    }\\n\\n    /**\\n     * Gets the name type currently in operation.\\n     *\\n     * @return the NameType currently being used\\n     */\\n    public NameType getNameType() {\\n        return this.engine.getNameType();\\n    }\\n\\n    /**\\n     * Gets the rule type currently in operation.\\n     *\\n     * @return the RuleType currently being used\\n     */\\n    public RuleType getRuleType() {\\n        return this.engine.getRuleType();\\n    }\\n\\n    /**\\n     * Discovers if multiple possible encodings are concatenated.\\n     *\\n     * @return true if multiple encodings are concatenated, false if just the first one is returned\\n     */\\n    public boolean isConcat() {\\n        return this.engine.isConcat();\\n    }\\n\\n    /**\\n     * Sets how multiple possible phonetic encodings are combined.\\n     *\\n     * @param concat\\n     *            true if multiple encodings are to be combined with a '|', false if just the first one is\\n     *            to be considered\\n     */\\n    public void setConcat(final boolean concat) {\\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\\n                                         this.engine.getRuleType(),\\n                                         concat,\\n                                         this.engine.getMaxPhonemes());\\n    }\\n\\n    /**\\n     * Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phonetic encodings\\n     * optimized for Ashkenazi or Sephardic Jewish family names.\\n     *\\n     * @param nameType\\n     *            the NameType in use\\n     */\\n    public void setNameType(final NameType nameType) {\\n        this.engine = new PhoneticEngine(nameType,\\n                                         this.engine.getRuleType(),\\n                                         this.engine.isConcat(),\\n                                         this.engine.getMaxPhonemes());\\n    }\\n\\n    /**\\n     * Sets the rule type to apply. This will widen or narrow the range of phonetic encodings considered.\\n     *\\n     * @param ruleType\\n     *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches\\n     */\\n    public void setRuleType(final RuleType ruleType) {\\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\\n                                         ruleType,\\n                                         this.engine.isConcat(),\\n                                         this.engine.getMaxPhonemes());\\n    }\\n\\n    /**\\n     * Sets the number of maximum of phonemes that shall be considered by the engine.\\n     *\\n     * @param maxPhonemes\\n     *            the maximum number of phonemes returned by the engine\\n     * @since 1.7\\n     */\\n    public void setMaxPhonemes(final int maxPhonemes) {\\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\\n                                         this.engine.getRuleType(),\\n                                         this.engine.isConcat(),\\n                                         maxPhonemes);\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 87, \"end_line\": 92, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object source) throws EncoderException {\\n        if (!(source instanceof String)) {\\n            throw new EncoderException(\\\"BeiderMorseEncoder encode parameter is not of type String\\\");\\n        }\\n        return encode((String) source);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"Object\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 95, \"end_line\": 100, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String source) throws EncoderException {\\n        if (source == null) {\\n            return null;\\n        }\\n        return this.engine.encode(source);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"source\", \"type\": \"String\"}]}, {\"name\": \"getNameType\", \"return_type\": \"NameType\", \"position\": {\"start_line\": 107, \"end_line\": 109, \"start_column\": 12, \"end_column\": 5}, \"code\": \"NameType getNameType() {\\n        return this.engine.getNameType();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getRuleType\", \"return_type\": \"RuleType\", \"position\": {\"start_line\": 116, \"end_line\": 118, \"start_column\": 12, \"end_column\": 5}, \"code\": \"RuleType getRuleType() {\\n        return this.engine.getRuleType();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isConcat\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 125, \"end_line\": 127, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isConcat() {\\n        return this.engine.isConcat();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"setConcat\", \"return_type\": \"void\", \"position\": {\"start_line\": 136, \"end_line\": 141, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setConcat(final boolean concat) {\\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\\n                                         this.engine.getRuleType(),\\n                                         concat,\\n                                         this.engine.getMaxPhonemes());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"concat\", \"type\": \"boolean\"}]}, {\"name\": \"setNameType\", \"return_type\": \"void\", \"position\": {\"start_line\": 150, \"end_line\": 155, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setNameType(final NameType nameType) {\\n        this.engine = new PhoneticEngine(nameType,\\n                                         this.engine.getRuleType(),\\n                                         this.engine.isConcat(),\\n                                         this.engine.getMaxPhonemes());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"nameType\", \"type\": \"NameType\"}]}, {\"name\": \"setRuleType\", \"return_type\": \"void\", \"position\": {\"start_line\": 163, \"end_line\": 168, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setRuleType(final RuleType ruleType) {\\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\\n                                         ruleType,\\n                                         this.engine.isConcat(),\\n                                         this.engine.getMaxPhonemes());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ruleType\", \"type\": \"RuleType\"}]}, {\"name\": \"setMaxPhonemes\", \"return_type\": \"void\", \"position\": {\"start_line\": 177, \"end_line\": 182, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setMaxPhonemes(final int maxPhonemes) {\\n        this.engine = new PhoneticEngine(this.engine.getNameType(),\\n                                         this.engine.getRuleType(),\\n                                         this.engine.isConcat(),\\n                                         maxPhonemes);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"maxPhonemes\", \"type\": \"int\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/bm/Lang.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language.bm;\\n\\nimport java.io.InputStream;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.EnumMap;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Map;\\nimport java.util.Scanner;\\nimport java.util.Set;\\nimport java.util.regex.Pattern;\\n\\n/**\\n * Language guessing utility.\\n * <p>\\n * This class encapsulates rules used to guess the possible languages that a word originates from. This is\\n * done by reference to a whole series of rules distributed in resource files.\\n * <p>\\n * Instances of this class are typically managed through the static factory method instance().\\n * Unless you are developing your own language guessing rules, you will not need to interact with this class directly.\\n * <p>\\n * This class is intended to be immutable and thread-safe.\\n * <p>\\n * <b>Lang resources</b>\\n * <p>\\n * Language guessing rules are typically loaded from resource files. These are UTF-8 encoded text files.\\n * They are systematically named following the pattern:\\n * <blockquote>org/apache/commons/codec/language/bm/lang.txt</blockquote>\\n * The format of these resources is the following:\\n * <ul>\\n * <li><b>Rules:</b> whitespace separated strings.\\n * There should be 3 columns to each row, and these will be interpreted as:\\n * <ol>\\n * <li>pattern: a regular expression.</li>\\n * <li>languages: a '+'-separated list of languages.</li>\\n * <li>acceptOnMatch: 'true' or 'false' indicating if a match rules in or rules out the language.</li>\\n * </ol>\\n * </li>\\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be\\n * discarded as a comment.</li>\\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode.\\n * This will skip all content until a line ending in '*' and '/' is found.</li>\\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\\n * </ul>\\n * <p>\\n * Port of lang.php\\n *\\n * @since 1.6\\n * @version $Id: Lang.java 1608115 2014-07-05 19:58:38Z tn $\\n */\\npublic class Lang {\\n    // Implementation note: This class is divided into two sections. The first part is a static factory interface that\\n    // exposes the LANGUAGE_RULES_RN resource as a Lang instance. The second part is the Lang instance methods that\\n    // encapsulate a particular language-guessing rule table and the language guessing itself.\\n    //\\n    // It may make sense in the future to expose the private constructor to allow power users to build custom language-\\n    // guessing rules, perhaps by marking it protected and allowing sub-classing. However, the vast majority of users\\n    // should be strongly encouraged to use the static factory <code>instance</code> method to get their Lang instances.\\n\\n    private static final class LangRule {\\n        private final boolean acceptOnMatch;\\n        private final Set<String> languages;\\n        private final Pattern pattern;\\n\\n        private LangRule(final Pattern pattern, final Set<String> languages, final boolean acceptOnMatch) {\\n            this.pattern = pattern;\\n            this.languages = languages;\\n            this.acceptOnMatch = acceptOnMatch;\\n        }\\n\\n        public boolean matches(final String txt) {\\n            return this.pattern.matcher(txt).find();\\n        }\\n    }\\n\\n    private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class);\\n\\n    private static final String LANGUAGE_RULES_RN = \\\"org/apache/commons/codec/language/bm/%s_lang.txt\\\";\\n\\n    static {\\n        for (final NameType s : NameType.values()) {\\n            Langs.put(s, loadFromResource(String.format(LANGUAGE_RULES_RN, s.getName()), Languages.getInstance(s)));\\n        }\\n    }\\n\\n    /**\\n     * Gets a Lang instance for one of the supported NameTypes.\\n     *\\n     * @param nameType\\n     *            the NameType to look up\\n     * @return a Lang encapsulating the language guessing rules for that name type\\n     */\\n    public static Lang instance(final NameType nameType) {\\n        return Langs.get(nameType);\\n    }\\n\\n    /**\\n     * Loads language rules from a resource.\\n     * <p>\\n     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method.\\n     * You will only need to call this yourself if you are developing custom language mapping rules.\\n     *\\n     * @param languageRulesResourceName\\n     *            the fully-qualified resource name to load\\n     * @param languages\\n     *            the languages that these rules will support\\n     * @return a Lang encapsulating the loaded language-guessing rules.\\n     */\\n    public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {\\n        final List<LangRule> rules = new ArrayList<LangRule>();\\n        final InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\\n\\n        if (lRulesIS == null) {\\n            throw new IllegalStateException(\\\"Unable to resolve required resource:\\\" + LANGUAGE_RULES_RN);\\n        }\\n\\n        final Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\\n        try {\\n            boolean inExtendedComment = false;\\n            while (scanner.hasNextLine()) {\\n                final String rawLine = scanner.nextLine();\\n                String line = rawLine;\\n                if (inExtendedComment) {\\n                    // check for closing comment marker, otherwise discard doc comment line\\n                    if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\\n                        inExtendedComment = false;\\n                    }\\n                } else {\\n                    if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\\n                        inExtendedComment = true;\\n                    } else {\\n                        // discard comments\\n                        final int cmtI = line.indexOf(ResourceConstants.CMT);\\n                        if (cmtI >= 0) {\\n                            line = line.substring(0, cmtI);\\n                        }\\n\\n                        // trim leading-trailing whitespace\\n                        line = line.trim();\\n\\n                        if (line.length() == 0) {\\n                            continue; // empty lines can be safely skipped\\n                        }\\n\\n                        // split it up\\n                        final String[] parts = line.split(\\\"\\\\\\\\s+\\\");\\n\\n                        if (parts.length != 3) {\\n                            throw new IllegalArgumentException(\\\"Malformed line '\\\" + rawLine +\\n                                    \\\"' in language resource '\\\" + languageRulesResourceName + \\\"'\\\");\\n                        }\\n\\n                        final Pattern pattern = Pattern.compile(parts[0]);\\n                        final String[] langs = parts[1].split(\\\"\\\\\\\\+\\\");\\n                        final boolean accept = parts[2].equals(\\\"true\\\");\\n\\n                        rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept));\\n                    }\\n                }\\n            }\\n        } finally {\\n            scanner.close();\\n        }\\n        return new Lang(rules, languages);\\n    }\\n\\n    private final Languages languages;\\n    private final List<LangRule> rules;\\n\\n    private Lang(final List<LangRule> rules, final Languages languages) {\\n        this.rules = Collections.unmodifiableList(rules);\\n        this.languages = languages;\\n    }\\n\\n    /**\\n     * Guesses the language of a word.\\n     *\\n     * @param text\\n     *            the word\\n     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match\\n     */\\n    public String guessLanguage(final String text) {\\n        final Languages.LanguageSet ls = guessLanguages(text);\\n        return ls.isSingleton() ? ls.getAny() : Languages.ANY;\\n    }\\n\\n    /**\\n     * Guesses the languages of a word.\\n     *\\n     * @param input\\n     *            the word\\n     * @return a Set of Strings of language names that are potential matches for the input word\\n     */\\n    public Languages.LanguageSet guessLanguages(final String input) {\\n        final String text = input.toLowerCase(Locale.ENGLISH);\\n\\n        final Set<String> langs = new HashSet<String>(this.languages.getLanguages());\\n        for (final LangRule rule : this.rules) {\\n            if (rule.matches(text)) {\\n                if (rule.acceptOnMatch) {\\n                    langs.retainAll(rule.languages);\\n                } else {\\n                    langs.removeAll(rule.languages);\\n                }\\n            }\\n        }\\n\\n        final Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\\n        return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Lang\", \"position\": {\"start_line\": 71, \"end_line\": 231, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Lang {\\n    // Implementation note: This class is divided into two sections. The first part is a static factory interface that\\n    // exposes the LANGUAGE_RULES_RN resource as a Lang instance. The second part is the Lang instance methods that\\n    // encapsulate a particular language-guessing rule table and the language guessing itself.\\n    //\\n    // It may make sense in the future to expose the private constructor to allow power users to build custom language-\\n    // guessing rules, perhaps by marking it protected and allowing sub-classing. However, the vast majority of users\\n    // should be strongly encouraged to use the static factory <code>instance</code> method to get their Lang instances.\\n\\n    private static final class LangRule {\\n        private final boolean acceptOnMatch;\\n        private final Set<String> languages;\\n        private final Pattern pattern;\\n\\n        private LangRule(final Pattern pattern, final Set<String> languages, final boolean acceptOnMatch) {\\n            this.pattern = pattern;\\n            this.languages = languages;\\n            this.acceptOnMatch = acceptOnMatch;\\n        }\\n\\n        public boolean matches(final String txt) {\\n            return this.pattern.matcher(txt).find();\\n        }\\n    }\\n\\n    private static final Map<NameType, Lang> Langs = new EnumMap<NameType, Lang>(NameType.class);\\n\\n    private static final String LANGUAGE_RULES_RN = \\\"org/apache/commons/codec/language/bm/%s_lang.txt\\\";\\n\\n    static {\\n        for (final NameType s : NameType.values()) {\\n            Langs.put(s, loadFromResource(String.format(LANGUAGE_RULES_RN, s.getName()), Languages.getInstance(s)));\\n        }\\n    }\\n\\n    /**\\n     * Gets a Lang instance for one of the supported NameTypes.\\n     *\\n     * @param nameType\\n     *            the NameType to look up\\n     * @return a Lang encapsulating the language guessing rules for that name type\\n     */\\n    public static Lang instance(final NameType nameType) {\\n        return Langs.get(nameType);\\n    }\\n\\n    /**\\n     * Loads language rules from a resource.\\n     * <p>\\n     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method.\\n     * You will only need to call this yourself if you are developing custom language mapping rules.\\n     *\\n     * @param languageRulesResourceName\\n     *            the fully-qualified resource name to load\\n     * @param languages\\n     *            the languages that these rules will support\\n     * @return a Lang encapsulating the loaded language-guessing rules.\\n     */\\n    public static Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {\\n        final List<LangRule> rules = new ArrayList<LangRule>();\\n        final InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\\n\\n        if (lRulesIS == null) {\\n            throw new IllegalStateException(\\\"Unable to resolve required resource:\\\" + LANGUAGE_RULES_RN);\\n        }\\n\\n        final Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\\n        try {\\n            boolean inExtendedComment = false;\\n            while (scanner.hasNextLine()) {\\n                final String rawLine = scanner.nextLine();\\n                String line = rawLine;\\n                if (inExtendedComment) {\\n                    // check for closing comment marker, otherwise discard doc comment line\\n                    if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\\n                        inExtendedComment = false;\\n                    }\\n                } else {\\n                    if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\\n                        inExtendedComment = true;\\n                    } else {\\n                        // discard comments\\n                        final int cmtI = line.indexOf(ResourceConstants.CMT);\\n                        if (cmtI >= 0) {\\n                            line = line.substring(0, cmtI);\\n                        }\\n\\n                        // trim leading-trailing whitespace\\n                        line = line.trim();\\n\\n                        if (line.length() == 0) {\\n                            continue; // empty lines can be safely skipped\\n                        }\\n\\n                        // split it up\\n                        final String[] parts = line.split(\\\"\\\\\\\\s+\\\");\\n\\n                        if (parts.length != 3) {\\n                            throw new IllegalArgumentException(\\\"Malformed line '\\\" + rawLine +\\n                                    \\\"' in language resource '\\\" + languageRulesResourceName + \\\"'\\\");\\n                        }\\n\\n                        final Pattern pattern = Pattern.compile(parts[0]);\\n                        final String[] langs = parts[1].split(\\\"\\\\\\\\+\\\");\\n                        final boolean accept = parts[2].equals(\\\"true\\\");\\n\\n                        rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept));\\n                    }\\n                }\\n            }\\n        } finally {\\n            scanner.close();\\n        }\\n        return new Lang(rules, languages);\\n    }\\n\\n    private final Languages languages;\\n    private final List<LangRule> rules;\\n\\n    private Lang(final List<LangRule> rules, final Languages languages) {\\n        this.rules = Collections.unmodifiableList(rules);\\n        this.languages = languages;\\n    }\\n\\n    /**\\n     * Guesses the language of a word.\\n     *\\n     * @param text\\n     *            the word\\n     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match\\n     */\\n    public String guessLanguage(final String text) {\\n        final Languages.LanguageSet ls = guessLanguages(text);\\n        return ls.isSingleton() ? ls.getAny() : Languages.ANY;\\n    }\\n\\n    /**\\n     * Guesses the languages of a word.\\n     *\\n     * @param input\\n     *            the word\\n     * @return a Set of Strings of language names that are potential matches for the input word\\n     */\\n    public Languages.LanguageSet guessLanguages(final String input) {\\n        final String text = input.toLowerCase(Locale.ENGLISH);\\n\\n        final Set<String> langs = new HashSet<String>(this.languages.getLanguages());\\n        for (final LangRule rule : this.rules) {\\n            if (rule.matches(text)) {\\n                if (rule.acceptOnMatch) {\\n                    langs.retainAll(rule.languages);\\n                } else {\\n                    langs.removeAll(rule.languages);\\n                }\\n            }\\n        }\\n\\n        final Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\\n        return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\\n    }\\n}\", \"summary\": \"\", \"methods\": []}, {\"parent_file\": null, \"name\": \"LangRule\", \"position\": {\"start_line\": 80, \"end_line\": 94, \"start_column\": 26, \"end_column\": 5}, \"code\": \"class LangRule {\\n        private final boolean acceptOnMatch;\\n        private final Set<String> languages;\\n        private final Pattern pattern;\\n\\n        private LangRule(final Pattern pattern, final Set<String> languages, final boolean acceptOnMatch) {\\n            this.pattern = pattern;\\n            this.languages = languages;\\n            this.acceptOnMatch = acceptOnMatch;\\n        }\\n\\n        public boolean matches(final String txt) {\\n            return this.pattern.matcher(txt).find();\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"matches\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 91, \"end_line\": 93, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean matches(final String txt) {\\n            return this.pattern.matcher(txt).find();\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"txt\", \"type\": \"String\"}]}, {\"name\": \"instance\", \"return_type\": \"Lang\", \"position\": {\"start_line\": 113, \"end_line\": 115, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Lang instance(final NameType nameType) {\\n        return Langs.get(nameType);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"nameType\", \"type\": \"NameType\"}]}, {\"name\": \"loadFromResource\", \"return_type\": \"Lang\", \"position\": {\"start_line\": 129, \"end_line\": 185, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Lang loadFromResource(final String languageRulesResourceName, final Languages languages) {\\n        final List<LangRule> rules = new ArrayList<LangRule>();\\n        final InputStream lRulesIS = Lang.class.getClassLoader().getResourceAsStream(languageRulesResourceName);\\n\\n        if (lRulesIS == null) {\\n            throw new IllegalStateException(\\\"Unable to resolve required resource:\\\" + LANGUAGE_RULES_RN);\\n        }\\n\\n        final Scanner scanner = new Scanner(lRulesIS, ResourceConstants.ENCODING);\\n        try {\\n            boolean inExtendedComment = false;\\n            while (scanner.hasNextLine()) {\\n                final String rawLine = scanner.nextLine();\\n                String line = rawLine;\\n                if (inExtendedComment) {\\n                    // check for closing comment marker, otherwise discard doc comment line\\n                    if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\\n                        inExtendedComment = false;\\n                    }\\n                } else {\\n                    if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\\n                        inExtendedComment = true;\\n                    } else {\\n                        // discard comments\\n                        final int cmtI = line.indexOf(ResourceConstants.CMT);\\n                        if (cmtI >= 0) {\\n                            line = line.substring(0, cmtI);\\n                        }\\n\\n                        // trim leading-trailing whitespace\\n                        line = line.trim();\\n\\n                        if (line.length() == 0) {\\n                            continue; // empty lines can be safely skipped\\n                        }\\n\\n                        // split it up\\n                        final String[] parts = line.split(\\\"\\\\\\\\s+\\\");\\n\\n                        if (parts.length != 3) {\\n                            throw new IllegalArgumentException(\\\"Malformed line '\\\" + rawLine +\\n                                    \\\"' in language resource '\\\" + languageRulesResourceName + \\\"'\\\");\\n                        }\\n\\n                        final Pattern pattern = Pattern.compile(parts[0]);\\n                        final String[] langs = parts[1].split(\\\"\\\\\\\\+\\\");\\n                        final boolean accept = parts[2].equals(\\\"true\\\");\\n\\n                        rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept));\\n                    }\\n                }\\n            }\\n        } finally {\\n            scanner.close();\\n        }\\n        return new Lang(rules, languages);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"languageRulesResourceName\", \"type\": \"String\"}, {\"name\": \"languages\", \"type\": \"Languages\"}]}, {\"name\": \"guessLanguage\", \"return_type\": \"String\", \"position\": {\"start_line\": 202, \"end_line\": 205, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String guessLanguage(final String text) {\\n        final Languages.LanguageSet ls = guessLanguages(text);\\n        return ls.isSingleton() ? ls.getAny() : Languages.ANY;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"text\", \"type\": \"String\"}]}, {\"name\": \"guessLanguages\", \"return_type\": \"Languages\", \"position\": {\"start_line\": 214, \"end_line\": 230, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Languages.LanguageSet guessLanguages(final String input) {\\n        final String text = input.toLowerCase(Locale.ENGLISH);\\n\\n        final Set<String> langs = new HashSet<String>(this.languages.getLanguages());\\n        for (final LangRule rule : this.rules) {\\n            if (rule.matches(text)) {\\n                if (rule.acceptOnMatch) {\\n                    langs.retainAll(rule.languages);\\n                } else {\\n                    langs.removeAll(rule.languages);\\n                }\\n            }\\n        }\\n\\n        final Languages.LanguageSet ls = Languages.LanguageSet.from(langs);\\n        return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/bm/Languages.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language.bm;\\n\\nimport java.io.InputStream;\\nimport java.util.Collections;\\nimport java.util.EnumMap;\\nimport java.util.HashSet;\\nimport java.util.Map;\\nimport java.util.NoSuchElementException;\\nimport java.util.Scanner;\\nimport java.util.Set;\\n\\n/**\\n * Language codes.\\n * <p>\\n * Language codes are typically loaded from resource files. These are UTF-8 encoded text files. They are\\n * systematically named following the pattern:\\n * <blockquote>org/apache/commons/codec/language/bm/${{@link NameType#getName()} languages.txt</blockquote>\\n * <p>\\n * The format of these resources is the following:\\n * <ul>\\n * <li><b>Language:</b> a single string containing no whitespace</li>\\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be\\n * discarded as a comment.</li>\\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode.\\n * This will skip all content until a line ending in '*' and '/' is found.</li>\\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\\n * </ul>\\n * <p>\\n * Ported from language.php\\n * <p>\\n * This class is immutable and thread-safe.\\n *\\n * @since 1.6\\n * @version $Id: Languages.java 1694610 2015-08-07 03:47:38Z ggregory $\\n */\\npublic class Languages {\\n    // Implementation note: This class is divided into two sections. The first part is a static factory interface that\\n    // exposes org/apache/commons/codec/language/bm/%s_languages.txt for %s in NameType.* as a list of supported\\n    // languages, and a second part that provides instance methods for accessing this set for supported languages.\\n\\n    /**\\n     * A set of languages.\\n     */\\n    public static abstract class LanguageSet {\\n\\n        public static LanguageSet from(final Set<String> langs) {\\n            return langs.isEmpty() ? NO_LANGUAGES : new SomeLanguages(langs);\\n        }\\n\\n        public abstract boolean contains(String language);\\n\\n        public abstract String getAny();\\n\\n        public abstract boolean isEmpty();\\n\\n        public abstract boolean isSingleton();\\n\\n        public abstract LanguageSet restrictTo(LanguageSet other);\\n\\n        abstract LanguageSet merge(LanguageSet other);\\n    }\\n\\n    /**\\n     * Some languages, explicitly enumerated.\\n     */\\n    public static final class SomeLanguages extends LanguageSet {\\n        private final Set<String> languages;\\n\\n        private SomeLanguages(final Set<String> languages) {\\n            this.languages = Collections.unmodifiableSet(languages);\\n        }\\n\\n        @Override\\n        public boolean contains(final String language) {\\n            return this.languages.contains(language);\\n        }\\n\\n        @Override\\n        public String getAny() {\\n            return this.languages.iterator().next();\\n        }\\n\\n        public Set<String> getLanguages() {\\n            return this.languages;\\n        }\\n\\n        @Override\\n        public boolean isEmpty() {\\n            return this.languages.isEmpty();\\n        }\\n\\n        @Override\\n        public boolean isSingleton() {\\n            return this.languages.size() == 1;\\n        }\\n\\n        @Override\\n        public LanguageSet restrictTo(final LanguageSet other) {\\n            if (other == NO_LANGUAGES) {\\n                return other;\\n            } else if (other == ANY_LANGUAGE) {\\n                return this;\\n            } else {\\n                final SomeLanguages sl = (SomeLanguages) other;\\n                final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\\n                for (final String lang : languages) {\\n                    if (sl.languages.contains(lang)) {\\n                        ls.add(lang);\\n                    }\\n                }\\n                return from(ls);\\n            }\\n        }\\n\\n        @Override\\n        public LanguageSet merge(final LanguageSet other) {\\n            if (other == NO_LANGUAGES) {\\n                return this;\\n            } else if (other == ANY_LANGUAGE) {\\n                return other;\\n            } else {\\n                final SomeLanguages sl = (SomeLanguages) other;\\n                final Set<String> ls = new HashSet<String>(languages);\\n                for (final String lang : sl.languages) {\\n                  ls.add(lang);\\n                }\\n                return from(ls);\\n            }\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \\\"Languages(\\\" + languages.toString() + \\\")\\\";\\n        }\\n\\n    }\\n\\n    public static final String ANY = \\\"any\\\";\\n\\n    private static final Map<NameType, Languages> LANGUAGES = new EnumMap<NameType, Languages>(NameType.class);\\n\\n    static {\\n        for (final NameType s : NameType.values()) {\\n            LANGUAGES.put(s, getInstance(langResourceName(s)));\\n        }\\n    }\\n\\n    public static Languages getInstance(final NameType nameType) {\\n        return LANGUAGES.get(nameType);\\n    }\\n\\n    public static Languages getInstance(final String languagesResourceName) {\\n        // read languages list\\n        final Set<String> ls = new HashSet<String>();\\n        final InputStream langIS = Languages.class.getClassLoader().getResourceAsStream(languagesResourceName);\\n\\n        if (langIS == null) {\\n            throw new IllegalArgumentException(\\\"Unable to resolve required resource: \\\" + languagesResourceName);\\n        }\\n\\n        final Scanner lsScanner = new Scanner(langIS, ResourceConstants.ENCODING);\\n        try {\\n            boolean inExtendedComment = false;\\n            while (lsScanner.hasNextLine()) {\\n                final String line = lsScanner.nextLine().trim();\\n                if (inExtendedComment) {\\n                    if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\\n                        inExtendedComment = false;\\n                    }\\n                } else {\\n                    if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\\n                        inExtendedComment = true;\\n                    } else if (line.length() > 0) {\\n                        ls.add(line);\\n                    }\\n                }\\n            }\\n        } finally {\\n            lsScanner.close();\\n        }\\n\\n        return new Languages(Collections.unmodifiableSet(ls));\\n    }\\n\\n    private static String langResourceName(final NameType nameType) {\\n        return String.format(\\\"org/apache/commons/codec/language/bm/%s_languages.txt\\\", nameType.getName());\\n    }\\n\\n    private final Set<String> languages;\\n\\n    /**\\n     * No languages at all.\\n     */\\n    public static final LanguageSet NO_LANGUAGES = new LanguageSet() {\\n        @Override\\n        public boolean contains(final String language) {\\n            return false;\\n        }\\n\\n        @Override\\n        public String getAny() {\\n            throw new NoSuchElementException(\\\"Can't fetch any language from the empty language set.\\\");\\n        }\\n\\n        @Override\\n        public boolean isEmpty() {\\n            return true;\\n        }\\n\\n        @Override\\n        public boolean isSingleton() {\\n            return false;\\n        }\\n\\n        @Override\\n        public LanguageSet restrictTo(final LanguageSet other) {\\n            return this;\\n        }\\n\\n        @Override\\n        public LanguageSet merge(final LanguageSet other) {\\n            return other;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \\\"NO_LANGUAGES\\\";\\n        }\\n    };\\n\\n    /**\\n     * Any/all languages.\\n     */\\n    public static final LanguageSet ANY_LANGUAGE = new LanguageSet() {\\n        @Override\\n        public boolean contains(final String language) {\\n            return true;\\n        }\\n\\n        @Override\\n        public String getAny() {\\n            throw new NoSuchElementException(\\\"Can't fetch any language from the any language set.\\\");\\n        }\\n\\n        @Override\\n        public boolean isEmpty() {\\n            return false;\\n        }\\n\\n        @Override\\n        public boolean isSingleton() {\\n            return false;\\n        }\\n\\n        @Override\\n        public LanguageSet restrictTo(final LanguageSet other) {\\n            return other;\\n        }\\n\\n        @Override\\n        public LanguageSet merge(final LanguageSet other) {\\n            return other;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \\\"ANY_LANGUAGE\\\";\\n        }\\n    };\\n\\n    private Languages(final Set<String> languages) {\\n        this.languages = languages;\\n    }\\n\\n    public Set<String> getLanguages() {\\n        return this.languages;\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Languages\", \"position\": {\"start_line\": 53, \"end_line\": 295, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Languages {\\n    // Implementation note: This class is divided into two sections. The first part is a static factory interface that\\n    // exposes org/apache/commons/codec/language/bm/%s_languages.txt for %s in NameType.* as a list of supported\\n    // languages, and a second part that provides instance methods for accessing this set for supported languages.\\n\\n    /**\\n     * A set of languages.\\n     */\\n    public static abstract class LanguageSet {\\n\\n        public static LanguageSet from(final Set<String> langs) {\\n            return langs.isEmpty() ? NO_LANGUAGES : new SomeLanguages(langs);\\n        }\\n\\n        public abstract boolean contains(String language);\\n\\n        public abstract String getAny();\\n\\n        public abstract boolean isEmpty();\\n\\n        public abstract boolean isSingleton();\\n\\n        public abstract LanguageSet restrictTo(LanguageSet other);\\n\\n        abstract LanguageSet merge(LanguageSet other);\\n    }\\n\\n    /**\\n     * Some languages, explicitly enumerated.\\n     */\\n    public static final class SomeLanguages extends LanguageSet {\\n        private final Set<String> languages;\\n\\n        private SomeLanguages(final Set<String> languages) {\\n            this.languages = Collections.unmodifiableSet(languages);\\n        }\\n\\n        @Override\\n        public boolean contains(final String language) {\\n            return this.languages.contains(language);\\n        }\\n\\n        @Override\\n        public String getAny() {\\n            return this.languages.iterator().next();\\n        }\\n\\n        public Set<String> getLanguages() {\\n            return this.languages;\\n        }\\n\\n        @Override\\n        public boolean isEmpty() {\\n            return this.languages.isEmpty();\\n        }\\n\\n        @Override\\n        public boolean isSingleton() {\\n            return this.languages.size() == 1;\\n        }\\n\\n        @Override\\n        public LanguageSet restrictTo(final LanguageSet other) {\\n            if (other == NO_LANGUAGES) {\\n                return other;\\n            } else if (other == ANY_LANGUAGE) {\\n                return this;\\n            } else {\\n                final SomeLanguages sl = (SomeLanguages) other;\\n                final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\\n                for (final String lang : languages) {\\n                    if (sl.languages.contains(lang)) {\\n                        ls.add(lang);\\n                    }\\n                }\\n                return from(ls);\\n            }\\n        }\\n\\n        @Override\\n        public LanguageSet merge(final LanguageSet other) {\\n            if (other == NO_LANGUAGES) {\\n                return this;\\n            } else if (other == ANY_LANGUAGE) {\\n                return other;\\n            } else {\\n                final SomeLanguages sl = (SomeLanguages) other;\\n                final Set<String> ls = new HashSet<String>(languages);\\n                for (final String lang : sl.languages) {\\n                  ls.add(lang);\\n                }\\n                return from(ls);\\n            }\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \\\"Languages(\\\" + languages.toString() + \\\")\\\";\\n        }\\n\\n    }\\n\\n    public static final String ANY = \\\"any\\\";\\n\\n    private static final Map<NameType, Languages> LANGUAGES = new EnumMap<NameType, Languages>(NameType.class);\\n\\n    static {\\n        for (final NameType s : NameType.values()) {\\n            LANGUAGES.put(s, getInstance(langResourceName(s)));\\n        }\\n    }\\n\\n    public static Languages getInstance(final NameType nameType) {\\n        return LANGUAGES.get(nameType);\\n    }\\n\\n    public static Languages getInstance(final String languagesResourceName) {\\n        // read languages list\\n        final Set<String> ls = new HashSet<String>();\\n        final InputStream langIS = Languages.class.getClassLoader().getResourceAsStream(languagesResourceName);\\n\\n        if (langIS == null) {\\n            throw new IllegalArgumentException(\\\"Unable to resolve required resource: \\\" + languagesResourceName);\\n        }\\n\\n        final Scanner lsScanner = new Scanner(langIS, ResourceConstants.ENCODING);\\n        try {\\n            boolean inExtendedComment = false;\\n            while (lsScanner.hasNextLine()) {\\n                final String line = lsScanner.nextLine().trim();\\n                if (inExtendedComment) {\\n                    if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\\n                        inExtendedComment = false;\\n                    }\\n                } else {\\n                    if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\\n                        inExtendedComment = true;\\n                    } else if (line.length() > 0) {\\n                        ls.add(line);\\n                    }\\n                }\\n            }\\n        } finally {\\n            lsScanner.close();\\n        }\\n\\n        return new Languages(Collections.unmodifiableSet(ls));\\n    }\\n\\n    private static String langResourceName(final NameType nameType) {\\n        return String.format(\\\"org/apache/commons/codec/language/bm/%s_languages.txt\\\", nameType.getName());\\n    }\\n\\n    private final Set<String> languages;\\n\\n    /**\\n     * No languages at all.\\n     */\\n    public static final LanguageSet NO_LANGUAGES = new LanguageSet() {\\n        @Override\\n        public boolean contains(final String language) {\\n            return false;\\n        }\\n\\n        @Override\\n        public String getAny() {\\n            throw new NoSuchElementException(\\\"Can't fetch any language from the empty language set.\\\");\\n        }\\n\\n        @Override\\n        public boolean isEmpty() {\\n            return true;\\n        }\\n\\n        @Override\\n        public boolean isSingleton() {\\n            return false;\\n        }\\n\\n        @Override\\n        public LanguageSet restrictTo(final LanguageSet other) {\\n            return this;\\n        }\\n\\n        @Override\\n        public LanguageSet merge(final LanguageSet other) {\\n            return other;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \\\"NO_LANGUAGES\\\";\\n        }\\n    };\\n\\n    /**\\n     * Any/all languages.\\n     */\\n    public static final LanguageSet ANY_LANGUAGE = new LanguageSet() {\\n        @Override\\n        public boolean contains(final String language) {\\n            return true;\\n        }\\n\\n        @Override\\n        public String getAny() {\\n            throw new NoSuchElementException(\\\"Can't fetch any language from the any language set.\\\");\\n        }\\n\\n        @Override\\n        public boolean isEmpty() {\\n            return false;\\n        }\\n\\n        @Override\\n        public boolean isSingleton() {\\n            return false;\\n        }\\n\\n        @Override\\n        public LanguageSet restrictTo(final LanguageSet other) {\\n            return other;\\n        }\\n\\n        @Override\\n        public LanguageSet merge(final LanguageSet other) {\\n            return other;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \\\"ANY_LANGUAGE\\\";\\n        }\\n    };\\n\\n    private Languages(final Set<String> languages) {\\n        this.languages = languages;\\n    }\\n\\n    public Set<String> getLanguages() {\\n        return this.languages;\\n    }\\n}\", \"summary\": \"\", \"methods\": []}, {\"parent_file\": null, \"name\": \"LanguageSet\", \"position\": {\"start_line\": 61, \"end_line\": 78, \"start_column\": 28, \"end_column\": 5}, \"code\": \"class LanguageSet {\\n\\n        public static LanguageSet from(final Set<String> langs) {\\n            return langs.isEmpty() ? NO_LANGUAGES : new SomeLanguages(langs);\\n        }\\n\\n        public abstract boolean contains(String language);\\n\\n        public abstract String getAny();\\n\\n        public abstract boolean isEmpty();\\n\\n        public abstract boolean isSingleton();\\n\\n        public abstract LanguageSet restrictTo(LanguageSet other);\\n\\n        abstract LanguageSet merge(LanguageSet other);\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"from\", \"return_type\": \"LanguageSet\", \"position\": {\"start_line\": 63, \"end_line\": 65, \"start_column\": 23, \"end_column\": 9}, \"code\": \"LanguageSet from(final Set<String> langs) {\\n            return langs.isEmpty() ? NO_LANGUAGES : new SomeLanguages(langs);\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"langs\", \"type\": \"Set\"}]}, {\"name\": \"contains\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 67, \"end_line\": 67, \"start_column\": 25, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"language\", \"type\": \"String\"}]}, {\"name\": \"getAny\", \"return_type\": \"String\", \"position\": {\"start_line\": 69, \"end_line\": 69, \"start_column\": 25, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isEmpty\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 71, \"end_line\": 71, \"start_column\": 25, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isSingleton\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 73, \"end_line\": 73, \"start_column\": 25, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"restrictTo\", \"return_type\": \"LanguageSet\", \"position\": {\"start_line\": 75, \"end_line\": 75, \"start_column\": 25, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"other\", \"type\": \"LanguageSet\"}]}, {\"name\": \"merge\", \"return_type\": \"LanguageSet\", \"position\": {\"start_line\": 77, \"end_line\": 77, \"start_column\": 18, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"other\", \"type\": \"LanguageSet\"}]}]}, {\"parent_file\": null, \"name\": \"SomeLanguages\", \"position\": {\"start_line\": 83, \"end_line\": 153, \"start_column\": 25, \"end_column\": 5}, \"code\": \"class SomeLanguages extends LanguageSet {\\n        private final Set<String> languages;\\n\\n        private SomeLanguages(final Set<String> languages) {\\n            this.languages = Collections.unmodifiableSet(languages);\\n        }\\n\\n        @Override\\n        public boolean contains(final String language) {\\n            return this.languages.contains(language);\\n        }\\n\\n        @Override\\n        public String getAny() {\\n            return this.languages.iterator().next();\\n        }\\n\\n        public Set<String> getLanguages() {\\n            return this.languages;\\n        }\\n\\n        @Override\\n        public boolean isEmpty() {\\n            return this.languages.isEmpty();\\n        }\\n\\n        @Override\\n        public boolean isSingleton() {\\n            return this.languages.size() == 1;\\n        }\\n\\n        @Override\\n        public LanguageSet restrictTo(final LanguageSet other) {\\n            if (other == NO_LANGUAGES) {\\n                return other;\\n            } else if (other == ANY_LANGUAGE) {\\n                return this;\\n            } else {\\n                final SomeLanguages sl = (SomeLanguages) other;\\n                final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\\n                for (final String lang : languages) {\\n                    if (sl.languages.contains(lang)) {\\n                        ls.add(lang);\\n                    }\\n                }\\n                return from(ls);\\n            }\\n        }\\n\\n        @Override\\n        public LanguageSet merge(final LanguageSet other) {\\n            if (other == NO_LANGUAGES) {\\n                return this;\\n            } else if (other == ANY_LANGUAGE) {\\n                return other;\\n            } else {\\n                final SomeLanguages sl = (SomeLanguages) other;\\n                final Set<String> ls = new HashSet<String>(languages);\\n                for (final String lang : sl.languages) {\\n                  ls.add(lang);\\n                }\\n                return from(ls);\\n            }\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \\\"Languages(\\\" + languages.toString() + \\\")\\\";\\n        }\\n\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"contains\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 91, \"end_line\": 93, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean contains(final String language) {\\n            return this.languages.contains(language);\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"language\", \"type\": \"String\"}]}, {\"name\": \"getAny\", \"return_type\": \"String\", \"position\": {\"start_line\": 96, \"end_line\": 98, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String getAny() {\\n            return this.languages.iterator().next();\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getLanguages\", \"return_type\": \"Set\", \"position\": {\"start_line\": 100, \"end_line\": 102, \"start_column\": 16, \"end_column\": 9}, \"code\": \"Set<String> getLanguages() {\\n            return this.languages;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isEmpty\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 105, \"end_line\": 107, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean isEmpty() {\\n            return this.languages.isEmpty();\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isSingleton\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 110, \"end_line\": 112, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean isSingleton() {\\n            return this.languages.size() == 1;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"restrictTo\", \"return_type\": \"LanguageSet\", \"position\": {\"start_line\": 115, \"end_line\": 130, \"start_column\": 16, \"end_column\": 9}, \"code\": \"LanguageSet restrictTo(final LanguageSet other) {\\n            if (other == NO_LANGUAGES) {\\n                return other;\\n            } else if (other == ANY_LANGUAGE) {\\n                return this;\\n            } else {\\n                final SomeLanguages sl = (SomeLanguages) other;\\n                final Set<String> ls = new HashSet<String>(Math.min(languages.size(), sl.languages.size()));\\n                for (final String lang : languages) {\\n                    if (sl.languages.contains(lang)) {\\n                        ls.add(lang);\\n                    }\\n                }\\n                return from(ls);\\n            }\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"other\", \"type\": \"LanguageSet\"}]}, {\"name\": \"merge\", \"return_type\": \"LanguageSet\", \"position\": {\"start_line\": 133, \"end_line\": 146, \"start_column\": 16, \"end_column\": 9}, \"code\": \"LanguageSet merge(final LanguageSet other) {\\n            if (other == NO_LANGUAGES) {\\n                return this;\\n            } else if (other == ANY_LANGUAGE) {\\n                return other;\\n            } else {\\n                final SomeLanguages sl = (SomeLanguages) other;\\n                final Set<String> ls = new HashSet<String>(languages);\\n                for (final String lang : sl.languages) {\\n                  ls.add(lang);\\n                }\\n                return from(ls);\\n            }\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"other\", \"type\": \"LanguageSet\"}]}, {\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 149, \"end_line\": 151, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String toString() {\\n            return \\\"Languages(\\\" + languages.toString() + \\\")\\\";\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getInstance\", \"return_type\": \"Languages\", \"position\": {\"start_line\": 165, \"end_line\": 167, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Languages getInstance(final NameType nameType) {\\n        return LANGUAGES.get(nameType);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"nameType\", \"type\": \"NameType\"}]}, {\"name\": \"getInstance\", \"return_type\": \"Languages\", \"position\": {\"start_line\": 169, \"end_line\": 200, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Languages getInstance(final String languagesResourceName) {\\n        // read languages list\\n        final Set<String> ls = new HashSet<String>();\\n        final InputStream langIS = Languages.class.getClassLoader().getResourceAsStream(languagesResourceName);\\n\\n        if (langIS == null) {\\n            throw new IllegalArgumentException(\\\"Unable to resolve required resource: \\\" + languagesResourceName);\\n        }\\n\\n        final Scanner lsScanner = new Scanner(langIS, ResourceConstants.ENCODING);\\n        try {\\n            boolean inExtendedComment = false;\\n            while (lsScanner.hasNextLine()) {\\n                final String line = lsScanner.nextLine().trim();\\n                if (inExtendedComment) {\\n                    if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\\n                        inExtendedComment = false;\\n                    }\\n                } else {\\n                    if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\\n                        inExtendedComment = true;\\n                    } else if (line.length() > 0) {\\n                        ls.add(line);\\n                    }\\n                }\\n            }\\n        } finally {\\n            lsScanner.close();\\n        }\\n\\n        return new Languages(Collections.unmodifiableSet(ls));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"languagesResourceName\", \"type\": \"String\"}]}, {\"name\": \"langResourceName\", \"return_type\": \"String\", \"position\": {\"start_line\": 202, \"end_line\": 204, \"start_column\": 20, \"end_column\": 5}, \"code\": \"String langResourceName(final NameType nameType) {\\n        return String.format(\\\"org/apache/commons/codec/language/bm/%s_languages.txt\\\", nameType.getName());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"nameType\", \"type\": \"NameType\"}]}, {\"name\": \"contains\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 213, \"end_line\": 215, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean contains(final String language) {\\n            return false;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"language\", \"type\": \"String\"}]}, {\"name\": \"getAny\", \"return_type\": \"String\", \"position\": {\"start_line\": 218, \"end_line\": 220, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String getAny() {\\n            throw new NoSuchElementException(\\\"Can't fetch any language from the empty language set.\\\");\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isEmpty\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 223, \"end_line\": 225, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean isEmpty() {\\n            return true;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isSingleton\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 228, \"end_line\": 230, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean isSingleton() {\\n            return false;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"restrictTo\", \"return_type\": \"LanguageSet\", \"position\": {\"start_line\": 233, \"end_line\": 235, \"start_column\": 16, \"end_column\": 9}, \"code\": \"LanguageSet restrictTo(final LanguageSet other) {\\n            return this;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"other\", \"type\": \"LanguageSet\"}]}, {\"name\": \"merge\", \"return_type\": \"LanguageSet\", \"position\": {\"start_line\": 238, \"end_line\": 240, \"start_column\": 16, \"end_column\": 9}, \"code\": \"LanguageSet merge(final LanguageSet other) {\\n            return other;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"other\", \"type\": \"LanguageSet\"}]}, {\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 243, \"end_line\": 245, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String toString() {\\n            return \\\"NO_LANGUAGES\\\";\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"contains\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 253, \"end_line\": 255, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean contains(final String language) {\\n            return true;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"language\", \"type\": \"String\"}]}, {\"name\": \"getAny\", \"return_type\": \"String\", \"position\": {\"start_line\": 258, \"end_line\": 260, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String getAny() {\\n            throw new NoSuchElementException(\\\"Can't fetch any language from the any language set.\\\");\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isEmpty\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 263, \"end_line\": 265, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean isEmpty() {\\n            return false;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isSingleton\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 268, \"end_line\": 270, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean isSingleton() {\\n            return false;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"restrictTo\", \"return_type\": \"LanguageSet\", \"position\": {\"start_line\": 273, \"end_line\": 275, \"start_column\": 16, \"end_column\": 9}, \"code\": \"LanguageSet restrictTo(final LanguageSet other) {\\n            return other;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"other\", \"type\": \"LanguageSet\"}]}, {\"name\": \"merge\", \"return_type\": \"LanguageSet\", \"position\": {\"start_line\": 278, \"end_line\": 280, \"start_column\": 16, \"end_column\": 9}, \"code\": \"LanguageSet merge(final LanguageSet other) {\\n            return other;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"other\", \"type\": \"LanguageSet\"}]}, {\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 283, \"end_line\": 285, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String toString() {\\n            return \\\"ANY_LANGUAGE\\\";\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getLanguages\", \"return_type\": \"Set\", \"position\": {\"start_line\": 292, \"end_line\": 294, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Set<String> getLanguages() {\\n        return this.languages;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/bm/NameType.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language.bm;\\n\\n/**\\n * Supported types of names. Unless you are matching particular family names, use {@link #GENERIC}. The\\n * <code>GENERIC</code> NameType should work reasonably well for non-name words. The other encodings are\\n * specifically tuned to family names, and may not work well at all for general text.\\n *\\n * @since 1.6\\n * @version $Id: NameType.java 1429868 2013-01-07 16:08:05Z ggregory $\\n */\\npublic enum NameType {\\n\\n    /** Ashkenazi family names */\\n    ASHKENAZI(\\\"ash\\\"),\\n\\n    /** Generic names and words */\\n    GENERIC(\\\"gen\\\"),\\n\\n    /** Sephardic family names */\\n    SEPHARDIC(\\\"sep\\\");\\n\\n    private final String name;\\n\\n    NameType(final String name) {\\n        this.name = name;\\n    }\\n\\n    /**\\n     * Gets the short version of the name type.\\n     *\\n     * @return the NameType short string\\n     */\\n    public String getName() {\\n        return this.name;\\n    }\\n}\\n\", \"classes\": []}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language.bm;\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.EnumMap;\\nimport java.util.HashSet;\\nimport java.util.Iterator;\\nimport java.util.LinkedHashSet;\\nimport java.util.List;\\nimport java.util.Locale;\\nimport java.util.Map;\\nimport java.util.Set;\\nimport java.util.TreeMap;\\n\\nimport org.apache.commons.codec.language.bm.Languages.LanguageSet;\\nimport org.apache.commons.codec.language.bm.Rule.Phoneme;\\n\\n/**\\n * Converts words into potential phonetic representations.\\n * <p>\\n * This is a two-stage process. Firstly, the word is converted into a phonetic representation that takes\\n * into account the likely source language. Next, this phonetic representation is converted into a\\n * pan-European 'average' representation, allowing comparison between different versions of essentially\\n * the same word from different languages.\\n * <p>\\n * This class is intentionally immutable and thread-safe.\\n * If you wish to alter the settings for a PhoneticEngine, you\\n * must make a new one with the updated settings.\\n * <p>\\n * Ported from phoneticengine.php\\n *\\n * @since 1.6\\n * @version $Id: PhoneticEngine.java 1694610 2015-08-07 03:47:38Z ggregory $\\n */\\npublic class PhoneticEngine {\\n\\n    /**\\n     * Utility for manipulating a set of phonemes as they are being built up. Not intended for use outside\\n     * this package, and probably not outside the {@link PhoneticEngine} class.\\n     *\\n     * @since 1.6\\n     */\\n    static final class PhonemeBuilder {\\n\\n        /**\\n         * An empty builder where all phonemes must come from some set of languages. This will contain a single\\n         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new\\n         * phoneme from scratch.\\n         *\\n         * @param languages the set of languages\\n         * @return  a new, empty phoneme builder\\n         */\\n        public static PhonemeBuilder empty(final Languages.LanguageSet languages) {\\n            return new PhonemeBuilder(new Rule.Phoneme(\\\"\\\", languages));\\n        }\\n\\n        private final Set<Rule.Phoneme> phonemes;\\n\\n        private PhonemeBuilder(final Rule.Phoneme phoneme) {\\n            this.phonemes = new LinkedHashSet<Rule.Phoneme>();\\n            this.phonemes.add(phoneme);\\n        }\\n\\n        private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) {\\n            this.phonemes = phonemes;\\n        }\\n\\n        /**\\n         * Creates a new phoneme builder containing all phonemes in this one extended by <code>str</code>.\\n         *\\n         * @param str   the characters to append to the phonemes\\n         */\\n        public void append(final CharSequence str) {\\n            for (final Rule.Phoneme ph : this.phonemes) {\\n                ph.append(str);\\n            }\\n        }\\n\\n        /**\\n         * Applies the given phoneme expression to all phonemes in this phoneme builder.\\n         * <p>\\n         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are\\n         * incompatible.\\n         *\\n         * @param phonemeExpr   the expression to apply\\n         * @param maxPhonemes   the maximum number of phonemes to build up\\n         */\\n        public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\\n            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);\\n\\n            EXPR: for (final Rule.Phoneme left : this.phonemes) {\\n                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\\n                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());\\n                    if (!languages.isEmpty()) {\\n                        final Rule.Phoneme join = new Phoneme(left, right, languages);\\n                        if (newPhonemes.size() < maxPhonemes) {\\n                            newPhonemes.add(join);\\n                            if (newPhonemes.size() >= maxPhonemes) {\\n                                break EXPR;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            this.phonemes.clear();\\n            this.phonemes.addAll(newPhonemes);\\n        }\\n\\n        /**\\n         * Gets underlying phoneme set. Please don't mutate.\\n         *\\n         * @return  the phoneme set\\n         */\\n        public Set<Rule.Phoneme> getPhonemes() {\\n            return this.phonemes;\\n        }\\n\\n        /**\\n         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme,\\n         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially\\n         * expensive operation, which should be avoided when debugging.\\n         *\\n         * @return  the stringified phoneme set\\n         */\\n        public String makeString() {\\n            final StringBuilder sb = new StringBuilder();\\n\\n            for (final Rule.Phoneme ph : this.phonemes) {\\n                if (sb.length() > 0) {\\n                    sb.append(\\\"|\\\");\\n                }\\n                sb.append(ph.getPhonemeText());\\n            }\\n\\n            return sb.toString();\\n        }\\n    }\\n\\n    /**\\n     * A function closure capturing the application of a list of rules to an input sequence at a particular offset.\\n     * After invocation, the values <code>i</code> and <code>found</code> are updated. <code>i</code> points to the\\n     * index of the next char in <code>input</code> that must be processed next (the input up to that index having been\\n     * processed already), and <code>found</code> indicates if a matching rule was found or not. In the case where a\\n     * matching rule was found, <code>phonemeBuilder</code> is replaced with a new builder containing the phonemes\\n     * updated by the matching rule.\\n     *\\n     * Although this class is not thread-safe (it has mutable unprotected fields), it is not shared between threads\\n     * as it is constructed as needed by the calling methods.\\n     * @since 1.6\\n     */\\n    private static final class RulesApplication {\\n        private final Map<String, List<Rule>> finalRules;\\n        private final CharSequence input;\\n\\n        private final PhonemeBuilder phonemeBuilder;\\n        private int i;\\n        private final int maxPhonemes;\\n        private boolean found;\\n\\n        public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input,\\n                                final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {\\n            if (finalRules == null) {\\n                throw new NullPointerException(\\\"The finalRules argument must not be null\\\");\\n            }\\n            this.finalRules = finalRules;\\n            this.phonemeBuilder = phonemeBuilder;\\n            this.input = input;\\n            this.i = i;\\n            this.maxPhonemes = maxPhonemes;\\n        }\\n\\n        public int getI() {\\n            return this.i;\\n        }\\n\\n        public PhonemeBuilder getPhonemeBuilder() {\\n            return this.phonemeBuilder;\\n        }\\n\\n        /**\\n         * Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context\\n         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no\\n         * match, <code>i</code> is advanced one and the character is silently dropped from the phonetic spelling.\\n         *\\n         * @return <code>this</code>\\n         */\\n        public RulesApplication invoke() {\\n            this.found = false;\\n            int patternLength = 1;\\n            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));\\n            if (rules != null) {\\n                for (final Rule rule : rules) {\\n                    final String pattern = rule.getPattern();\\n                    patternLength = pattern.length();\\n                    if (rule.patternAndContextMatches(this.input, this.i)) {\\n                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\\n                        this.found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if (!this.found) {\\n                patternLength = 1;\\n            }\\n\\n            this.i += patternLength;\\n            return this;\\n        }\\n\\n        public boolean isFound() {\\n            return this.found;\\n        }\\n    }\\n\\n    private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class);\\n\\n    static {\\n        NAME_PREFIXES.put(NameType.ASHKENAZI,\\n                Collections.unmodifiableSet(\\n                        new HashSet<String>(Arrays.asList(\\\"bar\\\", \\\"ben\\\", \\\"da\\\", \\\"de\\\", \\\"van\\\", \\\"von\\\"))));\\n        NAME_PREFIXES.put(NameType.SEPHARDIC,\\n                Collections.unmodifiableSet(\\n                        new HashSet<String>(Arrays.asList(\\\"al\\\", \\\"el\\\", \\\"da\\\", \\\"dal\\\", \\\"de\\\", \\\"del\\\", \\\"dela\\\", \\\"de la\\\",\\n                                                          \\\"della\\\", \\\"des\\\", \\\"di\\\", \\\"do\\\", \\\"dos\\\", \\\"du\\\", \\\"van\\\", \\\"von\\\"))));\\n        NAME_PREFIXES.put(NameType.GENERIC,\\n                Collections.unmodifiableSet(\\n                        new HashSet<String>(Arrays.asList(\\\"da\\\", \\\"dal\\\", \\\"de\\\", \\\"del\\\", \\\"dela\\\", \\\"de la\\\", \\\"della\\\",\\n                                                          \\\"des\\\", \\\"di\\\", \\\"do\\\", \\\"dos\\\", \\\"du\\\", \\\"van\\\", \\\"von\\\"))));\\n    }\\n\\n    /**\\n     * Joins some strings with an internal separator.\\n     * @param strings   Strings to join\\n     * @param sep       String to separate them with\\n     * @return a single String consisting of each element of <code>strings</code> interleaved by <code>sep</code>\\n     */\\n    private static String join(final Iterable<String> strings, final String sep) {\\n        final StringBuilder sb = new StringBuilder();\\n        final Iterator<String> si = strings.iterator();\\n        if (si.hasNext()) {\\n            sb.append(si.next());\\n        }\\n        while (si.hasNext()) {\\n            sb.append(sep).append(si.next());\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    private static final int DEFAULT_MAX_PHONEMES = 20;\\n\\n    private final Lang lang;\\n\\n    private final NameType nameType;\\n\\n    private final RuleType ruleType;\\n\\n    private final boolean concat;\\n\\n    private final int maxPhonemes;\\n\\n    /**\\n     * Generates a new, fully-configured phonetic engine.\\n     *\\n     * @param nameType\\n     *            the type of names it will use\\n     * @param ruleType\\n     *            the type of rules it will apply\\n     * @param concat\\n     *            if it will concatenate multiple encodings\\n     */\\n    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {\\n        this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);\\n    }\\n\\n    /**\\n     * Generates a new, fully-configured phonetic engine.\\n     *\\n     * @param nameType\\n     *            the type of names it will use\\n     * @param ruleType\\n     *            the type of rules it will apply\\n     * @param concat\\n     *            if it will concatenate multiple encodings\\n     * @param maxPhonemes\\n     *            the maximum number of phonemes that will be handled\\n     * @since 1.7\\n     */\\n    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat,\\n                          final int maxPhonemes) {\\n        if (ruleType == RuleType.RULES) {\\n            throw new IllegalArgumentException(\\\"ruleType must not be \\\" + RuleType.RULES);\\n        }\\n        this.nameType = nameType;\\n        this.ruleType = ruleType;\\n        this.concat = concat;\\n        this.lang = Lang.instance(nameType);\\n        this.maxPhonemes = maxPhonemes;\\n    }\\n\\n    /**\\n     * Applies the final rules to convert from a language-specific phonetic representation to a\\n     * language-independent representation.\\n     *\\n     * @param phonemeBuilder the current phonemes\\n     * @param finalRules the final rules to apply\\n     * @return the resulting phonemes\\n     */\\n    private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,\\n                                           final Map<String, List<Rule>> finalRules) {\\n        if (finalRules == null) {\\n            throw new NullPointerException(\\\"finalRules can not be null\\\");\\n        }\\n        if (finalRules.isEmpty()) {\\n            return phonemeBuilder;\\n        }\\n\\n        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =\\n            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\\n\\n        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\\n            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\\n            final String phonemeText = phoneme.getPhonemeText().toString();\\n\\n            for (int i = 0; i < phonemeText.length();) {\\n                final RulesApplication rulesApplication =\\n                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\\n                final boolean found = rulesApplication.isFound();\\n                subBuilder = rulesApplication.getPhonemeBuilder();\\n\\n                if (!found) {\\n                    // not found, appending as-is\\n                    subBuilder.append(phonemeText.subSequence(i, i + 1));\\n                }\\n\\n                i = rulesApplication.getI();\\n            }\\n\\n            // the phonemes map orders the phonemes only based on their text, but ignores the language set\\n            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise\\n            // phonemes with the same text but different language set get lost\\n            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {\\n                if (phonemes.containsKey(newPhoneme)) {\\n                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);\\n                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());\\n                    phonemes.put(mergedPhoneme, mergedPhoneme);\\n                } else {\\n                    phonemes.put(newPhoneme, newPhoneme);\\n                }\\n            }\\n        }\\n\\n        return new PhonemeBuilder(phonemes.keySet());\\n    }\\n\\n    /**\\n     * Encodes a string to its phonetic representation.\\n     *\\n     * @param input\\n     *            the String to encode\\n     * @return the encoding of the input\\n     */\\n    public String encode(final String input) {\\n        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\\n        return encode(input, languageSet);\\n    }\\n\\n    /**\\n     * Encodes an input string into an output phonetic representation, given a set of possible origin languages.\\n     *\\n     * @param input\\n     *            String to phoneticise; a String with dashes or spaces separating each word\\n     * @param languageSet\\n     *            set of possible origin languages\\n     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations of the\\n     *         input\\n     */\\n    public String encode(String input, final Languages.LanguageSet languageSet) {\\n        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\\n        // rules common across many (all) languages\\n        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \\\"common\\\");\\n        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\\n        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\\n\\n        // tidy the input\\n        // lower case is a locale-dependent operation\\n        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\\n\\n        if (this.nameType == NameType.GENERIC) {\\n            if (input.length() >= 2 && input.substring(0, 2).equals(\\\"d'\\\")) { // check for d'\\n                final String remainder = input.substring(2);\\n                final String combined = \\\"d\\\" + remainder;\\n                return \\\"(\\\" + encode(remainder) + \\\")-(\\\" + encode(combined) + \\\")\\\";\\n            }\\n            for (final String l : NAME_PREFIXES.get(this.nameType)) {\\n                // handle generic prefixes\\n                if (input.startsWith(l + \\\" \\\")) {\\n                    // check for any prefix in the words list\\n                    final String remainder = input.substring(l.length() + 1); // input without the prefix\\n                    final String combined = l + remainder; // input with prefix without space\\n                    return \\\"(\\\" + encode(remainder) + \\\")-(\\\" + encode(combined) + \\\")\\\";\\n                }\\n            }\\n        }\\n\\n        final List<String> words = Arrays.asList(input.split(\\\"\\\\\\\\s+\\\"));\\n        final List<String> words2 = new ArrayList<String>();\\n\\n        // special-case handling of word prefixes based upon the name type\\n        switch (this.nameType) {\\n        case SEPHARDIC:\\n            for (final String aWord : words) {\\n                final String[] parts = aWord.split(\\\"'\\\");\\n                final String lastPart = parts[parts.length - 1];\\n                words2.add(lastPart);\\n            }\\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\\n            break;\\n        case ASHKENAZI:\\n            words2.addAll(words);\\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\\n            break;\\n        case GENERIC:\\n            words2.addAll(words);\\n            break;\\n        default:\\n            throw new IllegalStateException(\\\"Unreachable case: \\\" + this.nameType);\\n        }\\n\\n        if (this.concat) {\\n            // concat mode enabled\\n            input = join(words2, \\\" \\\");\\n        } else if (words2.size() == 1) {\\n            // not a multi-word name\\n            input = words.iterator().next();\\n        } else {\\n            // encode each word in a multi-word name separately (normally used for approx matches)\\n            final StringBuilder result = new StringBuilder();\\n            for (final String word : words2) {\\n                result.append(\\\"-\\\").append(encode(word));\\n            }\\n            // return the result without the leading \\\"-\\\"\\n            return result.substring(1);\\n        }\\n\\n        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\\n\\n        // loop over each char in the input - we will handle the increment manually\\n        for (int i = 0; i < input.length();) {\\n            final RulesApplication rulesApplication =\\n                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\\n            i = rulesApplication.getI();\\n            phonemeBuilder = rulesApplication.getPhonemeBuilder();\\n        }\\n\\n        // Apply the general rules\\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\\n        // Apply the language-specific rules\\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\\n\\n        return phonemeBuilder.makeString();\\n    }\\n\\n    /**\\n     * Gets the Lang language guessing rules being used.\\n     *\\n     * @return the Lang in use\\n     */\\n    public Lang getLang() {\\n        return this.lang;\\n    }\\n\\n    /**\\n     * Gets the NameType being used.\\n     *\\n     * @return the NameType in use\\n     */\\n    public NameType getNameType() {\\n        return this.nameType;\\n    }\\n\\n    /**\\n     * Gets the RuleType being used.\\n     *\\n     * @return the RuleType in use\\n     */\\n    public RuleType getRuleType() {\\n        return this.ruleType;\\n    }\\n\\n    /**\\n     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\\n     *\\n     * @return true if multiple phonetic encodings are returned, false if just the first is\\n     */\\n    public boolean isConcat() {\\n        return this.concat;\\n    }\\n\\n    /**\\n     * Gets the maximum number of phonemes the engine will calculate for a given input.\\n     *\\n     * @return the maximum number of phonemes\\n     * @since 1.7\\n     */\\n    public int getMaxPhonemes() {\\n        return this.maxPhonemes;\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"PhoneticEngine\", \"position\": {\"start_line\": 53, \"end_line\": 529, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class PhoneticEngine {\\n\\n    /**\\n     * Utility for manipulating a set of phonemes as they are being built up. Not intended for use outside\\n     * this package, and probably not outside the {@link PhoneticEngine} class.\\n     *\\n     * @since 1.6\\n     */\\n    static final class PhonemeBuilder {\\n\\n        /**\\n         * An empty builder where all phonemes must come from some set of languages. This will contain a single\\n         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new\\n         * phoneme from scratch.\\n         *\\n         * @param languages the set of languages\\n         * @return  a new, empty phoneme builder\\n         */\\n        public static PhonemeBuilder empty(final Languages.LanguageSet languages) {\\n            return new PhonemeBuilder(new Rule.Phoneme(\\\"\\\", languages));\\n        }\\n\\n        private final Set<Rule.Phoneme> phonemes;\\n\\n        private PhonemeBuilder(final Rule.Phoneme phoneme) {\\n            this.phonemes = new LinkedHashSet<Rule.Phoneme>();\\n            this.phonemes.add(phoneme);\\n        }\\n\\n        private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) {\\n            this.phonemes = phonemes;\\n        }\\n\\n        /**\\n         * Creates a new phoneme builder containing all phonemes in this one extended by <code>str</code>.\\n         *\\n         * @param str   the characters to append to the phonemes\\n         */\\n        public void append(final CharSequence str) {\\n            for (final Rule.Phoneme ph : this.phonemes) {\\n                ph.append(str);\\n            }\\n        }\\n\\n        /**\\n         * Applies the given phoneme expression to all phonemes in this phoneme builder.\\n         * <p>\\n         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are\\n         * incompatible.\\n         *\\n         * @param phonemeExpr   the expression to apply\\n         * @param maxPhonemes   the maximum number of phonemes to build up\\n         */\\n        public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\\n            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);\\n\\n            EXPR: for (final Rule.Phoneme left : this.phonemes) {\\n                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\\n                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());\\n                    if (!languages.isEmpty()) {\\n                        final Rule.Phoneme join = new Phoneme(left, right, languages);\\n                        if (newPhonemes.size() < maxPhonemes) {\\n                            newPhonemes.add(join);\\n                            if (newPhonemes.size() >= maxPhonemes) {\\n                                break EXPR;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            this.phonemes.clear();\\n            this.phonemes.addAll(newPhonemes);\\n        }\\n\\n        /**\\n         * Gets underlying phoneme set. Please don't mutate.\\n         *\\n         * @return  the phoneme set\\n         */\\n        public Set<Rule.Phoneme> getPhonemes() {\\n            return this.phonemes;\\n        }\\n\\n        /**\\n         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme,\\n         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially\\n         * expensive operation, which should be avoided when debugging.\\n         *\\n         * @return  the stringified phoneme set\\n         */\\n        public String makeString() {\\n            final StringBuilder sb = new StringBuilder();\\n\\n            for (final Rule.Phoneme ph : this.phonemes) {\\n                if (sb.length() > 0) {\\n                    sb.append(\\\"|\\\");\\n                }\\n                sb.append(ph.getPhonemeText());\\n            }\\n\\n            return sb.toString();\\n        }\\n    }\\n\\n    /**\\n     * A function closure capturing the application of a list of rules to an input sequence at a particular offset.\\n     * After invocation, the values <code>i</code> and <code>found</code> are updated. <code>i</code> points to the\\n     * index of the next char in <code>input</code> that must be processed next (the input up to that index having been\\n     * processed already), and <code>found</code> indicates if a matching rule was found or not. In the case where a\\n     * matching rule was found, <code>phonemeBuilder</code> is replaced with a new builder containing the phonemes\\n     * updated by the matching rule.\\n     *\\n     * Although this class is not thread-safe (it has mutable unprotected fields), it is not shared between threads\\n     * as it is constructed as needed by the calling methods.\\n     * @since 1.6\\n     */\\n    private static final class RulesApplication {\\n        private final Map<String, List<Rule>> finalRules;\\n        private final CharSequence input;\\n\\n        private final PhonemeBuilder phonemeBuilder;\\n        private int i;\\n        private final int maxPhonemes;\\n        private boolean found;\\n\\n        public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input,\\n                                final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {\\n            if (finalRules == null) {\\n                throw new NullPointerException(\\\"The finalRules argument must not be null\\\");\\n            }\\n            this.finalRules = finalRules;\\n            this.phonemeBuilder = phonemeBuilder;\\n            this.input = input;\\n            this.i = i;\\n            this.maxPhonemes = maxPhonemes;\\n        }\\n\\n        public int getI() {\\n            return this.i;\\n        }\\n\\n        public PhonemeBuilder getPhonemeBuilder() {\\n            return this.phonemeBuilder;\\n        }\\n\\n        /**\\n         * Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context\\n         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no\\n         * match, <code>i</code> is advanced one and the character is silently dropped from the phonetic spelling.\\n         *\\n         * @return <code>this</code>\\n         */\\n        public RulesApplication invoke() {\\n            this.found = false;\\n            int patternLength = 1;\\n            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));\\n            if (rules != null) {\\n                for (final Rule rule : rules) {\\n                    final String pattern = rule.getPattern();\\n                    patternLength = pattern.length();\\n                    if (rule.patternAndContextMatches(this.input, this.i)) {\\n                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\\n                        this.found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if (!this.found) {\\n                patternLength = 1;\\n            }\\n\\n            this.i += patternLength;\\n            return this;\\n        }\\n\\n        public boolean isFound() {\\n            return this.found;\\n        }\\n    }\\n\\n    private static final Map<NameType, Set<String>> NAME_PREFIXES = new EnumMap<NameType, Set<String>>(NameType.class);\\n\\n    static {\\n        NAME_PREFIXES.put(NameType.ASHKENAZI,\\n                Collections.unmodifiableSet(\\n                        new HashSet<String>(Arrays.asList(\\\"bar\\\", \\\"ben\\\", \\\"da\\\", \\\"de\\\", \\\"van\\\", \\\"von\\\"))));\\n        NAME_PREFIXES.put(NameType.SEPHARDIC,\\n                Collections.unmodifiableSet(\\n                        new HashSet<String>(Arrays.asList(\\\"al\\\", \\\"el\\\", \\\"da\\\", \\\"dal\\\", \\\"de\\\", \\\"del\\\", \\\"dela\\\", \\\"de la\\\",\\n                                                          \\\"della\\\", \\\"des\\\", \\\"di\\\", \\\"do\\\", \\\"dos\\\", \\\"du\\\", \\\"van\\\", \\\"von\\\"))));\\n        NAME_PREFIXES.put(NameType.GENERIC,\\n                Collections.unmodifiableSet(\\n                        new HashSet<String>(Arrays.asList(\\\"da\\\", \\\"dal\\\", \\\"de\\\", \\\"del\\\", \\\"dela\\\", \\\"de la\\\", \\\"della\\\",\\n                                                          \\\"des\\\", \\\"di\\\", \\\"do\\\", \\\"dos\\\", \\\"du\\\", \\\"van\\\", \\\"von\\\"))));\\n    }\\n\\n    /**\\n     * Joins some strings with an internal separator.\\n     * @param strings   Strings to join\\n     * @param sep       String to separate them with\\n     * @return a single String consisting of each element of <code>strings</code> interleaved by <code>sep</code>\\n     */\\n    private static String join(final Iterable<String> strings, final String sep) {\\n        final StringBuilder sb = new StringBuilder();\\n        final Iterator<String> si = strings.iterator();\\n        if (si.hasNext()) {\\n            sb.append(si.next());\\n        }\\n        while (si.hasNext()) {\\n            sb.append(sep).append(si.next());\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    private static final int DEFAULT_MAX_PHONEMES = 20;\\n\\n    private final Lang lang;\\n\\n    private final NameType nameType;\\n\\n    private final RuleType ruleType;\\n\\n    private final boolean concat;\\n\\n    private final int maxPhonemes;\\n\\n    /**\\n     * Generates a new, fully-configured phonetic engine.\\n     *\\n     * @param nameType\\n     *            the type of names it will use\\n     * @param ruleType\\n     *            the type of rules it will apply\\n     * @param concat\\n     *            if it will concatenate multiple encodings\\n     */\\n    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat) {\\n        this(nameType, ruleType, concat, DEFAULT_MAX_PHONEMES);\\n    }\\n\\n    /**\\n     * Generates a new, fully-configured phonetic engine.\\n     *\\n     * @param nameType\\n     *            the type of names it will use\\n     * @param ruleType\\n     *            the type of rules it will apply\\n     * @param concat\\n     *            if it will concatenate multiple encodings\\n     * @param maxPhonemes\\n     *            the maximum number of phonemes that will be handled\\n     * @since 1.7\\n     */\\n    public PhoneticEngine(final NameType nameType, final RuleType ruleType, final boolean concat,\\n                          final int maxPhonemes) {\\n        if (ruleType == RuleType.RULES) {\\n            throw new IllegalArgumentException(\\\"ruleType must not be \\\" + RuleType.RULES);\\n        }\\n        this.nameType = nameType;\\n        this.ruleType = ruleType;\\n        this.concat = concat;\\n        this.lang = Lang.instance(nameType);\\n        this.maxPhonemes = maxPhonemes;\\n    }\\n\\n    /**\\n     * Applies the final rules to convert from a language-specific phonetic representation to a\\n     * language-independent representation.\\n     *\\n     * @param phonemeBuilder the current phonemes\\n     * @param finalRules the final rules to apply\\n     * @return the resulting phonemes\\n     */\\n    private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,\\n                                           final Map<String, List<Rule>> finalRules) {\\n        if (finalRules == null) {\\n            throw new NullPointerException(\\\"finalRules can not be null\\\");\\n        }\\n        if (finalRules.isEmpty()) {\\n            return phonemeBuilder;\\n        }\\n\\n        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =\\n            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\\n\\n        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\\n            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\\n            final String phonemeText = phoneme.getPhonemeText().toString();\\n\\n            for (int i = 0; i < phonemeText.length();) {\\n                final RulesApplication rulesApplication =\\n                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\\n                final boolean found = rulesApplication.isFound();\\n                subBuilder = rulesApplication.getPhonemeBuilder();\\n\\n                if (!found) {\\n                    // not found, appending as-is\\n                    subBuilder.append(phonemeText.subSequence(i, i + 1));\\n                }\\n\\n                i = rulesApplication.getI();\\n            }\\n\\n            // the phonemes map orders the phonemes only based on their text, but ignores the language set\\n            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise\\n            // phonemes with the same text but different language set get lost\\n            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {\\n                if (phonemes.containsKey(newPhoneme)) {\\n                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);\\n                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());\\n                    phonemes.put(mergedPhoneme, mergedPhoneme);\\n                } else {\\n                    phonemes.put(newPhoneme, newPhoneme);\\n                }\\n            }\\n        }\\n\\n        return new PhonemeBuilder(phonemes.keySet());\\n    }\\n\\n    /**\\n     * Encodes a string to its phonetic representation.\\n     *\\n     * @param input\\n     *            the String to encode\\n     * @return the encoding of the input\\n     */\\n    public String encode(final String input) {\\n        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\\n        return encode(input, languageSet);\\n    }\\n\\n    /**\\n     * Encodes an input string into an output phonetic representation, given a set of possible origin languages.\\n     *\\n     * @param input\\n     *            String to phoneticise; a String with dashes or spaces separating each word\\n     * @param languageSet\\n     *            set of possible origin languages\\n     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations of the\\n     *         input\\n     */\\n    public String encode(String input, final Languages.LanguageSet languageSet) {\\n        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\\n        // rules common across many (all) languages\\n        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \\\"common\\\");\\n        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\\n        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\\n\\n        // tidy the input\\n        // lower case is a locale-dependent operation\\n        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\\n\\n        if (this.nameType == NameType.GENERIC) {\\n            if (input.length() >= 2 && input.substring(0, 2).equals(\\\"d'\\\")) { // check for d'\\n                final String remainder = input.substring(2);\\n                final String combined = \\\"d\\\" + remainder;\\n                return \\\"(\\\" + encode(remainder) + \\\")-(\\\" + encode(combined) + \\\")\\\";\\n            }\\n            for (final String l : NAME_PREFIXES.get(this.nameType)) {\\n                // handle generic prefixes\\n                if (input.startsWith(l + \\\" \\\")) {\\n                    // check for any prefix in the words list\\n                    final String remainder = input.substring(l.length() + 1); // input without the prefix\\n                    final String combined = l + remainder; // input with prefix without space\\n                    return \\\"(\\\" + encode(remainder) + \\\")-(\\\" + encode(combined) + \\\")\\\";\\n                }\\n            }\\n        }\\n\\n        final List<String> words = Arrays.asList(input.split(\\\"\\\\\\\\s+\\\"));\\n        final List<String> words2 = new ArrayList<String>();\\n\\n        // special-case handling of word prefixes based upon the name type\\n        switch (this.nameType) {\\n        case SEPHARDIC:\\n            for (final String aWord : words) {\\n                final String[] parts = aWord.split(\\\"'\\\");\\n                final String lastPart = parts[parts.length - 1];\\n                words2.add(lastPart);\\n            }\\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\\n            break;\\n        case ASHKENAZI:\\n            words2.addAll(words);\\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\\n            break;\\n        case GENERIC:\\n            words2.addAll(words);\\n            break;\\n        default:\\n            throw new IllegalStateException(\\\"Unreachable case: \\\" + this.nameType);\\n        }\\n\\n        if (this.concat) {\\n            // concat mode enabled\\n            input = join(words2, \\\" \\\");\\n        } else if (words2.size() == 1) {\\n            // not a multi-word name\\n            input = words.iterator().next();\\n        } else {\\n            // encode each word in a multi-word name separately (normally used for approx matches)\\n            final StringBuilder result = new StringBuilder();\\n            for (final String word : words2) {\\n                result.append(\\\"-\\\").append(encode(word));\\n            }\\n            // return the result without the leading \\\"-\\\"\\n            return result.substring(1);\\n        }\\n\\n        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\\n\\n        // loop over each char in the input - we will handle the increment manually\\n        for (int i = 0; i < input.length();) {\\n            final RulesApplication rulesApplication =\\n                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\\n            i = rulesApplication.getI();\\n            phonemeBuilder = rulesApplication.getPhonemeBuilder();\\n        }\\n\\n        // Apply the general rules\\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\\n        // Apply the language-specific rules\\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\\n\\n        return phonemeBuilder.makeString();\\n    }\\n\\n    /**\\n     * Gets the Lang language guessing rules being used.\\n     *\\n     * @return the Lang in use\\n     */\\n    public Lang getLang() {\\n        return this.lang;\\n    }\\n\\n    /**\\n     * Gets the NameType being used.\\n     *\\n     * @return the NameType in use\\n     */\\n    public NameType getNameType() {\\n        return this.nameType;\\n    }\\n\\n    /**\\n     * Gets the RuleType being used.\\n     *\\n     * @return the RuleType in use\\n     */\\n    public RuleType getRuleType() {\\n        return this.ruleType;\\n    }\\n\\n    /**\\n     * Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\\n     *\\n     * @return true if multiple phonetic encodings are returned, false if just the first is\\n     */\\n    public boolean isConcat() {\\n        return this.concat;\\n    }\\n\\n    /**\\n     * Gets the maximum number of phonemes the engine will calculate for a given input.\\n     *\\n     * @return the maximum number of phonemes\\n     * @since 1.7\\n     */\\n    public int getMaxPhonemes() {\\n        return this.maxPhonemes;\\n    }\\n}\", \"summary\": \"\", \"methods\": []}, {\"parent_file\": null, \"name\": \"PhonemeBuilder\", \"position\": {\"start_line\": 61, \"end_line\": 156, \"start_column\": 18, \"end_column\": 5}, \"code\": \"class PhonemeBuilder {\\n\\n        /**\\n         * An empty builder where all phonemes must come from some set of languages. This will contain a single\\n         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new\\n         * phoneme from scratch.\\n         *\\n         * @param languages the set of languages\\n         * @return  a new, empty phoneme builder\\n         */\\n        public static PhonemeBuilder empty(final Languages.LanguageSet languages) {\\n            return new PhonemeBuilder(new Rule.Phoneme(\\\"\\\", languages));\\n        }\\n\\n        private final Set<Rule.Phoneme> phonemes;\\n\\n        private PhonemeBuilder(final Rule.Phoneme phoneme) {\\n            this.phonemes = new LinkedHashSet<Rule.Phoneme>();\\n            this.phonemes.add(phoneme);\\n        }\\n\\n        private PhonemeBuilder(final Set<Rule.Phoneme> phonemes) {\\n            this.phonemes = phonemes;\\n        }\\n\\n        /**\\n         * Creates a new phoneme builder containing all phonemes in this one extended by <code>str</code>.\\n         *\\n         * @param str   the characters to append to the phonemes\\n         */\\n        public void append(final CharSequence str) {\\n            for (final Rule.Phoneme ph : this.phonemes) {\\n                ph.append(str);\\n            }\\n        }\\n\\n        /**\\n         * Applies the given phoneme expression to all phonemes in this phoneme builder.\\n         * <p>\\n         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are\\n         * incompatible.\\n         *\\n         * @param phonemeExpr   the expression to apply\\n         * @param maxPhonemes   the maximum number of phonemes to build up\\n         */\\n        public void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\\n            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);\\n\\n            EXPR: for (final Rule.Phoneme left : this.phonemes) {\\n                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\\n                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());\\n                    if (!languages.isEmpty()) {\\n                        final Rule.Phoneme join = new Phoneme(left, right, languages);\\n                        if (newPhonemes.size() < maxPhonemes) {\\n                            newPhonemes.add(join);\\n                            if (newPhonemes.size() >= maxPhonemes) {\\n                                break EXPR;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            this.phonemes.clear();\\n            this.phonemes.addAll(newPhonemes);\\n        }\\n\\n        /**\\n         * Gets underlying phoneme set. Please don't mutate.\\n         *\\n         * @return  the phoneme set\\n         */\\n        public Set<Rule.Phoneme> getPhonemes() {\\n            return this.phonemes;\\n        }\\n\\n        /**\\n         * Stringifies the phoneme set. This produces a single string of the strings of each phoneme,\\n         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially\\n         * expensive operation, which should be avoided when debugging.\\n         *\\n         * @return  the stringified phoneme set\\n         */\\n        public String makeString() {\\n            final StringBuilder sb = new StringBuilder();\\n\\n            for (final Rule.Phoneme ph : this.phonemes) {\\n                if (sb.length() > 0) {\\n                    sb.append(\\\"|\\\");\\n                }\\n                sb.append(ph.getPhonemeText());\\n            }\\n\\n            return sb.toString();\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"empty\", \"return_type\": \"PhonemeBuilder\", \"position\": {\"start_line\": 71, \"end_line\": 73, \"start_column\": 23, \"end_column\": 9}, \"code\": \"PhonemeBuilder empty(final Languages.LanguageSet languages) {\\n            return new PhonemeBuilder(new Rule.Phoneme(\\\"\\\", languages));\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"languages\", \"type\": \"Languages.LanguageSet\"}]}, {\"name\": \"append\", \"return_type\": \"void\", \"position\": {\"start_line\": 91, \"end_line\": 95, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void append(final CharSequence str) {\\n            for (final Rule.Phoneme ph : this.phonemes) {\\n                ph.append(str);\\n            }\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"CharSequence\"}]}, {\"name\": \"apply\", \"return_type\": \"void\", \"position\": {\"start_line\": 106, \"end_line\": 126, \"start_column\": 16, \"end_column\": 9}, \"code\": \"void apply(final Rule.PhonemeExpr phonemeExpr, final int maxPhonemes) {\\n            final Set<Rule.Phoneme> newPhonemes = new LinkedHashSet<Rule.Phoneme>(maxPhonemes);\\n\\n            EXPR: for (final Rule.Phoneme left : this.phonemes) {\\n                for (final Rule.Phoneme right : phonemeExpr.getPhonemes()) {\\n                    final LanguageSet languages = left.getLanguages().restrictTo(right.getLanguages());\\n                    if (!languages.isEmpty()) {\\n                        final Rule.Phoneme join = new Phoneme(left, right, languages);\\n                        if (newPhonemes.size() < maxPhonemes) {\\n                            newPhonemes.add(join);\\n                            if (newPhonemes.size() >= maxPhonemes) {\\n                                break EXPR;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            this.phonemes.clear();\\n            this.phonemes.addAll(newPhonemes);\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"phonemeExpr\", \"type\": \"Rule.PhonemeExpr\"}, {\"name\": \"maxPhonemes\", \"type\": \"int\"}]}, {\"name\": \"getPhonemes\", \"return_type\": \"Set\", \"position\": {\"start_line\": 133, \"end_line\": 135, \"start_column\": 16, \"end_column\": 9}, \"code\": \"Set<Rule.Phoneme> getPhonemes() {\\n            return this.phonemes;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"makeString\", \"return_type\": \"String\", \"position\": {\"start_line\": 144, \"end_line\": 155, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String makeString() {\\n            final StringBuilder sb = new StringBuilder();\\n\\n            for (final Rule.Phoneme ph : this.phonemes) {\\n                if (sb.length() > 0) {\\n                    sb.append(\\\"|\\\");\\n                }\\n                sb.append(ph.getPhonemeText());\\n            }\\n\\n            return sb.toString();\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}, {\"parent_file\": null, \"name\": \"RulesApplication\", \"position\": {\"start_line\": 170, \"end_line\": 233, \"start_column\": 26, \"end_column\": 5}, \"code\": \"class RulesApplication {\\n        private final Map<String, List<Rule>> finalRules;\\n        private final CharSequence input;\\n\\n        private final PhonemeBuilder phonemeBuilder;\\n        private int i;\\n        private final int maxPhonemes;\\n        private boolean found;\\n\\n        public RulesApplication(final Map<String, List<Rule>> finalRules, final CharSequence input,\\n                                final PhonemeBuilder phonemeBuilder, final int i, final int maxPhonemes) {\\n            if (finalRules == null) {\\n                throw new NullPointerException(\\\"The finalRules argument must not be null\\\");\\n            }\\n            this.finalRules = finalRules;\\n            this.phonemeBuilder = phonemeBuilder;\\n            this.input = input;\\n            this.i = i;\\n            this.maxPhonemes = maxPhonemes;\\n        }\\n\\n        public int getI() {\\n            return this.i;\\n        }\\n\\n        public PhonemeBuilder getPhonemeBuilder() {\\n            return this.phonemeBuilder;\\n        }\\n\\n        /**\\n         * Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context\\n         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no\\n         * match, <code>i</code> is advanced one and the character is silently dropped from the phonetic spelling.\\n         *\\n         * @return <code>this</code>\\n         */\\n        public RulesApplication invoke() {\\n            this.found = false;\\n            int patternLength = 1;\\n            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));\\n            if (rules != null) {\\n                for (final Rule rule : rules) {\\n                    final String pattern = rule.getPattern();\\n                    patternLength = pattern.length();\\n                    if (rule.patternAndContextMatches(this.input, this.i)) {\\n                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\\n                        this.found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if (!this.found) {\\n                patternLength = 1;\\n            }\\n\\n            this.i += patternLength;\\n            return this;\\n        }\\n\\n        public boolean isFound() {\\n            return this.found;\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"getI\", \"return_type\": \"int\", \"position\": {\"start_line\": 191, \"end_line\": 193, \"start_column\": 16, \"end_column\": 9}, \"code\": \"int getI() {\\n            return this.i;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getPhonemeBuilder\", \"return_type\": \"PhonemeBuilder\", \"position\": {\"start_line\": 195, \"end_line\": 197, \"start_column\": 16, \"end_column\": 9}, \"code\": \"PhonemeBuilder getPhonemeBuilder() {\\n            return this.phonemeBuilder;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"invoke\", \"return_type\": \"RulesApplication\", \"position\": {\"start_line\": 206, \"end_line\": 228, \"start_column\": 16, \"end_column\": 9}, \"code\": \"RulesApplication invoke() {\\n            this.found = false;\\n            int patternLength = 1;\\n            final List<Rule> rules = this.finalRules.get(input.subSequence(i, i+patternLength));\\n            if (rules != null) {\\n                for (final Rule rule : rules) {\\n                    final String pattern = rule.getPattern();\\n                    patternLength = pattern.length();\\n                    if (rule.patternAndContextMatches(this.input, this.i)) {\\n                        this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes);\\n                        this.found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if (!this.found) {\\n                patternLength = 1;\\n            }\\n\\n            this.i += patternLength;\\n            return this;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isFound\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 230, \"end_line\": 232, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean isFound() {\\n            return this.found;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"join\", \"return_type\": \"String\", \"position\": {\"start_line\": 257, \"end_line\": 268, \"start_column\": 20, \"end_column\": 5}, \"code\": \"String join(final Iterable<String> strings, final String sep) {\\n        final StringBuilder sb = new StringBuilder();\\n        final Iterator<String> si = strings.iterator();\\n        if (si.hasNext()) {\\n            sb.append(si.next());\\n        }\\n        while (si.hasNext()) {\\n            sb.append(sep).append(si.next());\\n        }\\n\\n        return sb.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"strings\", \"type\": \"Iterable\"}, {\"name\": \"sep\", \"type\": \"String\"}]}, {\"name\": \"applyFinalRules\", \"return_type\": \"PhonemeBuilder\", \"position\": {\"start_line\": 329, \"end_line\": 374, \"start_column\": 13, \"end_column\": 5}, \"code\": \"PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,\\n                                           final Map<String, List<Rule>> finalRules) {\\n        if (finalRules == null) {\\n            throw new NullPointerException(\\\"finalRules can not be null\\\");\\n        }\\n        if (finalRules.isEmpty()) {\\n            return phonemeBuilder;\\n        }\\n\\n        final Map<Rule.Phoneme, Rule.Phoneme> phonemes =\\n            new TreeMap<Rule.Phoneme, Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\\n\\n        for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\\n            PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\\n            final String phonemeText = phoneme.getPhonemeText().toString();\\n\\n            for (int i = 0; i < phonemeText.length();) {\\n                final RulesApplication rulesApplication =\\n                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\\n                final boolean found = rulesApplication.isFound();\\n                subBuilder = rulesApplication.getPhonemeBuilder();\\n\\n                if (!found) {\\n                    // not found, appending as-is\\n                    subBuilder.append(phonemeText.subSequence(i, i + 1));\\n                }\\n\\n                i = rulesApplication.getI();\\n            }\\n\\n            // the phonemes map orders the phonemes only based on their text, but ignores the language set\\n            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise\\n            // phonemes with the same text but different language set get lost\\n            for (final Rule.Phoneme newPhoneme : subBuilder.getPhonemes()) {\\n                if (phonemes.containsKey(newPhoneme)) {\\n                    final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme);\\n                    final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());\\n                    phonemes.put(mergedPhoneme, mergedPhoneme);\\n                } else {\\n                    phonemes.put(newPhoneme, newPhoneme);\\n                }\\n            }\\n        }\\n\\n        return new PhonemeBuilder(phonemes.keySet());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"phonemeBuilder\", \"type\": \"PhonemeBuilder\"}, {\"name\": \"finalRules\", \"type\": \"Map\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 383, \"end_line\": 386, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String input) {\\n        final Languages.LanguageSet languageSet = this.lang.guessLanguages(input);\\n        return encode(input, languageSet);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 398, \"end_line\": 482, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(String input, final Languages.LanguageSet languageSet) {\\n        final Map<String, List<Rule>> rules = Rule.getInstanceMap(this.nameType, RuleType.RULES, languageSet);\\n        // rules common across many (all) languages\\n        final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, \\\"common\\\");\\n        // rules that apply to a specific language that may be ambiguous or wrong if applied to other languages\\n        final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet);\\n\\n        // tidy the input\\n        // lower case is a locale-dependent operation\\n        input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim();\\n\\n        if (this.nameType == NameType.GENERIC) {\\n            if (input.length() >= 2 && input.substring(0, 2).equals(\\\"d'\\\")) { // check for d'\\n                final String remainder = input.substring(2);\\n                final String combined = \\\"d\\\" + remainder;\\n                return \\\"(\\\" + encode(remainder) + \\\")-(\\\" + encode(combined) + \\\")\\\";\\n            }\\n            for (final String l : NAME_PREFIXES.get(this.nameType)) {\\n                // handle generic prefixes\\n                if (input.startsWith(l + \\\" \\\")) {\\n                    // check for any prefix in the words list\\n                    final String remainder = input.substring(l.length() + 1); // input without the prefix\\n                    final String combined = l + remainder; // input with prefix without space\\n                    return \\\"(\\\" + encode(remainder) + \\\")-(\\\" + encode(combined) + \\\")\\\";\\n                }\\n            }\\n        }\\n\\n        final List<String> words = Arrays.asList(input.split(\\\"\\\\\\\\s+\\\"));\\n        final List<String> words2 = new ArrayList<String>();\\n\\n        // special-case handling of word prefixes based upon the name type\\n        switch (this.nameType) {\\n        case SEPHARDIC:\\n            for (final String aWord : words) {\\n                final String[] parts = aWord.split(\\\"'\\\");\\n                final String lastPart = parts[parts.length - 1];\\n                words2.add(lastPart);\\n            }\\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\\n            break;\\n        case ASHKENAZI:\\n            words2.addAll(words);\\n            words2.removeAll(NAME_PREFIXES.get(this.nameType));\\n            break;\\n        case GENERIC:\\n            words2.addAll(words);\\n            break;\\n        default:\\n            throw new IllegalStateException(\\\"Unreachable case: \\\" + this.nameType);\\n        }\\n\\n        if (this.concat) {\\n            // concat mode enabled\\n            input = join(words2, \\\" \\\");\\n        } else if (words2.size() == 1) {\\n            // not a multi-word name\\n            input = words.iterator().next();\\n        } else {\\n            // encode each word in a multi-word name separately (normally used for approx matches)\\n            final StringBuilder result = new StringBuilder();\\n            for (final String word : words2) {\\n                result.append(\\\"-\\\").append(encode(word));\\n            }\\n            // return the result without the leading \\\"-\\\"\\n            return result.substring(1);\\n        }\\n\\n        PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet);\\n\\n        // loop over each char in the input - we will handle the increment manually\\n        for (int i = 0; i < input.length();) {\\n            final RulesApplication rulesApplication =\\n                    new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke();\\n            i = rulesApplication.getI();\\n            phonemeBuilder = rulesApplication.getPhonemeBuilder();\\n        }\\n\\n        // Apply the general rules\\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1);\\n        // Apply the language-specific rules\\n        phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2);\\n\\n        return phonemeBuilder.makeString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"String\"}, {\"name\": \"languageSet\", \"type\": \"Languages.LanguageSet\"}]}, {\"name\": \"getLang\", \"return_type\": \"Lang\", \"position\": {\"start_line\": 489, \"end_line\": 491, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Lang getLang() {\\n        return this.lang;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getNameType\", \"return_type\": \"NameType\", \"position\": {\"start_line\": 498, \"end_line\": 500, \"start_column\": 12, \"end_column\": 5}, \"code\": \"NameType getNameType() {\\n        return this.nameType;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getRuleType\", \"return_type\": \"RuleType\", \"position\": {\"start_line\": 507, \"end_line\": 509, \"start_column\": 12, \"end_column\": 5}, \"code\": \"RuleType getRuleType() {\\n        return this.ruleType;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isConcat\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 516, \"end_line\": 518, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isConcat() {\\n        return this.concat;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getMaxPhonemes\", \"return_type\": \"int\", \"position\": {\"start_line\": 526, \"end_line\": 528, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int getMaxPhonemes() {\\n        return this.maxPhonemes;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/bm/ResourceConstants.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language.bm;\\n\\nimport org.apache.commons.codec.CharEncoding;\\n\\n/**\\n * Constants used to process resource files.\\n *\\n * <p>This class is immutable and thread-safe.</p>\\n *\\n * @since 1.6\\n * @version $Id: ResourceConstants.java 1376690 2012-08-23 20:51:45Z tn $\\n */\\nclass ResourceConstants {\\n\\n    static final String CMT = \\\"//\\\";\\n    static final String ENCODING = CharEncoding.UTF_8;\\n    static final String EXT_CMT_END = \\\"*/\\\";\\n    static final String EXT_CMT_START = \\\"/*\\\";\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"ResourceConstants\", \"position\": {\"start_line\": 30, \"end_line\": 37, \"start_column\": 1, \"end_column\": 1}, \"code\": \"class ResourceConstants {\\n\\n    static final String CMT = \\\"//\\\";\\n    static final String ENCODING = CharEncoding.UTF_8;\\n    static final String EXT_CMT_END = \\\"*/\\\";\\n    static final String EXT_CMT_START = \\\"/*\\\";\\n\\n}\", \"summary\": \"\", \"methods\": []}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/bm/Rule.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language.bm;\\n\\nimport java.io.InputStream;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.Comparator;\\nimport java.util.EnumMap;\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Scanner;\\nimport java.util.Set;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\nimport org.apache.commons.codec.language.bm.Languages.LanguageSet;\\n\\n/**\\n * A phoneme rule.\\n * <p>\\n * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply\\n * and a logical flag indicating if all languages must be in play. A rule matches if:\\n * <ul>\\n * <li>the pattern matches at the current position</li>\\n * <li>the string up until the beginning of the pattern matches the left context</li>\\n * <li>the string from the end of the pattern matches the right context</li>\\n * <li>logical is ALL and all languages are in scope; or</li>\\n * <li>logical is any other value and at least one language is in scope</li>\\n * </ul>\\n * <p>\\n * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user\\n * to explicitly construct their own.\\n * <p>\\n * Rules are immutable and thread-safe.\\n * <p>\\n * <b>Rules resources</b>\\n * <p>\\n * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically\\n * named following the pattern:\\n * <blockquote>org/apache/commons/codec/language/bm/${NameType#getName}_${RuleType#getName}_${language}.txt</blockquote>\\n * <p>\\n * The format of these resources is the following:\\n * <ul>\\n * <li><b>Rules:</b> whitespace separated, double-quoted strings. There should be 4 columns to each row, and these\\n * will be interpreted as:\\n * <ol>\\n * <li>pattern</li>\\n * <li>left context</li>\\n * <li>right context</li>\\n * <li>phoneme</li>\\n * </ol>\\n * </li>\\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be discarded\\n * as a comment.</li>\\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip\\n * all content until a line ending in '*' and '/' is found.</li>\\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\\n * </ul>\\n *\\n * @since 1.6\\n * @version $Id: Rule.java 1760691 2016-09-14 12:14:26Z jochen $\\n */\\npublic class Rule {\\n\\n    public static final class Phoneme implements PhonemeExpr {\\n        public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() {\\n            @Override\\n            public int compare(final Phoneme o1, final Phoneme o2) {\\n                for (int i = 0; i < o1.phonemeText.length(); i++) {\\n                    if (i >= o2.phonemeText.length()) {\\n                        return +1;\\n                    }\\n                    final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\\n                    if (c != 0) {\\n                        return c;\\n                    }\\n                }\\n\\n                if (o1.phonemeText.length() < o2.phonemeText.length()) {\\n                    return -1;\\n                }\\n\\n                return 0;\\n            }\\n        };\\n\\n        private final StringBuilder phonemeText;\\n        private final Languages.LanguageSet languages;\\n\\n        public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {\\n            this.phonemeText = new StringBuilder(phonemeText);\\n            this.languages = languages;\\n        }\\n\\n        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight) {\\n            this(phonemeLeft.phonemeText, phonemeLeft.languages);\\n            this.phonemeText.append(phonemeRight.phonemeText);\\n        }\\n\\n        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) {\\n            this(phonemeLeft.phonemeText, languages);\\n            this.phonemeText.append(phonemeRight.phonemeText);\\n        }\\n\\n        public Phoneme append(final CharSequence str) {\\n            this.phonemeText.append(str);\\n            return this;\\n        }\\n\\n        public Languages.LanguageSet getLanguages() {\\n            return this.languages;\\n        }\\n\\n        @Override\\n        public Iterable<Phoneme> getPhonemes() {\\n            return Collections.singleton(this);\\n        }\\n\\n        public CharSequence getPhonemeText() {\\n            return this.phonemeText;\\n        }\\n\\n        /**\\n         * Deprecated since 1.9.\\n         *\\n         * @param right the Phoneme to join\\n         * @return a new Phoneme\\n         * @deprecated since 1.9\\n         */\\n        @Deprecated\\n        public Phoneme join(final Phoneme right) {\\n            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(),\\n                               this.languages.restrictTo(right.languages));\\n        }\\n\\n        /**\\n         * Returns a new Phoneme with the same text but a union of its\\n         * current language set and the given one.\\n         *\\n         * @param lang the language set to merge\\n         * @return a new Phoneme\\n         */\\n        public Phoneme mergeWithLanguage(final LanguageSet lang) {\\n          return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));\\n        }\\n\\n        @Override\\n        public String toString() {\\n          return phonemeText.toString() + \\\"[\\\" + languages + \\\"]\\\";\\n        }\\n    }\\n\\n    public interface PhonemeExpr {\\n        Iterable<Phoneme> getPhonemes();\\n    }\\n\\n    public static final class PhonemeList implements PhonemeExpr {\\n        private final List<Phoneme> phonemes;\\n\\n        public PhonemeList(final List<Phoneme> phonemes) {\\n            this.phonemes = phonemes;\\n        }\\n\\n        @Override\\n        public List<Phoneme> getPhonemes() {\\n            return this.phonemes;\\n        }\\n    }\\n\\n    /**\\n     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.\\n     */\\n    public interface RPattern {\\n        boolean isMatch(CharSequence input);\\n    }\\n\\n    public static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {\\n        @Override\\n        public boolean isMatch(final CharSequence input) {\\n            return true;\\n        }\\n    };\\n\\n    public static final String ALL = \\\"ALL\\\";\\n\\n    private static final String DOUBLE_QUOTE = \\\"\\\\\\\"\\\";\\n\\n    private static final String HASH_INCLUDE = \\\"#include\\\";\\n\\n    private static final Map<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>> RULES =\\n            new EnumMap<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>>(NameType.class);\\n\\n    static {\\n        for (final NameType s : NameType.values()) {\\n            final Map<RuleType, Map<String, Map<String, List<Rule>>>> rts =\\n                    new EnumMap<RuleType, Map<String, Map<String, List<Rule>>>>(RuleType.class);\\n\\n            for (final RuleType rt : RuleType.values()) {\\n                final Map<String, Map<String, List<Rule>>> rs = new HashMap<String, Map<String, List<Rule>>>();\\n\\n                final Languages ls = Languages.getInstance(s);\\n                for (final String l : ls.getLanguages()) {\\n                    final Scanner scanner = createScanner(s, rt, l);\\n                    try {\\n                        rs.put(l, parseRules(scanner, createResourceName(s, rt, l)));\\n                    } catch (final IllegalStateException e) {\\n                        throw new IllegalStateException(\\\"Problem processing \\\" + createResourceName(s, rt, l), e);\\n                    } finally {\\n                        scanner.close();\\n                    }\\n                }\\n                if (!rt.equals(RuleType.RULES)) {\\n                    final Scanner scanner = createScanner(s, rt, \\\"common\\\");\\n                    try {\\n                        rs.put(\\\"common\\\", parseRules(scanner, createResourceName(s, rt, \\\"common\\\")));\\n                    } finally {\\n                        scanner.close();\\n                    }\\n                }\\n\\n                rts.put(rt, Collections.unmodifiableMap(rs));\\n            }\\n\\n            RULES.put(s, Collections.unmodifiableMap(rts));\\n        }\\n    }\\n\\n    private static boolean contains(final CharSequence chars, final char input) {\\n        for (int i = 0; i < chars.length(); i++) {\\n            if (chars.charAt(i) == input) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) {\\n        return String.format(\\\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\\\",\\n                             nameType.getName(), rt.getName(), lang);\\n    }\\n\\n    private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {\\n        final String resName = createResourceName(nameType, rt, lang);\\n        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\\n\\n        if (rulesIS == null) {\\n            throw new IllegalArgumentException(\\\"Unable to load resource: \\\" + resName);\\n        }\\n\\n        return new Scanner(rulesIS, ResourceConstants.ENCODING);\\n    }\\n\\n    private static Scanner createScanner(final String lang) {\\n        final String resName = String.format(\\\"org/apache/commons/codec/language/bm/%s.txt\\\", lang);\\n        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\\n\\n        if (rulesIS == null) {\\n            throw new IllegalArgumentException(\\\"Unable to load resource: \\\" + resName);\\n        }\\n\\n        return new Scanner(rulesIS, ResourceConstants.ENCODING);\\n    }\\n\\n    private static boolean endsWith(final CharSequence input, final CharSequence suffix) {\\n        if (suffix.length() > input.length()) {\\n            return false;\\n        }\\n        for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) {\\n            if (input.charAt(i) != suffix.charAt(j)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * Gets rules for a combination of name type, rule type and languages.\\n     *\\n     * @param nameType\\n     *            the NameType to consider\\n     * @param rt\\n     *            the RuleType to consider\\n     * @param langs\\n     *            the set of languages to consider\\n     * @return a list of Rules that apply\\n     */\\n    public static List<Rule> getInstance(final NameType nameType, final RuleType rt,\\n                                         final Languages.LanguageSet langs) {\\n        final Map<String, List<Rule>> ruleMap = getInstanceMap(nameType, rt, langs);\\n        final List<Rule> allRules = new ArrayList<Rule>();\\n        for (final List<Rule> rules : ruleMap.values()) {\\n            allRules.addAll(rules);\\n        }\\n        return allRules;\\n    }\\n\\n    /**\\n     * Gets rules for a combination of name type, rule type and a single language.\\n     *\\n     * @param nameType\\n     *            the NameType to consider\\n     * @param rt\\n     *            the RuleType to consider\\n     * @param lang\\n     *            the language to consider\\n     * @return a list of Rules that apply\\n     */\\n    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) {\\n        return getInstance(nameType, rt, LanguageSet.from(new HashSet<String>(Arrays.asList(lang))));\\n    }\\n\\n    /**\\n     * Gets rules for a combination of name type, rule type and languages.\\n     *\\n     * @param nameType\\n     *            the NameType to consider\\n     * @param rt\\n     *            the RuleType to consider\\n     * @param langs\\n     *            the set of languages to consider\\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\\n     * @since 1.9\\n     */\\n    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\\n                                                         final Languages.LanguageSet langs) {\\n        return langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) :\\n                                     getInstanceMap(nameType, rt, Languages.ANY);\\n    }\\n\\n    /**\\n     * Gets rules for a combination of name type, rule type and a single language.\\n     *\\n     * @param nameType\\n     *            the NameType to consider\\n     * @param rt\\n     *            the RuleType to consider\\n     * @param lang\\n     *            the language to consider\\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\\n     * @since 1.9\\n     */\\n    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\\n                                                         final String lang) {\\n        final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);\\n\\n        if (rules == null) {\\n            throw new IllegalArgumentException(String.format(\\\"No rules found for %s, %s, %s.\\\",\\n                                               nameType.getName(), rt.getName(), lang));\\n        }\\n\\n        return rules;\\n    }\\n\\n    private static Phoneme parsePhoneme(final String ph) {\\n        final int open = ph.indexOf(\\\"[\\\");\\n        if (open >= 0) {\\n            if (!ph.endsWith(\\\"]\\\")) {\\n                throw new IllegalArgumentException(\\\"Phoneme expression contains a '[' but does not end in ']'\\\");\\n            }\\n            final String before = ph.substring(0, open);\\n            final String in = ph.substring(open + 1, ph.length() - 1);\\n            final Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\\\"[+]\\\")));\\n\\n            return new Phoneme(before, Languages.LanguageSet.from(langs));\\n        }\\n        return new Phoneme(ph, Languages.ANY_LANGUAGE);\\n    }\\n\\n    private static PhonemeExpr parsePhonemeExpr(final String ph) {\\n        if (ph.startsWith(\\\"(\\\")) { // we have a bracketed list of options\\n            if (!ph.endsWith(\\\")\\\")) {\\n                throw new IllegalArgumentException(\\\"Phoneme starts with '(' so must end with ')'\\\");\\n            }\\n\\n            final List<Phoneme> phs = new ArrayList<Phoneme>();\\n            final String body = ph.substring(1, ph.length() - 1);\\n            for (final String part : body.split(\\\"[|]\\\")) {\\n                phs.add(parsePhoneme(part));\\n            }\\n            if (body.startsWith(\\\"|\\\") || body.endsWith(\\\"|\\\")) {\\n                phs.add(new Phoneme(\\\"\\\", Languages.ANY_LANGUAGE));\\n            }\\n\\n            return new PhonemeList(phs);\\n        }\\n        return parsePhoneme(ph);\\n    }\\n\\n    private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) {\\n        final Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>();\\n        int currentLine = 0;\\n\\n        boolean inMultilineComment = false;\\n        while (scanner.hasNextLine()) {\\n            currentLine++;\\n            final String rawLine = scanner.nextLine();\\n            String line = rawLine;\\n\\n            if (inMultilineComment) {\\n                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\\n                    inMultilineComment = false;\\n                }\\n            } else {\\n                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\\n                    inMultilineComment = true;\\n                } else {\\n                    // discard comments\\n                    final int cmtI = line.indexOf(ResourceConstants.CMT);\\n                    if (cmtI >= 0) {\\n                        line = line.substring(0, cmtI);\\n                    }\\n\\n                    // trim leading-trailing whitespace\\n                    line = line.trim();\\n\\n                    if (line.length() == 0) {\\n                        continue; // empty lines can be safely skipped\\n                    }\\n\\n                    if (line.startsWith(HASH_INCLUDE)) {\\n                        // include statement\\n                        final String incl = line.substring(HASH_INCLUDE.length()).trim();\\n                        if (incl.contains(\\\" \\\")) {\\n                            throw new IllegalArgumentException(\\\"Malformed import statement '\\\" + rawLine + \\\"' in \\\" +\\n                                                               location);\\n                        }\\n                        final Scanner hashIncludeScanner = createScanner(incl);\\n                        try {\\n                            lines.putAll(parseRules(hashIncludeScanner, location + \\\"->\\\" + incl));\\n                        } finally {\\n                            hashIncludeScanner.close();\\n                        }\\n                    } else {\\n                        // rule\\n                        final String[] parts = line.split(\\\"\\\\\\\\s+\\\");\\n                        if (parts.length != 4) {\\n                            throw new IllegalArgumentException(\\\"Malformed rule statement split into \\\" + parts.length +\\n                                                               \\\" parts: \\\" + rawLine + \\\" in \\\" + location);\\n                        }\\n                        try {\\n                            final String pat = stripQuotes(parts[0]);\\n                            final String lCon = stripQuotes(parts[1]);\\n                            final String rCon = stripQuotes(parts[2]);\\n                            final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\\n                            final int cLine = currentLine;\\n                            final Rule r = new Rule(pat, lCon, rCon, ph) {\\n                                private final int myLine = cLine;\\n                                private final String loc = location;\\n\\n                                @Override\\n                                public String toString() {\\n                                    final StringBuilder sb = new StringBuilder();\\n                                    sb.append(\\\"Rule\\\");\\n                                    sb.append(\\\"{line=\\\").append(myLine);\\n                                    sb.append(\\\", loc='\\\").append(loc).append('\\\\'');\\n                                    sb.append(\\\", pat='\\\").append(pat).append('\\\\'');\\n                                    sb.append(\\\", lcon='\\\").append(lCon).append('\\\\'');\\n                                    sb.append(\\\", rcon='\\\").append(rCon).append('\\\\'');\\n                                    sb.append('}');\\n                                    return sb.toString();\\n                                }\\n                            };\\n                            final String patternKey = r.pattern.substring(0,1);\\n                            List<Rule> rules = lines.get(patternKey);\\n                            if (rules == null) {\\n                                rules = new ArrayList<Rule>();\\n                                lines.put(patternKey, rules);\\n                            }\\n                            rules.add(r);\\n                        } catch (final IllegalArgumentException e) {\\n                            throw new IllegalStateException(\\\"Problem parsing line '\\\" + currentLine + \\\"' in \\\" +\\n                                                            location, e);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return lines;\\n    }\\n\\n    /**\\n     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.\\n     *\\n     * @param regex\\n     *            the regular expression to compile\\n     * @return an RPattern that will match this regex\\n     */\\n    private static RPattern pattern(final String regex) {\\n        final boolean startsWith = regex.startsWith(\\\"^\\\");\\n        final boolean endsWith = regex.endsWith(\\\"$\\\");\\n        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\\n        final boolean boxes = content.contains(\\\"[\\\");\\n\\n        if (!boxes) {\\n            if (startsWith && endsWith) {\\n                // exact match\\n                if (content.length() == 0) {\\n                    // empty\\n                    return new RPattern() {\\n                        @Override\\n                        public boolean isMatch(final CharSequence input) {\\n                            return input.length() == 0;\\n                        }\\n                    };\\n                }\\n                return new RPattern() {\\n                    @Override\\n                    public boolean isMatch(final CharSequence input) {\\n                        return input.equals(content);\\n                    }\\n                };\\n            } else if ((startsWith || endsWith) && content.length() == 0) {\\n                // matches every string\\n                return ALL_STRINGS_RMATCHER;\\n            } else if (startsWith) {\\n                // matches from start\\n                return new RPattern() {\\n                    @Override\\n                    public boolean isMatch(final CharSequence input) {\\n                        return startsWith(input, content);\\n                    }\\n                };\\n            } else if (endsWith) {\\n                // matches from start\\n                return new RPattern() {\\n                    @Override\\n                    public boolean isMatch(final CharSequence input) {\\n                        return endsWith(input, content);\\n                    }\\n                };\\n            }\\n        } else {\\n            final boolean startsWithBox = content.startsWith(\\\"[\\\");\\n            final boolean endsWithBox = content.endsWith(\\\"]\\\");\\n\\n            if (startsWithBox && endsWithBox) {\\n                String boxContent = content.substring(1, content.length() - 1);\\n                if (!boxContent.contains(\\\"[\\\")) {\\n                    // box containing alternatives\\n                    final boolean negate = boxContent.startsWith(\\\"^\\\");\\n                    if (negate) {\\n                        boxContent = boxContent.substring(1);\\n                    }\\n                    final String bContent = boxContent;\\n                    final boolean shouldMatch = !negate;\\n\\n                    if (startsWith && endsWith) {\\n                        // exact match\\n                        return new RPattern() {\\n                            @Override\\n                            public boolean isMatch(final CharSequence input) {\\n                                return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\\n                            }\\n                        };\\n                    } else if (startsWith) {\\n                        // first char\\n                        return new RPattern() {\\n                            @Override\\n                            public boolean isMatch(final CharSequence input) {\\n                                return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\\n                            }\\n                        };\\n                    } else if (endsWith) {\\n                        // last char\\n                        return new RPattern() {\\n                            @Override\\n                            public boolean isMatch(final CharSequence input) {\\n                                return input.length() > 0 &&\\n                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\\n                            }\\n                        };\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new RPattern() {\\n            Pattern pattern = Pattern.compile(regex);\\n\\n            @Override\\n            public boolean isMatch(final CharSequence input) {\\n                final Matcher matcher = pattern.matcher(input);\\n                return matcher.find();\\n            }\\n        };\\n    }\\n\\n    private static boolean startsWith(final CharSequence input, final CharSequence prefix) {\\n        if (prefix.length() > input.length()) {\\n            return false;\\n        }\\n        for (int i = 0; i < prefix.length(); i++) {\\n            if (input.charAt(i) != prefix.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static String stripQuotes(String str) {\\n        if (str.startsWith(DOUBLE_QUOTE)) {\\n            str = str.substring(1);\\n        }\\n\\n        if (str.endsWith(DOUBLE_QUOTE)) {\\n            str = str.substring(0, str.length() - 1);\\n        }\\n\\n        return str;\\n    }\\n\\n    private final RPattern lContext;\\n\\n    private final String pattern;\\n\\n    private final PhonemeExpr phoneme;\\n\\n    private final RPattern rContext;\\n\\n    /**\\n     * Creates a new rule.\\n     *\\n     * @param pattern\\n     *            the pattern\\n     * @param lContext\\n     *            the left context\\n     * @param rContext\\n     *            the right context\\n     * @param phoneme\\n     *            the resulting phoneme\\n     */\\n    public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {\\n        this.pattern = pattern;\\n        this.lContext = pattern(lContext + \\\"$\\\");\\n        this.rContext = pattern(\\\"^\\\" + rContext);\\n        this.phoneme = phoneme;\\n    }\\n\\n    /**\\n     * Gets the left context. This is a regular expression that must match to the left of the pattern.\\n     *\\n     * @return the left context Pattern\\n     */\\n    public RPattern getLContext() {\\n        return this.lContext;\\n    }\\n\\n    /**\\n     * Gets the pattern. This is a string-literal that must exactly match.\\n     *\\n     * @return the pattern\\n     */\\n    public String getPattern() {\\n        return this.pattern;\\n    }\\n\\n    /**\\n     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\\n     *\\n     * @return the phoneme\\n     */\\n    public PhonemeExpr getPhoneme() {\\n        return this.phoneme;\\n    }\\n\\n    /**\\n     * Gets the right context. This is a regular expression that must match to the right of the pattern.\\n     *\\n     * @return the right context Pattern\\n     */\\n    public RPattern getRContext() {\\n        return this.rContext;\\n    }\\n\\n    /**\\n     * Decides if the pattern and context match the input starting at a position. It is a match if the\\n     * <code>lContext</code> matches <code>input</code> up to <code>i</code>, <code>pattern</code> matches at i and\\n     * <code>rContext</code> matches from the end of the match of <code>pattern</code> to the end of <code>input</code>.\\n     *\\n     * @param input\\n     *            the input String\\n     * @param i\\n     *            the int position within the input\\n     * @return true if the pattern and left/right context match, false otherwise\\n     */\\n    public boolean patternAndContextMatches(final CharSequence input, final int i) {\\n        if (i < 0) {\\n            throw new IndexOutOfBoundsException(\\\"Can not match pattern at negative indexes\\\");\\n        }\\n\\n        final int patternLength = this.pattern.length();\\n        final int ipl = i + patternLength;\\n\\n        if (ipl > input.length()) {\\n            // not enough room for the pattern to match\\n            return false;\\n        }\\n\\n        // evaluate the pattern, left context and right context\\n        // fail early if any of the evaluations is not successful\\n        if (!input.subSequence(i, ipl).equals(this.pattern)) {\\n            return false;\\n        } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {\\n            return false;\\n        }\\n        return this.lContext.isMatch(input.subSequence(0, i));\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Rule\", \"position\": {\"start_line\": 82, \"end_line\": 728, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class Rule {\\n\\n    public static final class Phoneme implements PhonemeExpr {\\n        public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() {\\n            @Override\\n            public int compare(final Phoneme o1, final Phoneme o2) {\\n                for (int i = 0; i < o1.phonemeText.length(); i++) {\\n                    if (i >= o2.phonemeText.length()) {\\n                        return +1;\\n                    }\\n                    final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\\n                    if (c != 0) {\\n                        return c;\\n                    }\\n                }\\n\\n                if (o1.phonemeText.length() < o2.phonemeText.length()) {\\n                    return -1;\\n                }\\n\\n                return 0;\\n            }\\n        };\\n\\n        private final StringBuilder phonemeText;\\n        private final Languages.LanguageSet languages;\\n\\n        public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {\\n            this.phonemeText = new StringBuilder(phonemeText);\\n            this.languages = languages;\\n        }\\n\\n        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight) {\\n            this(phonemeLeft.phonemeText, phonemeLeft.languages);\\n            this.phonemeText.append(phonemeRight.phonemeText);\\n        }\\n\\n        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) {\\n            this(phonemeLeft.phonemeText, languages);\\n            this.phonemeText.append(phonemeRight.phonemeText);\\n        }\\n\\n        public Phoneme append(final CharSequence str) {\\n            this.phonemeText.append(str);\\n            return this;\\n        }\\n\\n        public Languages.LanguageSet getLanguages() {\\n            return this.languages;\\n        }\\n\\n        @Override\\n        public Iterable<Phoneme> getPhonemes() {\\n            return Collections.singleton(this);\\n        }\\n\\n        public CharSequence getPhonemeText() {\\n            return this.phonemeText;\\n        }\\n\\n        /**\\n         * Deprecated since 1.9.\\n         *\\n         * @param right the Phoneme to join\\n         * @return a new Phoneme\\n         * @deprecated since 1.9\\n         */\\n        @Deprecated\\n        public Phoneme join(final Phoneme right) {\\n            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(),\\n                               this.languages.restrictTo(right.languages));\\n        }\\n\\n        /**\\n         * Returns a new Phoneme with the same text but a union of its\\n         * current language set and the given one.\\n         *\\n         * @param lang the language set to merge\\n         * @return a new Phoneme\\n         */\\n        public Phoneme mergeWithLanguage(final LanguageSet lang) {\\n          return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));\\n        }\\n\\n        @Override\\n        public String toString() {\\n          return phonemeText.toString() + \\\"[\\\" + languages + \\\"]\\\";\\n        }\\n    }\\n\\n    public interface PhonemeExpr {\\n        Iterable<Phoneme> getPhonemes();\\n    }\\n\\n    public static final class PhonemeList implements PhonemeExpr {\\n        private final List<Phoneme> phonemes;\\n\\n        public PhonemeList(final List<Phoneme> phonemes) {\\n            this.phonemes = phonemes;\\n        }\\n\\n        @Override\\n        public List<Phoneme> getPhonemes() {\\n            return this.phonemes;\\n        }\\n    }\\n\\n    /**\\n     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.\\n     */\\n    public interface RPattern {\\n        boolean isMatch(CharSequence input);\\n    }\\n\\n    public static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {\\n        @Override\\n        public boolean isMatch(final CharSequence input) {\\n            return true;\\n        }\\n    };\\n\\n    public static final String ALL = \\\"ALL\\\";\\n\\n    private static final String DOUBLE_QUOTE = \\\"\\\\\\\"\\\";\\n\\n    private static final String HASH_INCLUDE = \\\"#include\\\";\\n\\n    private static final Map<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>> RULES =\\n            new EnumMap<NameType, Map<RuleType, Map<String, Map<String, List<Rule>>>>>(NameType.class);\\n\\n    static {\\n        for (final NameType s : NameType.values()) {\\n            final Map<RuleType, Map<String, Map<String, List<Rule>>>> rts =\\n                    new EnumMap<RuleType, Map<String, Map<String, List<Rule>>>>(RuleType.class);\\n\\n            for (final RuleType rt : RuleType.values()) {\\n                final Map<String, Map<String, List<Rule>>> rs = new HashMap<String, Map<String, List<Rule>>>();\\n\\n                final Languages ls = Languages.getInstance(s);\\n                for (final String l : ls.getLanguages()) {\\n                    final Scanner scanner = createScanner(s, rt, l);\\n                    try {\\n                        rs.put(l, parseRules(scanner, createResourceName(s, rt, l)));\\n                    } catch (final IllegalStateException e) {\\n                        throw new IllegalStateException(\\\"Problem processing \\\" + createResourceName(s, rt, l), e);\\n                    } finally {\\n                        scanner.close();\\n                    }\\n                }\\n                if (!rt.equals(RuleType.RULES)) {\\n                    final Scanner scanner = createScanner(s, rt, \\\"common\\\");\\n                    try {\\n                        rs.put(\\\"common\\\", parseRules(scanner, createResourceName(s, rt, \\\"common\\\")));\\n                    } finally {\\n                        scanner.close();\\n                    }\\n                }\\n\\n                rts.put(rt, Collections.unmodifiableMap(rs));\\n            }\\n\\n            RULES.put(s, Collections.unmodifiableMap(rts));\\n        }\\n    }\\n\\n    private static boolean contains(final CharSequence chars, final char input) {\\n        for (int i = 0; i < chars.length(); i++) {\\n            if (chars.charAt(i) == input) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) {\\n        return String.format(\\\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\\\",\\n                             nameType.getName(), rt.getName(), lang);\\n    }\\n\\n    private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {\\n        final String resName = createResourceName(nameType, rt, lang);\\n        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\\n\\n        if (rulesIS == null) {\\n            throw new IllegalArgumentException(\\\"Unable to load resource: \\\" + resName);\\n        }\\n\\n        return new Scanner(rulesIS, ResourceConstants.ENCODING);\\n    }\\n\\n    private static Scanner createScanner(final String lang) {\\n        final String resName = String.format(\\\"org/apache/commons/codec/language/bm/%s.txt\\\", lang);\\n        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\\n\\n        if (rulesIS == null) {\\n            throw new IllegalArgumentException(\\\"Unable to load resource: \\\" + resName);\\n        }\\n\\n        return new Scanner(rulesIS, ResourceConstants.ENCODING);\\n    }\\n\\n    private static boolean endsWith(final CharSequence input, final CharSequence suffix) {\\n        if (suffix.length() > input.length()) {\\n            return false;\\n        }\\n        for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) {\\n            if (input.charAt(i) != suffix.charAt(j)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * Gets rules for a combination of name type, rule type and languages.\\n     *\\n     * @param nameType\\n     *            the NameType to consider\\n     * @param rt\\n     *            the RuleType to consider\\n     * @param langs\\n     *            the set of languages to consider\\n     * @return a list of Rules that apply\\n     */\\n    public static List<Rule> getInstance(final NameType nameType, final RuleType rt,\\n                                         final Languages.LanguageSet langs) {\\n        final Map<String, List<Rule>> ruleMap = getInstanceMap(nameType, rt, langs);\\n        final List<Rule> allRules = new ArrayList<Rule>();\\n        for (final List<Rule> rules : ruleMap.values()) {\\n            allRules.addAll(rules);\\n        }\\n        return allRules;\\n    }\\n\\n    /**\\n     * Gets rules for a combination of name type, rule type and a single language.\\n     *\\n     * @param nameType\\n     *            the NameType to consider\\n     * @param rt\\n     *            the RuleType to consider\\n     * @param lang\\n     *            the language to consider\\n     * @return a list of Rules that apply\\n     */\\n    public static List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) {\\n        return getInstance(nameType, rt, LanguageSet.from(new HashSet<String>(Arrays.asList(lang))));\\n    }\\n\\n    /**\\n     * Gets rules for a combination of name type, rule type and languages.\\n     *\\n     * @param nameType\\n     *            the NameType to consider\\n     * @param rt\\n     *            the RuleType to consider\\n     * @param langs\\n     *            the set of languages to consider\\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\\n     * @since 1.9\\n     */\\n    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\\n                                                         final Languages.LanguageSet langs) {\\n        return langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) :\\n                                     getInstanceMap(nameType, rt, Languages.ANY);\\n    }\\n\\n    /**\\n     * Gets rules for a combination of name type, rule type and a single language.\\n     *\\n     * @param nameType\\n     *            the NameType to consider\\n     * @param rt\\n     *            the RuleType to consider\\n     * @param lang\\n     *            the language to consider\\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\\n     * @since 1.9\\n     */\\n    public static Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\\n                                                         final String lang) {\\n        final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);\\n\\n        if (rules == null) {\\n            throw new IllegalArgumentException(String.format(\\\"No rules found for %s, %s, %s.\\\",\\n                                               nameType.getName(), rt.getName(), lang));\\n        }\\n\\n        return rules;\\n    }\\n\\n    private static Phoneme parsePhoneme(final String ph) {\\n        final int open = ph.indexOf(\\\"[\\\");\\n        if (open >= 0) {\\n            if (!ph.endsWith(\\\"]\\\")) {\\n                throw new IllegalArgumentException(\\\"Phoneme expression contains a '[' but does not end in ']'\\\");\\n            }\\n            final String before = ph.substring(0, open);\\n            final String in = ph.substring(open + 1, ph.length() - 1);\\n            final Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\\\"[+]\\\")));\\n\\n            return new Phoneme(before, Languages.LanguageSet.from(langs));\\n        }\\n        return new Phoneme(ph, Languages.ANY_LANGUAGE);\\n    }\\n\\n    private static PhonemeExpr parsePhonemeExpr(final String ph) {\\n        if (ph.startsWith(\\\"(\\\")) { // we have a bracketed list of options\\n            if (!ph.endsWith(\\\")\\\")) {\\n                throw new IllegalArgumentException(\\\"Phoneme starts with '(' so must end with ')'\\\");\\n            }\\n\\n            final List<Phoneme> phs = new ArrayList<Phoneme>();\\n            final String body = ph.substring(1, ph.length() - 1);\\n            for (final String part : body.split(\\\"[|]\\\")) {\\n                phs.add(parsePhoneme(part));\\n            }\\n            if (body.startsWith(\\\"|\\\") || body.endsWith(\\\"|\\\")) {\\n                phs.add(new Phoneme(\\\"\\\", Languages.ANY_LANGUAGE));\\n            }\\n\\n            return new PhonemeList(phs);\\n        }\\n        return parsePhoneme(ph);\\n    }\\n\\n    private static Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) {\\n        final Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>();\\n        int currentLine = 0;\\n\\n        boolean inMultilineComment = false;\\n        while (scanner.hasNextLine()) {\\n            currentLine++;\\n            final String rawLine = scanner.nextLine();\\n            String line = rawLine;\\n\\n            if (inMultilineComment) {\\n                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\\n                    inMultilineComment = false;\\n                }\\n            } else {\\n                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\\n                    inMultilineComment = true;\\n                } else {\\n                    // discard comments\\n                    final int cmtI = line.indexOf(ResourceConstants.CMT);\\n                    if (cmtI >= 0) {\\n                        line = line.substring(0, cmtI);\\n                    }\\n\\n                    // trim leading-trailing whitespace\\n                    line = line.trim();\\n\\n                    if (line.length() == 0) {\\n                        continue; // empty lines can be safely skipped\\n                    }\\n\\n                    if (line.startsWith(HASH_INCLUDE)) {\\n                        // include statement\\n                        final String incl = line.substring(HASH_INCLUDE.length()).trim();\\n                        if (incl.contains(\\\" \\\")) {\\n                            throw new IllegalArgumentException(\\\"Malformed import statement '\\\" + rawLine + \\\"' in \\\" +\\n                                                               location);\\n                        }\\n                        final Scanner hashIncludeScanner = createScanner(incl);\\n                        try {\\n                            lines.putAll(parseRules(hashIncludeScanner, location + \\\"->\\\" + incl));\\n                        } finally {\\n                            hashIncludeScanner.close();\\n                        }\\n                    } else {\\n                        // rule\\n                        final String[] parts = line.split(\\\"\\\\\\\\s+\\\");\\n                        if (parts.length != 4) {\\n                            throw new IllegalArgumentException(\\\"Malformed rule statement split into \\\" + parts.length +\\n                                                               \\\" parts: \\\" + rawLine + \\\" in \\\" + location);\\n                        }\\n                        try {\\n                            final String pat = stripQuotes(parts[0]);\\n                            final String lCon = stripQuotes(parts[1]);\\n                            final String rCon = stripQuotes(parts[2]);\\n                            final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\\n                            final int cLine = currentLine;\\n                            final Rule r = new Rule(pat, lCon, rCon, ph) {\\n                                private final int myLine = cLine;\\n                                private final String loc = location;\\n\\n                                @Override\\n                                public String toString() {\\n                                    final StringBuilder sb = new StringBuilder();\\n                                    sb.append(\\\"Rule\\\");\\n                                    sb.append(\\\"{line=\\\").append(myLine);\\n                                    sb.append(\\\", loc='\\\").append(loc).append('\\\\'');\\n                                    sb.append(\\\", pat='\\\").append(pat).append('\\\\'');\\n                                    sb.append(\\\", lcon='\\\").append(lCon).append('\\\\'');\\n                                    sb.append(\\\", rcon='\\\").append(rCon).append('\\\\'');\\n                                    sb.append('}');\\n                                    return sb.toString();\\n                                }\\n                            };\\n                            final String patternKey = r.pattern.substring(0,1);\\n                            List<Rule> rules = lines.get(patternKey);\\n                            if (rules == null) {\\n                                rules = new ArrayList<Rule>();\\n                                lines.put(patternKey, rules);\\n                            }\\n                            rules.add(r);\\n                        } catch (final IllegalArgumentException e) {\\n                            throw new IllegalStateException(\\\"Problem parsing line '\\\" + currentLine + \\\"' in \\\" +\\n                                                            location, e);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return lines;\\n    }\\n\\n    /**\\n     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.\\n     *\\n     * @param regex\\n     *            the regular expression to compile\\n     * @return an RPattern that will match this regex\\n     */\\n    private static RPattern pattern(final String regex) {\\n        final boolean startsWith = regex.startsWith(\\\"^\\\");\\n        final boolean endsWith = regex.endsWith(\\\"$\\\");\\n        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\\n        final boolean boxes = content.contains(\\\"[\\\");\\n\\n        if (!boxes) {\\n            if (startsWith && endsWith) {\\n                // exact match\\n                if (content.length() == 0) {\\n                    // empty\\n                    return new RPattern() {\\n                        @Override\\n                        public boolean isMatch(final CharSequence input) {\\n                            return input.length() == 0;\\n                        }\\n                    };\\n                }\\n                return new RPattern() {\\n                    @Override\\n                    public boolean isMatch(final CharSequence input) {\\n                        return input.equals(content);\\n                    }\\n                };\\n            } else if ((startsWith || endsWith) && content.length() == 0) {\\n                // matches every string\\n                return ALL_STRINGS_RMATCHER;\\n            } else if (startsWith) {\\n                // matches from start\\n                return new RPattern() {\\n                    @Override\\n                    public boolean isMatch(final CharSequence input) {\\n                        return startsWith(input, content);\\n                    }\\n                };\\n            } else if (endsWith) {\\n                // matches from start\\n                return new RPattern() {\\n                    @Override\\n                    public boolean isMatch(final CharSequence input) {\\n                        return endsWith(input, content);\\n                    }\\n                };\\n            }\\n        } else {\\n            final boolean startsWithBox = content.startsWith(\\\"[\\\");\\n            final boolean endsWithBox = content.endsWith(\\\"]\\\");\\n\\n            if (startsWithBox && endsWithBox) {\\n                String boxContent = content.substring(1, content.length() - 1);\\n                if (!boxContent.contains(\\\"[\\\")) {\\n                    // box containing alternatives\\n                    final boolean negate = boxContent.startsWith(\\\"^\\\");\\n                    if (negate) {\\n                        boxContent = boxContent.substring(1);\\n                    }\\n                    final String bContent = boxContent;\\n                    final boolean shouldMatch = !negate;\\n\\n                    if (startsWith && endsWith) {\\n                        // exact match\\n                        return new RPattern() {\\n                            @Override\\n                            public boolean isMatch(final CharSequence input) {\\n                                return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\\n                            }\\n                        };\\n                    } else if (startsWith) {\\n                        // first char\\n                        return new RPattern() {\\n                            @Override\\n                            public boolean isMatch(final CharSequence input) {\\n                                return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\\n                            }\\n                        };\\n                    } else if (endsWith) {\\n                        // last char\\n                        return new RPattern() {\\n                            @Override\\n                            public boolean isMatch(final CharSequence input) {\\n                                return input.length() > 0 &&\\n                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\\n                            }\\n                        };\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new RPattern() {\\n            Pattern pattern = Pattern.compile(regex);\\n\\n            @Override\\n            public boolean isMatch(final CharSequence input) {\\n                final Matcher matcher = pattern.matcher(input);\\n                return matcher.find();\\n            }\\n        };\\n    }\\n\\n    private static boolean startsWith(final CharSequence input, final CharSequence prefix) {\\n        if (prefix.length() > input.length()) {\\n            return false;\\n        }\\n        for (int i = 0; i < prefix.length(); i++) {\\n            if (input.charAt(i) != prefix.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static String stripQuotes(String str) {\\n        if (str.startsWith(DOUBLE_QUOTE)) {\\n            str = str.substring(1);\\n        }\\n\\n        if (str.endsWith(DOUBLE_QUOTE)) {\\n            str = str.substring(0, str.length() - 1);\\n        }\\n\\n        return str;\\n    }\\n\\n    private final RPattern lContext;\\n\\n    private final String pattern;\\n\\n    private final PhonemeExpr phoneme;\\n\\n    private final RPattern rContext;\\n\\n    /**\\n     * Creates a new rule.\\n     *\\n     * @param pattern\\n     *            the pattern\\n     * @param lContext\\n     *            the left context\\n     * @param rContext\\n     *            the right context\\n     * @param phoneme\\n     *            the resulting phoneme\\n     */\\n    public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {\\n        this.pattern = pattern;\\n        this.lContext = pattern(lContext + \\\"$\\\");\\n        this.rContext = pattern(\\\"^\\\" + rContext);\\n        this.phoneme = phoneme;\\n    }\\n\\n    /**\\n     * Gets the left context. This is a regular expression that must match to the left of the pattern.\\n     *\\n     * @return the left context Pattern\\n     */\\n    public RPattern getLContext() {\\n        return this.lContext;\\n    }\\n\\n    /**\\n     * Gets the pattern. This is a string-literal that must exactly match.\\n     *\\n     * @return the pattern\\n     */\\n    public String getPattern() {\\n        return this.pattern;\\n    }\\n\\n    /**\\n     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\\n     *\\n     * @return the phoneme\\n     */\\n    public PhonemeExpr getPhoneme() {\\n        return this.phoneme;\\n    }\\n\\n    /**\\n     * Gets the right context. This is a regular expression that must match to the right of the pattern.\\n     *\\n     * @return the right context Pattern\\n     */\\n    public RPattern getRContext() {\\n        return this.rContext;\\n    }\\n\\n    /**\\n     * Decides if the pattern and context match the input starting at a position. It is a match if the\\n     * <code>lContext</code> matches <code>input</code> up to <code>i</code>, <code>pattern</code> matches at i and\\n     * <code>rContext</code> matches from the end of the match of <code>pattern</code> to the end of <code>input</code>.\\n     *\\n     * @param input\\n     *            the input String\\n     * @param i\\n     *            the int position within the input\\n     * @return true if the pattern and left/right context match, false otherwise\\n     */\\n    public boolean patternAndContextMatches(final CharSequence input, final int i) {\\n        if (i < 0) {\\n            throw new IndexOutOfBoundsException(\\\"Can not match pattern at negative indexes\\\");\\n        }\\n\\n        final int patternLength = this.pattern.length();\\n        final int ipl = i + patternLength;\\n\\n        if (ipl > input.length()) {\\n            // not enough room for the pattern to match\\n            return false;\\n        }\\n\\n        // evaluate the pattern, left context and right context\\n        // fail early if any of the evaluations is not successful\\n        if (!input.subSequence(i, ipl).equals(this.pattern)) {\\n            return false;\\n        } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {\\n            return false;\\n        }\\n        return this.lContext.isMatch(input.subSequence(0, i));\\n    }\\n}\", \"summary\": \"\", \"methods\": []}, {\"parent_file\": null, \"name\": \"Phoneme\", \"position\": {\"start_line\": 84, \"end_line\": 170, \"start_column\": 25, \"end_column\": 5}, \"code\": \"class Phoneme implements PhonemeExpr {\\n        public static final Comparator<Phoneme> COMPARATOR = new Comparator<Phoneme>() {\\n            @Override\\n            public int compare(final Phoneme o1, final Phoneme o2) {\\n                for (int i = 0; i < o1.phonemeText.length(); i++) {\\n                    if (i >= o2.phonemeText.length()) {\\n                        return +1;\\n                    }\\n                    final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\\n                    if (c != 0) {\\n                        return c;\\n                    }\\n                }\\n\\n                if (o1.phonemeText.length() < o2.phonemeText.length()) {\\n                    return -1;\\n                }\\n\\n                return 0;\\n            }\\n        };\\n\\n        private final StringBuilder phonemeText;\\n        private final Languages.LanguageSet languages;\\n\\n        public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {\\n            this.phonemeText = new StringBuilder(phonemeText);\\n            this.languages = languages;\\n        }\\n\\n        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight) {\\n            this(phonemeLeft.phonemeText, phonemeLeft.languages);\\n            this.phonemeText.append(phonemeRight.phonemeText);\\n        }\\n\\n        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) {\\n            this(phonemeLeft.phonemeText, languages);\\n            this.phonemeText.append(phonemeRight.phonemeText);\\n        }\\n\\n        public Phoneme append(final CharSequence str) {\\n            this.phonemeText.append(str);\\n            return this;\\n        }\\n\\n        public Languages.LanguageSet getLanguages() {\\n            return this.languages;\\n        }\\n\\n        @Override\\n        public Iterable<Phoneme> getPhonemes() {\\n            return Collections.singleton(this);\\n        }\\n\\n        public CharSequence getPhonemeText() {\\n            return this.phonemeText;\\n        }\\n\\n        /**\\n         * Deprecated since 1.9.\\n         *\\n         * @param right the Phoneme to join\\n         * @return a new Phoneme\\n         * @deprecated since 1.9\\n         */\\n        @Deprecated\\n        public Phoneme join(final Phoneme right) {\\n            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(),\\n                               this.languages.restrictTo(right.languages));\\n        }\\n\\n        /**\\n         * Returns a new Phoneme with the same text but a union of its\\n         * current language set and the given one.\\n         *\\n         * @param lang the language set to merge\\n         * @return a new Phoneme\\n         */\\n        public Phoneme mergeWithLanguage(final LanguageSet lang) {\\n          return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));\\n        }\\n\\n        @Override\\n        public String toString() {\\n          return phonemeText.toString() + \\\"[\\\" + languages + \\\"]\\\";\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"compare\", \"return_type\": \"int\", \"position\": {\"start_line\": 87, \"end_line\": 103, \"start_column\": 20, \"end_column\": 13}, \"code\": \"int compare(final Phoneme o1, final Phoneme o2) {\\n                for (int i = 0; i < o1.phonemeText.length(); i++) {\\n                    if (i >= o2.phonemeText.length()) {\\n                        return +1;\\n                    }\\n                    final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);\\n                    if (c != 0) {\\n                        return c;\\n                    }\\n                }\\n\\n                if (o1.phonemeText.length() < o2.phonemeText.length()) {\\n                    return -1;\\n                }\\n\\n                return 0;\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"o1\", \"type\": \"Phoneme\"}, {\"name\": \"o2\", \"type\": \"Phoneme\"}]}, {\"name\": \"append\", \"return_type\": \"Phoneme\", \"position\": {\"start_line\": 124, \"end_line\": 127, \"start_column\": 16, \"end_column\": 9}, \"code\": \"Phoneme append(final CharSequence str) {\\n            this.phonemeText.append(str);\\n            return this;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"CharSequence\"}]}, {\"name\": \"getLanguages\", \"return_type\": \"Languages\", \"position\": {\"start_line\": 129, \"end_line\": 131, \"start_column\": 16, \"end_column\": 9}, \"code\": \"Languages.LanguageSet getLanguages() {\\n            return this.languages;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getPhonemes\", \"return_type\": \"Iterable\", \"position\": {\"start_line\": 134, \"end_line\": 136, \"start_column\": 16, \"end_column\": 9}, \"code\": \"Iterable<Phoneme> getPhonemes() {\\n            return Collections.singleton(this);\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getPhonemeText\", \"return_type\": \"CharSequence\", \"position\": {\"start_line\": 138, \"end_line\": 140, \"start_column\": 16, \"end_column\": 9}, \"code\": \"CharSequence getPhonemeText() {\\n            return this.phonemeText;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"join\", \"return_type\": \"Phoneme\", \"position\": {\"start_line\": 150, \"end_line\": 153, \"start_column\": 16, \"end_column\": 9}, \"code\": \"Phoneme join(final Phoneme right) {\\n            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(),\\n                               this.languages.restrictTo(right.languages));\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"right\", \"type\": \"Phoneme\"}]}, {\"name\": \"mergeWithLanguage\", \"return_type\": \"Phoneme\", \"position\": {\"start_line\": 162, \"end_line\": 164, \"start_column\": 16, \"end_column\": 9}, \"code\": \"Phoneme mergeWithLanguage(final LanguageSet lang) {\\n          return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"lang\", \"type\": \"LanguageSet\"}]}, {\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 167, \"end_line\": 169, \"start_column\": 16, \"end_column\": 9}, \"code\": \"String toString() {\\n          return phonemeText.toString() + \\\"[\\\" + languages + \\\"]\\\";\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}, {\"parent_file\": null, \"name\": \"PhonemeExpr\", \"position\": {\"start_line\": 172, \"end_line\": 174, \"start_column\": 12, \"end_column\": 5}, \"code\": \"interface PhonemeExpr {\\n        Iterable<Phoneme> getPhonemes();\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"getPhonemes\", \"return_type\": \"Iterable\", \"position\": {\"start_line\": 173, \"end_line\": 173, \"start_column\": 9, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}, {\"parent_file\": null, \"name\": \"PhonemeList\", \"position\": {\"start_line\": 176, \"end_line\": 187, \"start_column\": 25, \"end_column\": 5}, \"code\": \"class PhonemeList implements PhonemeExpr {\\n        private final List<Phoneme> phonemes;\\n\\n        public PhonemeList(final List<Phoneme> phonemes) {\\n            this.phonemes = phonemes;\\n        }\\n\\n        @Override\\n        public List<Phoneme> getPhonemes() {\\n            return this.phonemes;\\n        }\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"getPhonemes\", \"return_type\": \"List\", \"position\": {\"start_line\": 184, \"end_line\": 186, \"start_column\": 16, \"end_column\": 9}, \"code\": \"List<Phoneme> getPhonemes() {\\n            return this.phonemes;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}, {\"parent_file\": null, \"name\": \"RPattern\", \"position\": {\"start_line\": 192, \"end_line\": 194, \"start_column\": 12, \"end_column\": 5}, \"code\": \"interface RPattern {\\n        boolean isMatch(CharSequence input);\\n    }\", \"summary\": \"\", \"methods\": [{\"name\": \"isMatch\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 193, \"end_line\": 193, \"start_column\": 9, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}]}, {\"name\": \"isMatch\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 198, \"end_line\": 200, \"start_column\": 16, \"end_column\": 9}, \"code\": \"boolean isMatch(final CharSequence input) {\\n            return true;\\n        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}]}, {\"name\": \"contains\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 247, \"end_line\": 254, \"start_column\": 20, \"end_column\": 5}, \"code\": \"boolean contains(final CharSequence chars, final char input) {\\n        for (int i = 0; i < chars.length(); i++) {\\n            if (chars.charAt(i) == input) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"chars\", \"type\": \"CharSequence\"}, {\"name\": \"input\", \"type\": \"char\"}]}, {\"name\": \"createResourceName\", \"return_type\": \"String\", \"position\": {\"start_line\": 256, \"end_line\": 259, \"start_column\": 20, \"end_column\": 5}, \"code\": \"String createResourceName(final NameType nameType, final RuleType rt, final String lang) {\\n        return String.format(\\\"org/apache/commons/codec/language/bm/%s_%s_%s.txt\\\",\\n                             nameType.getName(), rt.getName(), lang);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"nameType\", \"type\": \"NameType\"}, {\"name\": \"rt\", \"type\": \"RuleType\"}, {\"name\": \"lang\", \"type\": \"String\"}]}, {\"name\": \"createScanner\", \"return_type\": \"Scanner\", \"position\": {\"start_line\": 261, \"end_line\": 270, \"start_column\": 20, \"end_column\": 5}, \"code\": \"Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {\\n        final String resName = createResourceName(nameType, rt, lang);\\n        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\\n\\n        if (rulesIS == null) {\\n            throw new IllegalArgumentException(\\\"Unable to load resource: \\\" + resName);\\n        }\\n\\n        return new Scanner(rulesIS, ResourceConstants.ENCODING);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"nameType\", \"type\": \"NameType\"}, {\"name\": \"rt\", \"type\": \"RuleType\"}, {\"name\": \"lang\", \"type\": \"String\"}]}, {\"name\": \"createScanner\", \"return_type\": \"Scanner\", \"position\": {\"start_line\": 272, \"end_line\": 281, \"start_column\": 20, \"end_column\": 5}, \"code\": \"Scanner createScanner(final String lang) {\\n        final String resName = String.format(\\\"org/apache/commons/codec/language/bm/%s.txt\\\", lang);\\n        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);\\n\\n        if (rulesIS == null) {\\n            throw new IllegalArgumentException(\\\"Unable to load resource: \\\" + resName);\\n        }\\n\\n        return new Scanner(rulesIS, ResourceConstants.ENCODING);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"lang\", \"type\": \"String\"}]}, {\"name\": \"endsWith\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 283, \"end_line\": 293, \"start_column\": 20, \"end_column\": 5}, \"code\": \"boolean endsWith(final CharSequence input, final CharSequence suffix) {\\n        if (suffix.length() > input.length()) {\\n            return false;\\n        }\\n        for (int i = input.length() - 1, j = suffix.length() - 1; j >= 0; i--, j--) {\\n            if (input.charAt(i) != suffix.charAt(j)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}, {\"name\": \"suffix\", \"type\": \"CharSequence\"}]}, {\"name\": \"getInstance\", \"return_type\": \"List\", \"position\": {\"start_line\": 306, \"end_line\": 314, \"start_column\": 19, \"end_column\": 5}, \"code\": \"List<Rule> getInstance(final NameType nameType, final RuleType rt,\\n                                         final Languages.LanguageSet langs) {\\n        final Map<String, List<Rule>> ruleMap = getInstanceMap(nameType, rt, langs);\\n        final List<Rule> allRules = new ArrayList<Rule>();\\n        for (final List<Rule> rules : ruleMap.values()) {\\n            allRules.addAll(rules);\\n        }\\n        return allRules;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"nameType\", \"type\": \"NameType\"}, {\"name\": \"rt\", \"type\": \"RuleType\"}, {\"name\": \"langs\", \"type\": \"Languages.LanguageSet\"}]}, {\"name\": \"getInstance\", \"return_type\": \"List\", \"position\": {\"start_line\": 327, \"end_line\": 329, \"start_column\": 19, \"end_column\": 5}, \"code\": \"List<Rule> getInstance(final NameType nameType, final RuleType rt, final String lang) {\\n        return getInstance(nameType, rt, LanguageSet.from(new HashSet<String>(Arrays.asList(lang))));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"nameType\", \"type\": \"NameType\"}, {\"name\": \"rt\", \"type\": \"RuleType\"}, {\"name\": \"lang\", \"type\": \"String\"}]}, {\"name\": \"getInstanceMap\", \"return_type\": \"Map\", \"position\": {\"start_line\": 343, \"end_line\": 347, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\\n                                                         final Languages.LanguageSet langs) {\\n        return langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) :\\n                                     getInstanceMap(nameType, rt, Languages.ANY);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"nameType\", \"type\": \"NameType\"}, {\"name\": \"rt\", \"type\": \"RuleType\"}, {\"name\": \"langs\", \"type\": \"Languages.LanguageSet\"}]}, {\"name\": \"getInstanceMap\", \"return_type\": \"Map\", \"position\": {\"start_line\": 361, \"end_line\": 371, \"start_column\": 19, \"end_column\": 5}, \"code\": \"Map<String, List<Rule>> getInstanceMap(final NameType nameType, final RuleType rt,\\n                                                         final String lang) {\\n        final Map<String, List<Rule>> rules = RULES.get(nameType).get(rt).get(lang);\\n\\n        if (rules == null) {\\n            throw new IllegalArgumentException(String.format(\\\"No rules found for %s, %s, %s.\\\",\\n                                               nameType.getName(), rt.getName(), lang));\\n        }\\n\\n        return rules;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"nameType\", \"type\": \"NameType\"}, {\"name\": \"rt\", \"type\": \"RuleType\"}, {\"name\": \"lang\", \"type\": \"String\"}]}, {\"name\": \"parsePhoneme\", \"return_type\": \"Phoneme\", \"position\": {\"start_line\": 373, \"end_line\": 386, \"start_column\": 20, \"end_column\": 5}, \"code\": \"Phoneme parsePhoneme(final String ph) {\\n        final int open = ph.indexOf(\\\"[\\\");\\n        if (open >= 0) {\\n            if (!ph.endsWith(\\\"]\\\")) {\\n                throw new IllegalArgumentException(\\\"Phoneme expression contains a '[' but does not end in ']'\\\");\\n            }\\n            final String before = ph.substring(0, open);\\n            final String in = ph.substring(open + 1, ph.length() - 1);\\n            final Set<String> langs = new HashSet<String>(Arrays.asList(in.split(\\\"[+]\\\")));\\n\\n            return new Phoneme(before, Languages.LanguageSet.from(langs));\\n        }\\n        return new Phoneme(ph, Languages.ANY_LANGUAGE);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ph\", \"type\": \"String\"}]}, {\"name\": \"parsePhonemeExpr\", \"return_type\": \"PhonemeExpr\", \"position\": {\"start_line\": 388, \"end_line\": 406, \"start_column\": 20, \"end_column\": 5}, \"code\": \"PhonemeExpr parsePhonemeExpr(final String ph) {\\n        if (ph.startsWith(\\\"(\\\")) { // we have a bracketed list of options\\n            if (!ph.endsWith(\\\")\\\")) {\\n                throw new IllegalArgumentException(\\\"Phoneme starts with '(' so must end with ')'\\\");\\n            }\\n\\n            final List<Phoneme> phs = new ArrayList<Phoneme>();\\n            final String body = ph.substring(1, ph.length() - 1);\\n            for (final String part : body.split(\\\"[|]\\\")) {\\n                phs.add(parsePhoneme(part));\\n            }\\n            if (body.startsWith(\\\"|\\\") || body.endsWith(\\\"|\\\")) {\\n                phs.add(new Phoneme(\\\"\\\", Languages.ANY_LANGUAGE));\\n            }\\n\\n            return new PhonemeList(phs);\\n        }\\n        return parsePhoneme(ph);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"ph\", \"type\": \"String\"}]}, {\"name\": \"parseRules\", \"return_type\": \"Map\", \"position\": {\"start_line\": 408, \"end_line\": 499, \"start_column\": 20, \"end_column\": 5}, \"code\": \"Map<String, List<Rule>> parseRules(final Scanner scanner, final String location) {\\n        final Map<String, List<Rule>> lines = new HashMap<String, List<Rule>>();\\n        int currentLine = 0;\\n\\n        boolean inMultilineComment = false;\\n        while (scanner.hasNextLine()) {\\n            currentLine++;\\n            final String rawLine = scanner.nextLine();\\n            String line = rawLine;\\n\\n            if (inMultilineComment) {\\n                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {\\n                    inMultilineComment = false;\\n                }\\n            } else {\\n                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {\\n                    inMultilineComment = true;\\n                } else {\\n                    // discard comments\\n                    final int cmtI = line.indexOf(ResourceConstants.CMT);\\n                    if (cmtI >= 0) {\\n                        line = line.substring(0, cmtI);\\n                    }\\n\\n                    // trim leading-trailing whitespace\\n                    line = line.trim();\\n\\n                    if (line.length() == 0) {\\n                        continue; // empty lines can be safely skipped\\n                    }\\n\\n                    if (line.startsWith(HASH_INCLUDE)) {\\n                        // include statement\\n                        final String incl = line.substring(HASH_INCLUDE.length()).trim();\\n                        if (incl.contains(\\\" \\\")) {\\n                            throw new IllegalArgumentException(\\\"Malformed import statement '\\\" + rawLine + \\\"' in \\\" +\\n                                                               location);\\n                        }\\n                        final Scanner hashIncludeScanner = createScanner(incl);\\n                        try {\\n                            lines.putAll(parseRules(hashIncludeScanner, location + \\\"->\\\" + incl));\\n                        } finally {\\n                            hashIncludeScanner.close();\\n                        }\\n                    } else {\\n                        // rule\\n                        final String[] parts = line.split(\\\"\\\\\\\\s+\\\");\\n                        if (parts.length != 4) {\\n                            throw new IllegalArgumentException(\\\"Malformed rule statement split into \\\" + parts.length +\\n                                                               \\\" parts: \\\" + rawLine + \\\" in \\\" + location);\\n                        }\\n                        try {\\n                            final String pat = stripQuotes(parts[0]);\\n                            final String lCon = stripQuotes(parts[1]);\\n                            final String rCon = stripQuotes(parts[2]);\\n                            final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));\\n                            final int cLine = currentLine;\\n                            final Rule r = new Rule(pat, lCon, rCon, ph) {\\n                                private final int myLine = cLine;\\n                                private final String loc = location;\\n\\n                                @Override\\n                                public String toString() {\\n                                    final StringBuilder sb = new StringBuilder();\\n                                    sb.append(\\\"Rule\\\");\\n                                    sb.append(\\\"{line=\\\").append(myLine);\\n                                    sb.append(\\\", loc='\\\").append(loc).append('\\\\'');\\n                                    sb.append(\\\", pat='\\\").append(pat).append('\\\\'');\\n                                    sb.append(\\\", lcon='\\\").append(lCon).append('\\\\'');\\n                                    sb.append(\\\", rcon='\\\").append(rCon).append('\\\\'');\\n                                    sb.append('}');\\n                                    return sb.toString();\\n                                }\\n                            };\\n                            final String patternKey = r.pattern.substring(0,1);\\n                            List<Rule> rules = lines.get(patternKey);\\n                            if (rules == null) {\\n                                rules = new ArrayList<Rule>();\\n                                lines.put(patternKey, rules);\\n                            }\\n                            rules.add(r);\\n                        } catch (final IllegalArgumentException e) {\\n                            throw new IllegalStateException(\\\"Problem parsing line '\\\" + currentLine + \\\"' in \\\" +\\n                                                            location, e);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return lines;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"scanner\", \"type\": \"Scanner\"}, {\"name\": \"location\", \"type\": \"String\"}]}, {\"name\": \"toString\", \"return_type\": \"String\", \"position\": {\"start_line\": 470, \"end_line\": 480, \"start_column\": 40, \"end_column\": 33}, \"code\": \"String toString() {\\n                                    final StringBuilder sb = new StringBuilder();\\n                                    sb.append(\\\"Rule\\\");\\n                                    sb.append(\\\"{line=\\\").append(myLine);\\n                                    sb.append(\\\", loc='\\\").append(loc).append('\\\\'');\\n                                    sb.append(\\\", pat='\\\").append(pat).append('\\\\'');\\n                                    sb.append(\\\", lcon='\\\").append(lCon).append('\\\\'');\\n                                    sb.append(\\\", rcon='\\\").append(rCon).append('\\\\'');\\n                                    sb.append('}');\\n                                    return sb.toString();\\n                                }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"pattern\", \"return_type\": \"RPattern\", \"position\": {\"start_line\": 508, \"end_line\": 606, \"start_column\": 20, \"end_column\": 5}, \"code\": \"RPattern pattern(final String regex) {\\n        final boolean startsWith = regex.startsWith(\\\"^\\\");\\n        final boolean endsWith = regex.endsWith(\\\"$\\\");\\n        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());\\n        final boolean boxes = content.contains(\\\"[\\\");\\n\\n        if (!boxes) {\\n            if (startsWith && endsWith) {\\n                // exact match\\n                if (content.length() == 0) {\\n                    // empty\\n                    return new RPattern() {\\n                        @Override\\n                        public boolean isMatch(final CharSequence input) {\\n                            return input.length() == 0;\\n                        }\\n                    };\\n                }\\n                return new RPattern() {\\n                    @Override\\n                    public boolean isMatch(final CharSequence input) {\\n                        return input.equals(content);\\n                    }\\n                };\\n            } else if ((startsWith || endsWith) && content.length() == 0) {\\n                // matches every string\\n                return ALL_STRINGS_RMATCHER;\\n            } else if (startsWith) {\\n                // matches from start\\n                return new RPattern() {\\n                    @Override\\n                    public boolean isMatch(final CharSequence input) {\\n                        return startsWith(input, content);\\n                    }\\n                };\\n            } else if (endsWith) {\\n                // matches from start\\n                return new RPattern() {\\n                    @Override\\n                    public boolean isMatch(final CharSequence input) {\\n                        return endsWith(input, content);\\n                    }\\n                };\\n            }\\n        } else {\\n            final boolean startsWithBox = content.startsWith(\\\"[\\\");\\n            final boolean endsWithBox = content.endsWith(\\\"]\\\");\\n\\n            if (startsWithBox && endsWithBox) {\\n                String boxContent = content.substring(1, content.length() - 1);\\n                if (!boxContent.contains(\\\"[\\\")) {\\n                    // box containing alternatives\\n                    final boolean negate = boxContent.startsWith(\\\"^\\\");\\n                    if (negate) {\\n                        boxContent = boxContent.substring(1);\\n                    }\\n                    final String bContent = boxContent;\\n                    final boolean shouldMatch = !negate;\\n\\n                    if (startsWith && endsWith) {\\n                        // exact match\\n                        return new RPattern() {\\n                            @Override\\n                            public boolean isMatch(final CharSequence input) {\\n                                return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\\n                            }\\n                        };\\n                    } else if (startsWith) {\\n                        // first char\\n                        return new RPattern() {\\n                            @Override\\n                            public boolean isMatch(final CharSequence input) {\\n                                return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\\n                            }\\n                        };\\n                    } else if (endsWith) {\\n                        // last char\\n                        return new RPattern() {\\n                            @Override\\n                            public boolean isMatch(final CharSequence input) {\\n                                return input.length() > 0 &&\\n                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\\n                            }\\n                        };\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new RPattern() {\\n            Pattern pattern = Pattern.compile(regex);\\n\\n            @Override\\n            public boolean isMatch(final CharSequence input) {\\n                final Matcher matcher = pattern.matcher(input);\\n                return matcher.find();\\n            }\\n        };\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"regex\", \"type\": \"String\"}]}, {\"name\": \"isMatch\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 521, \"end_line\": 523, \"start_column\": 32, \"end_column\": 25}, \"code\": \"boolean isMatch(final CharSequence input) {\\n                            return input.length() == 0;\\n                        }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}]}, {\"name\": \"isMatch\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 528, \"end_line\": 530, \"start_column\": 28, \"end_column\": 21}, \"code\": \"boolean isMatch(final CharSequence input) {\\n                        return input.equals(content);\\n                    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}]}, {\"name\": \"isMatch\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 539, \"end_line\": 541, \"start_column\": 28, \"end_column\": 21}, \"code\": \"boolean isMatch(final CharSequence input) {\\n                        return startsWith(input, content);\\n                    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}]}, {\"name\": \"isMatch\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 547, \"end_line\": 549, \"start_column\": 28, \"end_column\": 21}, \"code\": \"boolean isMatch(final CharSequence input) {\\n                        return endsWith(input, content);\\n                    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}]}, {\"name\": \"isMatch\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 571, \"end_line\": 573, \"start_column\": 36, \"end_column\": 29}, \"code\": \"boolean isMatch(final CharSequence input) {\\n                                return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch;\\n                            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}]}, {\"name\": \"isMatch\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 579, \"end_line\": 581, \"start_column\": 36, \"end_column\": 29}, \"code\": \"boolean isMatch(final CharSequence input) {\\n                                return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch;\\n                            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}]}, {\"name\": \"isMatch\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 587, \"end_line\": 590, \"start_column\": 36, \"end_column\": 29}, \"code\": \"boolean isMatch(final CharSequence input) {\\n                                return input.length() > 0 &&\\n                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;\\n                            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}]}, {\"name\": \"isMatch\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 601, \"end_line\": 604, \"start_column\": 20, \"end_column\": 13}, \"code\": \"boolean isMatch(final CharSequence input) {\\n                final Matcher matcher = pattern.matcher(input);\\n                return matcher.find();\\n            }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}]}, {\"name\": \"startsWith\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 608, \"end_line\": 618, \"start_column\": 20, \"end_column\": 5}, \"code\": \"boolean startsWith(final CharSequence input, final CharSequence prefix) {\\n        if (prefix.length() > input.length()) {\\n            return false;\\n        }\\n        for (int i = 0; i < prefix.length(); i++) {\\n            if (input.charAt(i) != prefix.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}, {\"name\": \"prefix\", \"type\": \"CharSequence\"}]}, {\"name\": \"stripQuotes\", \"return_type\": \"String\", \"position\": {\"start_line\": 620, \"end_line\": 630, \"start_column\": 20, \"end_column\": 5}, \"code\": \"String stripQuotes(String str) {\\n        if (str.startsWith(DOUBLE_QUOTE)) {\\n            str = str.substring(1);\\n        }\\n\\n        if (str.endsWith(DOUBLE_QUOTE)) {\\n            str = str.substring(0, str.length() - 1);\\n        }\\n\\n        return str;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"getLContext\", \"return_type\": \"RPattern\", \"position\": {\"start_line\": 664, \"end_line\": 666, \"start_column\": 12, \"end_column\": 5}, \"code\": \"RPattern getLContext() {\\n        return this.lContext;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getPattern\", \"return_type\": \"String\", \"position\": {\"start_line\": 673, \"end_line\": 675, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getPattern() {\\n        return this.pattern;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getPhoneme\", \"return_type\": \"PhonemeExpr\", \"position\": {\"start_line\": 682, \"end_line\": 684, \"start_column\": 12, \"end_column\": 5}, \"code\": \"PhonemeExpr getPhoneme() {\\n        return this.phoneme;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getRContext\", \"return_type\": \"RPattern\", \"position\": {\"start_line\": 691, \"end_line\": 693, \"start_column\": 12, \"end_column\": 5}, \"code\": \"RPattern getRContext() {\\n        return this.rContext;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"patternAndContextMatches\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 706, \"end_line\": 727, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean patternAndContextMatches(final CharSequence input, final int i) {\\n        if (i < 0) {\\n            throw new IndexOutOfBoundsException(\\\"Can not match pattern at negative indexes\\\");\\n        }\\n\\n        final int patternLength = this.pattern.length();\\n        final int ipl = i + patternLength;\\n\\n        if (ipl > input.length()) {\\n            // not enough room for the pattern to match\\n            return false;\\n        }\\n\\n        // evaluate the pattern, left context and right context\\n        // fail early if any of the evaluations is not successful\\n        if (!input.subSequence(i, ipl).equals(this.pattern)) {\\n            return false;\\n        } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {\\n            return false;\\n        }\\n        return this.lContext.isMatch(input.subSequence(0, i));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"input\", \"type\": \"CharSequence\"}, {\"name\": \"i\", \"type\": \"int\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/language/bm/RuleType.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.language.bm;\\n\\n/**\\n * Types of rule.\\n *\\n * @since 1.6\\n * @version $Id: RuleType.java 1542813 2013-11-17 20:52:32Z tn $\\n */\\npublic enum RuleType {\\n\\n    /** Approximate rules, which will lead to the largest number of phonetic interpretations. */\\n    APPROX(\\\"approx\\\"),\\n    /** Exact rules, which will lead to a minimum number of phonetic interpretations. */\\n    EXACT(\\\"exact\\\"),\\n    /** For internal use only. Please use {@link #APPROX} or {@link #EXACT}. */\\n    RULES(\\\"rules\\\");\\n\\n    private final String name;\\n\\n    RuleType(final String name) {\\n        this.name = name;\\n    }\\n\\n    /**\\n     * Gets the rule name.\\n     *\\n     * @return the rule name.\\n     */\\n    public String getName() {\\n        return this.name;\\n    }\\n\\n}\\n\", \"classes\": []}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/net/BCodec.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.net;\\n\\nimport java.io.UnsupportedEncodingException;\\nimport java.nio.charset.Charset;\\n\\nimport org.apache.commons.codec.Charsets;\\nimport org.apache.commons.codec.DecoderException;\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringDecoder;\\nimport org.apache.commons.codec.StringEncoder;\\nimport org.apache.commons.codec.binary.Base64;\\n\\n/**\\n * Identical to the Base64 encoding defined by <a href=\\\"http://www.ietf.org/rfc/rfc1521.txt\\\">RFC 1521</a>\\n * and allows a character set to be specified.\\n * <p>\\n * <a href=\\\"http://www.ietf.org/rfc/rfc1522.txt\\\">RFC 1522</a> describes techniques to allow the encoding of non-ASCII\\n * text in various portions of a RFC 822 [2] message header, in a manner which is unlikely to confuse existing message\\n * handling software.\\n * <p>\\n * This class is immutable and thread-safe.\\n *\\n * @see <a href=\\\"http://www.ietf.org/rfc/rfc1522.txt\\\">MIME (Multipurpose Internet Mail Extensions) Part Two: Message\\n *          Header Extensions for Non-ASCII Text</a>\\n *\\n * @since 1.3\\n * @version $Id: BCodec.java 1429868 2013-01-07 16:08:05Z ggregory $\\n */\\npublic class BCodec extends RFC1522Codec implements StringEncoder, StringDecoder {\\n    /**\\n     * The default charset used for string decoding and encoding.\\n     */\\n    private final Charset charset;\\n\\n    /**\\n     * Default constructor.\\n     */\\n    public BCodec() {\\n        this(Charsets.UTF_8);\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset\\n     *\\n     * @param charset\\n     *            the default string charset to use.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @since 1.7\\n     */\\n    public BCodec(final Charset charset) {\\n        this.charset = charset;\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset\\n     *\\n     * @param charsetName\\n     *            the default charset to use.\\n     * @throws java.nio.charset.UnsupportedCharsetException\\n     *             If the named charset is unavailable\\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public BCodec(final String charsetName) {\\n        this(Charset.forName(charsetName));\\n    }\\n\\n    @Override\\n    protected String getEncoding() {\\n        return \\\"B\\\";\\n    }\\n\\n    @Override\\n    protected byte[] doEncoding(final byte[] bytes) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        return Base64.encodeBase64(bytes);\\n    }\\n\\n    @Override\\n    protected byte[] doDecoding(final byte[] bytes) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        return Base64.decodeBase64(bytes);\\n    }\\n\\n    /**\\n     * Encodes a string into its Base64 form using the specified charset. Unsafe characters are escaped.\\n     *\\n     * @param value\\n     *            string to convert to Base64 form\\n     * @param charset\\n     *            the charset for <code>value</code>\\n     * @return Base64 string\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     * @since 1.7\\n     */\\n    public String encode(final String value, final Charset charset) throws EncoderException {\\n        if (value == null) {\\n            return null;\\n        }\\n        return encodeText(value, charset);\\n    }\\n\\n    /**\\n     * Encodes a string into its Base64 form using the specified charset. Unsafe characters are escaped.\\n     *\\n     * @param value\\n     *            string to convert to Base64 form\\n     * @param charset\\n     *            the charset for <code>value</code>\\n     * @return Base64 string\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     */\\n    public String encode(final String value, final String charset) throws EncoderException {\\n        if (value == null) {\\n            return null;\\n        }\\n        try {\\n            return this.encodeText(value, charset);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new EncoderException(e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * Encodes a string into its Base64 form using the default charset. Unsafe characters are escaped.\\n     *\\n     * @param value\\n     *            string to convert to Base64 form\\n     * @return Base64 string\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     */\\n    @Override\\n    public String encode(final String value) throws EncoderException {\\n        if (value == null) {\\n            return null;\\n        }\\n        return encode(value, this.getCharset());\\n    }\\n\\n    /**\\n     * Decodes a Base64 string into its original form. Escaped characters are converted back to their original\\n     * representation.\\n     *\\n     * @param value\\n     *            Base64 string to convert into its original form\\n     * @return original string\\n     * @throws DecoderException\\n     *             A decoder exception is thrown if a failure condition is encountered during the decode process.\\n     */\\n    @Override\\n    public String decode(final String value) throws DecoderException {\\n        if (value == null) {\\n            return null;\\n        }\\n        try {\\n            return this.decodeText(value);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new DecoderException(e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * Encodes an object into its Base64 form using the default charset. Unsafe characters are escaped.\\n     *\\n     * @param value\\n     *            object to convert to Base64 form\\n     * @return Base64 object\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     */\\n    @Override\\n    public Object encode(final Object value) throws EncoderException {\\n        if (value == null) {\\n            return null;\\n        } else if (value instanceof String) {\\n            return encode((String) value);\\n        } else {\\n            throw new EncoderException(\\\"Objects of type \\\" +\\n                  value.getClass().getName() +\\n                  \\\" cannot be encoded using BCodec\\\");\\n        }\\n    }\\n\\n    /**\\n     * Decodes a Base64 object into its original form. Escaped characters are converted back to their original\\n     * representation.\\n     *\\n     * @param value\\n     *            Base64 object to convert into its original form\\n     * @return original object\\n     * @throws DecoderException\\n     *             Thrown if the argument is not a <code>String</code>. Thrown if a failure condition is encountered\\n     *             during the decode process.\\n     */\\n    @Override\\n    public Object decode(final Object value) throws DecoderException {\\n        if (value == null) {\\n            return null;\\n        } else if (value instanceof String) {\\n            return decode((String) value);\\n        } else {\\n            throw new DecoderException(\\\"Objects of type \\\" +\\n                  value.getClass().getName() +\\n                  \\\" cannot be decoded using BCodec\\\");\\n        }\\n    }\\n\\n    /**\\n     * Gets the default charset name used for string decoding and encoding.\\n     *\\n     * @return the default charset name\\n     * @since 1.7\\n     */\\n    public Charset getCharset() {\\n        return this.charset;\\n    }\\n\\n    /**\\n     * Gets the default charset name used for string decoding and encoding.\\n     *\\n     * @return the default charset name\\n     */\\n    public String getDefaultCharset() {\\n        return this.charset.name();\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"BCodec\", \"position\": {\"start_line\": 46, \"end_line\": 251, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class BCodec extends RFC1522Codec implements StringEncoder, StringDecoder {\\n    /**\\n     * The default charset used for string decoding and encoding.\\n     */\\n    private final Charset charset;\\n\\n    /**\\n     * Default constructor.\\n     */\\n    public BCodec() {\\n        this(Charsets.UTF_8);\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset\\n     *\\n     * @param charset\\n     *            the default string charset to use.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @since 1.7\\n     */\\n    public BCodec(final Charset charset) {\\n        this.charset = charset;\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset\\n     *\\n     * @param charsetName\\n     *            the default charset to use.\\n     * @throws java.nio.charset.UnsupportedCharsetException\\n     *             If the named charset is unavailable\\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public BCodec(final String charsetName) {\\n        this(Charset.forName(charsetName));\\n    }\\n\\n    @Override\\n    protected String getEncoding() {\\n        return \\\"B\\\";\\n    }\\n\\n    @Override\\n    protected byte[] doEncoding(final byte[] bytes) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        return Base64.encodeBase64(bytes);\\n    }\\n\\n    @Override\\n    protected byte[] doDecoding(final byte[] bytes) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        return Base64.decodeBase64(bytes);\\n    }\\n\\n    /**\\n     * Encodes a string into its Base64 form using the specified charset. Unsafe characters are escaped.\\n     *\\n     * @param value\\n     *            string to convert to Base64 form\\n     * @param charset\\n     *            the charset for <code>value</code>\\n     * @return Base64 string\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     * @since 1.7\\n     */\\n    public String encode(final String value, final Charset charset) throws EncoderException {\\n        if (value == null) {\\n            return null;\\n        }\\n        return encodeText(value, charset);\\n    }\\n\\n    /**\\n     * Encodes a string into its Base64 form using the specified charset. Unsafe characters are escaped.\\n     *\\n     * @param value\\n     *            string to convert to Base64 form\\n     * @param charset\\n     *            the charset for <code>value</code>\\n     * @return Base64 string\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     */\\n    public String encode(final String value, final String charset) throws EncoderException {\\n        if (value == null) {\\n            return null;\\n        }\\n        try {\\n            return this.encodeText(value, charset);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new EncoderException(e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * Encodes a string into its Base64 form using the default charset. Unsafe characters are escaped.\\n     *\\n     * @param value\\n     *            string to convert to Base64 form\\n     * @return Base64 string\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     */\\n    @Override\\n    public String encode(final String value) throws EncoderException {\\n        if (value == null) {\\n            return null;\\n        }\\n        return encode(value, this.getCharset());\\n    }\\n\\n    /**\\n     * Decodes a Base64 string into its original form. Escaped characters are converted back to their original\\n     * representation.\\n     *\\n     * @param value\\n     *            Base64 string to convert into its original form\\n     * @return original string\\n     * @throws DecoderException\\n     *             A decoder exception is thrown if a failure condition is encountered during the decode process.\\n     */\\n    @Override\\n    public String decode(final String value) throws DecoderException {\\n        if (value == null) {\\n            return null;\\n        }\\n        try {\\n            return this.decodeText(value);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new DecoderException(e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * Encodes an object into its Base64 form using the default charset. Unsafe characters are escaped.\\n     *\\n     * @param value\\n     *            object to convert to Base64 form\\n     * @return Base64 object\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     */\\n    @Override\\n    public Object encode(final Object value) throws EncoderException {\\n        if (value == null) {\\n            return null;\\n        } else if (value instanceof String) {\\n            return encode((String) value);\\n        } else {\\n            throw new EncoderException(\\\"Objects of type \\\" +\\n                  value.getClass().getName() +\\n                  \\\" cannot be encoded using BCodec\\\");\\n        }\\n    }\\n\\n    /**\\n     * Decodes a Base64 object into its original form. Escaped characters are converted back to their original\\n     * representation.\\n     *\\n     * @param value\\n     *            Base64 object to convert into its original form\\n     * @return original object\\n     * @throws DecoderException\\n     *             Thrown if the argument is not a <code>String</code>. Thrown if a failure condition is encountered\\n     *             during the decode process.\\n     */\\n    @Override\\n    public Object decode(final Object value) throws DecoderException {\\n        if (value == null) {\\n            return null;\\n        } else if (value instanceof String) {\\n            return decode((String) value);\\n        } else {\\n            throw new DecoderException(\\\"Objects of type \\\" +\\n                  value.getClass().getName() +\\n                  \\\" cannot be decoded using BCodec\\\");\\n        }\\n    }\\n\\n    /**\\n     * Gets the default charset name used for string decoding and encoding.\\n     *\\n     * @return the default charset name\\n     * @since 1.7\\n     */\\n    public Charset getCharset() {\\n        return this.charset;\\n    }\\n\\n    /**\\n     * Gets the default charset name used for string decoding and encoding.\\n     *\\n     * @return the default charset name\\n     */\\n    public String getDefaultCharset() {\\n        return this.charset.name();\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"getEncoding\", \"return_type\": \"String\", \"position\": {\"start_line\": 87, \"end_line\": 89, \"start_column\": 15, \"end_column\": 5}, \"code\": \"String getEncoding() {\\n        return \\\"B\\\";\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"doEncoding\", \"return_type\": \"byte\", \"position\": {\"start_line\": 92, \"end_line\": 97, \"start_column\": 15, \"end_column\": 5}, \"code\": \"byte[] doEncoding(final byte[] bytes) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        return Base64.encodeBase64(bytes);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"doDecoding\", \"return_type\": \"byte\", \"position\": {\"start_line\": 100, \"end_line\": 105, \"start_column\": 15, \"end_column\": 5}, \"code\": \"byte[] doDecoding(final byte[] bytes) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        return Base64.decodeBase64(bytes);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 119, \"end_line\": 124, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String value, final Charset charset) throws EncoderException {\\n        if (value == null) {\\n            return null;\\n        }\\n        return encodeText(value, charset);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"Charset\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 137, \"end_line\": 146, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String value, final String charset) throws EncoderException {\\n        if (value == null) {\\n            return null;\\n        }\\n        try {\\n            return this.encodeText(value, charset);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new EncoderException(e.getMessage(), e);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 158, \"end_line\": 163, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String value) throws EncoderException {\\n        if (value == null) {\\n            return null;\\n        }\\n        return encode(value, this.getCharset());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}]}, {\"name\": \"decode\", \"return_type\": \"String\", \"position\": {\"start_line\": 176, \"end_line\": 185, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String decode(final String value) throws DecoderException {\\n        if (value == null) {\\n            return null;\\n        }\\n        try {\\n            return this.decodeText(value);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new DecoderException(e.getMessage(), e);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 197, \"end_line\": 207, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object value) throws EncoderException {\\n        if (value == null) {\\n            return null;\\n        } else if (value instanceof String) {\\n            return encode((String) value);\\n        } else {\\n            throw new EncoderException(\\\"Objects of type \\\" +\\n                  value.getClass().getName() +\\n                  \\\" cannot be encoded using BCodec\\\");\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"Object\"}]}, {\"name\": \"decode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 221, \"end_line\": 231, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object decode(final Object value) throws DecoderException {\\n        if (value == null) {\\n            return null;\\n        } else if (value instanceof String) {\\n            return decode((String) value);\\n        } else {\\n            throw new DecoderException(\\\"Objects of type \\\" +\\n                  value.getClass().getName() +\\n                  \\\" cannot be decoded using BCodec\\\");\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"value\", \"type\": \"Object\"}]}, {\"name\": \"getCharset\", \"return_type\": \"Charset\", \"position\": {\"start_line\": 239, \"end_line\": 241, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Charset getCharset() {\\n        return this.charset;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getDefaultCharset\", \"return_type\": \"String\", \"position\": {\"start_line\": 248, \"end_line\": 250, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getDefaultCharset() {\\n        return this.charset.name();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/net/QCodec.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.net;\\n\\nimport java.io.UnsupportedEncodingException;\\nimport java.nio.charset.Charset;\\nimport java.util.BitSet;\\n\\nimport org.apache.commons.codec.Charsets;\\nimport org.apache.commons.codec.DecoderException;\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringDecoder;\\nimport org.apache.commons.codec.StringEncoder;\\n\\n/**\\n * Similar to the Quoted-Printable content-transfer-encoding defined in\\n * <a href=\\\"http://www.ietf.org/rfc/rfc1521.txt\\\">RFC 1521</a> and designed to allow text containing mostly ASCII\\n * characters to be decipherable on an ASCII terminal without decoding.\\n * <p>\\n * <a href=\\\"http://www.ietf.org/rfc/rfc1522.txt\\\">RFC 1522</a> describes techniques to allow the encoding of non-ASCII\\n * text in various portions of a RFC 822 [2] message header, in a manner which is unlikely to confuse existing message\\n * handling software.\\n * <p>\\n * This class is conditionally thread-safe.\\n * The instance field {@link #encodeBlanks} is mutable {@link #setEncodeBlanks(boolean)}\\n * but is not volatile, and accesses are not synchronised.\\n * If an instance of the class is shared between threads, the caller needs to ensure that suitable synchronisation\\n * is used to ensure safe publication of the value between threads, and must not invoke\\n * {@link #setEncodeBlanks(boolean)} after initial setup.\\n *\\n * @see <a href=\\\"http://www.ietf.org/rfc/rfc1522.txt\\\">MIME (Multipurpose Internet Mail Extensions) Part Two: Message\\n *          Header Extensions for Non-ASCII Text</a>\\n *\\n * @since 1.3\\n * @version $Id: QCodec.java 1619948 2014-08-22 22:53:55Z ggregory $\\n */\\npublic class QCodec extends RFC1522Codec implements StringEncoder, StringDecoder {\\n    /**\\n     * The default charset used for string decoding and encoding.\\n     */\\n    private final Charset charset;\\n\\n    /**\\n     * BitSet of printable characters as defined in RFC 1522.\\n     */\\n    private static final BitSet PRINTABLE_CHARS = new BitSet(256);\\n    // Static initializer for printable chars collection\\n    static {\\n        // alpha characters\\n        PRINTABLE_CHARS.set(' ');\\n        PRINTABLE_CHARS.set('!');\\n        PRINTABLE_CHARS.set('\\\"');\\n        PRINTABLE_CHARS.set('#');\\n        PRINTABLE_CHARS.set('$');\\n        PRINTABLE_CHARS.set('%');\\n        PRINTABLE_CHARS.set('&');\\n        PRINTABLE_CHARS.set('\\\\'');\\n        PRINTABLE_CHARS.set('(');\\n        PRINTABLE_CHARS.set(')');\\n        PRINTABLE_CHARS.set('*');\\n        PRINTABLE_CHARS.set('+');\\n        PRINTABLE_CHARS.set(',');\\n        PRINTABLE_CHARS.set('-');\\n        PRINTABLE_CHARS.set('.');\\n        PRINTABLE_CHARS.set('/');\\n        for (int i = '0'; i <= '9'; i++) {\\n            PRINTABLE_CHARS.set(i);\\n        }\\n        PRINTABLE_CHARS.set(':');\\n        PRINTABLE_CHARS.set(';');\\n        PRINTABLE_CHARS.set('<');\\n        PRINTABLE_CHARS.set('>');\\n        PRINTABLE_CHARS.set('@');\\n        for (int i = 'A'; i <= 'Z'; i++) {\\n            PRINTABLE_CHARS.set(i);\\n        }\\n        PRINTABLE_CHARS.set('[');\\n        PRINTABLE_CHARS.set('\\\\\\\\');\\n        PRINTABLE_CHARS.set(']');\\n        PRINTABLE_CHARS.set('^');\\n        PRINTABLE_CHARS.set('`');\\n        for (int i = 'a'; i <= 'z'; i++) {\\n            PRINTABLE_CHARS.set(i);\\n        }\\n        PRINTABLE_CHARS.set('{');\\n        PRINTABLE_CHARS.set('|');\\n        PRINTABLE_CHARS.set('}');\\n        PRINTABLE_CHARS.set('~');\\n    }\\n\\n    private static final byte BLANK = 32;\\n\\n    private static final byte UNDERSCORE = 95;\\n\\n    private boolean encodeBlanks = false;\\n\\n    /**\\n     * Default constructor.\\n     */\\n    public QCodec() {\\n        this(Charsets.UTF_8);\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset.\\n     *\\n     * @param charset\\n     *            the default string charset to use.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @since 1.7\\n     */\\n    public QCodec(final Charset charset) {\\n        super();\\n        this.charset = charset;\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset.\\n     *\\n     * @param charsetName\\n     *            the charset to use.\\n     * @throws java.nio.charset.UnsupportedCharsetException\\n     *             If the named charset is unavailable\\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public QCodec(final String charsetName) {\\n        this(Charset.forName(charsetName));\\n    }\\n\\n    @Override\\n    protected String getEncoding() {\\n        return \\\"Q\\\";\\n    }\\n\\n    @Override\\n    protected byte[] doEncoding(final byte[] bytes) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\\n        if (this.encodeBlanks) {\\n            for (int i = 0; i < data.length; i++) {\\n                if (data[i] == BLANK) {\\n                    data[i] = UNDERSCORE;\\n                }\\n            }\\n        }\\n        return data;\\n    }\\n\\n    @Override\\n    protected byte[] doDecoding(final byte[] bytes) throws DecoderException {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        boolean hasUnderscores = false;\\n        for (final byte b : bytes) {\\n            if (b == UNDERSCORE) {\\n                hasUnderscores = true;\\n                break;\\n            }\\n        }\\n        if (hasUnderscores) {\\n            final byte[] tmp = new byte[bytes.length];\\n            for (int i = 0; i < bytes.length; i++) {\\n                final byte b = bytes[i];\\n                if (b != UNDERSCORE) {\\n                    tmp[i] = b;\\n                } else {\\n                    tmp[i] = BLANK;\\n                }\\n            }\\n            return QuotedPrintableCodec.decodeQuotedPrintable(tmp);\\n        }\\n        return QuotedPrintableCodec.decodeQuotedPrintable(bytes);\\n    }\\n\\n    /**\\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\\n     *\\n     * @param str\\n     *            string to convert to quoted-printable form\\n     * @param charset\\n     *            the charset for str\\n     * @return quoted-printable string\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     * @since 1.7\\n     */\\n    public String encode(final String str, final Charset charset) throws EncoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return encodeText(str, charset);\\n    }\\n\\n    /**\\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\\n     *\\n     * @param str\\n     *            string to convert to quoted-printable form\\n     * @param charset\\n     *            the charset for str\\n     * @return quoted-printable string\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     */\\n    public String encode(final String str, final String charset) throws EncoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        try {\\n            return encodeText(str, charset);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new EncoderException(e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * Encodes a string into its quoted-printable form using the default charset. Unsafe characters are escaped.\\n     *\\n     * @param str\\n     *            string to convert to quoted-printable form\\n     * @return quoted-printable string\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     */\\n    @Override\\n    public String encode(final String str) throws EncoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return encode(str, getCharset());\\n    }\\n\\n    /**\\n     * Decodes a quoted-printable string into its original form. Escaped characters are converted back to their original\\n     * representation.\\n     *\\n     * @param str\\n     *            quoted-printable string to convert into its original form\\n     * @return original string\\n     * @throws DecoderException\\n     *             A decoder exception is thrown if a failure condition is encountered during the decode process.\\n     */\\n    @Override\\n    public String decode(final String str) throws DecoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        try {\\n            return decodeText(str);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new DecoderException(e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * Encodes an object into its quoted-printable form using the default charset. Unsafe characters are escaped.\\n     *\\n     * @param obj\\n     *            object to convert to quoted-printable form\\n     * @return quoted-printable object\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof String) {\\n            return encode((String) obj);\\n        } else {\\n            throw new EncoderException(\\\"Objects of type \\\" +\\n                  obj.getClass().getName() +\\n                  \\\" cannot be encoded using Q codec\\\");\\n        }\\n    }\\n\\n    /**\\n     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\\n     * representation.\\n     *\\n     * @param obj\\n     *            quoted-printable object to convert into its original form\\n     * @return original object\\n     * @throws DecoderException\\n     *             Thrown if the argument is not a <code>String</code>. Thrown if a failure condition is encountered\\n     *             during the decode process.\\n     */\\n    @Override\\n    public Object decode(final Object obj) throws DecoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof String) {\\n            return decode((String) obj);\\n        } else {\\n            throw new DecoderException(\\\"Objects of type \\\" +\\n                  obj.getClass().getName() +\\n                  \\\" cannot be decoded using Q codec\\\");\\n        }\\n    }\\n\\n    /**\\n     * Gets the default charset name used for string decoding and encoding.\\n     *\\n     * @return the default charset name\\n     * @since 1.7\\n     */\\n    public Charset getCharset() {\\n        return this.charset;\\n    }\\n\\n    /**\\n     * Gets the default charset name used for string decoding and encoding.\\n     *\\n     * @return the default charset name\\n     */\\n    public String getDefaultCharset() {\\n        return this.charset.name();\\n    }\\n\\n    /**\\n     * Tests if optional transformation of SPACE characters is to be used\\n     *\\n     * @return <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise\\n     */\\n    public boolean isEncodeBlanks() {\\n        return this.encodeBlanks;\\n    }\\n\\n    /**\\n     * Defines whether optional transformation of SPACE characters is to be used\\n     *\\n     * @param b\\n     *            <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise\\n     */\\n    public void setEncodeBlanks(final boolean b) {\\n        this.encodeBlanks = b;\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"QCodec\", \"position\": {\"start_line\": 52, \"end_line\": 358, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class QCodec extends RFC1522Codec implements StringEncoder, StringDecoder {\\n    /**\\n     * The default charset used for string decoding and encoding.\\n     */\\n    private final Charset charset;\\n\\n    /**\\n     * BitSet of printable characters as defined in RFC 1522.\\n     */\\n    private static final BitSet PRINTABLE_CHARS = new BitSet(256);\\n    // Static initializer for printable chars collection\\n    static {\\n        // alpha characters\\n        PRINTABLE_CHARS.set(' ');\\n        PRINTABLE_CHARS.set('!');\\n        PRINTABLE_CHARS.set('\\\"');\\n        PRINTABLE_CHARS.set('#');\\n        PRINTABLE_CHARS.set('$');\\n        PRINTABLE_CHARS.set('%');\\n        PRINTABLE_CHARS.set('&');\\n        PRINTABLE_CHARS.set('\\\\'');\\n        PRINTABLE_CHARS.set('(');\\n        PRINTABLE_CHARS.set(')');\\n        PRINTABLE_CHARS.set('*');\\n        PRINTABLE_CHARS.set('+');\\n        PRINTABLE_CHARS.set(',');\\n        PRINTABLE_CHARS.set('-');\\n        PRINTABLE_CHARS.set('.');\\n        PRINTABLE_CHARS.set('/');\\n        for (int i = '0'; i <= '9'; i++) {\\n            PRINTABLE_CHARS.set(i);\\n        }\\n        PRINTABLE_CHARS.set(':');\\n        PRINTABLE_CHARS.set(';');\\n        PRINTABLE_CHARS.set('<');\\n        PRINTABLE_CHARS.set('>');\\n        PRINTABLE_CHARS.set('@');\\n        for (int i = 'A'; i <= 'Z'; i++) {\\n            PRINTABLE_CHARS.set(i);\\n        }\\n        PRINTABLE_CHARS.set('[');\\n        PRINTABLE_CHARS.set('\\\\\\\\');\\n        PRINTABLE_CHARS.set(']');\\n        PRINTABLE_CHARS.set('^');\\n        PRINTABLE_CHARS.set('`');\\n        for (int i = 'a'; i <= 'z'; i++) {\\n            PRINTABLE_CHARS.set(i);\\n        }\\n        PRINTABLE_CHARS.set('{');\\n        PRINTABLE_CHARS.set('|');\\n        PRINTABLE_CHARS.set('}');\\n        PRINTABLE_CHARS.set('~');\\n    }\\n\\n    private static final byte BLANK = 32;\\n\\n    private static final byte UNDERSCORE = 95;\\n\\n    private boolean encodeBlanks = false;\\n\\n    /**\\n     * Default constructor.\\n     */\\n    public QCodec() {\\n        this(Charsets.UTF_8);\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset.\\n     *\\n     * @param charset\\n     *            the default string charset to use.\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     * @since 1.7\\n     */\\n    public QCodec(final Charset charset) {\\n        super();\\n        this.charset = charset;\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset.\\n     *\\n     * @param charsetName\\n     *            the charset to use.\\n     * @throws java.nio.charset.UnsupportedCharsetException\\n     *             If the named charset is unavailable\\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    public QCodec(final String charsetName) {\\n        this(Charset.forName(charsetName));\\n    }\\n\\n    @Override\\n    protected String getEncoding() {\\n        return \\\"Q\\\";\\n    }\\n\\n    @Override\\n    protected byte[] doEncoding(final byte[] bytes) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\\n        if (this.encodeBlanks) {\\n            for (int i = 0; i < data.length; i++) {\\n                if (data[i] == BLANK) {\\n                    data[i] = UNDERSCORE;\\n                }\\n            }\\n        }\\n        return data;\\n    }\\n\\n    @Override\\n    protected byte[] doDecoding(final byte[] bytes) throws DecoderException {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        boolean hasUnderscores = false;\\n        for (final byte b : bytes) {\\n            if (b == UNDERSCORE) {\\n                hasUnderscores = true;\\n                break;\\n            }\\n        }\\n        if (hasUnderscores) {\\n            final byte[] tmp = new byte[bytes.length];\\n            for (int i = 0; i < bytes.length; i++) {\\n                final byte b = bytes[i];\\n                if (b != UNDERSCORE) {\\n                    tmp[i] = b;\\n                } else {\\n                    tmp[i] = BLANK;\\n                }\\n            }\\n            return QuotedPrintableCodec.decodeQuotedPrintable(tmp);\\n        }\\n        return QuotedPrintableCodec.decodeQuotedPrintable(bytes);\\n    }\\n\\n    /**\\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\\n     *\\n     * @param str\\n     *            string to convert to quoted-printable form\\n     * @param charset\\n     *            the charset for str\\n     * @return quoted-printable string\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     * @since 1.7\\n     */\\n    public String encode(final String str, final Charset charset) throws EncoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return encodeText(str, charset);\\n    }\\n\\n    /**\\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\\n     *\\n     * @param str\\n     *            string to convert to quoted-printable form\\n     * @param charset\\n     *            the charset for str\\n     * @return quoted-printable string\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     */\\n    public String encode(final String str, final String charset) throws EncoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        try {\\n            return encodeText(str, charset);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new EncoderException(e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * Encodes a string into its quoted-printable form using the default charset. Unsafe characters are escaped.\\n     *\\n     * @param str\\n     *            string to convert to quoted-printable form\\n     * @return quoted-printable string\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     */\\n    @Override\\n    public String encode(final String str) throws EncoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return encode(str, getCharset());\\n    }\\n\\n    /**\\n     * Decodes a quoted-printable string into its original form. Escaped characters are converted back to their original\\n     * representation.\\n     *\\n     * @param str\\n     *            quoted-printable string to convert into its original form\\n     * @return original string\\n     * @throws DecoderException\\n     *             A decoder exception is thrown if a failure condition is encountered during the decode process.\\n     */\\n    @Override\\n    public String decode(final String str) throws DecoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        try {\\n            return decodeText(str);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new DecoderException(e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * Encodes an object into its quoted-printable form using the default charset. Unsafe characters are escaped.\\n     *\\n     * @param obj\\n     *            object to convert to quoted-printable form\\n     * @return quoted-printable object\\n     * @throws EncoderException\\n     *             thrown if a failure condition is encountered during the encoding process.\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof String) {\\n            return encode((String) obj);\\n        } else {\\n            throw new EncoderException(\\\"Objects of type \\\" +\\n                  obj.getClass().getName() +\\n                  \\\" cannot be encoded using Q codec\\\");\\n        }\\n    }\\n\\n    /**\\n     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\\n     * representation.\\n     *\\n     * @param obj\\n     *            quoted-printable object to convert into its original form\\n     * @return original object\\n     * @throws DecoderException\\n     *             Thrown if the argument is not a <code>String</code>. Thrown if a failure condition is encountered\\n     *             during the decode process.\\n     */\\n    @Override\\n    public Object decode(final Object obj) throws DecoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof String) {\\n            return decode((String) obj);\\n        } else {\\n            throw new DecoderException(\\\"Objects of type \\\" +\\n                  obj.getClass().getName() +\\n                  \\\" cannot be decoded using Q codec\\\");\\n        }\\n    }\\n\\n    /**\\n     * Gets the default charset name used for string decoding and encoding.\\n     *\\n     * @return the default charset name\\n     * @since 1.7\\n     */\\n    public Charset getCharset() {\\n        return this.charset;\\n    }\\n\\n    /**\\n     * Gets the default charset name used for string decoding and encoding.\\n     *\\n     * @return the default charset name\\n     */\\n    public String getDefaultCharset() {\\n        return this.charset.name();\\n    }\\n\\n    /**\\n     * Tests if optional transformation of SPACE characters is to be used\\n     *\\n     * @return <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise\\n     */\\n    public boolean isEncodeBlanks() {\\n        return this.encodeBlanks;\\n    }\\n\\n    /**\\n     * Defines whether optional transformation of SPACE characters is to be used\\n     *\\n     * @param b\\n     *            <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise\\n     */\\n    public void setEncodeBlanks(final boolean b) {\\n        this.encodeBlanks = b;\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"getEncoding\", \"return_type\": \"String\", \"position\": {\"start_line\": 148, \"end_line\": 150, \"start_column\": 15, \"end_column\": 5}, \"code\": \"String getEncoding() {\\n        return \\\"Q\\\";\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"doEncoding\", \"return_type\": \"byte\", \"position\": {\"start_line\": 153, \"end_line\": 166, \"start_column\": 15, \"end_column\": 5}, \"code\": \"byte[] doEncoding(final byte[] bytes) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        final byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\\n        if (this.encodeBlanks) {\\n            for (int i = 0; i < data.length; i++) {\\n                if (data[i] == BLANK) {\\n                    data[i] = UNDERSCORE;\\n                }\\n            }\\n        }\\n        return data;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"doDecoding\", \"return_type\": \"byte\", \"position\": {\"start_line\": 169, \"end_line\": 193, \"start_column\": 15, \"end_column\": 5}, \"code\": \"byte[] doDecoding(final byte[] bytes) throws DecoderException {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        boolean hasUnderscores = false;\\n        for (final byte b : bytes) {\\n            if (b == UNDERSCORE) {\\n                hasUnderscores = true;\\n                break;\\n            }\\n        }\\n        if (hasUnderscores) {\\n            final byte[] tmp = new byte[bytes.length];\\n            for (int i = 0; i < bytes.length; i++) {\\n                final byte b = bytes[i];\\n                if (b != UNDERSCORE) {\\n                    tmp[i] = b;\\n                } else {\\n                    tmp[i] = BLANK;\\n                }\\n            }\\n            return QuotedPrintableCodec.decodeQuotedPrintable(tmp);\\n        }\\n        return QuotedPrintableCodec.decodeQuotedPrintable(bytes);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 207, \"end_line\": 212, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str, final Charset charset) throws EncoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return encodeText(str, charset);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"Charset\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 225, \"end_line\": 234, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str, final String charset) throws EncoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        try {\\n            return encodeText(str, charset);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new EncoderException(e.getMessage(), e);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 246, \"end_line\": 251, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str) throws EncoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return encode(str, getCharset());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"decode\", \"return_type\": \"String\", \"position\": {\"start_line\": 264, \"end_line\": 273, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String decode(final String str) throws DecoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        try {\\n            return decodeText(str);\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new DecoderException(e.getMessage(), e);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 285, \"end_line\": 295, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object obj) throws EncoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof String) {\\n            return encode((String) obj);\\n        } else {\\n            throw new EncoderException(\\\"Objects of type \\\" +\\n                  obj.getClass().getName() +\\n                  \\\" cannot be encoded using Q codec\\\");\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"decode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 309, \"end_line\": 319, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object decode(final Object obj) throws DecoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof String) {\\n            return decode((String) obj);\\n        } else {\\n            throw new DecoderException(\\\"Objects of type \\\" +\\n                  obj.getClass().getName() +\\n                  \\\" cannot be decoded using Q codec\\\");\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"getCharset\", \"return_type\": \"Charset\", \"position\": {\"start_line\": 327, \"end_line\": 329, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Charset getCharset() {\\n        return this.charset;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getDefaultCharset\", \"return_type\": \"String\", \"position\": {\"start_line\": 336, \"end_line\": 338, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getDefaultCharset() {\\n        return this.charset.name();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"isEncodeBlanks\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 345, \"end_line\": 347, \"start_column\": 12, \"end_column\": 5}, \"code\": \"boolean isEncodeBlanks() {\\n        return this.encodeBlanks;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"setEncodeBlanks\", \"return_type\": \"void\", \"position\": {\"start_line\": 355, \"end_line\": 357, \"start_column\": 12, \"end_column\": 5}, \"code\": \"void setEncodeBlanks(final boolean b) {\\n        this.encodeBlanks = b;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"boolean\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.net;\\n\\nimport java.io.ByteArrayOutputStream;\\nimport java.io.UnsupportedEncodingException;\\nimport java.nio.charset.Charset;\\nimport java.nio.charset.IllegalCharsetNameException;\\nimport java.nio.charset.UnsupportedCharsetException;\\nimport java.util.BitSet;\\n\\nimport org.apache.commons.codec.BinaryDecoder;\\nimport org.apache.commons.codec.BinaryEncoder;\\nimport org.apache.commons.codec.Charsets;\\nimport org.apache.commons.codec.DecoderException;\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringDecoder;\\nimport org.apache.commons.codec.StringEncoder;\\nimport org.apache.commons.codec.binary.StringUtils;\\n\\n/**\\n * Codec for the Quoted-Printable section of <a href=\\\"http://www.ietf.org/rfc/rfc1521.txt\\\">RFC 1521</a>.\\n * <p>\\n * The Quoted-Printable encoding is intended to represent data that largely consists of octets that correspond to\\n * printable characters in the ASCII character set. It encodes the data in such a way that the resulting octets are\\n * unlikely to be modified by mail transport. If the data being encoded are mostly ASCII text, the encoded form of the\\n * data remains largely recognizable by humans. A body which is entirely ASCII may also be encoded in Quoted-Printable\\n * to ensure the integrity of the data should the message pass through a character- translating, and/or line-wrapping\\n * gateway.\\n * <p>\\n * Note:\\n * <p>\\n * Depending on the selected {@code strict} parameter, this class will implement a different set of rules of the\\n * quoted-printable spec:\\n * <ul>\\n *   <li>{@code strict=false}: only rules #1 and #2 are implemented\\n *   <li>{@code strict=true}: all rules #1 through #5 are implemented\\n * </ul>\\n * Originally, this class only supported the non-strict mode, but the codec in this partial form could already be used\\n * for certain applications that do not require quoted-printable line formatting (rules #3, #4, #5), for instance\\n * Q codec. The strict mode has been added in 1.10.\\n * <p>\\n * This class is immutable and thread-safe.\\n *\\n * @see <a href=\\\"http://www.ietf.org/rfc/rfc1521.txt\\\">RFC 1521 MIME (Multipurpose Internet Mail Extensions) Part One:\\n *          Mechanisms for Specifying and Describing the Format of Internet Message Bodies </a>\\n *\\n * @since 1.3\\n * @version $Id: QuotedPrintableCodec.java 1788792 2017-03-26 23:57:00Z sebb $\\n */\\npublic class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, StringEncoder, StringDecoder {\\n    /**\\n     * The default charset used for string decoding and encoding.\\n     */\\n    private final Charset charset;\\n\\n    /**\\n     * Indicates whether soft line breaks shall be used during encoding (rule #3-5).\\n     */\\n    private final boolean strict;\\n\\n    /**\\n     * BitSet of printable characters as defined in RFC 1521.\\n     */\\n    private static final BitSet PRINTABLE_CHARS = new BitSet(256);\\n\\n    private static final byte ESCAPE_CHAR = '=';\\n\\n    private static final byte TAB = 9;\\n\\n    private static final byte SPACE = 32;\\n\\n    private static final byte CR = 13;\\n\\n    private static final byte LF = 10;\\n\\n    /**\\n     * Safe line length for quoted printable encoded text.\\n     */\\n    private static final int SAFE_LENGTH = 73;\\n\\n    // Static initializer for printable chars collection\\n    static {\\n        // alpha characters\\n        for (int i = 33; i <= 60; i++) {\\n            PRINTABLE_CHARS.set(i);\\n        }\\n        for (int i = 62; i <= 126; i++) {\\n            PRINTABLE_CHARS.set(i);\\n        }\\n        PRINTABLE_CHARS.set(TAB);\\n        PRINTABLE_CHARS.set(SPACE);\\n    }\\n\\n    /**\\n     * Default constructor, assumes default charset of {@link Charsets#UTF_8}\\n     */\\n    public QuotedPrintableCodec() {\\n        this(Charsets.UTF_8, false);\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of the strict mode.\\n     *\\n     * @param strict\\n     *            if {@code true}, soft line breaks will be used\\n     * @since 1.10\\n     */\\n    public QuotedPrintableCodec(final boolean strict) {\\n        this(Charsets.UTF_8, strict);\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset.\\n     *\\n     * @param charset\\n     *            the default string charset to use.\\n     * @since 1.7\\n     */\\n    public QuotedPrintableCodec(final Charset charset) {\\n        this(charset, false);\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset and strict mode.\\n     *\\n     * @param charset\\n     *            the default string charset to use.\\n     * @param strict\\n     *            if {@code true}, soft line breaks will be used\\n     * @since 1.10\\n     */\\n    public QuotedPrintableCodec(final Charset charset, final boolean strict) {\\n        this.charset = charset;\\n        this.strict = strict;\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset.\\n     *\\n     * @param charsetName\\n     *            the default string charset to use.\\n     * @throws UnsupportedCharsetException\\n     *             If no support for the named charset is available\\n     *             in this instance of the Java virtual machine\\n     * @throws IllegalArgumentException\\n     *             If the given charsetName is null\\n     * @throws IllegalCharsetNameException\\n     *             If the given charset name is illegal\\n     *\\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\\n     */\\n    public QuotedPrintableCodec(final String charsetName)\\n            throws IllegalCharsetNameException, IllegalArgumentException, UnsupportedCharsetException {\\n        this(Charset.forName(charsetName), false);\\n    }\\n\\n    /**\\n     * Encodes byte into its quoted-printable representation.\\n     *\\n     * @param b\\n     *            byte to encode\\n     * @param buffer\\n     *            the buffer to write to\\n     * @return The number of bytes written to the <code>buffer</code>\\n     */\\n    private static final int encodeQuotedPrintable(final int b, final ByteArrayOutputStream buffer) {\\n        buffer.write(ESCAPE_CHAR);\\n        final char hex1 = Utils.hexDigit(b >> 4);\\n        final char hex2 = Utils.hexDigit(b);\\n        buffer.write(hex1);\\n        buffer.write(hex2);\\n        return 3;\\n    }\\n\\n    /**\\n     * Return the byte at position <code>index</code> of the byte array and\\n     * make sure it is unsigned.\\n     *\\n     * @param index\\n     *            position in the array\\n     * @param bytes\\n     *            the byte array\\n     * @return the unsigned octet at position <code>index</code> from the array\\n     */\\n    private static int getUnsignedOctet(final int index, final byte[] bytes) {\\n        int b = bytes[index];\\n        if (b < 0) {\\n            b = 256 + b;\\n        }\\n        return b;\\n    }\\n\\n    /**\\n     * Write a byte to the buffer.\\n     *\\n     * @param b\\n     *            byte to write\\n     * @param encode\\n     *            indicates whether the octet shall be encoded\\n     * @param buffer\\n     *            the buffer to write to\\n     * @return the number of bytes that have been written to the buffer\\n     */\\n    private static int encodeByte(final int b, final boolean encode,\\n                                  final ByteArrayOutputStream buffer) {\\n        if (encode) {\\n            return encodeQuotedPrintable(b, buffer);\\n        }\\n        buffer.write(b);\\n        return 1;\\n    }\\n\\n    /**\\n     * Checks whether the given byte is whitespace.\\n     *\\n     * @param b\\n     *            byte to be checked\\n     * @return <code>true</code> if the byte is either a space or tab character\\n     */\\n    private static boolean isWhitespace(final int b) {\\n        return b == SPACE || b == TAB;\\n    }\\n\\n    /**\\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\\n     * <p>\\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\\n     *\\n     * @param printable\\n     *            bitset of characters deemed quoted-printable\\n     * @param bytes\\n     *            array of bytes to be encoded\\n     * @return array of bytes containing quoted-printable data\\n     */\\n    public static final byte[] encodeQuotedPrintable(final BitSet printable, final byte[] bytes) {\\n        return encodeQuotedPrintable(printable, bytes, false);\\n    }\\n\\n    /**\\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\\n     * <p>\\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\\n     *\\n     * @param printable\\n     *            bitset of characters deemed quoted-printable\\n     * @param bytes\\n     *            array of bytes to be encoded\\n     * @param strict\\n     *            if {@code true} the full ruleset is used, otherwise only rule #1 and rule #2\\n     * @return array of bytes containing quoted-printable data\\n     * @since 1.10\\n     */\\n    public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        if (printable == null) {\\n            printable = PRINTABLE_CHARS;\\n        }\\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\\n\\n        if (strict) {\\n            int pos = 1;\\n            // encode up to buffer.length - 3, the last three octets will be treated\\n            // separately for simplification of note #3\\n            for (int i = 0; i < bytes.length - 3; i++) {\\n                final int b = getUnsignedOctet(i, bytes);\\n                if (pos < SAFE_LENGTH) {\\n                    // up to this length it is safe to add any byte, encoded or not\\n                    pos += encodeByte(b, !printable.get(b), buffer);\\n                } else {\\n                    // rule #3: whitespace at the end of a line *must* be encoded\\n                    encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\\n\\n                    // rule #5: soft line break\\n                    buffer.write(ESCAPE_CHAR);\\n                    buffer.write(CR);\\n                    buffer.write(LF);\\n                    pos = 1;\\n                }\\n            }\\n\\n            // rule #3: whitespace at the end of a line *must* be encoded\\n            // if we would do a soft break line after this octet, encode whitespace\\n            int b = getUnsignedOctet(bytes.length - 3, bytes);\\n            boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);\\n            pos += encodeByte(b, encode, buffer);\\n\\n            // note #3: '=' *must not* be the ultimate or penultimate character\\n            // simplification: if < 6 bytes left, do a soft line break as we may need\\n            //                 exactly 6 bytes space for the last 2 bytes\\n            if (pos > SAFE_LENGTH - 2) {\\n                buffer.write(ESCAPE_CHAR);\\n                buffer.write(CR);\\n                buffer.write(LF);\\n            }\\n            for (int i = bytes.length - 2; i < bytes.length; i++) {\\n                b = getUnsignedOctet(i, bytes);\\n                // rule #3: trailing whitespace shall be encoded\\n                encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));\\n                encodeByte(b, encode, buffer);\\n            }\\n        } else {\\n            for (final byte c : bytes) {\\n                int b = c;\\n                if (b < 0) {\\n                    b = 256 + b;\\n                }\\n                if (printable.get(b)) {\\n                    buffer.write(b);\\n                } else {\\n                    encodeQuotedPrintable(b, buffer);\\n                }\\n            }\\n        }\\n        return buffer.toByteArray();\\n    }\\n\\n    /**\\n     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted\\n     * back to their original representation.\\n     * <p>\\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\\n     * defined in RFC 1521.\\n     *\\n     * @param bytes\\n     *            array of quoted-printable characters\\n     * @return array of original bytes\\n     * @throws DecoderException\\n     *             Thrown if quoted-printable decoding is unsuccessful\\n     */\\n    public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\\n        for (int i = 0; i < bytes.length; i++) {\\n            final int b = bytes[i];\\n            if (b == ESCAPE_CHAR) {\\n                try {\\n                    // if the next octet is a CR we have found a soft line break\\n                    if (bytes[++i] == CR) {\\n                        continue;\\n                    }\\n                    final int u = Utils.digit16(bytes[i]);\\n                    final int l = Utils.digit16(bytes[++i]);\\n                    buffer.write((char) ((u << 4) + l));\\n                } catch (final ArrayIndexOutOfBoundsException e) {\\n                    throw new DecoderException(\\\"Invalid quoted-printable encoding\\\", e);\\n                }\\n            } else if (b != CR && b != LF) {\\n                // every other octet is appended except for CR & LF\\n                buffer.write(b);\\n            }\\n        }\\n        return buffer.toByteArray();\\n    }\\n\\n    /**\\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\\n     * <p>\\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\\n     *\\n     * @param bytes\\n     *            array of bytes to be encoded\\n     * @return array of bytes containing quoted-printable data\\n     */\\n    @Override\\n    public byte[] encode(final byte[] bytes) {\\n        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes, strict);\\n    }\\n\\n    /**\\n     * Decodes an array of quoted-printable characters into an array of original bytes. Escaped characters are converted\\n     * back to their original representation.\\n     * <p>\\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\\n     * defined in RFC 1521.\\n     *\\n     * @param bytes\\n     *            array of quoted-printable characters\\n     * @return array of original bytes\\n     * @throws DecoderException\\n     *             Thrown if quoted-printable decoding is unsuccessful\\n     */\\n    @Override\\n    public byte[] decode(final byte[] bytes) throws DecoderException {\\n        return decodeQuotedPrintable(bytes);\\n    }\\n\\n    /**\\n     * Encodes a string into its quoted-printable form using the default string charset. Unsafe characters are escaped.\\n     * <p>\\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\\n     *\\n     * @param str\\n     *            string to convert to quoted-printable form\\n     * @return quoted-printable string\\n     * @throws EncoderException\\n     *             Thrown if quoted-printable encoding is unsuccessful\\n     *\\n     * @see #getCharset()\\n     */\\n    @Override\\n    public String encode(final String str) throws EncoderException {\\n        return this.encode(str, getCharset());\\n    }\\n\\n    /**\\n     * Decodes a quoted-printable string into its original form using the specified string charset. Escaped characters\\n     * are converted back to their original representation.\\n     *\\n     * @param str\\n     *            quoted-printable string to convert into its original form\\n     * @param charset\\n     *            the original string charset\\n     * @return original string\\n     * @throws DecoderException\\n     *             Thrown if quoted-printable decoding is unsuccessful\\n     * @since 1.7\\n     */\\n    public String decode(final String str, final Charset charset) throws DecoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return new String(this.decode(StringUtils.getBytesUsAscii(str)), charset);\\n    }\\n\\n    /**\\n     * Decodes a quoted-printable string into its original form using the specified string charset. Escaped characters\\n     * are converted back to their original representation.\\n     *\\n     * @param str\\n     *            quoted-printable string to convert into its original form\\n     * @param charset\\n     *            the original string charset\\n     * @return original string\\n     * @throws DecoderException\\n     *             Thrown if quoted-printable decoding is unsuccessful\\n     * @throws UnsupportedEncodingException\\n     *             Thrown if charset is not supported\\n     */\\n    public String decode(final String str, final String charset) throws DecoderException, UnsupportedEncodingException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return new String(decode(StringUtils.getBytesUsAscii(str)), charset);\\n    }\\n\\n    /**\\n     * Decodes a quoted-printable string into its original form using the default string charset. Escaped characters are\\n     * converted back to their original representation.\\n     *\\n     * @param str\\n     *            quoted-printable string to convert into its original form\\n     * @return original string\\n     * @throws DecoderException\\n     *             Thrown if quoted-printable decoding is unsuccessful. Thrown if charset is not supported.\\n     * @see #getCharset()\\n     */\\n    @Override\\n    public String decode(final String str) throws DecoderException {\\n        return this.decode(str, this.getCharset());\\n    }\\n\\n    /**\\n     * Encodes an object into its quoted-printable safe form. Unsafe characters are escaped.\\n     *\\n     * @param obj\\n     *            string to convert to a quoted-printable form\\n     * @return quoted-printable object\\n     * @throws EncoderException\\n     *             Thrown if quoted-printable encoding is not applicable to objects of this type or if encoding is\\n     *             unsuccessful\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof byte[]) {\\n            return encode((byte[]) obj);\\n        } else if (obj instanceof String) {\\n            return encode((String) obj);\\n        } else {\\n            throw new EncoderException(\\\"Objects of type \\\" +\\n                  obj.getClass().getName() +\\n                  \\\" cannot be quoted-printable encoded\\\");\\n        }\\n    }\\n\\n    /**\\n     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\\n     * representation.\\n     *\\n     * @param obj\\n     *            quoted-printable object to convert into its original form\\n     * @return original object\\n     * @throws DecoderException\\n     *             Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure\\n     *             condition is encountered during the decode process.\\n     */\\n    @Override\\n    public Object decode(final Object obj) throws DecoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof byte[]) {\\n            return decode((byte[]) obj);\\n        } else if (obj instanceof String) {\\n            return decode((String) obj);\\n        } else {\\n            throw new DecoderException(\\\"Objects of type \\\" +\\n                  obj.getClass().getName() +\\n                  \\\" cannot be quoted-printable decoded\\\");\\n        }\\n    }\\n\\n    /**\\n     * Gets the default charset name used for string decoding and encoding.\\n     *\\n     * @return the default charset name\\n     * @since 1.7\\n     */\\n    public Charset getCharset() {\\n        return this.charset;\\n    }\\n\\n    /**\\n     * Gets the default charset name used for string decoding and encoding.\\n     *\\n     * @return the default charset name\\n     */\\n    public String getDefaultCharset() {\\n        return this.charset.name();\\n    }\\n\\n    /**\\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\\n     * <p>\\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\\n     *\\n     * @param str\\n     *            string to convert to quoted-printable form\\n     * @param charset\\n     *            the charset for str\\n     * @return quoted-printable string\\n     * @since 1.7\\n     */\\n    public String encode(final String str, final Charset charset) {\\n        if (str == null) {\\n            return null;\\n        }\\n        return StringUtils.newStringUsAscii(this.encode(str.getBytes(charset)));\\n    }\\n\\n    /**\\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\\n     * <p>\\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\\n     *\\n     * @param str\\n     *            string to convert to quoted-printable form\\n     * @param charset\\n     *            the charset for str\\n     * @return quoted-printable string\\n     * @throws UnsupportedEncodingException\\n     *             Thrown if the charset is not supported\\n     */\\n    public String encode(final String str, final String charset) throws UnsupportedEncodingException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return StringUtils.newStringUsAscii(encode(str.getBytes(charset)));\\n    }\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"QuotedPrintableCodec\", \"position\": {\"start_line\": 66, \"end_line\": 601, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, StringEncoder, StringDecoder {\\n    /**\\n     * The default charset used for string decoding and encoding.\\n     */\\n    private final Charset charset;\\n\\n    /**\\n     * Indicates whether soft line breaks shall be used during encoding (rule #3-5).\\n     */\\n    private final boolean strict;\\n\\n    /**\\n     * BitSet of printable characters as defined in RFC 1521.\\n     */\\n    private static final BitSet PRINTABLE_CHARS = new BitSet(256);\\n\\n    private static final byte ESCAPE_CHAR = '=';\\n\\n    private static final byte TAB = 9;\\n\\n    private static final byte SPACE = 32;\\n\\n    private static final byte CR = 13;\\n\\n    private static final byte LF = 10;\\n\\n    /**\\n     * Safe line length for quoted printable encoded text.\\n     */\\n    private static final int SAFE_LENGTH = 73;\\n\\n    // Static initializer for printable chars collection\\n    static {\\n        // alpha characters\\n        for (int i = 33; i <= 60; i++) {\\n            PRINTABLE_CHARS.set(i);\\n        }\\n        for (int i = 62; i <= 126; i++) {\\n            PRINTABLE_CHARS.set(i);\\n        }\\n        PRINTABLE_CHARS.set(TAB);\\n        PRINTABLE_CHARS.set(SPACE);\\n    }\\n\\n    /**\\n     * Default constructor, assumes default charset of {@link Charsets#UTF_8}\\n     */\\n    public QuotedPrintableCodec() {\\n        this(Charsets.UTF_8, false);\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of the strict mode.\\n     *\\n     * @param strict\\n     *            if {@code true}, soft line breaks will be used\\n     * @since 1.10\\n     */\\n    public QuotedPrintableCodec(final boolean strict) {\\n        this(Charsets.UTF_8, strict);\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset.\\n     *\\n     * @param charset\\n     *            the default string charset to use.\\n     * @since 1.7\\n     */\\n    public QuotedPrintableCodec(final Charset charset) {\\n        this(charset, false);\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset and strict mode.\\n     *\\n     * @param charset\\n     *            the default string charset to use.\\n     * @param strict\\n     *            if {@code true}, soft line breaks will be used\\n     * @since 1.10\\n     */\\n    public QuotedPrintableCodec(final Charset charset, final boolean strict) {\\n        this.charset = charset;\\n        this.strict = strict;\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset.\\n     *\\n     * @param charsetName\\n     *            the default string charset to use.\\n     * @throws UnsupportedCharsetException\\n     *             If no support for the named charset is available\\n     *             in this instance of the Java virtual machine\\n     * @throws IllegalArgumentException\\n     *             If the given charsetName is null\\n     * @throws IllegalCharsetNameException\\n     *             If the given charset name is illegal\\n     *\\n     * @since 1.7 throws UnsupportedCharsetException if the named charset is unavailable\\n     */\\n    public QuotedPrintableCodec(final String charsetName)\\n            throws IllegalCharsetNameException, IllegalArgumentException, UnsupportedCharsetException {\\n        this(Charset.forName(charsetName), false);\\n    }\\n\\n    /**\\n     * Encodes byte into its quoted-printable representation.\\n     *\\n     * @param b\\n     *            byte to encode\\n     * @param buffer\\n     *            the buffer to write to\\n     * @return The number of bytes written to the <code>buffer</code>\\n     */\\n    private static final int encodeQuotedPrintable(final int b, final ByteArrayOutputStream buffer) {\\n        buffer.write(ESCAPE_CHAR);\\n        final char hex1 = Utils.hexDigit(b >> 4);\\n        final char hex2 = Utils.hexDigit(b);\\n        buffer.write(hex1);\\n        buffer.write(hex2);\\n        return 3;\\n    }\\n\\n    /**\\n     * Return the byte at position <code>index</code> of the byte array and\\n     * make sure it is unsigned.\\n     *\\n     * @param index\\n     *            position in the array\\n     * @param bytes\\n     *            the byte array\\n     * @return the unsigned octet at position <code>index</code> from the array\\n     */\\n    private static int getUnsignedOctet(final int index, final byte[] bytes) {\\n        int b = bytes[index];\\n        if (b < 0) {\\n            b = 256 + b;\\n        }\\n        return b;\\n    }\\n\\n    /**\\n     * Write a byte to the buffer.\\n     *\\n     * @param b\\n     *            byte to write\\n     * @param encode\\n     *            indicates whether the octet shall be encoded\\n     * @param buffer\\n     *            the buffer to write to\\n     * @return the number of bytes that have been written to the buffer\\n     */\\n    private static int encodeByte(final int b, final boolean encode,\\n                                  final ByteArrayOutputStream buffer) {\\n        if (encode) {\\n            return encodeQuotedPrintable(b, buffer);\\n        }\\n        buffer.write(b);\\n        return 1;\\n    }\\n\\n    /**\\n     * Checks whether the given byte is whitespace.\\n     *\\n     * @param b\\n     *            byte to be checked\\n     * @return <code>true</code> if the byte is either a space or tab character\\n     */\\n    private static boolean isWhitespace(final int b) {\\n        return b == SPACE || b == TAB;\\n    }\\n\\n    /**\\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\\n     * <p>\\n     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\\n     *\\n     * @param printable\\n     *            bitset of characters deemed quoted-printable\\n     * @param bytes\\n     *            array of bytes to be encoded\\n     * @return array of bytes containing quoted-printable data\\n     */\\n    public static final byte[] encodeQuotedPrintable(final BitSet printable, final byte[] bytes) {\\n        return encodeQuotedPrintable(printable, bytes, false);\\n    }\\n\\n    /**\\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\\n     * <p>\\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\\n     *\\n     * @param printable\\n     *            bitset of characters deemed quoted-printable\\n     * @param bytes\\n     *            array of bytes to be encoded\\n     * @param strict\\n     *            if {@code true} the full ruleset is used, otherwise only rule #1 and rule #2\\n     * @return array of bytes containing quoted-printable data\\n     * @since 1.10\\n     */\\n    public static final byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        if (printable == null) {\\n            printable = PRINTABLE_CHARS;\\n        }\\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\\n\\n        if (strict) {\\n            int pos = 1;\\n            // encode up to buffer.length - 3, the last three octets will be treated\\n            // separately for simplification of note #3\\n            for (int i = 0; i < bytes.length - 3; i++) {\\n                final int b = getUnsignedOctet(i, bytes);\\n                if (pos < SAFE_LENGTH) {\\n                    // up to this length it is safe to add any byte, encoded or not\\n                    pos += encodeByte(b, !printable.get(b), buffer);\\n                } else {\\n                    // rule #3: whitespace at the end of a line *must* be encoded\\n                    encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\\n\\n                    // rule #5: soft line break\\n                    buffer.write(ESCAPE_CHAR);\\n                    buffer.write(CR);\\n                    buffer.write(LF);\\n                    pos = 1;\\n                }\\n            }\\n\\n            // rule #3: whitespace at the end of a line *must* be encoded\\n            // if we would do a soft break line after this octet, encode whitespace\\n            int b = getUnsignedOctet(bytes.length - 3, bytes);\\n            boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);\\n            pos += encodeByte(b, encode, buffer);\\n\\n            // note #3: '=' *must not* be the ultimate or penultimate character\\n            // simplification: if < 6 bytes left, do a soft line break as we may need\\n            //                 exactly 6 bytes space for the last 2 bytes\\n            if (pos > SAFE_LENGTH - 2) {\\n                buffer.write(ESCAPE_CHAR);\\n                buffer.write(CR);\\n                buffer.write(LF);\\n            }\\n            for (int i = bytes.length - 2; i < bytes.length; i++) {\\n                b = getUnsignedOctet(i, bytes);\\n                // rule #3: trailing whitespace shall be encoded\\n                encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));\\n                encodeByte(b, encode, buffer);\\n            }\\n        } else {\\n            for (final byte c : bytes) {\\n                int b = c;\\n                if (b < 0) {\\n                    b = 256 + b;\\n                }\\n                if (printable.get(b)) {\\n                    buffer.write(b);\\n                } else {\\n                    encodeQuotedPrintable(b, buffer);\\n                }\\n            }\\n        }\\n        return buffer.toByteArray();\\n    }\\n\\n    /**\\n     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted\\n     * back to their original representation.\\n     * <p>\\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\\n     * defined in RFC 1521.\\n     *\\n     * @param bytes\\n     *            array of quoted-printable characters\\n     * @return array of original bytes\\n     * @throws DecoderException\\n     *             Thrown if quoted-printable decoding is unsuccessful\\n     */\\n    public static final byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\\n        for (int i = 0; i < bytes.length; i++) {\\n            final int b = bytes[i];\\n            if (b == ESCAPE_CHAR) {\\n                try {\\n                    // if the next octet is a CR we have found a soft line break\\n                    if (bytes[++i] == CR) {\\n                        continue;\\n                    }\\n                    final int u = Utils.digit16(bytes[i]);\\n                    final int l = Utils.digit16(bytes[++i]);\\n                    buffer.write((char) ((u << 4) + l));\\n                } catch (final ArrayIndexOutOfBoundsException e) {\\n                    throw new DecoderException(\\\"Invalid quoted-printable encoding\\\", e);\\n                }\\n            } else if (b != CR && b != LF) {\\n                // every other octet is appended except for CR & LF\\n                buffer.write(b);\\n            }\\n        }\\n        return buffer.toByteArray();\\n    }\\n\\n    /**\\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\\n     * <p>\\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\\n     *\\n     * @param bytes\\n     *            array of bytes to be encoded\\n     * @return array of bytes containing quoted-printable data\\n     */\\n    @Override\\n    public byte[] encode(final byte[] bytes) {\\n        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes, strict);\\n    }\\n\\n    /**\\n     * Decodes an array of quoted-printable characters into an array of original bytes. Escaped characters are converted\\n     * back to their original representation.\\n     * <p>\\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\\n     * defined in RFC 1521.\\n     *\\n     * @param bytes\\n     *            array of quoted-printable characters\\n     * @return array of original bytes\\n     * @throws DecoderException\\n     *             Thrown if quoted-printable decoding is unsuccessful\\n     */\\n    @Override\\n    public byte[] decode(final byte[] bytes) throws DecoderException {\\n        return decodeQuotedPrintable(bytes);\\n    }\\n\\n    /**\\n     * Encodes a string into its quoted-printable form using the default string charset. Unsafe characters are escaped.\\n     * <p>\\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\\n     *\\n     * @param str\\n     *            string to convert to quoted-printable form\\n     * @return quoted-printable string\\n     * @throws EncoderException\\n     *             Thrown if quoted-printable encoding is unsuccessful\\n     *\\n     * @see #getCharset()\\n     */\\n    @Override\\n    public String encode(final String str) throws EncoderException {\\n        return this.encode(str, getCharset());\\n    }\\n\\n    /**\\n     * Decodes a quoted-printable string into its original form using the specified string charset. Escaped characters\\n     * are converted back to their original representation.\\n     *\\n     * @param str\\n     *            quoted-printable string to convert into its original form\\n     * @param charset\\n     *            the original string charset\\n     * @return original string\\n     * @throws DecoderException\\n     *             Thrown if quoted-printable decoding is unsuccessful\\n     * @since 1.7\\n     */\\n    public String decode(final String str, final Charset charset) throws DecoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return new String(this.decode(StringUtils.getBytesUsAscii(str)), charset);\\n    }\\n\\n    /**\\n     * Decodes a quoted-printable string into its original form using the specified string charset. Escaped characters\\n     * are converted back to their original representation.\\n     *\\n     * @param str\\n     *            quoted-printable string to convert into its original form\\n     * @param charset\\n     *            the original string charset\\n     * @return original string\\n     * @throws DecoderException\\n     *             Thrown if quoted-printable decoding is unsuccessful\\n     * @throws UnsupportedEncodingException\\n     *             Thrown if charset is not supported\\n     */\\n    public String decode(final String str, final String charset) throws DecoderException, UnsupportedEncodingException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return new String(decode(StringUtils.getBytesUsAscii(str)), charset);\\n    }\\n\\n    /**\\n     * Decodes a quoted-printable string into its original form using the default string charset. Escaped characters are\\n     * converted back to their original representation.\\n     *\\n     * @param str\\n     *            quoted-printable string to convert into its original form\\n     * @return original string\\n     * @throws DecoderException\\n     *             Thrown if quoted-printable decoding is unsuccessful. Thrown if charset is not supported.\\n     * @see #getCharset()\\n     */\\n    @Override\\n    public String decode(final String str) throws DecoderException {\\n        return this.decode(str, this.getCharset());\\n    }\\n\\n    /**\\n     * Encodes an object into its quoted-printable safe form. Unsafe characters are escaped.\\n     *\\n     * @param obj\\n     *            string to convert to a quoted-printable form\\n     * @return quoted-printable object\\n     * @throws EncoderException\\n     *             Thrown if quoted-printable encoding is not applicable to objects of this type or if encoding is\\n     *             unsuccessful\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof byte[]) {\\n            return encode((byte[]) obj);\\n        } else if (obj instanceof String) {\\n            return encode((String) obj);\\n        } else {\\n            throw new EncoderException(\\\"Objects of type \\\" +\\n                  obj.getClass().getName() +\\n                  \\\" cannot be quoted-printable encoded\\\");\\n        }\\n    }\\n\\n    /**\\n     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original\\n     * representation.\\n     *\\n     * @param obj\\n     *            quoted-printable object to convert into its original form\\n     * @return original object\\n     * @throws DecoderException\\n     *             Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure\\n     *             condition is encountered during the decode process.\\n     */\\n    @Override\\n    public Object decode(final Object obj) throws DecoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof byte[]) {\\n            return decode((byte[]) obj);\\n        } else if (obj instanceof String) {\\n            return decode((String) obj);\\n        } else {\\n            throw new DecoderException(\\\"Objects of type \\\" +\\n                  obj.getClass().getName() +\\n                  \\\" cannot be quoted-printable decoded\\\");\\n        }\\n    }\\n\\n    /**\\n     * Gets the default charset name used for string decoding and encoding.\\n     *\\n     * @return the default charset name\\n     * @since 1.7\\n     */\\n    public Charset getCharset() {\\n        return this.charset;\\n    }\\n\\n    /**\\n     * Gets the default charset name used for string decoding and encoding.\\n     *\\n     * @return the default charset name\\n     */\\n    public String getDefaultCharset() {\\n        return this.charset.name();\\n    }\\n\\n    /**\\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\\n     * <p>\\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\\n     *\\n     * @param str\\n     *            string to convert to quoted-printable form\\n     * @param charset\\n     *            the charset for str\\n     * @return quoted-printable string\\n     * @since 1.7\\n     */\\n    public String encode(final String str, final Charset charset) {\\n        if (str == null) {\\n            return null;\\n        }\\n        return StringUtils.newStringUsAscii(this.encode(str.getBytes(charset)));\\n    }\\n\\n    /**\\n     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.\\n     * <p>\\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\\n     *\\n     * @param str\\n     *            string to convert to quoted-printable form\\n     * @param charset\\n     *            the charset for str\\n     * @return quoted-printable string\\n     * @throws UnsupportedEncodingException\\n     *             Thrown if the charset is not supported\\n     */\\n    public String encode(final String str, final String charset) throws UnsupportedEncodingException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return StringUtils.newStringUsAscii(encode(str.getBytes(charset)));\\n    }\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"encodeQuotedPrintable\", \"return_type\": \"int\", \"position\": {\"start_line\": 182, \"end_line\": 189, \"start_column\": 26, \"end_column\": 5}, \"code\": \"int encodeQuotedPrintable(final int b, final ByteArrayOutputStream buffer) {\\n        buffer.write(ESCAPE_CHAR);\\n        final char hex1 = Utils.hexDigit(b >> 4);\\n        final char hex2 = Utils.hexDigit(b);\\n        buffer.write(hex1);\\n        buffer.write(hex2);\\n        return 3;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"int\"}, {\"name\": \"buffer\", \"type\": \"ByteArrayOutputStream\"}]}, {\"name\": \"getUnsignedOctet\", \"return_type\": \"int\", \"position\": {\"start_line\": 201, \"end_line\": 207, \"start_column\": 20, \"end_column\": 5}, \"code\": \"int getUnsignedOctet(final int index, final byte[] bytes) {\\n        int b = bytes[index];\\n        if (b < 0) {\\n            b = 256 + b;\\n        }\\n        return b;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"index\", \"type\": \"int\"}, {\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"encodeByte\", \"return_type\": \"int\", \"position\": {\"start_line\": 220, \"end_line\": 227, \"start_column\": 20, \"end_column\": 5}, \"code\": \"int encodeByte(final int b, final boolean encode,\\n                                  final ByteArrayOutputStream buffer) {\\n        if (encode) {\\n            return encodeQuotedPrintable(b, buffer);\\n        }\\n        buffer.write(b);\\n        return 1;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"int\"}, {\"name\": \"encode\", \"type\": \"boolean\"}, {\"name\": \"buffer\", \"type\": \"ByteArrayOutputStream\"}]}, {\"name\": \"isWhitespace\", \"return_type\": \"boolean\", \"position\": {\"start_line\": 236, \"end_line\": 238, \"start_column\": 20, \"end_column\": 5}, \"code\": \"boolean isWhitespace(final int b) {\\n        return b == SPACE || b == TAB;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"int\"}]}, {\"name\": \"encodeQuotedPrintable\", \"return_type\": \"byte\", \"position\": {\"start_line\": 252, \"end_line\": 254, \"start_column\": 25, \"end_column\": 5}, \"code\": \"byte[] encodeQuotedPrintable(final BitSet printable, final byte[] bytes) {\\n        return encodeQuotedPrintable(printable, bytes, false);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"printable\", \"type\": \"BitSet\"}, {\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"encodeQuotedPrintable\", \"return_type\": \"byte\", \"position\": {\"start_line\": 272, \"end_line\": 336, \"start_column\": 25, \"end_column\": 5}, \"code\": \"byte[] encodeQuotedPrintable(BitSet printable, final byte[] bytes, final boolean strict) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        if (printable == null) {\\n            printable = PRINTABLE_CHARS;\\n        }\\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\\n\\n        if (strict) {\\n            int pos = 1;\\n            // encode up to buffer.length - 3, the last three octets will be treated\\n            // separately for simplification of note #3\\n            for (int i = 0; i < bytes.length - 3; i++) {\\n                final int b = getUnsignedOctet(i, bytes);\\n                if (pos < SAFE_LENGTH) {\\n                    // up to this length it is safe to add any byte, encoded or not\\n                    pos += encodeByte(b, !printable.get(b), buffer);\\n                } else {\\n                    // rule #3: whitespace at the end of a line *must* be encoded\\n                    encodeByte(b, !printable.get(b) || isWhitespace(b), buffer);\\n\\n                    // rule #5: soft line break\\n                    buffer.write(ESCAPE_CHAR);\\n                    buffer.write(CR);\\n                    buffer.write(LF);\\n                    pos = 1;\\n                }\\n            }\\n\\n            // rule #3: whitespace at the end of a line *must* be encoded\\n            // if we would do a soft break line after this octet, encode whitespace\\n            int b = getUnsignedOctet(bytes.length - 3, bytes);\\n            boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5);\\n            pos += encodeByte(b, encode, buffer);\\n\\n            // note #3: '=' *must not* be the ultimate or penultimate character\\n            // simplification: if < 6 bytes left, do a soft line break as we may need\\n            //                 exactly 6 bytes space for the last 2 bytes\\n            if (pos > SAFE_LENGTH - 2) {\\n                buffer.write(ESCAPE_CHAR);\\n                buffer.write(CR);\\n                buffer.write(LF);\\n            }\\n            for (int i = bytes.length - 2; i < bytes.length; i++) {\\n                b = getUnsignedOctet(i, bytes);\\n                // rule #3: trailing whitespace shall be encoded\\n                encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b));\\n                encodeByte(b, encode, buffer);\\n            }\\n        } else {\\n            for (final byte c : bytes) {\\n                int b = c;\\n                if (b < 0) {\\n                    b = 256 + b;\\n                }\\n                if (printable.get(b)) {\\n                    buffer.write(b);\\n                } else {\\n                    encodeQuotedPrintable(b, buffer);\\n                }\\n            }\\n        }\\n        return buffer.toByteArray();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"printable\", \"type\": \"BitSet\"}, {\"name\": \"bytes\", \"type\": \"byte\"}, {\"name\": \"strict\", \"type\": \"boolean\"}]}, {\"name\": \"decodeQuotedPrintable\", \"return_type\": \"byte\", \"position\": {\"start_line\": 351, \"end_line\": 376, \"start_column\": 25, \"end_column\": 5}, \"code\": \"byte[] decodeQuotedPrintable(final byte[] bytes) throws DecoderException {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\\n        for (int i = 0; i < bytes.length; i++) {\\n            final int b = bytes[i];\\n            if (b == ESCAPE_CHAR) {\\n                try {\\n                    // if the next octet is a CR we have found a soft line break\\n                    if (bytes[++i] == CR) {\\n                        continue;\\n                    }\\n                    final int u = Utils.digit16(bytes[i]);\\n                    final int l = Utils.digit16(bytes[++i]);\\n                    buffer.write((char) ((u << 4) + l));\\n                } catch (final ArrayIndexOutOfBoundsException e) {\\n                    throw new DecoderException(\\\"Invalid quoted-printable encoding\\\", e);\\n                }\\n            } else if (b != CR && b != LF) {\\n                // every other octet is appended except for CR & LF\\n                buffer.write(b);\\n            }\\n        }\\n        return buffer.toByteArray();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"encode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 390, \"end_line\": 392, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] encode(final byte[] bytes) {\\n        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes, strict);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"decode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 408, \"end_line\": 410, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] decode(final byte[] bytes) throws DecoderException {\\n        return decodeQuotedPrintable(bytes);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 428, \"end_line\": 430, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str) throws EncoderException {\\n        return this.encode(str, getCharset());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"decode\", \"return_type\": \"String\", \"position\": {\"start_line\": 445, \"end_line\": 450, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String decode(final String str, final Charset charset) throws DecoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return new String(this.decode(StringUtils.getBytesUsAscii(str)), charset);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"Charset\"}]}, {\"name\": \"decode\", \"return_type\": \"String\", \"position\": {\"start_line\": 466, \"end_line\": 471, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String decode(final String str, final String charset) throws DecoderException, UnsupportedEncodingException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return new String(decode(StringUtils.getBytesUsAscii(str)), charset);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"String\"}]}, {\"name\": \"decode\", \"return_type\": \"String\", \"position\": {\"start_line\": 485, \"end_line\": 487, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String decode(final String str) throws DecoderException {\\n        return this.decode(str, this.getCharset());\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 500, \"end_line\": 512, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object obj) throws EncoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof byte[]) {\\n            return encode((byte[]) obj);\\n        } else if (obj instanceof String) {\\n            return encode((String) obj);\\n        } else {\\n            throw new EncoderException(\\\"Objects of type \\\" +\\n                  obj.getClass().getName() +\\n                  \\\" cannot be quoted-printable encoded\\\");\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"decode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 526, \"end_line\": 538, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object decode(final Object obj) throws DecoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof byte[]) {\\n            return decode((byte[]) obj);\\n        } else if (obj instanceof String) {\\n            return decode((String) obj);\\n        } else {\\n            throw new DecoderException(\\\"Objects of type \\\" +\\n                  obj.getClass().getName() +\\n                  \\\" cannot be quoted-printable decoded\\\");\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"getCharset\", \"return_type\": \"Charset\", \"position\": {\"start_line\": 546, \"end_line\": 548, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Charset getCharset() {\\n        return this.charset;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getDefaultCharset\", \"return_type\": \"String\", \"position\": {\"start_line\": 555, \"end_line\": 557, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getDefaultCharset() {\\n        return this.charset.name();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 573, \"end_line\": 578, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str, final Charset charset) {\\n        if (str == null) {\\n            return null;\\n        }\\n        return StringUtils.newStringUsAscii(this.encode(str.getBytes(charset)));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"Charset\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 595, \"end_line\": 600, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str, final String charset) throws UnsupportedEncodingException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return StringUtils.newStringUsAscii(encode(str.getBytes(charset)));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"String\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/net/RFC1522Codec.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.net;\\n\\nimport java.io.UnsupportedEncodingException;\\nimport java.nio.charset.Charset;\\n\\nimport org.apache.commons.codec.DecoderException;\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.binary.StringUtils;\\n\\n/**\\n * Implements methods common to all codecs defined in RFC 1522.\\n * <p>\\n * <a href=\\\"http://www.ietf.org/rfc/rfc1522.txt\\\">RFC 1522</a> describes techniques to allow the\\n * encoding of non-ASCII text in various portions of a RFC 822 [2] message header, in a manner which\\n * is unlikely to confuse existing message handling software.\\n * <p>\\n * This class is immutable and thread-safe.\\n *\\n * @see <a href=\\\"http://www.ietf.org/rfc/rfc1522.txt\\\">MIME (Multipurpose Internet Mail Extensions) Part Two:\\n *          Message Header Extensions for Non-ASCII Text</a>\\n *\\n * @since 1.3\\n * @version $Id: RFC1522Codec.java 1619948 2014-08-22 22:53:55Z ggregory $\\n */\\nabstract class RFC1522Codec {\\n\\n    /** Separator. */\\n    protected static final char SEP = '?';\\n\\n    /** Prefix. */\\n    protected static final String POSTFIX = \\\"?=\\\";\\n\\n    /** Postfix. */\\n    protected static final String PREFIX = \\\"=?\\\";\\n\\n    /**\\n     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.\\n     * <p>\\n     * This method constructs the \\\"encoded-word\\\" header common to all the RFC 1522 codecs and then invokes\\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific encoding.\\n     *\\n     * @param text\\n     *            a string to encode\\n     * @param charset\\n     *            a charset to be used\\n     * @return RFC 1522 compliant \\\"encoded-word\\\"\\n     * @throws EncoderException\\n     *             thrown if there is an error condition during the Encoding process.\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    protected String encodeText(final String text, final Charset charset) throws EncoderException {\\n        if (text == null) {\\n            return null;\\n        }\\n        final StringBuilder buffer = new StringBuilder();\\n        buffer.append(PREFIX);\\n        buffer.append(charset);\\n        buffer.append(SEP);\\n        buffer.append(this.getEncoding());\\n        buffer.append(SEP);\\n        final byte [] rawData = this.doEncoding(text.getBytes(charset));\\n        buffer.append(StringUtils.newStringUsAscii(rawData));\\n        buffer.append(POSTFIX);\\n        return buffer.toString();\\n    }\\n\\n    /**\\n     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.\\n     * <p>\\n     * This method constructs the \\\"encoded-word\\\" header common to all the RFC 1522 codecs and then invokes\\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific encoding.\\n     *\\n     * @param text\\n     *            a string to encode\\n     * @param charsetName\\n     *            the charset to use\\n     * @return RFC 1522 compliant \\\"encoded-word\\\"\\n     * @throws EncoderException\\n     *             thrown if there is an error condition during the Encoding process.\\n     * @throws UnsupportedEncodingException\\n     *             if charset is not available\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    protected String encodeText(final String text, final String charsetName)\\n            throws EncoderException, UnsupportedEncodingException {\\n        if (text == null) {\\n            return null;\\n        }\\n        return this.encodeText(text, Charset.forName(charsetName));\\n    }\\n\\n    /**\\n     * Applies an RFC 1522 compliant decoding scheme to the given string of text.\\n     * <p>\\n     * This method processes the \\\"encoded-word\\\" header common to all the RFC 1522 codecs and then invokes\\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific decoding.\\n     *\\n     * @param text\\n     *            a string to decode\\n     * @return A new decoded String or <code>null</code> if the input is <code>null</code>.\\n     * @throws DecoderException\\n     *             thrown if there is an error condition during the decoding process.\\n     * @throws UnsupportedEncodingException\\n     *             thrown if charset specified in the \\\"encoded-word\\\" header is not supported\\n     */\\n    protected String decodeText(final String text)\\n            throws DecoderException, UnsupportedEncodingException {\\n        if (text == null) {\\n            return null;\\n        }\\n        if (!text.startsWith(PREFIX) || !text.endsWith(POSTFIX)) {\\n            throw new DecoderException(\\\"RFC 1522 violation: malformed encoded content\\\");\\n        }\\n        final int terminator = text.length() - 2;\\n        int from = 2;\\n        int to = text.indexOf(SEP, from);\\n        if (to == terminator) {\\n            throw new DecoderException(\\\"RFC 1522 violation: charset token not found\\\");\\n        }\\n        final String charset = text.substring(from, to);\\n        if (charset.equals(\\\"\\\")) {\\n            throw new DecoderException(\\\"RFC 1522 violation: charset not specified\\\");\\n        }\\n        from = to + 1;\\n        to = text.indexOf(SEP, from);\\n        if (to == terminator) {\\n            throw new DecoderException(\\\"RFC 1522 violation: encoding token not found\\\");\\n        }\\n        final String encoding = text.substring(from, to);\\n        if (!getEncoding().equalsIgnoreCase(encoding)) {\\n            throw new DecoderException(\\\"This codec cannot decode \\\" + encoding + \\\" encoded content\\\");\\n        }\\n        from = to + 1;\\n        to = text.indexOf(SEP, from);\\n        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));\\n        data = doDecoding(data);\\n        return new String(data, charset);\\n    }\\n\\n    /**\\n     * Returns the codec name (referred to as encoding in the RFC 1522).\\n     *\\n     * @return name of the codec\\n     */\\n    protected abstract String getEncoding();\\n\\n    /**\\n     * Encodes an array of bytes using the defined encoding scheme.\\n     *\\n     * @param bytes\\n     *            Data to be encoded\\n     * @return A byte array containing the encoded data\\n     * @throws EncoderException\\n     *             thrown if the Encoder encounters a failure condition during the encoding process.\\n     */\\n    protected abstract byte[] doEncoding(byte[] bytes) throws EncoderException;\\n\\n    /**\\n     * Decodes an array of bytes using the defined encoding scheme.\\n     *\\n     * @param bytes\\n     *            Data to be decoded\\n     * @return a byte array that contains decoded data\\n     * @throws DecoderException\\n     *             A decoder exception is thrown if a Decoder encounters a failure condition during the decode process.\\n     */\\n    protected abstract byte[] doDecoding(byte[] bytes) throws DecoderException;\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"RFC1522Codec\", \"position\": {\"start_line\": 42, \"end_line\": 186, \"start_column\": 10, \"end_column\": 1}, \"code\": \"class RFC1522Codec {\\n\\n    /** Separator. */\\n    protected static final char SEP = '?';\\n\\n    /** Prefix. */\\n    protected static final String POSTFIX = \\\"?=\\\";\\n\\n    /** Postfix. */\\n    protected static final String PREFIX = \\\"=?\\\";\\n\\n    /**\\n     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.\\n     * <p>\\n     * This method constructs the \\\"encoded-word\\\" header common to all the RFC 1522 codecs and then invokes\\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific encoding.\\n     *\\n     * @param text\\n     *            a string to encode\\n     * @param charset\\n     *            a charset to be used\\n     * @return RFC 1522 compliant \\\"encoded-word\\\"\\n     * @throws EncoderException\\n     *             thrown if there is an error condition during the Encoding process.\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    protected String encodeText(final String text, final Charset charset) throws EncoderException {\\n        if (text == null) {\\n            return null;\\n        }\\n        final StringBuilder buffer = new StringBuilder();\\n        buffer.append(PREFIX);\\n        buffer.append(charset);\\n        buffer.append(SEP);\\n        buffer.append(this.getEncoding());\\n        buffer.append(SEP);\\n        final byte [] rawData = this.doEncoding(text.getBytes(charset));\\n        buffer.append(StringUtils.newStringUsAscii(rawData));\\n        buffer.append(POSTFIX);\\n        return buffer.toString();\\n    }\\n\\n    /**\\n     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.\\n     * <p>\\n     * This method constructs the \\\"encoded-word\\\" header common to all the RFC 1522 codecs and then invokes\\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific encoding.\\n     *\\n     * @param text\\n     *            a string to encode\\n     * @param charsetName\\n     *            the charset to use\\n     * @return RFC 1522 compliant \\\"encoded-word\\\"\\n     * @throws EncoderException\\n     *             thrown if there is an error condition during the Encoding process.\\n     * @throws UnsupportedEncodingException\\n     *             if charset is not available\\n     *\\n     * @see <a href=\\\"http://download.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\\\">Standard charsets</a>\\n     */\\n    protected String encodeText(final String text, final String charsetName)\\n            throws EncoderException, UnsupportedEncodingException {\\n        if (text == null) {\\n            return null;\\n        }\\n        return this.encodeText(text, Charset.forName(charsetName));\\n    }\\n\\n    /**\\n     * Applies an RFC 1522 compliant decoding scheme to the given string of text.\\n     * <p>\\n     * This method processes the \\\"encoded-word\\\" header common to all the RFC 1522 codecs and then invokes\\n     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific decoding.\\n     *\\n     * @param text\\n     *            a string to decode\\n     * @return A new decoded String or <code>null</code> if the input is <code>null</code>.\\n     * @throws DecoderException\\n     *             thrown if there is an error condition during the decoding process.\\n     * @throws UnsupportedEncodingException\\n     *             thrown if charset specified in the \\\"encoded-word\\\" header is not supported\\n     */\\n    protected String decodeText(final String text)\\n            throws DecoderException, UnsupportedEncodingException {\\n        if (text == null) {\\n            return null;\\n        }\\n        if (!text.startsWith(PREFIX) || !text.endsWith(POSTFIX)) {\\n            throw new DecoderException(\\\"RFC 1522 violation: malformed encoded content\\\");\\n        }\\n        final int terminator = text.length() - 2;\\n        int from = 2;\\n        int to = text.indexOf(SEP, from);\\n        if (to == terminator) {\\n            throw new DecoderException(\\\"RFC 1522 violation: charset token not found\\\");\\n        }\\n        final String charset = text.substring(from, to);\\n        if (charset.equals(\\\"\\\")) {\\n            throw new DecoderException(\\\"RFC 1522 violation: charset not specified\\\");\\n        }\\n        from = to + 1;\\n        to = text.indexOf(SEP, from);\\n        if (to == terminator) {\\n            throw new DecoderException(\\\"RFC 1522 violation: encoding token not found\\\");\\n        }\\n        final String encoding = text.substring(from, to);\\n        if (!getEncoding().equalsIgnoreCase(encoding)) {\\n            throw new DecoderException(\\\"This codec cannot decode \\\" + encoding + \\\" encoded content\\\");\\n        }\\n        from = to + 1;\\n        to = text.indexOf(SEP, from);\\n        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));\\n        data = doDecoding(data);\\n        return new String(data, charset);\\n    }\\n\\n    /**\\n     * Returns the codec name (referred to as encoding in the RFC 1522).\\n     *\\n     * @return name of the codec\\n     */\\n    protected abstract String getEncoding();\\n\\n    /**\\n     * Encodes an array of bytes using the defined encoding scheme.\\n     *\\n     * @param bytes\\n     *            Data to be encoded\\n     * @return A byte array containing the encoded data\\n     * @throws EncoderException\\n     *             thrown if the Encoder encounters a failure condition during the encoding process.\\n     */\\n    protected abstract byte[] doEncoding(byte[] bytes) throws EncoderException;\\n\\n    /**\\n     * Decodes an array of bytes using the defined encoding scheme.\\n     *\\n     * @param bytes\\n     *            Data to be decoded\\n     * @return a byte array that contains decoded data\\n     * @throws DecoderException\\n     *             A decoder exception is thrown if a Decoder encounters a failure condition during the decode process.\\n     */\\n    protected abstract byte[] doDecoding(byte[] bytes) throws DecoderException;\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"encodeText\", \"return_type\": \"String\", \"position\": {\"start_line\": 68, \"end_line\": 82, \"start_column\": 15, \"end_column\": 5}, \"code\": \"String encodeText(final String text, final Charset charset) throws EncoderException {\\n        if (text == null) {\\n            return null;\\n        }\\n        final StringBuilder buffer = new StringBuilder();\\n        buffer.append(PREFIX);\\n        buffer.append(charset);\\n        buffer.append(SEP);\\n        buffer.append(this.getEncoding());\\n        buffer.append(SEP);\\n        final byte [] rawData = this.doEncoding(text.getBytes(charset));\\n        buffer.append(StringUtils.newStringUsAscii(rawData));\\n        buffer.append(POSTFIX);\\n        return buffer.toString();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"text\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"Charset\"}]}, {\"name\": \"encodeText\", \"return_type\": \"String\", \"position\": {\"start_line\": 102, \"end_line\": 108, \"start_column\": 15, \"end_column\": 5}, \"code\": \"String encodeText(final String text, final String charsetName)\\n            throws EncoderException, UnsupportedEncodingException {\\n        if (text == null) {\\n            return null;\\n        }\\n        return this.encodeText(text, Charset.forName(charsetName));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"text\", \"type\": \"String\"}, {\"name\": \"charsetName\", \"type\": \"String\"}]}, {\"name\": \"decodeText\", \"return_type\": \"String\", \"position\": {\"start_line\": 124, \"end_line\": 156, \"start_column\": 15, \"end_column\": 5}, \"code\": \"String decodeText(final String text)\\n            throws DecoderException, UnsupportedEncodingException {\\n        if (text == null) {\\n            return null;\\n        }\\n        if (!text.startsWith(PREFIX) || !text.endsWith(POSTFIX)) {\\n            throw new DecoderException(\\\"RFC 1522 violation: malformed encoded content\\\");\\n        }\\n        final int terminator = text.length() - 2;\\n        int from = 2;\\n        int to = text.indexOf(SEP, from);\\n        if (to == terminator) {\\n            throw new DecoderException(\\\"RFC 1522 violation: charset token not found\\\");\\n        }\\n        final String charset = text.substring(from, to);\\n        if (charset.equals(\\\"\\\")) {\\n            throw new DecoderException(\\\"RFC 1522 violation: charset not specified\\\");\\n        }\\n        from = to + 1;\\n        to = text.indexOf(SEP, from);\\n        if (to == terminator) {\\n            throw new DecoderException(\\\"RFC 1522 violation: encoding token not found\\\");\\n        }\\n        final String encoding = text.substring(from, to);\\n        if (!getEncoding().equalsIgnoreCase(encoding)) {\\n            throw new DecoderException(\\\"This codec cannot decode \\\" + encoding + \\\" encoded content\\\");\\n        }\\n        from = to + 1;\\n        to = text.indexOf(SEP, from);\\n        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));\\n        data = doDecoding(data);\\n        return new String(data, charset);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"text\", \"type\": \"String\"}]}, {\"name\": \"getEncoding\", \"return_type\": \"String\", \"position\": {\"start_line\": 163, \"end_line\": 163, \"start_column\": 24, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"doEncoding\", \"return_type\": \"byte\", \"position\": {\"start_line\": 174, \"end_line\": 174, \"start_column\": 24, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"doDecoding\", \"return_type\": \"byte\", \"position\": {\"start_line\": 185, \"end_line\": 185, \"start_column\": 24, \"end_column\": 0}, \"code\": \"\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/net/URLCodec.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.net;\\n\\nimport java.io.ByteArrayOutputStream;\\nimport java.io.UnsupportedEncodingException;\\nimport java.util.BitSet;\\n\\nimport org.apache.commons.codec.BinaryDecoder;\\nimport org.apache.commons.codec.BinaryEncoder;\\nimport org.apache.commons.codec.CharEncoding;\\nimport org.apache.commons.codec.DecoderException;\\nimport org.apache.commons.codec.EncoderException;\\nimport org.apache.commons.codec.StringDecoder;\\nimport org.apache.commons.codec.StringEncoder;\\nimport org.apache.commons.codec.binary.StringUtils;\\n\\n/**\\n * Implements the 'www-form-urlencoded' encoding scheme, also misleadingly known as URL encoding.\\n * <p>\\n * This codec is meant to be a replacement for standard Java classes {@link java.net.URLEncoder} and\\n * {@link java.net.URLDecoder} on older Java platforms, as these classes in Java versions below\\n * 1.4 rely on the platform's default charset encoding.\\n * <p>\\n * This class is thread-safe since 1.11\\n *\\n * @see <a href=\\\"http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1\\\">Chapter 17.13.4 Form content types</a>\\n *           of the <a href=\\\"http://www.w3.org/TR/html4/\\\">HTML 4.01 Specification</a>\\n *\\n * @since 1.2\\n * @version $Id: URLCodec.java 1789142 2017-03-28 13:58:58Z sebb $\\n */\\npublic class URLCodec implements BinaryEncoder, BinaryDecoder, StringEncoder, StringDecoder {\\n\\n    /**\\n     * The default charset used for string decoding and encoding.\\n     *\\n     * @deprecated TODO: This field will be changed to a private final Charset in 2.0. (CODEC-126)\\n     */\\n    @Deprecated\\n    protected volatile String charset; // added volatile: see CODEC-232\\n\\n    /**\\n     * Release 1.5 made this field final.\\n     */\\n    protected static final byte ESCAPE_CHAR = '%';\\n\\n    /**\\n     * BitSet of www-form-url safe characters.\\n     * This is a copy of the internal BitSet which is now used for the conversion.\\n     * Changes to this field are ignored.\\n     * @deprecated 1.11 Will be removed in 2.0 (CODEC-230)\\n     */\\n    @Deprecated\\n    protected static final BitSet WWW_FORM_URL;\\n\\n    private static final BitSet WWW_FORM_URL_SAFE = new BitSet(256);\\n\\n    // Static initializer for www_form_url\\n    static {\\n        // alpha characters\\n        for (int i = 'a'; i <= 'z'; i++) {\\n            WWW_FORM_URL_SAFE.set(i);\\n        }\\n        for (int i = 'A'; i <= 'Z'; i++) {\\n            WWW_FORM_URL_SAFE.set(i);\\n        }\\n        // numeric characters\\n        for (int i = '0'; i <= '9'; i++) {\\n            WWW_FORM_URL_SAFE.set(i);\\n        }\\n        // special chars\\n        WWW_FORM_URL_SAFE.set('-');\\n        WWW_FORM_URL_SAFE.set('_');\\n        WWW_FORM_URL_SAFE.set('.');\\n        WWW_FORM_URL_SAFE.set('*');\\n        // blank to be replaced with +\\n        WWW_FORM_URL_SAFE.set(' ');\\n\\n        // Create a copy in case anyone (ab)uses it\\n        WWW_FORM_URL = (BitSet) WWW_FORM_URL_SAFE.clone();\\n    }\\n\\n\\n    /**\\n     * Default constructor.\\n     */\\n    public URLCodec() {\\n        this(CharEncoding.UTF_8);\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset.\\n     *\\n     * @param charset the default string charset to use.\\n     */\\n    public URLCodec(final String charset) {\\n        super();\\n        this.charset = charset;\\n    }\\n\\n    /**\\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\\n     *\\n     * @param urlsafe\\n     *            bitset of characters deemed URL safe\\n     * @param bytes\\n     *            array of bytes to convert to URL safe characters\\n     * @return array of bytes containing URL safe characters\\n     */\\n    public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        if (urlsafe == null) {\\n            urlsafe = WWW_FORM_URL_SAFE;\\n        }\\n\\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\\n        for (final byte c : bytes) {\\n            int b = c;\\n            if (b < 0) {\\n                b = 256 + b;\\n            }\\n            if (urlsafe.get(b)) {\\n                if (b == ' ') {\\n                    b = '+';\\n                }\\n                buffer.write(b);\\n            } else {\\n                buffer.write(ESCAPE_CHAR);\\n                final char hex1 = Utils.hexDigit(b >> 4);\\n                final char hex2 = Utils.hexDigit(b);\\n                buffer.write(hex1);\\n                buffer.write(hex2);\\n            }\\n        }\\n        return buffer.toByteArray();\\n    }\\n\\n    /**\\n     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\\n     * back to their original representation.\\n     *\\n     * @param bytes\\n     *            array of URL safe characters\\n     * @return array of original bytes\\n     * @throws DecoderException\\n     *             Thrown if URL decoding is unsuccessful\\n     */\\n    public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\\n        for (int i = 0; i < bytes.length; i++) {\\n            final int b = bytes[i];\\n            if (b == '+') {\\n                buffer.write(' ');\\n            } else if (b == ESCAPE_CHAR) {\\n                try {\\n                    final int u = Utils.digit16(bytes[++i]);\\n                    final int l = Utils.digit16(bytes[++i]);\\n                    buffer.write((char) ((u << 4) + l));\\n                } catch (final ArrayIndexOutOfBoundsException e) {\\n                    throw new DecoderException(\\\"Invalid URL encoding: \\\", e);\\n                }\\n            } else {\\n                buffer.write(b);\\n            }\\n        }\\n        return buffer.toByteArray();\\n    }\\n\\n    /**\\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\\n     *\\n     * @param bytes\\n     *            array of bytes to convert to URL safe characters\\n     * @return array of bytes containing URL safe characters\\n     */\\n    @Override\\n    public byte[] encode(final byte[] bytes) {\\n        return encodeUrl(WWW_FORM_URL_SAFE, bytes);\\n    }\\n\\n\\n    /**\\n     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\\n     * back to their original representation.\\n     *\\n     * @param bytes\\n     *            array of URL safe characters\\n     * @return array of original bytes\\n     * @throws DecoderException\\n     *             Thrown if URL decoding is unsuccessful\\n     */\\n    @Override\\n    public byte[] decode(final byte[] bytes) throws DecoderException {\\n        return decodeUrl(bytes);\\n    }\\n\\n    /**\\n     * Encodes a string into its URL safe form using the specified string charset. Unsafe characters are escaped.\\n     *\\n     * @param str\\n     *            string to convert to a URL safe form\\n     * @param charset\\n     *            the charset for str\\n     * @return URL safe string\\n     * @throws UnsupportedEncodingException\\n     *             Thrown if charset is not supported\\n     */\\n    public String encode(final String str, final String charset) throws UnsupportedEncodingException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return StringUtils.newStringUsAscii(encode(str.getBytes(charset)));\\n    }\\n\\n    /**\\n     * Encodes a string into its URL safe form using the default string charset. Unsafe characters are escaped.\\n     *\\n     * @param str\\n     *            string to convert to a URL safe form\\n     * @return URL safe string\\n     * @throws EncoderException\\n     *             Thrown if URL encoding is unsuccessful\\n     *\\n     * @see #getDefaultCharset()\\n     */\\n    @Override\\n    public String encode(final String str) throws EncoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        try {\\n            return encode(str, getDefaultCharset());\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new EncoderException(e.getMessage(), e);\\n        }\\n    }\\n\\n\\n    /**\\n     * Decodes a URL safe string into its original form using the specified encoding. Escaped characters are converted\\n     * back to their original representation.\\n     *\\n     * @param str\\n     *            URL safe string to convert into its original form\\n     * @param charset\\n     *            the original string charset\\n     * @return original string\\n     * @throws DecoderException\\n     *             Thrown if URL decoding is unsuccessful\\n     * @throws UnsupportedEncodingException\\n     *             Thrown if charset is not supported\\n     */\\n    public String decode(final String str, final String charset) throws DecoderException, UnsupportedEncodingException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return new String(decode(StringUtils.getBytesUsAscii(str)), charset);\\n    }\\n\\n    /**\\n     * Decodes a URL safe string into its original form using the default string charset. Escaped characters are\\n     * converted back to their original representation.\\n     *\\n     * @param str\\n     *            URL safe string to convert into its original form\\n     * @return original string\\n     * @throws DecoderException\\n     *             Thrown if URL decoding is unsuccessful\\n     * @see #getDefaultCharset()\\n     */\\n    @Override\\n    public String decode(final String str) throws DecoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        try {\\n            return decode(str, getDefaultCharset());\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new DecoderException(e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * Encodes an object into its URL safe form. Unsafe characters are escaped.\\n     *\\n     * @param obj\\n     *            string to convert to a URL safe form\\n     * @return URL safe object\\n     * @throws EncoderException\\n     *             Thrown if URL encoding is not applicable to objects of this type or if encoding is unsuccessful\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof byte[]) {\\n            return encode((byte[])obj);\\n        } else if (obj instanceof String) {\\n            return encode((String)obj);\\n        } else {\\n            throw new EncoderException(\\\"Objects of type \\\" + obj.getClass().getName() + \\\" cannot be URL encoded\\\");\\n\\n        }\\n    }\\n\\n    /**\\n     * Decodes a URL safe object into its original form. Escaped characters are converted back to their original\\n     * representation.\\n     *\\n     * @param obj\\n     *            URL safe object to convert into its original form\\n     * @return original object\\n     * @throws DecoderException\\n     *             Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure\\n     *             condition is encountered during the decode process.\\n     */\\n    @Override\\n    public Object decode(final Object obj) throws DecoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof byte[]) {\\n            return decode((byte[]) obj);\\n        } else if (obj instanceof String) {\\n            return decode((String) obj);\\n        } else {\\n            throw new DecoderException(\\\"Objects of type \\\" + obj.getClass().getName() + \\\" cannot be URL decoded\\\");\\n\\n        }\\n    }\\n\\n    /**\\n     * The default charset used for string decoding and encoding.\\n     *\\n     * @return the default string charset.\\n     */\\n    public String getDefaultCharset() {\\n        return this.charset;\\n    }\\n\\n    /**\\n     * The <code>String</code> encoding used for decoding and encoding.\\n     *\\n     * @return Returns the encoding.\\n     *\\n     * @deprecated Use {@link #getDefaultCharset()}, will be removed in 2.0.\\n     */\\n    @Deprecated\\n    public String getEncoding() {\\n        return this.charset;\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"URLCodec\", \"position\": {\"start_line\": 48, \"end_line\": 373, \"start_column\": 8, \"end_column\": 1}, \"code\": \"class URLCodec implements BinaryEncoder, BinaryDecoder, StringEncoder, StringDecoder {\\n\\n    /**\\n     * The default charset used for string decoding and encoding.\\n     *\\n     * @deprecated TODO: This field will be changed to a private final Charset in 2.0. (CODEC-126)\\n     */\\n    @Deprecated\\n    protected volatile String charset; // added volatile: see CODEC-232\\n\\n    /**\\n     * Release 1.5 made this field final.\\n     */\\n    protected static final byte ESCAPE_CHAR = '%';\\n\\n    /**\\n     * BitSet of www-form-url safe characters.\\n     * This is a copy of the internal BitSet which is now used for the conversion.\\n     * Changes to this field are ignored.\\n     * @deprecated 1.11 Will be removed in 2.0 (CODEC-230)\\n     */\\n    @Deprecated\\n    protected static final BitSet WWW_FORM_URL;\\n\\n    private static final BitSet WWW_FORM_URL_SAFE = new BitSet(256);\\n\\n    // Static initializer for www_form_url\\n    static {\\n        // alpha characters\\n        for (int i = 'a'; i <= 'z'; i++) {\\n            WWW_FORM_URL_SAFE.set(i);\\n        }\\n        for (int i = 'A'; i <= 'Z'; i++) {\\n            WWW_FORM_URL_SAFE.set(i);\\n        }\\n        // numeric characters\\n        for (int i = '0'; i <= '9'; i++) {\\n            WWW_FORM_URL_SAFE.set(i);\\n        }\\n        // special chars\\n        WWW_FORM_URL_SAFE.set('-');\\n        WWW_FORM_URL_SAFE.set('_');\\n        WWW_FORM_URL_SAFE.set('.');\\n        WWW_FORM_URL_SAFE.set('*');\\n        // blank to be replaced with +\\n        WWW_FORM_URL_SAFE.set(' ');\\n\\n        // Create a copy in case anyone (ab)uses it\\n        WWW_FORM_URL = (BitSet) WWW_FORM_URL_SAFE.clone();\\n    }\\n\\n\\n    /**\\n     * Default constructor.\\n     */\\n    public URLCodec() {\\n        this(CharEncoding.UTF_8);\\n    }\\n\\n    /**\\n     * Constructor which allows for the selection of a default charset.\\n     *\\n     * @param charset the default string charset to use.\\n     */\\n    public URLCodec(final String charset) {\\n        super();\\n        this.charset = charset;\\n    }\\n\\n    /**\\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\\n     *\\n     * @param urlsafe\\n     *            bitset of characters deemed URL safe\\n     * @param bytes\\n     *            array of bytes to convert to URL safe characters\\n     * @return array of bytes containing URL safe characters\\n     */\\n    public static final byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        if (urlsafe == null) {\\n            urlsafe = WWW_FORM_URL_SAFE;\\n        }\\n\\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\\n        for (final byte c : bytes) {\\n            int b = c;\\n            if (b < 0) {\\n                b = 256 + b;\\n            }\\n            if (urlsafe.get(b)) {\\n                if (b == ' ') {\\n                    b = '+';\\n                }\\n                buffer.write(b);\\n            } else {\\n                buffer.write(ESCAPE_CHAR);\\n                final char hex1 = Utils.hexDigit(b >> 4);\\n                final char hex2 = Utils.hexDigit(b);\\n                buffer.write(hex1);\\n                buffer.write(hex2);\\n            }\\n        }\\n        return buffer.toByteArray();\\n    }\\n\\n    /**\\n     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\\n     * back to their original representation.\\n     *\\n     * @param bytes\\n     *            array of URL safe characters\\n     * @return array of original bytes\\n     * @throws DecoderException\\n     *             Thrown if URL decoding is unsuccessful\\n     */\\n    public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\\n        for (int i = 0; i < bytes.length; i++) {\\n            final int b = bytes[i];\\n            if (b == '+') {\\n                buffer.write(' ');\\n            } else if (b == ESCAPE_CHAR) {\\n                try {\\n                    final int u = Utils.digit16(bytes[++i]);\\n                    final int l = Utils.digit16(bytes[++i]);\\n                    buffer.write((char) ((u << 4) + l));\\n                } catch (final ArrayIndexOutOfBoundsException e) {\\n                    throw new DecoderException(\\\"Invalid URL encoding: \\\", e);\\n                }\\n            } else {\\n                buffer.write(b);\\n            }\\n        }\\n        return buffer.toByteArray();\\n    }\\n\\n    /**\\n     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\\n     *\\n     * @param bytes\\n     *            array of bytes to convert to URL safe characters\\n     * @return array of bytes containing URL safe characters\\n     */\\n    @Override\\n    public byte[] encode(final byte[] bytes) {\\n        return encodeUrl(WWW_FORM_URL_SAFE, bytes);\\n    }\\n\\n\\n    /**\\n     * Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\\n     * back to their original representation.\\n     *\\n     * @param bytes\\n     *            array of URL safe characters\\n     * @return array of original bytes\\n     * @throws DecoderException\\n     *             Thrown if URL decoding is unsuccessful\\n     */\\n    @Override\\n    public byte[] decode(final byte[] bytes) throws DecoderException {\\n        return decodeUrl(bytes);\\n    }\\n\\n    /**\\n     * Encodes a string into its URL safe form using the specified string charset. Unsafe characters are escaped.\\n     *\\n     * @param str\\n     *            string to convert to a URL safe form\\n     * @param charset\\n     *            the charset for str\\n     * @return URL safe string\\n     * @throws UnsupportedEncodingException\\n     *             Thrown if charset is not supported\\n     */\\n    public String encode(final String str, final String charset) throws UnsupportedEncodingException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return StringUtils.newStringUsAscii(encode(str.getBytes(charset)));\\n    }\\n\\n    /**\\n     * Encodes a string into its URL safe form using the default string charset. Unsafe characters are escaped.\\n     *\\n     * @param str\\n     *            string to convert to a URL safe form\\n     * @return URL safe string\\n     * @throws EncoderException\\n     *             Thrown if URL encoding is unsuccessful\\n     *\\n     * @see #getDefaultCharset()\\n     */\\n    @Override\\n    public String encode(final String str) throws EncoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        try {\\n            return encode(str, getDefaultCharset());\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new EncoderException(e.getMessage(), e);\\n        }\\n    }\\n\\n\\n    /**\\n     * Decodes a URL safe string into its original form using the specified encoding. Escaped characters are converted\\n     * back to their original representation.\\n     *\\n     * @param str\\n     *            URL safe string to convert into its original form\\n     * @param charset\\n     *            the original string charset\\n     * @return original string\\n     * @throws DecoderException\\n     *             Thrown if URL decoding is unsuccessful\\n     * @throws UnsupportedEncodingException\\n     *             Thrown if charset is not supported\\n     */\\n    public String decode(final String str, final String charset) throws DecoderException, UnsupportedEncodingException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return new String(decode(StringUtils.getBytesUsAscii(str)), charset);\\n    }\\n\\n    /**\\n     * Decodes a URL safe string into its original form using the default string charset. Escaped characters are\\n     * converted back to their original representation.\\n     *\\n     * @param str\\n     *            URL safe string to convert into its original form\\n     * @return original string\\n     * @throws DecoderException\\n     *             Thrown if URL decoding is unsuccessful\\n     * @see #getDefaultCharset()\\n     */\\n    @Override\\n    public String decode(final String str) throws DecoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        try {\\n            return decode(str, getDefaultCharset());\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new DecoderException(e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * Encodes an object into its URL safe form. Unsafe characters are escaped.\\n     *\\n     * @param obj\\n     *            string to convert to a URL safe form\\n     * @return URL safe object\\n     * @throws EncoderException\\n     *             Thrown if URL encoding is not applicable to objects of this type or if encoding is unsuccessful\\n     */\\n    @Override\\n    public Object encode(final Object obj) throws EncoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof byte[]) {\\n            return encode((byte[])obj);\\n        } else if (obj instanceof String) {\\n            return encode((String)obj);\\n        } else {\\n            throw new EncoderException(\\\"Objects of type \\\" + obj.getClass().getName() + \\\" cannot be URL encoded\\\");\\n\\n        }\\n    }\\n\\n    /**\\n     * Decodes a URL safe object into its original form. Escaped characters are converted back to their original\\n     * representation.\\n     *\\n     * @param obj\\n     *            URL safe object to convert into its original form\\n     * @return original object\\n     * @throws DecoderException\\n     *             Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure\\n     *             condition is encountered during the decode process.\\n     */\\n    @Override\\n    public Object decode(final Object obj) throws DecoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof byte[]) {\\n            return decode((byte[]) obj);\\n        } else if (obj instanceof String) {\\n            return decode((String) obj);\\n        } else {\\n            throw new DecoderException(\\\"Objects of type \\\" + obj.getClass().getName() + \\\" cannot be URL decoded\\\");\\n\\n        }\\n    }\\n\\n    /**\\n     * The default charset used for string decoding and encoding.\\n     *\\n     * @return the default string charset.\\n     */\\n    public String getDefaultCharset() {\\n        return this.charset;\\n    }\\n\\n    /**\\n     * The <code>String</code> encoding used for decoding and encoding.\\n     *\\n     * @return Returns the encoding.\\n     *\\n     * @deprecated Use {@link #getDefaultCharset()}, will be removed in 2.0.\\n     */\\n    @Deprecated\\n    public String getEncoding() {\\n        return this.charset;\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"encodeUrl\", \"return_type\": \"byte\", \"position\": {\"start_line\": 126, \"end_line\": 154, \"start_column\": 25, \"end_column\": 5}, \"code\": \"byte[] encodeUrl(BitSet urlsafe, final byte[] bytes) {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        if (urlsafe == null) {\\n            urlsafe = WWW_FORM_URL_SAFE;\\n        }\\n\\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\\n        for (final byte c : bytes) {\\n            int b = c;\\n            if (b < 0) {\\n                b = 256 + b;\\n            }\\n            if (urlsafe.get(b)) {\\n                if (b == ' ') {\\n                    b = '+';\\n                }\\n                buffer.write(b);\\n            } else {\\n                buffer.write(ESCAPE_CHAR);\\n                final char hex1 = Utils.hexDigit(b >> 4);\\n                final char hex2 = Utils.hexDigit(b);\\n                buffer.write(hex1);\\n                buffer.write(hex2);\\n            }\\n        }\\n        return buffer.toByteArray();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"urlsafe\", \"type\": \"BitSet\"}, {\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"decodeUrl\", \"return_type\": \"byte\", \"position\": {\"start_line\": 166, \"end_line\": 188, \"start_column\": 25, \"end_column\": 5}, \"code\": \"byte[] decodeUrl(final byte[] bytes) throws DecoderException {\\n        if (bytes == null) {\\n            return null;\\n        }\\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\\n        for (int i = 0; i < bytes.length; i++) {\\n            final int b = bytes[i];\\n            if (b == '+') {\\n                buffer.write(' ');\\n            } else if (b == ESCAPE_CHAR) {\\n                try {\\n                    final int u = Utils.digit16(bytes[++i]);\\n                    final int l = Utils.digit16(bytes[++i]);\\n                    buffer.write((char) ((u << 4) + l));\\n                } catch (final ArrayIndexOutOfBoundsException e) {\\n                    throw new DecoderException(\\\"Invalid URL encoding: \\\", e);\\n                }\\n            } else {\\n                buffer.write(b);\\n            }\\n        }\\n        return buffer.toByteArray();\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"encode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 198, \"end_line\": 200, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] encode(final byte[] bytes) {\\n        return encodeUrl(WWW_FORM_URL_SAFE, bytes);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"decode\", \"return_type\": \"byte\", \"position\": {\"start_line\": 214, \"end_line\": 216, \"start_column\": 12, \"end_column\": 5}, \"code\": \"byte[] decode(final byte[] bytes) throws DecoderException {\\n        return decodeUrl(bytes);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"bytes\", \"type\": \"byte\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 229, \"end_line\": 234, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str, final String charset) throws UnsupportedEncodingException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return StringUtils.newStringUsAscii(encode(str.getBytes(charset)));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"String\", \"position\": {\"start_line\": 248, \"end_line\": 257, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String encode(final String str) throws EncoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        try {\\n            return encode(str, getDefaultCharset());\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new EncoderException(e.getMessage(), e);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"decode\", \"return_type\": \"String\", \"position\": {\"start_line\": 274, \"end_line\": 279, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String decode(final String str, final String charset) throws DecoderException, UnsupportedEncodingException {\\n        if (str == null) {\\n            return null;\\n        }\\n        return new String(decode(StringUtils.getBytesUsAscii(str)), charset);\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}, {\"name\": \"charset\", \"type\": \"String\"}]}, {\"name\": \"decode\", \"return_type\": \"String\", \"position\": {\"start_line\": 293, \"end_line\": 302, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String decode(final String str) throws DecoderException {\\n        if (str == null) {\\n            return null;\\n        }\\n        try {\\n            return decode(str, getDefaultCharset());\\n        } catch (final UnsupportedEncodingException e) {\\n            throw new DecoderException(e.getMessage(), e);\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"str\", \"type\": \"String\"}]}, {\"name\": \"encode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 314, \"end_line\": 325, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object encode(final Object obj) throws EncoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof byte[]) {\\n            return encode((byte[])obj);\\n        } else if (obj instanceof String) {\\n            return encode((String)obj);\\n        } else {\\n            throw new EncoderException(\\\"Objects of type \\\" + obj.getClass().getName() + \\\" cannot be URL encoded\\\");\\n\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"decode\", \"return_type\": \"Object\", \"position\": {\"start_line\": 339, \"end_line\": 350, \"start_column\": 12, \"end_column\": 5}, \"code\": \"Object decode(final Object obj) throws DecoderException {\\n        if (obj == null) {\\n            return null;\\n        } else if (obj instanceof byte[]) {\\n            return decode((byte[]) obj);\\n        } else if (obj instanceof String) {\\n            return decode((String) obj);\\n        } else {\\n            throw new DecoderException(\\\"Objects of type \\\" + obj.getClass().getName() + \\\" cannot be URL decoded\\\");\\n\\n        }\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"obj\", \"type\": \"Object\"}]}, {\"name\": \"getDefaultCharset\", \"return_type\": \"String\", \"position\": {\"start_line\": 357, \"end_line\": 359, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getDefaultCharset() {\\n        return this.charset;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}, {\"name\": \"getEncoding\", \"return_type\": \"String\", \"position\": {\"start_line\": 369, \"end_line\": 371, \"start_column\": 12, \"end_column\": 5}, \"code\": \"String getEncoding() {\\n        return this.charset;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": []}]}]}, {\"path\": \"dataset/pivaa/app/src/main/java/org/apache/commons/codec/net/Utils.java\", \"code\": \"/*\\n * Licensed to the Apache Software Foundation (ASF) under one or more\\n * contributor license agreements.  See the NOTICE file distributed with\\n * this work for additional information regarding copyright ownership.\\n * The ASF licenses this file to You under the Apache License, Version 2.0\\n * (the \\\"License\\\"); you may not use this file except in compliance with\\n * the License.  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npackage org.apache.commons.codec.net;\\n\\nimport org.apache.commons.codec.DecoderException;\\n\\n/**\\n * Utility methods for this package.\\n *\\n * <p>This class is immutable and thread-safe.</p>\\n *\\n * @version $Id: Utils.java 1811344 2017-10-06 15:19:57Z ggregory $\\n * @since 1.4\\n */\\nclass Utils {\\n\\n    /**\\n     * Radix used in encoding and decoding.\\n     */\\n    private static final int RADIX = 16;\\n\\n    /**\\n     * Returns the numeric value of the character <code>b</code> in radix 16.\\n     *\\n     * @param b\\n     *            The byte to be converted.\\n     * @return The numeric value represented by the character in radix 16.\\n     *\\n     * @throws DecoderException\\n     *             Thrown when the byte is not valid per {@link Character#digit(char,int)}\\n     */\\n    static int digit16(final byte b) throws DecoderException {\\n        final int i = Character.digit((char) b, RADIX);\\n        if (i == -1) {\\n            throw new DecoderException(\\\"Invalid URL encoding: not a valid digit (radix \\\" + RADIX + \\\"): \\\" + b);\\n        }\\n        return i;\\n    }\\n\\n    /**\\n     * Returns the upper case hex digit of the lower 4 bits of the int.\\n     *\\n     * @param b the input int\\n     * @return the upper case hex digit of the lower 4 bits of the int.\\n     */\\n    static char hexDigit(final int b) {\\n        return Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\\n    }\\n\\n}\\n\", \"classes\": [{\"parent_file\": null, \"name\": \"Utils\", \"position\": {\"start_line\": 30, \"end_line\": 65, \"start_column\": 1, \"end_column\": 1}, \"code\": \"class Utils {\\n\\n    /**\\n     * Radix used in encoding and decoding.\\n     */\\n    private static final int RADIX = 16;\\n\\n    /**\\n     * Returns the numeric value of the character <code>b</code> in radix 16.\\n     *\\n     * @param b\\n     *            The byte to be converted.\\n     * @return The numeric value represented by the character in radix 16.\\n     *\\n     * @throws DecoderException\\n     *             Thrown when the byte is not valid per {@link Character#digit(char,int)}\\n     */\\n    static int digit16(final byte b) throws DecoderException {\\n        final int i = Character.digit((char) b, RADIX);\\n        if (i == -1) {\\n            throw new DecoderException(\\\"Invalid URL encoding: not a valid digit (radix \\\" + RADIX + \\\"): \\\" + b);\\n        }\\n        return i;\\n    }\\n\\n    /**\\n     * Returns the upper case hex digit of the lower 4 bits of the int.\\n     *\\n     * @param b the input int\\n     * @return the upper case hex digit of the lower 4 bits of the int.\\n     */\\n    static char hexDigit(final int b) {\\n        return Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\\n    }\\n\\n}\", \"summary\": \"\", \"methods\": [{\"name\": \"digit16\", \"return_type\": \"int\", \"position\": {\"start_line\": 47, \"end_line\": 53, \"start_column\": 12, \"end_column\": 5}, \"code\": \"int digit16(final byte b) throws DecoderException {\\n        final int i = Character.digit((char) b, RADIX);\\n        if (i == -1) {\\n            throw new DecoderException(\\\"Invalid URL encoding: not a valid digit (radix \\\" + RADIX + \\\"): \\\" + b);\\n        }\\n        return i;\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"byte\"}]}, {\"name\": \"hexDigit\", \"return_type\": \"char\", \"position\": {\"start_line\": 61, \"end_line\": 63, \"start_column\": 12, \"end_column\": 5}, \"code\": \"char hexDigit(final int b) {\\n        return Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\\n    }\", \"summary\": \"\", \"cluster_summary\": \"\", \"parent\": null, \"parent_cluster\": null, \"is_false_positive\": null, \"is_vulnerable\": false, \"vulnerability_metadata\": null, \"vulnerability\": null, \"matched_string\": \"\", \"parameters\": [{\"name\": \"b\", \"type\": \"int\"}]}]}]}]"